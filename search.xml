<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[微服务商城（十八）—— 购物车]]></title>
    <url>%2Fday17.html</url>
    <content type="text"><![CDATA[1.购物车功能分析1.1.需求需求描述： 用户可以在登录状态下将商品添加到购物车 放入数据库 放入redis（采用） 用户可以在未登录状态下将商品添加到购物车 放入localstorage 用户可以使用购物车一起结算下单 用户可以查询自己的购物车 用户可以在购物车中修改购买商品的数量。 用户可以在购物车中删除商品。 在购物车中展示商品优惠信息 提示购物车商品价格变化 对商品结算下单 1.2.业务分析在需求描述中，不管用户是否登入，都需要实现加入购物车功能，那么已登入下，购物车数据应该存放在哪里呢？ 未登入购物车 用户如果未登录，将数据保存在服务端存在一些问题： 无法确定用户身份，需要借助与客户端存储识别身份 服务端数据存储压力增加，而且可能是无效数据 那么我们应该用把数据保存在客户端，这样每个用户保存自己的数据，就不存在身份识别的问题了，而且也解决了服务端数据存储压力问题。 已登入购物车 用户登录时，数据保存在哪里呢? 大家首先想到的应该是数据库，不过购物车数据比较特殊，读和写都比较频繁，存储数据库压力会比较大。因此我们可以考虑存入Redis中。 不过大家可能会担心Redis存储空间问题，我们可以效仿淘宝，限制购物车最多只能添加99件商品，或者更少。 2.未登录购物车2.1.准备2.1.1购物车的数据结构首先分析一下未登录购物车的数据结构。 我们看下页面展示需要什么数据： 因此每一个购物车信息，都是一个对象，包含： 12345678&#123; skuId:2131241, title:"小米6", image:"", price:190000, num:1, ownSpec:"&#123;"机身颜色":"陶瓷黑尊享版","内存":"6GB","机身存储":"128GB"&#125;"&#125; 另外，购物车中不止一条数据，因此最终会是对象的数组。即： 123[ &#123;...&#125;,&#123;...&#125;,&#123;...&#125;] 2.1.2.web本地存储知道了数据结构，下一个问题，就是如何保存购物车数据。前面我们分析过，可以使用Localstorage来实现。Localstorage是web本地存储的一种，那么，什么是web本地存储呢？ 什么是web本地存储？ web本地存储主要有两种方式： LocalStorage：localStorage 方法存储的数据没有时间限制。第二天、第二周或下一年之后，数据依然可用。 SessionStorage：sessionStorage 方法针对一个 session 进行数据存储。当用户关闭浏览器窗口后，数据会被删除。 LocalStorage的用法语法非常简单： 123localStorage.setItem("key","value"); // 存储数据localStorage.getItem("key"); // 获取数据localStorage.removeItem("key"); // 删除数据 注意：localStorage和SessionStorage都只能保存字符串。 不过，在我们的common.js中，已经对localStorage进行了简单的封装： 示例： 2.1.3.获取num添加购物车需要知道购物的数量，所以我们需要获取数量大小。我们在Vue中定义num，保存数量： 然后将num与页面的input框绑定，同时给+和-的按钮绑定事件： 编写事件： 2.2.添加购物车2.2.1.点击事件我们看下商品详情页： 现在点击加入购物车会跳转到购物车成功页面。 不过我们不这么做，我们绑定点击事件，然后实现添加购物车功能。 addCart方法中判断用户的登录状态： 2.2.2.获取数量，添加购物车12345678910111213141516171819202122232425262728293031323334addCart()&#123; // 判断登录状态 ly.http.get("/auth/verify") .then(resp =&gt; &#123; &#125;) .catch(() =&gt; &#123; // 未登录，添加到localstorage // 1、查询本地购物车 const carts = ly.store.get("carts") || []; let cart = carts.find(c =&gt; c.skuId === this.sku.id); // 2、判断是否存在 if(cart)&#123; // 3、存在，改数量 cart.num += this.num; &#125;else &#123; // 4、不存在，新增 cart = &#123; skuId: this.sku.id, title: this.sku.title, image: this.images[0], price: this.sku.price, num: this.num, ownSpec: JSON.stringify(this.ownSpec) &#125;; carts.push(cart); &#125; // 把carts写回localstorage ly.store.set("carts", carts); // 跳转 window.location.href = "http://www.leyou.com/cart.html"; &#125;);&#125; 结果： 添加完成后，页面会跳转到购物车结算页面：cart.html 2.3.查询购物车2.3.1.校验用户登录因为会多次校验用户登录状态，因此我们封装一个校验的方法： 在common.js中： 2.3.2.查询购物车页面加载时，就应该去查询购物车。 12345678910111213141516171819202122232425262728var cartVm = new Vue(&#123; el: "#cartApp", data: &#123; ly, carts: [],// 购物车数据 &#125;, created() &#123; this.loadCarts(); &#125;, methods: &#123; loadCarts() &#123; // 先判断登录状态 ly.verifyUser() .then(() =&gt; &#123; // 已登录 &#125;) .catch(() =&gt; &#123; // 未登录 this.carts = ly.store.get("carts") || []; this.selected = this.carts; &#125;) &#125; &#125; components: &#123; shortcut: () =&gt; import("/js/pages/shortcut.js") &#125;&#125;) 刷新页面，查看控制台Vue实例： 2.5.2.渲染到页面接下来，我们在页面中展示carts的数据： 页面位置： 修改后： 要注意，价格的展示需要进行格式化，这里使用的是我们在common.js中定义的formatPrice方法： 效果： 2.6.修改数量我们给页面的 + 和 -绑定点击事件，修改num 的值： 两个事件： 12345678910111213141516171819202122232425increment(c) &#123; c.num++; ly.verifyUser() .then(() =&gt; &#123; // TODO 已登录，向后台发起请求 &#125;) .catch(() =&gt; &#123; // 未登录，直接操作本地数据 ly.store.set("carts", this.carts); &#125;)&#125;,decrement(c) &#123; if (c.num &lt;= 1) &#123; return; &#125; c.num--; this.verifyUser() .then(() =&gt; &#123; // TODO 已登录，向后台发起请求 &#125;) .catch(() =&gt; &#123; // 未登录，直接操作本地数据 ly.store.set("carts", this.carts); &#125;)&#125;, 2.7.删除商品给删除按钮绑定事件： 点击事件中删除商品： 1234567891011deleteCart(i) &#123; this.verifyUser() .then(() =&gt; &#123; // 已登录 &#125;) .catch(() =&gt; &#123; // 未登录 this.carts.splice(i, 1); ly.store.set("carts", this.carts); &#125;)&#125; 2.8.选中商品在页面中，每个购物车商品左侧，都有一个复选框，用户可以选择部分商品进行下单，而不一定是全部： 我们定义一个变量，记录所有被选中的商品： 2.8.1.选中一个我们给商品前面的复选框与selected绑定，并且指定其值为当前购物车商品： 2.8.2.初始化全选我们在加载完成购物车查询后，初始化全选： 2.8.4.总价格然后编写一个计算属性，计算出选中商品总价格： 12345computed: &#123; totalPrice() &#123; return this.selected.map(c =&gt; c.num * c.price).reduce((p1, p2) =&gt; p1 + p2, 0); &#125;&#125; 在页面中展示总价格： 效果： 3.搭建购物车服务3.1.创建module 3.2.pom依赖123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;leyou&lt;/artifactId&gt; &lt;groupId&gt;com.leyou.parent&lt;/groupId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.service&lt;/groupId&gt; &lt;artifactId&gt;ly-cart&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 3.3.配置文件123456789101112131415161718server: port: 8088spring: application: name: cart-service redis: host: 192.168.25.128eureka: client: service-url: defaultZone: http://127.0.0.1:10086/eureka registry-fetch-interval-seconds: 5 instance: prefer-ip-address: true ip-address: 127.0.0.1 instance-id: $&#123;eureka.instance.ip-address&#125;.$&#123;server.port&#125; lease-renewal-interval-in-seconds: 3 lease-expiration-duration-in-seconds: 10 3.4.启动类123456789@SpringBootApplication@EnableDiscoveryClient@EnableFeignClientspublic class LyCartApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(LyCartApplication.class, args); &#125;&#125; 3.5.路由1234zuul: prefix: /api routes: cart-service: /cart/** 4.已登录购物车接下来，我们完成已登录购物车。 在刚才的未登录购物车编写时，我们已经预留好了编写代码的位置，逻辑也基本一致。 4.1.添加登录校验购物车系统只负责登录状态的购物车处理，因此需要添加登录校验，我们通过JWT鉴权即可实现。 4.1.1.引入JWT相关依赖我们引入之前写的鉴权工具：ly-auth-common 12345678910&lt;dependency&gt; &lt;groupId&gt;com.leyou.service&lt;/groupId&gt; &lt;artifactId&gt;ly-auth-common&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.leyou.service&lt;/groupId&gt; &lt;artifactId&gt;ly-common&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt; 4.1.2.配置公钥1234ly: jwt: pubKeyPath: D:/heima/rsa/rsa.pub # 公钥地址 cookieName: LY_TOKEN # cookie的名称 4.1.3.加载公钥 代码： 12345678910111213141516171819@Data@ConfigurationProperties(prefix = "ly.jwt")public class JwtProperties &#123; private String pubKeyPath;// 公钥 private String CookieName; private Integer CookieMaxage; private PublicKey publicKey; //对象一旦实例化后，就应该读取公钥和私钥 @PostConstruct //实例化后执行 public void init() throws Exception &#123; //读取公钥和私钥 this.publicKey = RsaUtils.getPublicKey(pubKeyPath); &#125;&#125; 4.1.4.编写过滤器因为很多接口都需要进行登录，我们直接编写SpringMVC拦截器，进行统一登录校验。同时，我们还要把解析得到的用户信息保存起来，以便后续的接口可以使用。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243@Slf4jpublic class UserInterceptor implements HandlerInterceptor &#123; @Autowired private JwtProperties jwtProperties; //线程，用来传递值 private static final ThreadLocal&lt;UserInfo&gt; tl=new ThreadLocal&lt;&gt;(); public UserInterceptor(JwtProperties jwtProperties)&#123; this.jwtProperties=jwtProperties; &#125; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; //获取cookie String token = CookieUtils.getCookieValue(request, jwtProperties.getCookieName()); try &#123; //解析token UserInfo user = JwtUtils.getInfoFromToken(jwtProperties.getPublicKey(), token); //传递user tl.set(user); //放行 return true; &#125;catch (Exception e)&#123; log.error("[购物车服务] 解析身份失败",e); return false; &#125; &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) &#123; //最后用完数据清空 tl.remove(); &#125; //取出userinfo public static UserInfo getUser()&#123; return tl.get(); &#125;&#125; 注意： 这里我们使用了ThreadLocal来存储查询到的用户信息，线程内共享，因此请求到达Controller后可以共享User 并且对外提供了静态的方法：getLoginUser()来获取User信息 4.1.5.配置过滤器配置SpringMVC，使过滤器生效： 12345678910@Configuration@EnableConfigurationProperties(JwtProperties.class)public class MvcConfig implements WebMvcConfigurer &#123; @Autowired private JwtProperties jwtProperties; @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(new UserInterceptor(jwtProperties)).addPathPatterns("/**"); &#125;&#125; 4.2.后台购物车设计数据结构设计当用户登录时，我们需要把购物车数据保存到后台，可以选择保存在数据库。但是购物车是一个读写频率很高的数据。因此我们这里选择读写效率比较高的Redis作为购物车存储。 Redis有5种不同数据结构，这里选择哪一种比较合适呢？ 首先不同用户应该有独立的购物车，因此购物车应该以用户的作为key来存储，Value是用户的所有购物车信息。这样看来基本的k-v结构就可以了。 但是，我们对购物车中的商品进行增、删、改操作，基本都需要根据商品id进行判断，为了方便后期处理，我们的购物车也应该是k-v结构，key是商品id，value才是这个商品的购物车信息。 综上所述，我们的购物车结构是一个双层Map：Map&lt;String,Map&lt;String,String&gt;&gt; 第一层Map，Key是用户id 第二层Map，Key是购物车中商品id，值是购物车数据 实体类12345678910@Datapublic class Cart &#123; private Long userId;// 用户id private Long skuId;// 商品id private String title;// 标题 private String image;// 图片 private Long price;// 加入购物车时的价格 private Integer num;// 购买数量 private String ownSpec;// 商品规格参数&#125; 4.3.添加商品到购物车4.3.1.页面发起请求：已登录情况下，向后台添加购物车： 这里发起的是Json请求。那么我们后台也要以json接收。 4.3.2.后台添加购物车controller先分析一下： 请求方式：新增，肯定是Post 请求路径：/cart ，这个其实是Zuul路由的路径，我们可以不管 请求参数：Json对象，包含skuId和num属性 返回结果：无 123456789101112131415161718@RequestMappingpublic class CartController &#123; @Autowired private CartService cartService; /** * 添加商品到购物车 * @param cart * @return */ @PostMapping public ResponseEntity&lt;Void&gt;addCart(@RequestBody Cart cart)&#123; cartService.addCart(cart); return ResponseEntity.status(HttpStatus.OK).build(); &#125;&#125; Service这里我们不访问数据库，而是直接操作Redis。基本思路： 先查询之前的购物车数据 判断要添加的商品是否存在 存在：则直接修改数量后写回Redis 不存在：新建一条数据，然后写入Redis 代码： 12345678910111213141516171819202122232425262728293031323334@Servicepublic class CartService &#123; private static final String KEY_CART="cart:user:id:"; @Autowired private StringRedisTemplate redisTemplate; /** * 第一层Map，Key是用户id * 第二层Map，Key是购物车中商品id(skuid)，值是购物车数据 * @param cart */ public void addCart(Cart cart) &#123; //获取登入的用户 UserInfo user = UserInterceptor.getUser(); //key String key=KEY_CART+user.getId(); //hashKey String hashKey = cart.getSkuId().toString(); //绑定key BoundHashOperations&lt;String, Object, Object&gt; operations = redisTemplate.boundHashOps(key); //判断当前购物车商品是否存在 if (operations.hasKey(hashKey))&#123; //是，修改数量 String json = operations.get(hashKey).toString(); //将json转成cart类型 Cart cachCart = JsonUtils.toBean(json, Cart.class); cachCart.setNum(cachCart.getNum()+cart.getNum()); operations.put(hashKey,JsonUtils.toString(cachCart)); &#125;else &#123; //否，新增 operations.put(hashKey,JsonUtils.toString(cart)); &#125; &#125;&#125; 4.3.3.结果： 4.4.查询购物车4.4.1.页面发起请求 4.4.2.后台实现 Controller 12345678/** * 查询购物车 * @return */ @GetMapping("list") public ResponseEntity&lt;List&lt;Cart&gt;&gt; selectCart()&#123; return ResponseEntity.ok(cartService.queryCartList()); &#125; Service 123456789101112131415public List&lt;Cart&gt; queryCartList() &#123; //获取登入的用户 UserInfo user = UserInterceptor.getUser(); //key String key=KEY_CART+user.getId(); if (!redisTemplate.hasKey(key))&#123; throw new LyException(ExceptionEnums.CART_NOT_FOUND); &#125; //获取登入用户的所有购物车 //绑定key BoundHashOperations&lt;String, Object, Object&gt; operations = redisTemplate.boundHashOps(key); List&lt;Cart&gt; carts = operations.values().stream().map(o -&gt; JsonUtils.toBean(o.toString(), Cart.class)).collect(Collectors.toList()); return carts;&#125; 4.4.3.测试 4.5.修改商品数量4.5.1.页面发起请求 4.5.2.后台实现 Controller 123456789101112/** * 修改购物车的商品数量 * @param skuId * @param num * @return */ @PutMapping public ResponseEntity&lt;Void&gt; updateCartNum(@RequestParam("skuId")Long skuId,@RequestParam("num")Integer num)&#123; cartService.updateCartNum(skuId,num); return ResponseEntity.status(HttpStatus.OK).build(); &#125; Service 1234567891011121314151617public void updateCartNum(Long skuId, Integer num) &#123; //获取登入的用户 UserInfo user = UserInterceptor.getUser(); //key String key=KEY_CART+user.getId(); //绑定key BoundHashOperations&lt;String, Object, Object&gt; operations = redisTemplate.boundHashOps(key); if (!operations.hasKey(skuId.toString()))&#123; throw new LyException(ExceptionEnums.SKU_NOT_FOUND); &#125; //通过skuId获取redis中购物车的商品信息 Cart cart = JsonUtils.toBean(operations.get(skuId.toString()).toString(), Cart.class); cart.setNum(num); //保存到redis中 operations.put(skuId.toString(),JsonUtils.toString(cart));&#125; 4.6.删除购物车商品4.6.1.页面发起请求 注意：后台成功响应后，要把页面的购物车中数据也删除 4.6.2.后台实现 Controller 1234567891011/** * 删除购物车 * @param skuId * @return */@DeleteMapping("&#123;skuId&#125;")public ResponseEntity&lt;Void&gt; deleteCart(@PathVariable("skuId")Long skuId)&#123; cartService.deleteCart(skuId); return ResponseEntity.status(HttpStatus.OK).build();&#125; Service 12345678910111213141516public void deleteCart(Long skuId) &#123; //获取登入的用户 UserInfo user = UserInterceptor.getUser(); //key String key=KEY_CART+user.getId(); //判断是否存在 if (!redisTemplate.hasKey(key))&#123; throw new LyException(ExceptionEnums.CART_NOT_FOUND); &#125; redisTemplate.opsForHash().delete(key,skuId.toString());&#125; 5.登录后购物车合并（作业）当跳转到购物车页面，查询购物车列表前，需要判断用户登录状态， 如果登录： 首先检查用户的LocalStorage中是否有购物车信息， 如果有，则提交到后台保存， 清空LocalStorage 如果未登录，直接查询即可 修改cart.html即可]]></content>
      <categories>
        <category>项目实战-微服务商城</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务商城（十九）—— 下单、微信支付]]></title>
    <url>%2Fday19-%E4%B8%8B%E5%8D%95.html</url>
    <content type="text"><![CDATA[0.学习目标 搭建订单微服务 创建订单 微信支付下单 生成二维码 1.创建订单微服务1.1.搭建服务创建Model ly-order 依赖pom.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;leyou&lt;/artifactId&gt; &lt;groupId&gt;com.leyou.parent&lt;/groupId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.service&lt;/groupId&gt; &lt;artifactId&gt;ly-order&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.leyou.service&lt;/groupId&gt; &lt;artifactId&gt;ly-item-interface&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.leyou.common&lt;/groupId&gt; &lt;artifactId&gt;ly-common&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.leyou.service&lt;/groupId&gt; &lt;artifactId&gt;ly-auth-common&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.wxpay&lt;/groupId&gt; &lt;artifactId&gt;wxpay-sdk&lt;/artifactId&gt; &lt;version&gt;0.0.3&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; application： 12345678910111213141516171819202122232425server: port: 8089spring: application: name: order-service datasource: url: jdbc:mysql://localhost:3306/leyou-new?serverTimezone=Asia/Shanghai&amp;characterEncoding=utf8 username: root password: cxg200888 hikari: maximum-pool-size: 30 minimum-idle: 10eureka: client: service-url: defaultZone: http://127.0.0.1:10086/eureka registry-fetch-interval-seconds: 5 instance: lease-renewal-interval-in-seconds: 5 # 每隔5秒发送一次心跳 lease-expiration-duration-in-seconds: 10 # 10秒不发送就过期 prefer-ip-address: true ip-address: 127.0.0.1 instance-id: $&#123;spring.application.name&#125;:$&#123;server.port&#125;mybatis: type-aliases-package: com.leyou.order.pojo 启动类：12345678@SpringBootApplication@EnableDiscoveryClient@MapperScan("com.leyou.order.mapper")public class LyOrderApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(LyOrderApplication.class, args); &#125;&#125; 在ly-gateway中添加路由 1234zuul: prefix: /api # 添加路由前缀 routes: order-service: /order/** # 订单微服务 1.2.用户登入校验 1.2.1.配置密钥12345678910111213141516171819@Data@ConfigurationProperties(prefix = "ly.jwt")public class JwtProperties &#123; private String pubKeyPath;// 公钥 private String CookieName; private Integer CookieMaxage; private PublicKey publicKey; //对象一旦实例化后，就应该读取公钥和私钥 @PostConstruct //实例化后执行 public void init() throws Exception &#123; //读取公钥和私钥 this.publicKey = RsaUtils.getPublicKey(pubKeyPath); &#125;&#125; 1.2.2.拦截器1234567891011121314151617181920212223242526272829303132333435363738394041@Slf4jpublic class UserInterceptor implements HandlerInterceptor &#123; @Autowired private JwtProperties jwtProperties; private static final ThreadLocal&lt;UserInfo&gt; tl=new ThreadLocal&lt;&gt;(); public UserInterceptor(JwtProperties jwtProperties)&#123; this.jwtProperties=jwtProperties; &#125; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; //获取cookie String token = CookieUtils.getCookieValue(request, jwtProperties.getCookieName()); try &#123; //解析token UserInfo user = JwtUtils.getInfoFromToken(jwtProperties.getPublicKey(), token); //传递user tl.set(user); //放行 return true; &#125;catch (Exception e)&#123; log.error("[购物车服务] 解析身份失败",e); return false; &#125; &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) &#123; //最后用完数据清空 tl.remove(); &#125; //取出userinfo public static UserInfo getUser()&#123; return tl.get(); &#125;&#125; 1.3.数据结构订单表： 123456789101112131415161718192021222324252627CREATE TABLE `tb_order` ( `order_id` bigint(20) NOT NULL COMMENT &apos;订单id&apos;, `total_pay` bigint(20) NOT NULL COMMENT &apos;总金额，单位为分&apos;, `actual_pay` bigint(20) NOT NULL COMMENT &apos;实付金额。单位:分。如:20007，表示:200元7分&apos;, `promotion_ids` varchar(256) COLLATE utf8_bin DEFAULT &apos;&apos;, `payment_type` tinyint(1) unsigned zerofill NOT NULL COMMENT &apos;支付类型，1、在线支付，2、货到付款&apos;, `post_fee` bigint(20) NOT NULL COMMENT &apos;邮费。单位:分。如:20007，表示:200元7分&apos;, `create_time` datetime DEFAULT NULL COMMENT &apos;订单创建时间&apos;, `shipping_name` varchar(20) COLLATE utf8_bin DEFAULT NULL COMMENT &apos;物流名称&apos;, `shipping_code` varchar(20) COLLATE utf8_bin DEFAULT NULL COMMENT &apos;物流单号&apos;, `user_id` varchar(32) COLLATE utf8_bin NOT NULL COMMENT &apos;用户id&apos;, `buyer_message` varchar(128) COLLATE utf8_bin DEFAULT NULL COMMENT &apos;买家留言&apos;, `buyer_nick` varchar(32) COLLATE utf8_bin NOT NULL COMMENT &apos;买家昵称&apos;, `buyer_rate` tinyint(1) DEFAULT NULL COMMENT &apos;买家是否已经评价,0未评价，1已评价&apos;, `receiver_state` varchar(128) COLLATE utf8_bin DEFAULT &apos;&apos; COMMENT &apos;收获地址（省）&apos;, `receiver_city` varchar(256) COLLATE utf8_bin DEFAULT &apos;&apos; COMMENT &apos;收获地址（市）&apos;, `receiver_district` varchar(256) COLLATE utf8_bin DEFAULT &apos;&apos; COMMENT &apos;收获地址（区/县）&apos;, `receiver_address` varchar(256) COLLATE utf8_bin DEFAULT &apos;&apos; COMMENT &apos;收获地址（街道、住址等详细地址）&apos;, `receiver_mobile` varchar(11) COLLATE utf8_bin DEFAULT NULL COMMENT &apos;收货人手机&apos;, `receiver_zip` varchar(16) COLLATE utf8_bin DEFAULT NULL COMMENT &apos;收货人邮编&apos;, `receiver` varchar(32) COLLATE utf8_bin DEFAULT NULL COMMENT &apos;收货人&apos;, `invoice_type` int(1) DEFAULT &apos;0&apos; COMMENT &apos;发票类型(0无发票1普通发票，2电子发票，3增值税发票)&apos;, `source_type` int(1) DEFAULT &apos;2&apos; COMMENT &apos;订单来源：1:app端，2：pc端，3：M端，4：微信端，5：手机qq端&apos;, PRIMARY KEY (`order_id`), KEY `create_time` (`create_time`), KEY `buyer_nick` (`buyer_nick`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin 订单条目： 123456789101112CREATE TABLE `tb_order_detail` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &apos;订单详情id &apos;, `order_id` bigint(20) NOT NULL COMMENT &apos;订单id&apos;, `sku_id` bigint(20) NOT NULL COMMENT &apos;sku商品id&apos;, `num` int(11) NOT NULL COMMENT &apos;购买数量&apos;, `title` varchar(256) NOT NULL COMMENT &apos;商品标题&apos;, `own_spec` varchar(1024) DEFAULT &apos;&apos; COMMENT &apos;商品动态属性键值集&apos;, `price` bigint(20) NOT NULL COMMENT &apos;价格,单位：分&apos;, `image` varchar(128) DEFAULT &apos;&apos; COMMENT &apos;商品图片&apos;, PRIMARY KEY (`id`), KEY `key_order_id` (`order_id`) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=126 DEFAULT CHARSET=utf8 COMMENT=&apos;订单详情表&apos; 订单状态 123456789101112CREATE TABLE `tb_order_status` ( `order_id` bigint(20) NOT NULL COMMENT &apos;订单id&apos;, `status` int(1) DEFAULT NULL COMMENT &apos;状态：1、未付款 2、已付款,未发货 3、已发货,未确认 4、交易成功 5、交易关闭 6、已评价&apos;, `create_time` datetime DEFAULT NULL COMMENT &apos;订单创建时间&apos;, `payment_time` datetime DEFAULT NULL COMMENT &apos;付款时间&apos;, `consign_time` datetime DEFAULT NULL COMMENT &apos;发货时间&apos;, `end_time` datetime DEFAULT NULL COMMENT &apos;交易完成时间&apos;, `close_time` datetime DEFAULT NULL COMMENT &apos;交易关闭时间&apos;, `comment_time` datetime DEFAULT NULL COMMENT &apos;评价时间&apos;, PRIMARY KEY (`order_id`), KEY `status` (`status`) USING BTREE) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&apos;订单状态表&apos; 1.4.基本代码实体类 Order.java 12345678910111213141516171819202122232425262728293031323334@Data@Table(name = "tb_order")public class Order &#123; @Id private Long orderId;// id private Long totalPay;// 总金额 private Long actualPay;//实付金额 private Integer paymentType; //支付类型，1、在线支付，2、货到付款 private String promotionIds; //参与促销活动的id private Long postFee=0L ;// 邮费 private Date createTime;//创建时间 private String shippingName;// 物流名称 private String shippingCode;// 物流单号 private Long userId;//用户id private String buyerMessage;//买家留言 private String buyerNick;//买家昵称 private Boolean buyerRate;//买家是否已经评价 private String receiver; //收货人全名 private String receiverMobile; //移动电话 private String receiverState; //省份 private String receiverCity; //城市 private String receiverDistrict; //区/县 private String receiverAddress; //收货地址，如: xx路xx号 private String receiverZip; //邮政编码，如: 310001 private Integer invoiceType = 0;//发票类型，8无发票，1普通发票，2电子发票，3增值税发票 private Integer sourceType = 1;//订单来源1:app端，2: pc端，3: M端，4:微信端，5: 手机qq端 @Transient private OrderStatus orderStatus; @Transient private List&lt;OrderDetail&gt; orderDetails;&#125; OrderDetail.java 12345678910111213141516171819202122@Data@Table(name = "tb_order_detail")public class OrderDetail &#123; @Id @KeySql(useGeneratedKeys = true)private Long id; private Long orderId; // 订单1d private Long skuId;// 商品id private Integer num;//商品购买数量 private String title;// 商品标题 private Long price;// 商品单价 private String ownSpec;// 商品规格数据 private String image;// 图片&#125; OrderStatus.java 123456789101112131415161718192021@Data@Table(name = "tb_order_status")public class OrderStatus &#123; @Id private Long orderId; private Integer status; private Date createTime;// 创建时间 private Date paymentTime;// 付款时间 private Date consignTime;// 发货时间 private Date endTime;//交易结束时间 private Date closeTime;// 交易关闭时间 private Date commentTime;// 评价时间&#125; 2.订单结算页2.1.页面跳转在购物车页面的最下方，有一个去结算按钮： 当点击结算，我们应该跳转到订单结算页，即：getOrderInfo.html 查看购物车cart.html的结算按钮： 可以看到，地址是正确的。但是只有登录用户才可以去结算付款，因此我们不能直接跳转，而是在跳转前校验用户的登录状态，如果发现是未登录，应该重定向到登录页！ 我们给这个按钮绑定点击事件： 事件中判断登录状态，进行页面跳转： 12345678910toOrderInfo() &#123; // 判断是否登录 ly.verifyUser().then(() =&gt; &#123; // 已登录 window.location.href = "/getOrderInfo.html" &#125;).catch(() =&gt; &#123; // 未登录 window.location.href = "/login.html?returnUrl=" + window.location.href; &#125;)&#125; 登录后测试： 此处页面需要渲染的内容主要包含3部分： 收货人信息 支付方式 商品信息 2.2.收货人信息（作业） 这里的收货人信息肯定是当前登录用户的收货地址。所以需要根据当前登录用户去查询，目前我们在页面是写的假数据： 大家可以在在后台提供地址的增删改查接口，然后页面加载时根据当前登录用户查询，而后赋值给addresses即可。 2.3.支付方式支付方式有2种： 微信支付 货到付款 与我们订单数据中的paymentType关联： 所以我们可以在Vue实例中定义一个属性来记录支付方式： 然后在页面渲染时与这个变量关联： 2.4.商品清单效果图： 这里的送货清单，其实就是购物车中用户选择的要付款的商品 因此，我们需要在购物车跳转过来的同时，携带选中的购物车的信息 2.4.1.购物车信息获取我们修改cart.html中的页面跳转逻辑，把用户选中的购物车信息传递过来： 然后在created钩子函数中获取购物车数据，保存到本地属性，要注意的是，我们应该在获取数据前校验用户登录状态，如果发现未登录，则直接重定向到登录页： 然后重新加载页面，查看控制台： 2.4.2.页面渲染要修改的页面位置：每一个li就是一件商品 我们修改为： 1234567891011121314151617181920212223242526&lt;ul class="send-detail"&gt; &lt;li v-for="(cart,index) in carts" :key="index"&gt; &lt;div class="sendGoods"&gt; &lt;ul class="yui3-g"&gt; &lt;li class="yui3-u-1-6"&gt; &lt;span&gt;&lt;img width="70px" height="70px" :src="cart.image"/&gt;&lt;/span&gt; &lt;/li&gt; &lt;li class="yui3-u-7-12"&gt; &lt;div class="desc"&gt;&#123;&#123;cart.title&#125;&#125;&lt;/div&gt; &lt;div class="seven"&gt; &lt;span v-for="(v) in JSON.parse(cart.ownSpec)"&gt;&#123;&#123;v + " "&#125;&#125; &lt;/span&gt; &lt;/div&gt; &lt;/li&gt; &lt;li class="yui3-u-1-12"&gt; &lt;div class="price"&gt;￥&#123;&#123;ly.formatPrice(cart.price * cart.num)&#125;&#125;&lt;/div&gt; &lt;/li&gt; &lt;li class="yui3-u-1-12"&gt; &lt;div class="num"&gt;&#123;&#123;cart.num&#125;&#125;&lt;/div&gt; &lt;/li&gt; &lt;li class="yui3-u-1-12"&gt; &lt;div class="exit"&gt;有货&lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/li&gt;&lt;/ul&gt; 2.5.总金额另外在商品列表下面，还有一个总金额的计算： 可以看出这里主要有4个数据： 总金额：totalPay 优惠返现：discount 运费：postFee 实付金额：actualPay 不过我们没有做优惠活动，另外运费需要结合物流系统来计算，暂时我们都设置为0，在order属性中写死： 我们通过计算属性来得到totalPay和actualPay值： 1234567891011computed: &#123; totalNum()&#123; return this.carts.reduce((c1, c2) =&gt; c1 + c2.num, 0) &#125;, totalPay()&#123; return this.carts.reduce((c1, c2) =&gt; c1 + c2.price * c2.num, 0); &#125;, actualPay()&#123; return this.totalPay + this.order.postFee - this.order.discount; &#125;&#125;, 然后在页面渲染： 效果： 2.6.提交订单2.6.1.页面提交来看下订单接口所需要的数据： 参数说明： addressId：收货人地址信息的id，需要去用户中心查询收货人地址 carts：购物车中的商品数据，可以有多个对象 num：购物车中指定商品的购买数量 skuId：购物车中的某商品id paymentType：付款方式 1：在线支付 2：货到付款 getOrderInfo.html对应的js代码 给提交按钮绑定事件： 可以看到返回的提交订单成功，返回的应该是订单的编号id。 3.创建订单接口订单信息共有3张表，内容喝多，但是前台提交的数据却很少，也就是说我们需要自己填很多数据。 3.1.Controller请求分析： 请求方式：POST 请求路径：/order 请求参数：包含收货人地址id、付款方式、购物车商品数据集合的json内容，我们需要封装一个对象来接收 123456789101112@Data@AllArgsConstructor@NoArgsConstructorpublic class OrderDTO &#123; @NotNull private Long addressId;// 收货人地址id @NotNull private Integer paymentType;// 付款方式 @NotNull private List&lt;CartDTO&gt; carts;// 订单详情&#125; 其中的购物车数据再次封装对象： 1234567@Data@AllArgsConstructor@NoArgsConstructorpublic class CartDTO &#123; private Long skuId;// 商品skuId private Integer num;// 购买数量&#125; 返回结果：订单id 具体代码 123456789@RestControllerpublic class OrderController &#123; @Autowired private OrderService orderService; @PostMapping("/order") public ResponseEntity&lt;Long&gt; createOrder(@RequestBody OrderDTO orderDTO)&#123; return ResponseEntity.ok(orderService.createOrder(orderDTO)); &#125;&#125; 3.2.Service创建订单逻辑比较复杂，需要组装订单数据，基本步骤如下: 获取登录用户信息 生成订单编号，初始化订单基本信息 查询商品信息弄 查询收货人信息 封装OrderDetail信息 计算总金额、实付金额 保存订单状态信息 删除购物车中已购买商品 减库存 3.2.1.生成订单编号 订单id的特殊性 订单数据非常庞大，将来一定会做分库分表，name这种情况下，要保证id的唯一，就不能靠数据库自增，而是自己来实现算法，生成唯一id。 雪花算法 这里的订单id是通过一个工具类生成： 而工具类所采用的生成id算法，是由Twitter公司开源的snowflake（雪花）算法。 简单原理 雪花算法会生成一个64位的二进制数据，位一个long型，（转换成字符串后长度最多19），其基本结构： 第一位:为未使用 第二部分: 41位为毫秒级时间(41位的长度可以使用69年) 第三部分: 5位datacenterld和5位workerld(10位的长度 最多支持部署1024个节点) 第四部分:最后12位是毫秒内的计数(12位 的计数顺序号支持每个节点每毫秒产生4096个ID序号) snowflake生成的ID整体上按照时间自增排序，并且整个分布式系统内不会产生ID碰撞(由datacenter和workerld作区分)，并且效率较高。经测试snowflake每秒能够产生26万个ID。 配置 为了保证不重复，我们在application.yml中给每个部署的节点都配置机器id： 放入ly-order的application.yml中 1234ly: worker: workerId:1 dataCenterId:1 在config中编写 加载属性： 123456@Data@ConfigurationProperties(prefix = "ly.worker")public class idWorkerProperties &#123; private long workerId;// 当前机器id private long dataCenterId;// 序列号&#125; 在config中 编写配置类： 1234567891011121314@Configuration@EnableConfigurationProperties(IdWorkerProperties.class)public class IdWorkerConfig &#123; /** * 注册IdWorker * @param prop * @return */ @Bean public IdWorker idWorker(IdWorkerProperties prop) &#123; return new IdWorker(prop.getWorkerId(), prop.getDataCenterId()); &#125;&#125; 3.2.2.查询sku的接口创建订单过程中，肯定需要查询sku信息，因为我们需要在商品微服务提供根据skuId查询sku的接口： 在ly-item-interface的GoodsApi中添加接口： 1234567/** * 根据sku的id集合查询sku * @param ids * @return */@GetMapping("sku/list/ids")List&lt;Sku&gt; querySkuByids(@RequestParam("ids")List&lt;Long&gt; ids); 在ly-item-service的GoodsController中编写业务 123456789/** * 根据sku的id集合查询sku * @param ids * @return */@GetMapping("sku/list/ids")public ResponseEntity&lt;List&lt;Sku&gt;&gt; querySkuByids(@RequestParam("ids")List&lt;Long&gt; ids)&#123; return ResponseEntity.ok(goodsService.querySkuByids(ids));&#125; service和mapper代码略 3.2.3.减库存接口创建订单，肯定需要减库存，我们还要在商品微服务提供减库的接口 在ly-item-interface的GoodsApi中添加接口： 1234567/** * 减库存 * @param carts * @return */ @PostMapping("stock/decrease") void decreaseStock(@RequestBody List&lt;CartDTO&gt; carts); 在ly-item-service的 GoodController中编写业务 12345678910/** * 减库存 * @param carts * @return */@PostMapping("stock/decrease")public ResponseEntity&lt;Void&gt; decreaseStock(@RequestBody List&lt;CartDTO&gt; carts)&#123; goodsService.decreaseStock(carts); return ResponseEntity.status(HttpStatus.NO_CONTENT).build();&#125; 在ly-item-service的 GoodService中编写业务 12345678public void decreaseStock(List&lt;CartDTO&gt; carts) &#123; for (CartDTO cart : carts) &#123; int count = stockMapper.decreaseStock(cart.getSkuId(), cart.getNum()); if (count!=1)&#123; throw new LyException(ExceptionEnums.STOCK_NOT_ENOUGH); &#125; &#125;&#125; 此处采用了手写sql在mapper中： 1234public interface StockMapper extends BaseMapper&lt;Stock&gt; &#123; @Update("update tb_stock set stock = stock- #&#123;num&#125; where sku_id=#&#123;id&#125; and stock&gt;=#&#123;num&#125;") int decreaseStock(@Param("id") Long id, @Param("num") Integer num);&#125; 这里减库存并没有采用先查询库存，判断充足才减库存的方案，那样会有线程安全问题，当然可以通过加锁解决，不过我们此处为了效率，并没有使用悲观锁，而是对库存采用了乐观锁方案。 3.2.4.准备物流假数据我们前端页面传递来的是addressId，我们需要根据id查询物流信息，但是因为还没做物流地址管理，所以我们准备一些加数据。 首先是实体类： 123456789101112@Datapublic class AddressDTO &#123; private Long id; private String name;// 收件人姓名 private String phone;// 电话 private String state;// 省份 private String city;// 城市 private String district;// 区 private String address;// 街道地址 private String zipCode;// 邮编 private Boolean isDefault;&#125; 然后是一个常量类： 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.leyou.order.client;import com.leyou.order.dto.AddressDTO;import java.util.ArrayList;import java.util.List;public abstract class AddressClient &#123; public static final List&lt;AddressDTO&gt; addressList = new ArrayList&lt;AddressDTO&gt;()&#123; &#123; AddressDTO address = new AddressDTO(); address.setId(1L); address.setAddress("航头镇航头路18号传智播客 3号楼"); address.setCity("上海"); address.setDistrict("浦东新区"); address.setName("虎哥"); address.setPhone("15800000000"); address.setState("上海"); address.setZipCode("21000"); address.setIsDefault(true); add(address); AddressDTO address2 = new AddressDTO(); address2.setId(2L); address2.setAddress("天堂路 3号楼"); address2.setCity("北京"); address2.setDistrict("朝阳区"); address2.setName("张三"); address2.setPhone("13600000000"); address2.setState("北京"); address2.setZipCode("100000"); address2.setIsDefault(false); add(address2); &#125; &#125;; public static AddressDTO findById(Long id)&#123; for (AddressDTO addressDTO : addressList) &#123; if(addressDTO.getId().equals(id)) &#123;return addressDTO;&#125; &#125; return null; &#125;&#125; 3.2.5.创建订单代码3.2.6.订单状态枚举此处我们为订单状态定义了枚举 ly-order中enums创建OrderStatusEnum 12345678910111213141516171819public enum OrderStatusEnum &#123; UN_PAY(1,"未付款"), PAYED(2,"已付款,未发货"), DELIVERED(3,"已发货,未确认"), SUCCESS(4,"交易成功"), CLOSED(1,"交易关闭"), RATED(1,"已评价"), ; private int code; private String desc; OrderStatusEnum(int code, String desc) &#123; this.code = code; this.desc = desc; &#125; public Integer value()&#123; return this.code; &#125;&#125; 3.3.测试 查看数据库，发现订单已经生成： 订单 订单详情 订单状态 4.微信支付4.1.介绍微信支付官方文档：https://pay.weixin.qq.com/wiki/doc/api/native.php?chapter=6_1 我们选择开发文档，而后进入选择页面： 选择扫码支付： 此处我们使用模式二来开发： 4.2.开发流程模式二与模式一相比，流程更为简单，不依赖设置的回调支付URL。 商户后台系统先调用微信支付的统一下单接口，微信后台系统返回链接参数code_url； 商户后台系统将code_url值生成二维码图片，用户使用微信客户端扫码后发起支付。 注意：code_url有效期为2小时，过期后扫码不能再发起支付。 流程图： 这里我们把商户（我们）要做的事情总结一下： 1、商户生成订单 2、商户调用微信下单接口，获取预交易的链接 3、商户将链接生成二维码图片，展示给用户； 4、用户支付并确认 5、支付结果通知： 微信异步通知商户支付结果，商户告知微信支付接收情况 商户如果没有收到通知，可以调用接口，查询支付状态 6、如果支付成功，发货，修改订单状态 在前面的业务中，我们已经完成了： 1、生成订单 接下来，我们需要做的是： 2、调用微信接口，生成链接。 3、并且生成二维码图片 4、支付成功后修改订单状态 4.3.下单并生成支付链接4.3.1.API说明在微信支付文档中，可以查询到下面信息： 支付路径 URL地址：https://api.mch.weixin.qq.com/pay/unifiedorde 请求参数 查看官方文档：https://pay.weixin.qq.com/wiki/doc/api/native.php?chapter=9_1 其中，appid、mch_id、nonce_str、sign等都是可以提前配置，或者随即生成。可以统一配置 但是其他参数都需要我们自己组织。 虽然请求参数比较复杂，但官方已经提供SDK，供我们使用 4.3.2.统一配置在微信支付参数中个，appid、mch_id可以提前配置，sign签名需要商户密钥我们需要提前配置，另外请求的超时时长等，所以微信sdk提供了统一配置 在ly-order的config中创建PayConfig 123456789101112131415161718@Datapublic class PayConfig implements WXPayConfig&#123; private String appId; // 公众账号ID private String mchId; // 商户号 private String key; // 生成签名的密钥 private int connectTimeoutMs; // 连接超时时间 private int readTimeoutMs;// 读取超时时间 private String notifyUrl; // 通知地址 @Override public InputStream getCertStream()&#123;return null;&#125;&#125; 我们将这些属性定义到application.yml中 12345678ly: pay: appID: wx8397f8696b538317 mchID: 1473426802 key: T6m9iK73b0kn9g5v426MKfHQH7X8rKwb httpConnectTimeoutMs: 1000 httpReadTimeoutMs: 8000 notifyUrl: http://www.leyou.com 4.3.3.回调url参数中一个非常重要的，叫做notify_url的： 基于上文的介绍我们知道，这个地址是在支付成功后的异步结果通知。官网介绍如下: 支付完成后，微信会把相关支付结果和用户信息发送给商户，商户需要接收处理，并返回应答。 所以，此处的地址必须是-个外网可访问地址，而且我们要定义好回调的处理接口。 内网穿透此处我们肯定不能写: http://api.leyou.com/api/order/, 这个域名未经备案，是不被识别的。如何才能获取一个能够外网访问的域名呢? 我们可以通过内网穿透来实现，那么什么是内网穿透呢? 简单说：让外网能访问你本地的应用，例如在外网打开你本地http://127.0.0.1指定的web站点 学习内网穿透：https://blog.csdn.net/zhangguo5/article/details/77848658 使用natapp地址：https://natapp.cn 通过官网的教程/文档：NATAPP1分钟快速新手图文教程（https://natapp.cn/article/natapp_newbie） 下载客户端在客户端下配置 config.ini config.ini 123456789#将本文件放置于natapp同级目录 程序将读取 [default] 段#在命令行参数模式如 natapp -authtoken=xxx 等相同参数将会覆盖掉此配置#命令行参数 -config= 可以指定任意config.ini文件[default]authtoken=35fb8777346645fa #对应一条隧道的authtokenclienttoken= #对应客户端的clienttoken,将会忽略authtoken,若无请留空,log=none #log 日志文件,可指定本地文件, none=不做记录,stdout=直接屏幕输出 ,默认为noneloglevel=INFO #日志等级 DEBUG, INFO, WARNING, ERROR 默认为 DEBUGhttp_proxy= #代理设置 如 http://10.123.10.10:3128 非代理上网用户请务必留空 配置修改application.yml配置文件 12345678ly: pay: appID: wx8397f8696b538317 mchID: 1473426802 key: T6m9iK73b0kn9g5v426MKfHQH7X8rKwb httpConnectTimeoutMs: 1000 httpReadTimeoutMs: 8000 notifyUrl: http://g9i654.natappfree.cc/notify/pay 4.3.4.支付工具类将资料下的三个文件添加到ly-order的config中 4.3.5.创建下单支付链接 controller 在ly-order下的web中OrderController创建 123456789/** * 创建支付链接 * @param orderId * @return */@GetMapping("/url/&#123;id&#125;")public ResponseEntity&lt;String&gt; createPayUrl(@PathVariable("id")Long orderId)&#123; return ResponseEntity.ok(orderService.createPayUrl(orderId));&#125; 在ly-order下的service中OrderService创建 12345678910111213141516public String createPayUrl(Long orderId) &#123; //查询订单 Order order = queryOrderById(orderId); //判断订单状态 Integer status = order.getOrderStatus().getStatus(); if (!status.equals(OrderStatusEnum.UN_PAY.value()))&#123; throw new LyException(ExceptionEnums.ORDER_STATUS_ERROR); &#125; //支付金额 Long actualPay = /*order.getActualPay()*/1L; //商品描述 OrderDetail orderDetail = order.getOrderDetails().get(0); String desc = orderDetail.getTitle(); return payHelper.createPayUrl(orderId,actualPay,desc);&#125; 我们先根据订单的编号，调用后台服务，生成交易链接，而后才能根据链接生成二维码。 在页面发起请求： 12345678910111213141516171819202122232425var payVm = new Vue(&#123; el:"#payVm", data:&#123; ly, orderId:0,// 订单编号 &#125;, created()&#123; // 判断登录状态 ly.http.get("/auth/verify").then(() =&gt; &#123; // 获取订单编号 this.orderId = ly.getUrlParam("orderId"); // 获取请求链接 ly.http.get("/order/url/" + this.orderId) .then(resp =&gt; &#123; console.log(resp.data); &#125;) &#125;.catch(() =&gt; &#123; // 未登录，跳转至登录页 location.href = "/login.html?returnUrl=" + location.href; &#125;) &#125;, components: &#123; shortcut: () =&gt; import("./js/pages/shortcut.js") &#125;&#125;); 后台已经定义好生成付款地址的接口。 刷新页面查看： 4.4.生成二维码4.4.1.什么是二维码二维码又称QR Code, QR全 称Quick Response,是一个近几年来移动设备上超流行的一种编码方式，它比传统的Bar Code条形码能存更多的信息，也能表示更多的数据类型。 二维条码/二维码(2-dimensional bar code)是用某种特定的几何图形按一定规律在平面(二维方向上)分布的黑白相间的图形记录数据符号信息的;在代码编制上1巧妙地利用构成计算机内部逻辑基础的“0”、“1”比特 流的概念，使用若千个与二进制相对应的几何形体来表示文字数值信息，通过图象输入设备或光电扫描设备自动识读以实现信息自动处理:它具有条码技术的一些共性:每种码制有其特定的字符集;每个字符占有一定的宽度;具有一定的校验功能等。同时还具有对不同行的信息自动识别功能、及处理图形旋转变化点。 4.4.2.二维码优势 信息容量大,可以容纳多达1850个大写字母或2710个数字或500多个汉字 应用范围广,支持文字，声音图片，指纹等等… 容错能力强,即使图片出现部分破损也能使用 成本低，容易制作 4.4.3.二维码容错级别 L级(低) 7%的码字可以被恢复。 M级(中) 15%的码字可以被恢复。 Q级(四分) 25%的码字可以被恢复。 H级(高) 30%的码字可以被恢复。 4.4.4.二维码生成插件qriousqrious是一. 款基于HTML5 Canvas的纯JS二维码生成插件。通过qrious.js可以快速生成各种二维码，你可以控制二维码的尺寸颜色，还可以将生成的二维码进行Base64编码。 官网qrious.js二维码插件的可用配置参数如下: 这里我们使用一个生成二维码的JS插件：qrcode，官网：https://github.com/davidshimjs/qrcodejs 我们把课这个js脚本引入到项目中： 官方使用案例： 然后在页面引用： 页面定义一个div，用于展示二维码： 然后获取到付款链接后，根据链接生成二维码： 1234567891011121314151617181920// 判断登录状态ly.http.get("/auth/verify").then(() =&gt; &#123; // 获取订单编号 this.orderId = ly.getUrlParam("orderId"); // 获取请求链接 ly.http.get("/order/url/" + this.orderId) .then(resp =&gt; &#123; new QRCode(document.getElementById("qrImage"), &#123; text: resp.data, width: 250, height: 250, colorDark: "#000000", colorLight: "#ffffff", correctLevel: QRCode.CorrectLevel.H &#125;); &#125;)&#125;).catch(() =&gt; &#123; // 未登录，跳转至登录页 location.href = "/login.html?returnUrl=" + location.href;&#125;) 刷新页面，查看效果： 此时，客户用手机扫描二维码，可以看到付款页面。 4.5.异步回调4.5.1.官方API还记得刚才下单时填写的notify_url吗？ 应用场景 支付完成后，微信会把相关支付结果及用户信息通过数据流的形式发送给商户，商户需要接收处理，并按文档规范返回应答。 后台通知交互时，如果微信收到商户的应答不符合规范或超时，微信会判定本次通知失败，重新发送通知，直到成功为止（在通知一直不成功的情况下，微信总共会发起10次通知，通知频率为15s/15s/30s/3m/10m/20m/30m/30m/30m/60m/3h/3h/3h/6h/6h - 总计 24h4m） 注意:同样的通知可能会多次发送给商户系统。商户系统必须能够正确处理重复的通知。 推荐的做法是，当收到通知进行处理时，首先检查对应业务数据的状态，判断该通知是否已经处理过，如果没有处理过再进行处理，如果处理过直接返回结果成功。在对业务数据进行状态检查和处理之前，要采用数据锁进行并发控制，以避免函数重入造成的数据混乱。 特别提醒:商户系统对于支付结果通知的内容一定要做 签名验证,并校验返回的订单金额是否与商户侧的订单金额一致，防止数据泄漏导致出现“假通知”，造成资金损失。 支付完成后，微信服务会自动向notify_url地址发生POST请求，请求参数xml格式： 通信成功，会返回下面信息 我们需要返回给微信 1234&lt;xml&gt; &lt;return_code&gt;&lt;![CDATA[SUCCESS]]&gt;&lt;/return_code&gt; &lt;return_msg&gt;&lt;![CDATA[OK]]&gt;&lt;/return_msg&gt; &lt;/xml&gt; 4.5.2.编写回调接口先分析接口需要的四个数据: 请求方式:官方文档虽然没有明说，但是测试得出是POST请求 请求路径:我们之前指定的notify. url的路径是: /wxpay/notify 请求参数:应该是xml格式数据 返回结果:也是xml,表明是否成功 因为要接收xmI格式数据，因此我们需要引入解析xml的依赖: 12345&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.dataformat&lt;/groupId&gt; &lt;artifactId&gt;jackson-dataformat-xml&lt;/artifactId&gt; &lt;version&gt;2.9.3&lt;/version&gt;&lt;/dependency&gt; 在ly-order中编写controller 123456789101112131415161718192021222324@Slf4j@RestController@RequestMapping("notify")public class NotifyController &#123; @Autowired private OrderService orderService; /** * 微信支付成功回调 * @param result * @return */ @PostMapping(value = "pay",produces = "application/xml") public Map&lt;String,String&gt; hello(@RequestBody Map&lt;String,String&gt; result)&#123; //处理回调 orderService.handleNotify(result); log.info("[支付回调] 订单支付成功，订单号：&#123;&#125;",result.get("out_trade_no")); Map&lt;String,String&gt; msg=new HashMap&lt;&gt;(); msg.put("return_code","SUCCESS"); msg.put("retrun_msg","OK"); return msg; &#125;&#125; 在ly-order中编写OrderService 123456789101112131415161718192021222324252627282930313233public void handleNotify(Map&lt;String, String&gt; result) &#123; //1 数据校验 payHelper.isSuccess(result); //2 校验签名 payHelper.isValidSign(result); //3 校验金额 String totalFeeStr = result.get("total_fee"); String outTradeNo = result.get("out_trade_no"); if (StringUtils.isEmpty(totalFeeStr)|| StringUtils.isEmpty(outTradeNo)) &#123; throw new LyException(ExceptionEnums.INVALID_ORDER_PARAM); &#125; //将totalFeeStr转成long,获取结果的金额totalFee Long totalFee = Long.valueOf(totalFeeStr); //获取订单中的金额 Long orderId = Long.valueOf(outTradeNo); Order order = orderMapper.selectByPrimaryKey(orderId); Long actualPay = order.getActualPay(); //结果金额和订单金额是否一样 if (!totalFee.equals(actualPay))&#123; throw new LyException(ExceptionEnums.INVALID_ORDER_PARAM); &#125; //4 修改订单状态 OrderStatus orderStatus = new OrderStatus(); orderStatus.setStatus(OrderStatusEnum.PAYED.value()); orderStatus.setOrderId(orderId); orderStatus.setPaymentTime(new Date()); int i = orderStatusMapper.updateByPrimaryKeySelective(orderStatus); if (i!=1)&#123; throw new LyException(ExceptionEnums.UPDATE_ORDER_ERROR); &#125; log.info("[订单回调] ，订单支付成功",orderId);&#125; 4.6.付款状态查询当用户扫码支付成功，会自动调用回调接口，从而修改订单状态，完成订单支付。但是，页面上并不知道支付是否成功。怎么办? 4.6.1.页面查询支付状态因为不知道用户什么时候会支付，也不知道支付有没有成功，因此页面会采用定时任务，不断查询订单支付的状态: 123456789101112131415161718192021// 开启定时任务，查询付款状态const taskId = setInterval(() =&gt; &#123; ly.http.get("/order-service/order/state/" + id) .then(resp =&gt; &#123; let i = resp.data; if (i === 1) &#123; // 付款成功 clearInterval(taskId); // 跳转到付款成功页 location.href = "/paysuccess.html?orderId=" + id; &#125; else if (i === 2) &#123; // 付款失败 clearInterval(taskId); // 跳转到付款失败页 location.href = "/payfail.html"; &#125; &#125;).catch((e) =&gt; &#123; alert("支付状态查询失败，请刷新页面重试。"); clearInterval(taskId); &#125;)&#125;, 3000); 每隔3秒会查询一次。 4.6.2.微信查询支付状态接口应用场景该接口提供所有微信支付订单的查询，商户可以通过查询订单接口主动查询订单状态，完成下一步的业务逻辑。需要调用查询接口的情况 当商户后台、网络、服务器等出现异常，商户系统最终未接收到支付通知 调用支付接口后，返回系统错误或未知交易状态情况 调用刷卡支付API，返回USERPAYING的状态 调用关单或撤销接口API之前，需确认支付状态 接口链接 https://api.mch.weixin.qg.com/pay/orderquery 是否需要证书不需要 请求参数 举例如下： 1234567&lt;xml&gt; &lt;appid&gt;wx2421b1 c4370ec43b&lt;/appid&gt; &lt;mch_id&gt;10000100&lt;/mch_id&gt; &lt;nonce_str&gt;ec2316275641faa3aac f3cc599e8730f&lt;/nonce_str&gt; &lt;transaction_id&gt;1008450740201411110805820873&lt;/transaction_id&gt; &lt;sign&gt;FDD167FAA73459FD921B144BAF4F4CA2&lt;/sign&gt;&lt;/xml&gt; 返回结果返回结果中，比较重要的是状态信息： 通信状态： 查询状态码： 支付状态： 4.6.3.工具类我们查询完成后，把支付交易状态分为3种情况: 0，通信失败或未支付，需要重新查询。 1，支付成功 2,支付失败 我们定义一个枚举来表示： 在ly-order中的enums中创建 12345678910public enum PayState &#123; NOT_PAY(0),SUCCESS(1),FAIL(2); PayState(int value)&#123; this.value=value; &#125; int value; public int getValue()&#123; return value; &#125;&#125; 然后在工具类PayHelper中添加查询逻辑： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public PayState queryPayStatus(Long orderId) &#123; try &#123; //组织请求参数 Map&lt;String, String&gt; data = new HashMap&lt;&gt;(); //订单号 data.put("out_trade_no", orderId.toString()); //查询状态 Map&lt;String, String&gt; result = wxPay.orderQuery(data); // 通信和业务校验 isSuccess(result); //校验签名 isValidSign(result); //3 校验金额 String totalFeeStr = result.get("total_fee"); String outTradeNo = result.get("out_trade_no"); if (StringUtils.isEmpty(totalFeeStr)|| StringUtils.isEmpty(outTradeNo)) &#123; throw new LyException(ExceptionEnums.INVALID_ORDER_PARAM); &#125; //将totalFeeStr转成long,获取结果的金额totalFee Long totalFee = Long.valueOf(totalFeeStr); //获取订单中的金额 Order order = orderMapper.selectByPrimaryKey(orderId); Long actualPay = order.getActualPay(); //结果金额和订单金额是否一样 if (!totalFee.equals(/*actualPay*/1))&#123; throw new LyException(ExceptionEnums.INVALID_ORDER_PARAM); &#125; /** * 判断支付是否成功或失败 * SUCCESS—支付成功 * * REFUND—转入退款 * * NOTPAY—未支付 * * CLOSED—已关闭 * * REVOKED—已撤销（付款码支付） * * USERPAYING--用户支付中（付款码支付） * * PAYERROR--支付失败 */ String state = result.get("trade_state"); if (WXPayConstants.SUCCESS.equals(state))&#123; //4 修改订单状态 OrderStatus orderStatus = new OrderStatus(); orderStatus.setStatus(OrderStatusEnum.PAYED.value()); orderStatus.setOrderId(orderId); orderStatus.setPaymentTime(new Date()); int i = orderStatusMapper.updateByPrimaryKeySelective(orderStatus); if (i!=1)&#123; throw new LyException(ExceptionEnums.UPDATE_ORDER_ERROR); &#125; return PayState.SUCCESS; &#125; if ("NOTPAY".equals(state)||"USERPAYING".equals(state))&#123; return PayState.NOT_PAY; &#125; return PayState.FAIL; &#125; catch (Exception e) &#123; return PayState.NOT_PAY; &#125;&#125; 在ly-order中的orderController中编写controller 123456789/** * 查询订单状态 * @param orderId * @return */@GetMapping("state/&#123;id&#125;")public ResponseEntity&lt;Integer&gt; queryStatusById(@PathVariable("id")Long orderId)&#123; return ResponseEntity.ok(orderService.queryStatusById(orderId).getValue());&#125; 在ly-order的service中编写 123456789101112public PayState queryStatusById(Long orderId) &#123; //查询订单状态 OrderStatus orderStatus = orderStatusMapper.selectByPrimaryKey(orderId); Integer status = orderStatus.getStatus(); //判断是否支付 if (!status.equals(OrderStatusEnum.UN_PAY.value())) &#123; //如果已支付，真的是已支付 return PayState.SUCCESS; &#125; //如果未支付，但是其实不一定未支付，必须去微信查询状态 return payHelper.queryPayStatus(orderId);&#125;]]></content>
      <categories>
        <category>项目实战-微服务商城</category>
      </categories>
      <tags>
        <tag>微信支付</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务商城（十七）—— 授权中心]]></title>
    <url>%2Fday16-%E6%8E%88%E6%9D%83%E4%B8%AD%E5%BF%83.html</url>
    <content type="text"><![CDATA[0.学习目标1.无状态登录原理1.1.什么是有状态？有状态服务，即服务端需要记录每次会话的客户端信息，从而识别客户端身份，根据用户身份进行请求的处理，典型的设计如tomcat中的session。 例如登录：用户登录后，我们把登录者的信息保存在服务端session中，并且给用户一个cookie值，记录对应的session。然后下次请求，用户携带cookie值来，我们就能识别到对应session，从而找到用户的信息。 缺点是什么？ 服务端保存大量数据，增加服务端压力 服务端保存用户状态，无法进行水平扩展 客户端请求依赖服务端，多次请求必须访问同一台服务器 1.2.什么是无状态微服务集群中的每个服务，对外提供的都是Rest风格的接口。而Rest风格的一个最重要的规范就是：服务的无状态性，即： 服务端不保存任何客户端请求者信息 客户端的每次请求必须具备自描述信息，通过这些信息识别客户端身份 带来的好处是什么呢？ 客户端请求不依赖服务端的信息，任何多次请求不需要必须访问到同一台服务 服务端的集群和状态对客户端透明 服务端可以任意的迁移和伸缩 减小服务端存储压力 1.3.如何实现无状态无状态登录的流程： 当客户端第一次请求服务时，服务端对用户进行信息认证（登录） 认证通过，将用户信息进行加密形成token，返回给客户端，作为登录凭证 以后每次请求，客户端都携带认证的token 服务端对token进行解密，判断是否有效。 流程图： 整个登录过程中，最关键的点是什么？ token的安全性 token是识别客户端身份的唯一标示，如果加密不够严密，被人伪造那就完蛋了。 采用何种方式加密才是安全可靠的呢？ 我们将采用JWT + RSA非对称加密 1.4.JWT1.4.1.简介JWT，全称是Json Web Token， 是JSON风格轻量级的授权和身份认证规范，可实现无状态、分布式的Web应用授权；官网：https://jwt.io GitHub上jwt的java客户端：https://github.com/jwtk/jjwt 1.4.2.数据格式JWT包含三部分数据： Header：头部，通常头部有两部分信息： 声明类型，这里是JWT 加密算法，自定义 我们会对头部进行base64加密（可解密），得到第一部分数据 Payload：载荷，就是有效数据，一般包含下面信息： 用户身份信息（注意，这里因为采用base64加密，可解密，因此不要存放敏感信息） 注册声明：如token的签发时间，过期时间，签发人等 这部分也会采用base64加密，得到第二部分数据 Signature：签名，是整个数据的认证信息。一般根据前两步的数据，再加上服务的的密钥（secret）（不要泄漏，最好周期性更换），通过加密算法生成。用于验证整个数据完整和可靠性 生成的数据格式： 可以看到分为3段，每段就是上面的一部分数据 1.4.3.JWT交互流程流程图： 步骤翻译： 1、用户登录 2、服务的认证，通过后根据secret生成token 3、将生成的token返回给浏览器 4、用户每次请求携带token 5、服务端利用公钥解读jwt签名，判断签名有效后，从Payload中获取用户信息 6、处理请求，返回响应结果 因为JWT签发的token中已经包含了用户的身份信息，并且每次请求都会携带，这样服务的就无需保存用户信息，甚至无需去数据库查询，完全符合了Rest的无状态规范。 1.4.4.非对称加密加密技术是对信息进行编码和解码的技术，编码是把原来可读信息（又称明文）译成代码形式（又称密文），其逆过程就是解码（解密），加密技术的要点是加密算法，加密算法可以分为三类： 对称加密，如AES 基本原理：将明文分成N个组，然后使用密钥对各个组进行加密，形成各自的密文，最后把所有的分组密文进行合并，形成最终的密文。 优势：算法公开、计算量小、加密速度快、加密效率高 缺陷：双方都使用同样密钥，安全性得不到保证 非对称加密，如RSA 基本原理：同时生成两把密钥：私钥和公钥，私钥隐秘保存，公钥可以下发给信任客户端 私钥加密，持有私钥或公钥才可以解密 公钥加密，持有私钥才可解密 优点：安全，难以破解 缺点：算法比较耗时 不可逆加密，如MD5，SHA 基本原理：加密过程中不需要使用密钥，输入明文后由系统直接经过加密算法处理成密文，这种加密后的数据是无法被解密的，无法根据密文推算出明文。 RSA算法历史： 1977年，三位数学家Rivest、Shamir 和 Adleman 设计了一种算法，可以实现非对称加密。这种算法用他们三个人的名字缩写：RSA 1.5.结合Zuul的鉴权流程我们逐步演进系统架构设计。需要注意的是：secret是签名的关键，因此一定要保密，我们放到鉴权中心保存，其它任何服务中都不能获取secret。 1.5.1.没有RSA加密时在微服务架构中，我们可以把服务的鉴权操作放到网关中，将未通过鉴权的请求直接拦截，如图： 1、用户请求登录 2、Zuul将请求转发到授权中心，请求授权 3、授权中心校验完成，颁发JWT凭证 4、客户端请求其它功能，携带JWT 5、Zuul将jwt交给授权中心校验，通过后放行 6、用户请求到达微服务 7、微服务将jwt交给鉴权中心，鉴权同时解析用户信息 8、鉴权中心返回用户数据给微服务 9、微服务处理请求，返回响应 发现什么问题了？ 每次鉴权都需要访问鉴权中心，系统间的网络请求频率过高，效率略差，鉴权中心的压力较大。 1.5.2.结合RSA的鉴权直接看图： 我们首先利用RSA生成公钥和私钥。私钥保存在授权中心，公钥保存在Zuul和各个微服务 用户请求登录 授权中心校验，通过后用私钥对JWT进行签名加密 返回jwt给用户 用户携带JWT访问 Zuul直接通过公钥解密JWT，进行验证，验证通过则放行 请求到达微服务，微服务直接用公钥解析JWT，获取用户信息，无需访问授权中心 2.授权中心2.1.创建授权中心授权中心的主要职责： 用户鉴权： 接收用户的登录请求，通过用户中心的接口进行校验，通过后生成JWT 使用私钥生成JWT并返回 服务鉴权：微服务间的调用不经过Zuul，会有风险，需要鉴权中心进行认证 原理与用户鉴权类似，但逻辑稍微复杂一些（此处我们不做实现） 因为生成jwt，解析jwt这样的行为以后在其它微服务中也会用到，因此我们会抽取成工具。我们把鉴权中心进行聚合，一个工具module，一个提供服务的module 2.1.1.创建父module我们先创建父module，名称为：ly-auth 将pom打包方式改为pom： 12345678910111213141516&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;leyou&lt;/artifactId&gt; &lt;groupId&gt;com.leyou.parent&lt;/groupId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.auth&lt;/groupId&gt; &lt;artifactId&gt;leyou-auth&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;&lt;/project&gt; 2.1.2.通用module然后是授权服务的通用模块：ly-auth-common： pom.xml： 12345678910111213141516&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;leyou-auth&lt;/artifactId&gt; &lt;groupId&gt;com.leyou.auth&lt;/groupId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.auth&lt;/groupId&gt; &lt;artifactId&gt;leyou-auth-common&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/project&gt; 结构： 2.1.3.授权服务ly-auth-service pom.xml： 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;ly-auth&lt;/artifactId&gt; &lt;groupId&gt;com.leyou.service&lt;/groupId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.service&lt;/groupId&gt; &lt;artifactId&gt;ly-auth-service&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.leyou.service&lt;/groupId&gt; &lt;artifactId&gt;ly-auth-common&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.leyou.common&lt;/groupId&gt; &lt;artifactId&gt;ly-common&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 引导类： 123456789@SpringBootApplication@EnableDiscoveryClient@EnableFeignClientspublic class LyAuthApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(LyAuthApplication.class, args); &#125;&#125; application.yml 12345678910111213141516server: port: 8087spring: application: name: auth-serviceeureka: client: service-url: defaultZone: http://127.0.0.1:10086/eureka registry-fetch-interval-seconds: 10 instance: lease-renewal-interval-in-seconds: 5 # 每隔5秒发送一次心跳 lease-expiration-duration-in-seconds: 10 # 10秒不发送就过期 prefer-ip-address: true ip-address: 127.0.0.1 instance-id: $&#123;spring.application.name&#125;:$&#123;server.port&#125; 结构： 在ly-gateway工程的application.yml中，修改路由： 1234567zuul: prefix: /api # 路由路径前缀 routes: item-service: /item/** # 商品微服务的映射路径 search-service: /search/** # 搜索微服务 user-service: /user/** # 用户微服务 auth-service: /auth/** # 授权中心微服务 2.2.JWT工具类我们在ly-auth-common中导入课前资料中的工具类： 在资料中的JWT攻工具类中 UserInfo：载荷类 JwtConstans：其中定义了jwt中的payload的常用key JwtUtils：公钥秘钥操作token ObjectUtils：从jwt解析得到的数据是Object类型，转换为具体类型可能出现空指针，这个工具类进行了一些转换 RsaUtils：对秘钥公钥操作 需要在ly-auth-common中引入JWT依赖： 123456789101112131415&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt&lt;/artifactId&gt; &lt;version&gt;0.9.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;joda-time&lt;/groupId&gt; &lt;artifactId&gt;joda-time&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 2.3.测试工具类我们在ly-auth-common中编写测试类： ==注测试类不需要@RunWith(SpringRunner.class)，@SpringBootTest== 1234567891011121314151617181920212223242526272829303132333435363738public class JwtTest &#123; private static final String pubKeyPath = "D:\\heima\\rsa\\rsa.pub"; private static final String priKeyPath = "D:\\heima\\rsa\\rsa.pri"; private PublicKey publicKey; private PrivateKey privateKey; @Test public void testRsa() throws Exception &#123; RsaUtils.generateKey(pubKeyPath, priKeyPath, "234"); &#125; @Before public void testGetRsa() throws Exception &#123; this.publicKey = RsaUtils.getPublicKey(pubKeyPath); this.privateKey = RsaUtils.getPrivateKey(priKeyPath); &#125; @Test public void testGenerateToken() throws Exception &#123; // 生成token String token = JwtUtils.generateToken(new UserInfo(20L, "jack"), privateKey, 5); System.out.println("token = " + token); &#125; @Test public void testParseToken() throws Exception &#123; String token = "eyJhbGciOiJSUzI1NiJ9.eyJpZCI6MjAsInVzZXJOYW1lIjoiamFjayIsImV4cCI6MTUyNzMzMDY5NX0.VpGNedy1z0aR262uAp2sM6xB4ljuxa4fzqyyBpZcGTBNLodIfuCNZkOjdlqf-km6TQPoz3epYf8cc_Rf9snsGdz4YPIwpm6X14JKU9jwL74q6zy61J8Nl9q7Zu3YnLibAvcnC_y9omiqKN8-iCi7-MvM-LwVS7y_Cx9eu0aaY8E"; // 解析token UserInfo user = JwtUtils.getInfoFromToken( publicKey,token); System.out.println("id: " + user.getId()); System.out.println("userName: " + user.getName()); &#125;&#125; 测试生成公钥和私钥，我们运行这段代码： 运行之后，查看目标目录： 公钥和私钥已经生成了！ 测试生成token，把@Before的注释去掉的： 将上述得到的token复制到testParseToken（）中，并测试解析token： 正常情况： 解析得到 任意改动token，发现报错了： 2.3.编写登录授权接口接下来，我们需要在ly-auth-servcice编写一个接口，对外提供登录授权服务。基本流程如下： 客户端携带用户名和密码请求登录 授权中心调用客户中心接口，根据用户名和密码查询用户信息 如果用户名密码正确，能获取用户，否则为空，则登录失败 如果校验成功，则生成JWT并返回 2.3.1.生成公钥和私钥我们需要在授权中心 ly-auth-service 中生成真正的公钥和私钥。我们必须有一个生成公钥和私钥的secret，这个可以配置到application.yml中： 123456ly: jwt: secret: leyou@Login(Auth&#125;*^31)&amp;heiMa% # 登录校验的密钥 pubKeyPath: D:\\heima\\rsa\\rsa.pub # 公钥地址 priKeyPath: D:\\heima\\rsa\\rsa.pri # 私钥地址 expire: 30 # 过期时间,单位分钟 然后编写属性类，加载这些数据： 在ly-auth-service的pom.xml添加 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; ly-auth-service中com.leyou.auth.config中创建 1234567891011121314151617181920212223242526272829303132333435363738394041@Data@ConfigurationProperties(prefix = "ly.jwt")public class JwtProperties &#123; private String secret; // 密钥 private String pubKeyPath;// 公钥 private String priKeyPath;// 私钥 private int expire;// token过期时间 private PublicKey publicKey; // 公钥 private PrivateKey privateKey; // 私钥 private static final Logger logger = LoggerFactory.getLogger(JwtProperties.class); /** * @PostContruct：在构造方法执行之后执行该方法 */ @PostConstruct public void init()&#123; try &#123; File pubKey = new File(pubKeyPath); File priKey = new File(priKeyPath); if (!pubKey.exists() || !priKey.exists()) &#123; // 生成公钥和私钥 RsaUtils.generateKey(pubKeyPath, priKeyPath, secret); &#125; // 获取公钥和私钥 this.publicKey = RsaUtils.getPublicKey(pubKeyPath); this.privateKey = RsaUtils.getPrivateKey(priKeyPath); &#125; catch (Exception e) &#123; logger.error("初始化公钥和私钥失败！", e); throw new RuntimeException(); &#125; &#125; // getter setter ...&#125; 2.3.2.Controller编写授权接口，我们接收用户名和密码，校验成功后，写入cookie中。 请求方式：post 请求路径：/accredit 请求参数：username和password 返回结果：无 代码： 123456789101112131415161718192021222324252627282930313233/** * @version V1.0 * @ClassName:$&#123;file_name&#125; * @Description:授权中心 * @author:cxg * @Date:$&#123;time&#125; */public class AuthController &#123; @Autowired private AuthService authService; @Autowired private JwtProperties jwtProperties; /** * 登入授权功能 * @param username * @param password * @return */ @PostMapping("login") public ResponseEntity&lt;Void&gt; login( @RequestParam("username")String username, @RequestParam("password")String password, HttpServletRequest request, HttpServletResponse response)&#123; //登入校验 String token = authService.login(username, password); //将token写入cookie,并指定httpOnly为true，防止通过JS获取和修改 //同CookieUtils.newBuilder(response).httpOnly().request(request).build(cookieName,token)一样 CookieUtils.setCookie(request,response,jwtProperties.getCookieName(),token,jwtProperties.getCookieMaxage(),true); return ResponseEntity.status(HttpStatus.NO_CONTENT).build(); &#125;&#125; 这里的cookie的name和生存时间，我们配置到属性文件：application.yml： 然后在JwtProperties中添加属性： 2.3.3.CookieUtils要注意，这里我们使用了一个工具类，CookieUtils，可以在课前资料中找到，我们把它添加到leyou-common中，然后引入servlet相关依赖即可： 1234&lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-core&lt;/artifactId&gt;&lt;/dependency&gt; 代码：略 2.3.3.UserAPi和UserClient UserAPi 在ly-user-service中编写对外接口 1234567891011public interface UserAPi &#123; /** * 根据用户名和密码查询用户 * @param username * @param password * @return */ @GetMapping("query") public User queryUser(@RequestParam("username")String username, @RequestParam("password")String password);&#125; UserClient 接下来我们肯定要对用户密码进行校验，所以我们需要通过FeignClient去访问 user-service微服务： 在ly-anth-service中的pom.xml中引入user-service依赖： 12345&lt;dependency&gt; &lt;groupId&gt;com.leyou.service&lt;/groupId&gt; &lt;artifactId&gt;ly-user-service&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt; 编写FeignClient： 123@FeignClient(value = "user-service")public interface UserClient extends UserApi &#123;&#125; 2.3.4.Servicely-auth-service中的service 123456789101112131415161718192021222324252627282930@Servicepublic class AuthService &#123; @Autowired private UserClient userClient; @Autowired private JwtProperties properties; public String authentication(String username, String password) &#123; try &#123; // 调用微服务，执行查询 User user = this.userClient.queryUser(username, password); // 如果查询结果为null，则直接返回null if (user == null) &#123; return null; &#125; // 如果有查询结果，则生成token String token = JwtUtils.generateToken(new UserInfo(user.getId(), user.getUsername()), properties.getPrivateKey(), properties.getExpire()); return token; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125; 2.3.5.项目结构 2.3.6.测试 2.4.登录页面接下来，我们看看登录页面，是否能够正确的发出请求。 我们在页面输入登录信息，然后点击登录： 查看控制台： 发现请求的路径不对，我们的认证接口是： 1/api/auth/login 我们打开login.html，修改路径信息： 页面ajax请求： 然后再次测试，成功跳转到了首页： 2.5.解决cookie写入问题接下来我们查看首页cookie： 什么都没有，为什么？ 2.5.1.问题分析我们在之前测试时，清晰的看到了响应头中，有Set-Cookie属性，为什么在这里却什么都没有？ 我们之前在讲cors跨域时，讲到过跨域请求cookie生效的条件： 服务的响应头中需要携带Access-Control-Allow-Credentials并且为true。 响应头中的Access-Control-Allow-Origin一定不能为*，必须是指定的域名 浏览器发起ajax需要指定withCredentials 为true 看看我们的服务端cors配置： 没有任何问题。 再看客户端浏览器的ajax配置，我们在js/common.js中对axios进行了统一配置： 一切OK。 那说明，问题一定出在响应的set-cookie头中。我们再次仔细看看刚才的响应头： 我们发现cookie的 domain属性似乎不太对。 cookie也是有域 的限制，一个网页，只能操作当前域名下的cookie，但是现在我们看到的地址是0.0.1，而页面是www.leyou.com,域名不匹配，cookie设置肯定失败了！ 2.5.2.跟踪CookieUtils我们去Debug跟踪CookieUtils，看看到底是怎么回事： 我们发现内部有一个方法，用来获取Domain： 它获取domain是通过服务器的host来计算的，然而我们的地址竟然是：127.0.0.1:8087，因此后续的运算，最终得到的domain就变成了： 问题找到了：我们请求时的serverName明明是：api.leyou.com，现在却被变成了：127.0.0.1，因此计算domain是错误的，从而导致cookie设置失败！ 2.5.3.解决host地址的变化那么问题来了：为什么我们这里的请求serverName变成了：127.0.0.1:8087呢？ 这里的server name其实就是请求时的主机名：Host，之所以改变，有两个原因： 我们使用了nginx反向代理，当监听到api.leyou.com的时候，会自动将请求转发至127.0.0.1:10010，即Zuul。 而后请求到达我们的网关Zuul，Zuul就会根据路径匹配，我们的请求是/api/auth，根据规则被转发到了 127.0.0.1:8087 ，即我们的授权中心。 我们首先去更改nginx配置，让它不要修改我们的host：proxy_set_header Host $host; 把nginx进行reload： 1nginx -s reload 这样就解决了nginx这里的问题。但是Zuul还会有一次转发，所以要去修改网关的配置（ly-gateway工程）： 重启后，我们再次测试。 最后计算得到的domain： 完美！ 2.5.4.再次测试我们再次登录，发现依然没有cookie！！ 怎么回事呢？ 我们通过RestClient访问下看看： 发现，响应头中根本没有set-cookie了。 这是怎么回事？？ 2.5.5.Zuul的敏感头过滤Zuul内部有默认的过滤器，会对请求和响应头信息进行重组，过滤掉敏感的头信息： 会发现，这里会通过一个属性为SensitiveHeaders的属性，来获取敏感头列表，然后添加到IgnoredHeaders中，这些头信息就会被忽略。 而这个SensitiveHeaders的默认值就包含了set-cookie： 解决方案有两种： 全局设置： zuul.sensitive-headers= 指定路由设置： zuul.routes.&lt;routeName&gt;.sensitive-headers= zuul.routes.&lt;routeName&gt;.custom-sensitive-headers=true 思路都是把敏感头设置为null 2.5.6.最后的测试再次重启后测试： 3.首页判断登录状态虽然cookie已经成功写入，但是我们首页的顶部，登录状态依然没能判断出用户信息： 这里需要向后台发起请求，根据cookie获取当前用户的信息。 我们先看页面实现 3.1.页面JS代码页面的顶部已经被我们封装为一个独立的Vue组件，在/js/pages/shortcut.js中 打开js，发现里面已经定义好了Vue组件，并且在created函数中，查询用户信息： 查看网络控制台，发现发起了请求： 因为token在cookie中，因此本次请求肯定会携带token信息在头中。 3.2.后台实现校验用户接口我们在ly-auth-service中定义用户的校验接口，通过cookie获取token，然后校验通过返回用户信息。 请求方式：GET 请求路径：/verify 请求参数：无，不过我们需要从cookie中获取token信息 返回结果：UserInfo，校验成功返回用户信息；校验失败，则返回401 代码： 12345678910111213141516/** * 校验用户登入状态，获取用户名显示在前端 * @param token * @return */@GetMapping("verify")public ResponseEntity&lt;UserInfo&gt; verify(@CookieValue("LY_TOKEN")String token)&#123; try &#123; UserInfo info = JwtUtils.getInfoFromToken(jwtProperties.getPublicKey(), token); return ResponseEntity.ok(info); &#125;catch (Exception e)&#123; //token已经过期，或者，token已经被篡改 throw new LyException(ExceptionEnums.UN_AUTHORIZED); &#125;&#125; 3.3.测试 页面效果： 3.4.刷新token每当用户在页面进行新的操作，都应该刷新token的过期时间，否则30分钟后用户的登录信息就无效了。而刷新其实就是重新生成一份token，然后写入cookie即可。 那么问题来了：我们怎么知道用户有操作呢？ 事实上，每当用户来查询其个人信息，就证明他正在浏览网页，此时刷新cookie是比较合适的时机。因此我们可以对刚刚的校验用户登录状态的接口进行改进，加入刷新token的逻辑。 12345678910111213141516171819202122/** * 校验用户登入状态，获取用户名显示在前端 * @param token * @return */@GetMapping("verify")public ResponseEntity&lt;UserInfo&gt; verify(@CookieValue("LY_TOKEN")String token, HttpServletRequest request, HttpServletResponse response)&#123; try &#123; UserInfo info = JwtUtils.getInfoFromToken(jwtProperties.getPublicKey(), token); //重新刷新token String newToken = JwtUtils.generateToken(info, jwtProperties.getPrivateKey(), jwtProperties.getExpire()); //写入cookie CookieUtils.newBuilder(response).httpOnly().maxAge(jwtProperties.getCookieMaxage()).request(request).build(jwtProperties.getCookieName(),newToken); return ResponseEntity.ok(info); &#125;catch (Exception e)&#123; //token已经过期，或者，token已经被篡改 throw new LyException(ExceptionEnums.UN_AUTHORIZED); &#125;&#125; 4.网关的登录拦截器接下来，我们在Zuul编写拦截器，对用户的token进行校验，如果发现未登录，则进行拦截。 4.1.引入jwt相关配置既然是登录拦截，一定是前置拦截器，我们在ly-gateway中定义。 首先在pom.xml中，引入所需要的依赖： 12345678910&lt;dependency&gt; &lt;groupId&gt;com.leyou.common&lt;/groupId&gt; &lt;artifactId&gt;ly-common&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.leyou.auth&lt;/groupId&gt; &lt;artifactId&gt;ly-auth-common&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt; 然后编写application.yml属性文件，添加如下内容： 1234ly: jwt: pubKeyPath: D:\\heima\\rsa\\rsa.pub # 公钥地址 CookieName: LY_TOKEN 编写属性类，读取公钥： 12345678910111213141516171819@Data@ConfigurationProperties(prefix = "ly.jwt")public class JwtProperties &#123; private String pubKeyPath;// 公钥 private String CookieName; private Integer CookieMaxage; private PublicKey publicKey; //对象一旦实例化后，就应该读取公钥和私钥 @PostConstruct //实例化后执行 public void init() throws Exception &#123; //读取公钥和私钥 this.publicKey = RsaUtils.getPublicKey(pubKeyPath); &#125;&#125; 4.2.编写过滤器逻辑基本逻辑： 获取cookie中的token 通过JWT对token进行校验 通过：则放行；不通过：则重定向到登录页 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051@Component@EnableConfigurationProperties(JwtProperties.class)public class AuthFilter extends ZuulFilter&#123; @Autowired private JwtProperties jwtProperties; @Override public String filterType() &#123; return FilterConstants.PRE_TYPE;//过滤器类型，前置过滤 &#125; @Override public int filterOrder() &#123; return FilterConstants.PRE_DECORATION_FILTER_ORDER-1;//过滤器顺序 &#125; /** * 放行逻辑 * true：过滤 * false：不过滤 * @return */ @Override public boolean shouldFilter() &#123; return true; &#125; @Override public Object run() throws ZuulException &#123; //获取上下文 RequestContext ctx = RequestContext.getCurrentContext(); //获取request HttpServletRequest request = ctx.getRequest(); //获取cookie中的token String token = CookieUtils.getCookieValue(request, jwtProperties.getCookieName()); try &#123; //解析token UserInfo userInfo = JwtUtils.getInfoFromToken(jwtProperties.getPublicKey(), token); //todo 校验权限 &#125;catch (Exception e)&#123; //解析token失败，未登入，拦截 ctx.setSendZuulResponse(false); ctx.setResponseStatusCode(403); &#125; return null; &#125;&#125; 4.2.1测试http://api.leyou.com/api/item/category/list?pid=0 同时一切请求都被拦截下来 重启，刷新页面，发现请求校验的接口也被拦截了： 证明我们的拦截器生效了，但是，似乎有什么不对的。这个路径似乎不应该被拦截啊！ 4.3.白名单要注意，并不是所有的路径我们都需要拦截，例如： 登录校验接口：/auth/** 注册接口：/user/register 数据校验接口：/user/check/** 发送验证码接口：/user/code 搜索接口：/search/** 另外，跟后台管理相关的接口，因为我们没有做登录和权限，因此暂时都放行，但是生产环境中要做登录校验： 后台商品服务：/item/** 所以，我们需要在拦截时，配置一个白名单，如果在名单内，则不进行拦截。 在ly-gateway中application.yaml中添加规则： 123456789ly: filter: allowPaths: - /api/auth - /api/search - /api/user/register - /api/user/check - /api/user/code - /api/item 然后读取这些属性： 内容： 12345@Data@ConfigurationProperties(prefix = "ly.filter")public class FilterProperties &#123; private List&lt;String&gt; allowPaths;&#125; 在过滤器中的shouldFilter方法中添加判断逻辑： 代码： 修改ly-gateway拦截页面AuthFilter.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475@Component@EnableConfigurationProperties(&#123;JwtProperties.class, FilterProperties.class&#125;)public class AuthFilter extends ZuulFilter&#123; @Autowired private JwtProperties jwtProperties; @Autowired private FilterProperties filterProperties; @Override public String filterType() &#123; return FilterConstants.PRE_TYPE;//过滤器类型，前置过滤 &#125; @Override public int filterOrder() &#123; return FilterConstants.PRE_DECORATION_FILTER_ORDER-1;//过滤器顺序 &#125; /** * 放行逻辑 * true：过滤 * false：不过滤 * @return */ @Override public boolean shouldFilter() &#123; //获取上下文 RequestContext ctx = RequestContext.getCurrentContext(); //获取request HttpServletRequest request = ctx.getRequest(); //获取请求的url路径 String requestURL = request.getRequestURI(); //判断是否放行，否则返回false boolean isAllowPath=isAllowPath(requestURL); return !isAllowPath; &#125; /** * 判断路径 * @param requestURL * @return */ private Boolean isAllowPath(String requestURL) &#123; for (String allowPath : filterProperties.getAllowPaths()) &#123; //判断路径是否相等 if (requestURL.startsWith(allowPath))&#123; return true; &#125; &#125; return false; &#125; @Override public Object run() throws ZuulException &#123; //获取上下文 RequestContext ctx = RequestContext.getCurrentContext(); //获取request HttpServletRequest request = ctx.getRequest(); //获取cookie中的token String token = CookieUtils.getCookieValue(request, jwtProperties.getCookieName()); try &#123; //解析token UserInfo userInfo = JwtUtils.getInfoFromToken(jwtProperties.getPublicKey(), token); //todo 校验权限 &#125;catch (Exception e)&#123; //解析token失败，未登入，拦截 ctx.setSendZuulResponse(false); ctx.setResponseStatusCode(403); &#125; return null; &#125;&#125; 再次测试： 4.4.可优化的点授权登录还需要完善: 需要引入权限控制系统 在AuthFiter中， 应该判断权限 授权中心还可以做服务鉴权 面试点: 如果cookie被禁用怎么办? 首先可以提示用户，网站必须使用cookie,不能禁用。 把token放入头中返回，JS中获取头信息，存入web存储(localStorage,SessionStorage) ,每次请求都需要手动携带token,写入头中。 如果cookie被盗用怎么办？ 我们的cookie无法篡改 加入ip地址识别身份(不太好)。使用HTTPS协议，防止数据泄漏 如果你的微服务地址暴露怎么办? 首先地址不会暴露，因为所有微服务都是通过Zuuli进行访问，对外暴露的只有Zuul 万一暴露了呢? 服务间鉴权。 1querySkuByids]]></content>
      <categories>
        <category>项目实战-微服务商城</category>
      </categories>
      <tags>
        <tag>JWT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务商城（十六）——用户注册]]></title>
    <url>%2Fday15-%E7%94%A8%E6%88%B7%E6%B3%A8%E5%86%8C.html</url>
    <content type="text"><![CDATA[0.学习目标 独立创建用户中心 了解面向接口开发方式 实现数据校验功能 实现短信发送功能 实现注册功能 实现根据用户名和密码查询用户功能 1.创建用户中心用户搜索到自己心仪的商品，接下来就要去购买，但是购买必须先登录。所以接下来我们编写用户中心，实现用户的登录和注册功能。 用户中心的提供的服务： 用户的注册 用户登录 用户个人信息管理 用户地址管理 用户收藏管理 我的订单 优惠券管理 这里我们暂时先实现基本的：注册和登录功能，其它功能大家可以自行补充完整。 因为用户中心的服务其它微服务也会调用，因此这里我们做聚合。 ly-user：父工程，包含2个子工程： ly-user-interface：实体及接口 ly-user-service：业务和服务 1.1.创建父module创建 1.2.创建子工程ly-user-interface在leyou-user下，创建module： 位置： pom： 12345678910111213141516&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;ly-user&lt;/artifactId&gt; &lt;groupId&gt;com.leyou.service&lt;/groupId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.service&lt;/groupId&gt; &lt;artifactId&gt;ly-user-interface&lt;/artifactId&gt;&lt;/project&gt; 1.3.创建子工程ly-user-service创建module 位置 pom 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;ly-user&lt;/artifactId&gt; &lt;groupId&gt;com.leyou.service&lt;/groupId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.service&lt;/groupId&gt; &lt;artifactId&gt;ly-user-service&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- mybatis启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 通用Mapper启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- mysql驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.leyou.service&lt;/groupId&gt; &lt;artifactId&gt;ly-user-interface&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 启动类 123456789@SpringBootApplication@EnableDiscoveryClient@MapperScan("com.leyou.user.mapper")public class LyUserApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(LyUserApplication.class, args); &#125;&#125; 配置： 12345678910111213141516171819202122232425server: port: 8085spring: application: name: user-service datasource: url: jdbc:mysql://localhost:3306/leyou-new?serverTimezone=Asia/Shanghai&amp;characterEncoding=utf8 username: root password: cxg200888 hikari: maximum-pool-size: 30 minimum-idle: 10eureka: client: service-url: defaultZone: http://127.0.0.1:10086/eureka instance: prefer-ip-address: true ip-address: 127.0.0.1 instance-id: $&#123;eureka.instance.ip-address&#125;.$&#123;server.port&#125; lease-renewal-interval-in-seconds: 5 lease-expiration-duration-in-seconds: 15mybatis: type-aliases-package: com.leyou.user.pojo 父工程lyeyou-user的pom： 12345678910111213141516171819&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;leyou&lt;/artifactId&gt; &lt;groupId&gt;com.leyou.parent&lt;/groupId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.service&lt;/groupId&gt; &lt;artifactId&gt;ly-user&lt;/artifactId&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;modules&gt; &lt;module&gt;ly-user-interface&lt;/module&gt; &lt;module&gt;ly-user-service&lt;/module&gt; &lt;/modules&gt;&lt;/project&gt; 1.4.添加网关路由我们修改ly-gateway，添加路由规则，对ly-user-service进行路由: 2.后台功能准备2.1.接口文档整个用户中心的开发，我们将模拟公司内面向接口的开发。 现在假设项目经理已经设计好了接口文档，详见：《用户中心接口说明.md》 我们将根据文档直接编写后台功能，不关心页面实现。 2.2.数据结构12345678910CREATE TABLE `tb_user` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `username` varchar(50) NOT NULL COMMENT &apos;用户名&apos;, `password` varchar(32) NOT NULL COMMENT &apos;密码，加密存储&apos;, `phone` varchar(20) DEFAULT NULL COMMENT &apos;注册手机号&apos;, `created` datetime NOT NULL COMMENT &apos;创建时间&apos;, `salt` varchar(32) NOT NULL COMMENT &apos;密码加密的salt值&apos;, PRIMARY KEY (`id`), UNIQUE KEY `username` (`username`) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=28 DEFAULT CHARSET=utf8 COMMENT=&apos;用户表&apos;; 数据结构比较简单，因为根据用户名查询的频率较高，所以我们给用户名创建了索引 2.3.基本代码 2.3.1.实体类123456789101112131415161718@Table(name = "tb_user")public class User &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; private String username;// 用户名 @JsonIgnore private String password;// 密码 private String phone;// 电话 private Date created;// 创建时间 @JsonIgnore private String salt;// 密码的盐值&#125; 注意：为了安全考虑。这里对password和salt添加了注解@JsonIgnore，这样在json序列化时，就不会把password和salt返回。 2.3.2.mapper12public interface UserMapper extends Mapper&lt;User&gt; &#123;&#125; 2.3.3.Service123456@Servicepublic class UserService &#123; @Autowired private UserMapper userMapper;&#125; 2.3.4.controller1234567@Controllerpublic class UserController &#123; @Autowired private UserService userService; &#125; 3.数据验证功能3.1.接口说明实现用户数据的校验，主要包括对：手机号、用户名的唯一性校验。 接口路径： 1GET /check/&#123;data&#125;/&#123;type&#125; 参数说明： 参数 说明 是否必须 数据类型 默认值 data 要校验的数据 是 String 无 type 要校验的数据类型：1，用户名；2，手机； 否 Integer 1 返回结果： 返回布尔类型结果： true：可用 false：不可用 状态码： 200：校验成功 400：参数有误 500：服务器内部异常 3.2.controller因为有了接口，我们可以不关心页面，所有需要的东西都一清二楚： 请求方式：GET 请求路径：/check/{data}/{type} 请求参数：param,type 返回结果：true或false 12345678910111213141516171819@RestControllerpublic class UserController &#123; @Autowired private UserService userService; /** * 校验数据是否可用 * @param data 数据 * @param type 要校验的数据类型：1，用户名；2，手机； * @return */ @GetMapping("/check/&#123;data&#125;/&#123;type&#125;") public ResponseEntity&lt;Boolean&gt; checkData(@PathVariable("data") String data, @PathVariable("type")Integer type)&#123; return ResponseEntity.ok(userService.checkData(data,type)); &#125; &#125; 3.3.Service123456789101112131415161718192021@Servicepublic class UserService &#123; @Autowired private UserMapper userMapper; public Boolean checkData(String data, Integer type) &#123; User user = new User(); //判断数据类型用switch switch (type) &#123; case 1: user.setUsername(data); break; case 2: user.setPhone(data); break; default: throw new LyException(ExceptionEnums.INVALID_DATA_TYPE); &#125; return userMapper.selectCount(user)==0; &#125;&#125; 3.4.测试我们在数据库插入一条假数据： 然后在浏览器调用接口，测试： 4.发送短信功能短信微服务已经准备好，我们就可以继续编写用户中心接口了。 4.1.接口说明 这里的业务逻辑是这样的： 1）我们接收页面发送来的手机号码 2）生成一个随机验证码 3）将验证码保存在服务端 4）发送短信，将验证码发送到用户手机 那么问题来了：验证码保存在哪里呢？ 验证码有一定有效期，一般是5分钟，我们可以利用Redis的过期机制来保存。 4.2.UserControllerly-user中ly-user-service的web中 12345678910/** * 发送手机生成验证码 * @param phone * @return */@PostMapping("code")public ResponseEntity&lt;Void&gt; sendCode(@RequestParam("phone")String phone)&#123; userService.sendCode(phone); return ResponseEntity.status(HttpStatus.NO_CONTENT).build();&#125; 4.3.UserServicely-user中ly-user-service的service中 这里的逻辑会稍微复杂： 生成随机验证码 将验证码保存到Redis中，用来在注册的时候验证 发送验证码到ly-sm服务，发送短信 因此，我们需要引入Redis和AMQP： 12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;&lt;/dependency&gt; 添加RabbitMQ和Redis配置： 123456789101112131415spring: redis: host: 192.168.25.128 rabbitmq: host: 192.168.25.128 username: 2850105498 password: cxg200888 virtual-host: /leyou template: retry: enabled: true initial-interval: 10000ms max-interval: 210000ms multiplier: 2 publisher-confirms: true 另外还要用到工具类，生成6位随机码，这个我们封装到了leyou-common中，因此需要引入依赖： 12345&lt;dependency&gt; &lt;groupId&gt;com.leyou.common&lt;/groupId&gt; &lt;artifactId&gt;ly-common&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt; 生成随机码的工具：ly-common中的工具类NumberUtils方法generateCode 123456789101112/** * 生成指定位数的随机数字 * @param len 随机数的位数 * @return 生成的随机数 */public static String generateCode(int len)&#123; len = Math.min(len, 8); int min = Double.valueOf(Math.pow(10, len - 1)).intValue(); int num = new Random().nextInt( Double.valueOf(Math.pow(10, len + 1)).intValue() - 1) + min; return String.valueOf(num).substring(0,len);&#125; Service代码： 12345678910111213141516171819202122232425262728@Autowiredprivate UserMapper userMapper;@Autowiredprivate AmqpTemplate amqpTemplate;@Autowiredprivate StringRedisTemplate redisTemplate;private static final String KEY_CODE="user:code:phone:";public void sendCode(String phone) &#123; //随机生成六位数字 String code= NumberUtils.generateCode(6); String key=KEY_CODE+phone; try &#123; HashMap&lt;Object, Object&gt; msg = new HashMap&lt;&gt;(); msg.put("phone", phone); msg.put("code", code); redisTemplate.opsForValue().set(key,code,5, TimeUnit.MINUTES); //发送验证码 amqpTemplate.convertAndSend("ly.sms.exchange","sms.verify.code",msg); &#125; catch (Exception e) &#123; log.error("发送短信失败。phone：&#123;&#125;， code：&#123;&#125;", phone, code); &#125; &#125; 注意：要设置短信验证码在Redis的缓存时间为5分钟 4.4.测试通过RestClient发送请求试试： 查看Redis中的数据： 查看短信： 5.注册功能5.1.接口说明 5.2.UserControllerly-user中ly-user-server的web： 123456789101112/** * 注册 * @param user * @param code * @return */@PostMapping("register")public ResponseEntity&lt;Void&gt; register(User user,@RequestParam("code")String code)&#123; userService.register(user,code); return ResponseEntity.status(HttpStatus.CREATED).build();&#125; 5.3.UserServicely-user中ly-user-server的service： 基本逻辑： 1）校验短信验证码 2）生成盐 3）对密码加密 4）写入数据库 5）删除Redis中的验证码 1234567891011121314151617181920212223public void register(User user, String code) &#123; String key=KEY_CODE+user.getPhone(); //redis中取code String redisCode = redisTemplate.opsForValue().get(key); //校验验证码 if (!StringUtils.equals(code,redisCode))&#123; throw new LyException(ExceptionEnums.INVALID_USER_CODE); &#125; //生成盐 String salt = CodecUtils.generateSalt(); user.setSalt(salt); //对密码加密 user.setPassword(CodecUtils.md5Hex(user.getPassword(),salt)); user.setCreated(new Date()); user.setId(null); //写入数据库 int insert = userMapper.insert(user); //注册成功删除code的验证码 if (insert==1)&#123; redisTemplate.delete(key); &#125; &#125; 5.4.测试我们通过RestClient测试： 查看数据库： 5.5.服务端数据校验刚才虽然实现了注册，但是服务端并没有进行数据校验，而前端的校验是很容易被有心人绕过的。所以我们必须在后台添加数据校验功能： 我们这里会使用Hibernate-Validator框架完成数据校验： 而SpringBoot的web启动器中已经集成了相关依赖： 5.5.1.什么是Hibernate ValidatorHibernate Validator是Hibernate提供的一个开源框架，使用注解方式非常方便的实现服务端的数据校验。 官网：http://hibernate.org/validator/ hibernate Validator 是 Bean Validation 的参考实现 。 Hibernate Validator 提供了 JSR 303 规范中所有内置 constraint（约束） 的实现，除此之外还有一些附加的 constraint。 在日常开发中，Hibernate Validator经常用来验证bean的字段，基于注解，方便快捷高效。 5.5.2.Bean校验的注解常用注解如下： Constraint 详细信息 @Valid 被注释的元素是一个对象，需要检查此对象的所有字段值 @Null 被注释的元素必须为 null @NotNull 被注释的元素必须不为 null @AssertTrue 被注释的元素必须为 true @AssertFalse 被注释的元素必须为 false @Min(value) 被注释的元素必须是一个数字，其值必须大于等于指定的最小值 @Max(value) 被注释的元素必须是一个数字，其值必须小于等于指定的最大值 @DecimalMin(value) 被注释的元素必须是一个数字，其值必须大于等于指定的最小值 @DecimalMax(value) 被注释的元素必须是一个数字，其值必须小于等于指定的最大值 @Size(max, min) 被注释的元素的大小必须在指定的范围内 @Digits (integer, fraction) 被注释的元素必须是一个数字，其值必须在可接受的范围内 @Past 被注释的元素必须是一个过去的日期 @Future 被注释的元素必须是一个将来的日期 @Pattern(value) 被注释的元素必须符合指定的正则表达式 @Email 被注释的元素必须是电子邮箱地址 @Length 被注释的字符串的大小必须在指定的范围内 @NotEmpty 被注释的字符串的必须非空 @Range 被注释的元素必须在合适的范围内 @NotBlank 被注释的字符串的必须非空 @URL(protocol=,host=, port=,regexp=, flags=) 被注释的字符串必须是一个有效的url @CreditCardNumber 被注释的字符串必须通过Luhn校验算法，银行卡，信用卡等号码一般都用Luhn计算合法性 5.5.3.给User添加校验我们在ly-user-interface中添加Hibernate-Validator依赖： 1234&lt;dependency&gt; &lt;groupId&gt;org.hibernate.validator&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;&lt;/dependency&gt; 我们在User对象的部分属性上添加注解： 1234567891011121314151617181920@Table(name = "tb_user")public class User &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Length(min = 4, max = 30, message = "用户名只能在4~30位之间") private String username;// 用户名 @JsonIgnore @Length(min = 4, max = 30, message = "用户名只能在4~30位之间") private String password;// 密码 @Pattern(regexp = "^1[35678]\\d&#123;9&#125;$", message = "手机号格式不正确") private String phone;// 电话 private Date created;// 创建时间 @JsonIgnore private String salt;// 密码的盐值&#125; 5.5.4.在controller上进行控制在controller中只需要给User添加 @Valid注解即可。 5.5.5.测试我们故意填错： 然后SpringMVC会自动返回错误信息： 6.根据用户名和密码查询用户6.1.接口说明功能说明查询功能，根据参数中的用户名和密码查询指定用户 接口路径1GET /query 参数说明：form表单格式 参数 说明 是否必须 数据类型 默认值 username 用户名，格式为4~30位字母、数字、下划线 是 String 无 password 用户密码，格式为4~30位字母、数字、下划线 是 String 无 返回结果：用户的json格式数据 123456&#123; "id": 6572312, "username":"test", "phone":"13688886666", "created": 1342432424&#125; 状态码： 200：注册成功 400：用户名或密码错误 500：服务器内部异常，注册失败 6.2.UserControllerly-user —— ly-user-service————web中 1234567891011/** * 根据用户名和密码查询用户 * @param username * @param password * @return */ @GetMapping("query") public ResponseEntity&lt;User&gt; queryUser(@RequestParam("username")String username, @RequestParam("password")String password)&#123; return ResponseEntity.ok(userService.queryUser(username,password)); &#125; 6.3.UserServicely-user —— ly-user-service————service中 123456789101112131415public User queryUser(String username, String password) &#123; //查询用户 User recode = new User(); recode.setUsername(username); User user = userMapper.selectOne(recode); //校验 if (user==null)&#123; throw new LyException(ExceptionEnums.INVALID_USERNAME_PASSWORD); &#125; //校验密码和加密是否相等 if (!StringUtils.equals(user.getPassword(), CodecUtils.md5Hex(password,user.getSalt()))) &#123; throw new LyException(ExceptionEnums.INVALID_USERNAME_PASSWORD); &#125; return user;&#125; 要注意，查询时也要对密码进行加密后判断是否一致。 6.4.测试我们通过RestClient测试： 7.在注册页进行测试在注册页填写信息： 提交发现页面自动跳转到了登录页，查看数据库：]]></content>
      <categories>
        <category>项目实战-微服务商城</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[微服务商城（十五）——数据同步]]></title>
    <url>%2Fday14-%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5.html</url>
    <content type="text"><![CDATA[1.实现数据同步接下来，我们就改造项目，实现搜索服务、商品静态页的数据同步。 1.1.思路分析 发送方：商品微服务 什么时候发？ 当商品服务对商品进行写操作：增、删、改的时候，需要发送一条消息，通知其它服务。 发送什么内容？ 对商品的增删改时其它服务可能需要新的商品数据，但是如果消息内容中包含全部商品信息，数据量太大，而且并不是每个服务都需要全部的信息。因此我们只发送商品id，其它服务可以根据id查询自己需要的信息。 接收方：搜索微服务、静态页微服务 接收消息后如何处理？ 搜索微服务： 增/改：添加新的数据到索引库 删：删除索引库数据 静态页微服务： 增：创建新的静态页 删：删除原来的静态页 改：创建新的静态页并删除原来的 1.2.商品服务发送消息（ly-item-service）我们先在商品微服务ly-item-service中实现发送消息。 1.2.1.引入依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;&lt;/dependency&gt; 1.2.2.配置文件我们在application.yml中添加一些有关RabbitMQ的配置： 1234567891011121314spring: rabbitmq: host: 192.168.25.128 username: 2850105498 password: cxg200888 virtual-host: /leyou template: retry: enabled: true initial-interval: 10000ms max-interval: 30000ms multiplier: 2 exchange: ly.item.exchange publisher-confirms: true template：有关AmqpTemplate的配置 retry：失败重试 enabled：开启失败重试 initial-interval：第一次重试的间隔时长 max-interval：最长重试间隔，超过这个间隔将不再重试 multiplier：下次重试间隔的倍数，此处是2即下次重试间隔是上次的2倍 exchange：缺省的交换机名称，此处配置后，发送消息如果不指定交换机就会使用这个 publisher-confirms：生产者确认机制，确保消息会正确发送，如果发送失败会有错误回执，从而触发重试 1.2.3.改造GoodsService在GoodsService中封装一个发送消息到mq的方法： 12345678private void sendMessage(Long id, String type)&#123; // 发送消息 try &#123; this.amqpTemplate.convertAndSend("item." + type, id); &#125; catch (Exception e) &#123; logger.error("&#123;&#125;商品消息发送异常，商品id：&#123;&#125;", type, id, e); &#125;&#125; 这里没有指定交换机，因此默认发送到了配置中的：ly.item.exchange 注意：这里要把所有异常都try起来，不能让消息的发送影响到正常的业务逻辑 然后在新增的时候调用： 修改的时候调用： 1.3.搜索服务接收消息（ly-search）搜索服务接收到消息后要做的事情： 增：添加新的数据到索引库 删：删除索引库数据 改：修改索引库数据 因为索引库的新增和修改方法是合二为一的，因此我们可以将这两类消息一同处理，删除另外处理。 1.3.1.引入依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;&lt;/dependency&gt; 1.3.2.添加配置123456spring: rabbitmq: host: 192.168.25.128 username: 2850105498 password: cxg200888 virtual-host: /leyou 这里只是接收消息而不发送，所以不用配置template相关内容。 1.3.3.编写监听器 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142@Componentpublic class ItemListener &#123; @Autowired private SearchService searchService; /** * 处理insert和update的消息 * * @param spuId * @throws Exception */ @RabbitListener(bindings = @QueueBinding( value = @Queue(name = "search.item.insert.queue",durable = "true"), exchange = @Exchange(name = "ly.item.exchange",type = ExchangeTypes.TOPIC), key = &#123;"item.insert","item.update"&#125; )) public void listenInsertOrUpdate(Long spuId)&#123; if (spuId==null)&#123; return; &#125; //处理消息，对索引库进行新增和修改 searchService.createOrUpdateIndex(spuId); &#125; /** * 处理delete的消息 * * @param spuId */ @RabbitListener(bindings = @QueueBinding( value = @Queue(name = "search.item.delete.queue",durable = "true"), exchange = @Exchange(name = "ly.item.exchange",type = ExchangeTypes.TOPIC), key = &#123;"delete"&#125; )) public void listenDelete(Long spuId)&#123; if (spuId==null)&#123; return; &#125; //处理消息，对索引库进行新增和修改 searchService.deleteIndex(spuId); &#125;&#125; 1.3.4.编写创建和删除索引方法这里因为要创建和删除索引，我们需要在SearchService中拓展两个方法，创建和删除索引： 1234567891011121314151617181920/** * 处理mq消息(更新，修改) * @param spuId */ public void createOrUpdateIndex(Long spuId) &#123; //查询spu Spu spu = goodsClient.querySpuById(spuId); //构建goods Goods goods = buildGoods(spu); //存入索引库 goodsRepository.save(goods); &#125; /** * 处理mq消息(删除) * @param spuId */ public void deleteIndex(Long spuId) &#123; goodsRepository.deleteById(spuId); &#125; 创建索引的方法可以从之前导入数据的测试类中拷贝和改造。 1.4.静态页服务接收消息（ly-page）商品静态页服务接收到消息后的处理： 增：创建新的静态页 删：删除原来的静态页 改：创建新的静态页并删除原来的 不过，我们编写的创建静态页的方法也具备覆盖以前页面的功能，因此：增和改的消息可以放在一个方法中处理，删除消息放在另一个方法处理。 1.4.1.引入依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;&lt;/dependency&gt; 1.4.2.添加配置123456spring: rabbitmq: host: 192.168.25.128 username: 2850105498 password: cxg200888 virtual-host: /leyou 这里只是接收消息而不发送，所以不用配置template相关内容。 1.4.3.编写监听器 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142@Componentpublic class ItemListener &#123; @Autowired private PageService pageService; /** * 处理insert和update的消息 * * @param spuId * @throws Exception */ @RabbitListener(bindings = @QueueBinding( value = @Queue(name = "page.item.insert.queue",durable = "true"), exchange = @Exchange(name = "ly.item.exchange",type = ExchangeTypes.TOPIC), key = &#123;"item.insert","item.update"&#125; )) public void listenInsertOrUpdate(Long spuId)&#123; if (spuId==null)&#123; return; &#125; //处理消息，创建一个静态页 pageService.createHtml(spuId); &#125; /** * 处理delete的消息 * * @param spuId */ @RabbitListener(bindings = @QueueBinding( value = @Queue(name = "page.item.delete.queue",durable = "true"), exchange = @Exchange(name = "ly.item.exchange",type = ExchangeTypes.TOPIC), key = &#123;"delete"&#125; )) public void listenDelete(Long spuId)&#123; if (spuId==null)&#123; return; &#125; //处理消息，对静态页删除 pageService.deleteHtml(spuId); &#125;&#125; 1.4.4.添加删除页面方法12345678910111213141516171819202122232425262728293031323334/** * 创建静态文件 * @param spuId */public void createHtml(Long spuId)&#123; //上下文 Context context = new Context(); context.setVariables(loadModel(spuId)); //输出流 File file = new File("G:/Java-webspace/LeYou-store/leyou/ly-page/src/main/resources/templates", spuId + ".html"); //判断是否存在 if (file.exists())&#123; file.delete(); &#125; try (PrintWriter writer=new PrintWriter(file,"utf-8"))&#123; //生成html templateEngine.process("item",context,writer); &#125;catch (Exception e)&#123; log.error("[静态页服务]，生成静态页面异常！",e); &#125;&#125;/** * 删除静态页 * @param spuId */public void deleteHtml(Long spuId) &#123; File file = new File("G:/Java-webspace/LeYou-store/leyou/ly-page/src/main/resources/templates", spuId + ".html"); if (file.exists())&#123; file.delete(); &#125;&#125; 1.5.测试1.5.1.查看RabbitMQ控制台重新启动项目，并且登录RabbitMQ管理界面：http://192.168.25.128:15672 可以看到，交换机已经创建出来了： 队列也已经创建完毕： 并且队列都已经绑定到交换机： 1.5.2.修改数据试一试在后台修改商品数据的价格，分别在搜索及商品详情页查看是否统一。 2.Redis回顾完成商品详情展示，下一步自然是购物车，不过购物车之前要完成用户注册和登入业务，我们需要使用到redis技术，一起回顾下 2.1.NoSqlRedis是目前非常流行的一款NoSql数据库。 什么事NoSql 常见的NoSql产品 2.2.Redis的介绍和安装2.2.1.简介 Redis的网址： 官网： 中文网站：http://www.redis.cn/ 历史： 特性： 2.2.2.Redis与MemcacheRedis和Memcache是目前非常流行的两种NoSql数据库，都可以用于服务端缓存。两者有怎么样差异？ 实现来看 redis：单线程 Memcache：多线程 从存储方式来看： redis：支持数据持久化和主从备份，数据更安全 Memcache：数据存在内存，没有持久化功能 从功能来看： redis：除了基本的k-v结构外，支持多种其他复杂结构，事务等高级功能 Memcache：只支持基本的k-v结构 从可用性看： redis：支持主从备份，数据分片，哨兵监控 Memcache：没有分片功能，需要从客户端支持 可以看出，redis相比Memcache功能强大，只会的数据结构也比较丰富，已经不仅仅是一个缓冲服务，而是memcache的功能相对单一 2.2.3.安装参考课前资料中的《redis安装配置.md》 2.3.Redis指令通过help命令可以让我们查看到redis的指令帮助信息： 在help后面加空格,然后按tab键，会看到redis对命令分组的组名： 主要包括： @generic：通用指令 @string：字符串类型指令 @list：队列结构指令 @set：set结构指令 @sorted_set：可排序的set结构指令 @hash：hash结构指令 其中除了@generic以为的，对应了Redis中常用的5种数据类型： String：等同于java中的，Map&lt;String,String&gt; list：等同于java中的，Map&lt;String,List &gt; set： 等同于java中的，Map&lt;String,set&gt; sort_ set:：可排序的set hash： 等同于java中的: Map&lt;String,Map&lt;String,String&gt;&gt; 可见，Redis中存储数据结构都是类似java的map类型。Redis不同数据类型，只是map的值的类型不同 2.3.1.通用指令 keys 获取符合规则的键名列表 语法：keys pattern 实例：keys *（查询所有键） 这里的pattern其实是正则表达式，所以语法基本类似的 生产环境一定禁用keys： rename-command KEYS “” // 必禁命令，线上用这种查询方式绝对是不对的 rename-command FLUSHALL “” // 必禁命令，谁会清除数据呢 rename-command FLUSHDB “” // 必禁命令，谁会清除数据呢 rename-command CONFIG “” // 可以考虑重命名下 exists 判断一个键是否存在，如果存在返回整数1，否则返回0 语法：exists key 实例 select 切换库 语法：select key 实例 del DEL： 删除key，可以删除多个或一个key，返回删除个数 语法：del key，del [key … ] 实例： expire 语法 expire key seconds 作用：设置key的过期时间，超过时间后，将会自动删除该key 返回值： 如果成功设置过期时间，返回1. 如果key不存在或者不能设置时间，返回0 TTL TTL：查看一个key的过期时间 语法：TTL key 返回值： 返回剩余的过期时间 -1：永不过期 -2：已经过期，不存在 persist 语法：persist key 作用：移除给定的key的生存时间，将这个key从生存时间转换成一个不带生存时间，永不过期的key 返回值： 当生存时间移除成功，返回1 如果key不存在或key没有设置生存时间，返回0 2.3.2.字符串指令字符串结构，其实是redis中最基础的k-v结构。其键和值都是字符串，类似java的Map&lt;String,String&gt; 字符串类型是redis中最基本的数据库类型，它能存储任何形式的字符串，包括二进制数据，可以存储json化的对象，字符串数组等，一个字符串类型键允许存储的数据最大容量是512MB 常用指令： 2.3.3.hash结构命令redis的hash结构类似于java中Map&lt;String,Map&lt;String,String&gt;&gt;,键是字符串，值是另一个映射。 这里我们称键为key，字段名为hKey，字段值为hValue 常用指令： HSET、HSETNX和HGET（添加、获取） HSET 介绍： Redis Hset 命令用于为哈希表中的字段赋值 。 如果哈希表不存在，一个新的哈希表被创建并进行 HSET 操作。 如果字段已经存在于哈希表中，旧值将被覆盖。 返回值： 如果字段是哈希表中的一个新建字段，并且值设置成功，返回 1 。 如果哈希表中域字段已经存在且旧值已被新值覆盖，返回 0 实例： HGET 介绍： Hget 命令用于返回哈希表中指定字段的值。 返回值：返回给定字段的值。如果给定的字段或 key 不存在时，返回 nil 示例： HGETALL 介绍 返回值 指定key 的所有字段的名及值。返回值里，紧跟每个字段名(field name)之后是字段的值(value)，所以返回值的长度是哈希表大小的两倍 示例： HKEYS 介绍 示例 HVALS 注意：这个命令不是HVALUES，而是HVALS，是value 的缩写：val 示例： DEL Hdel 命令用于删除哈希表 key 中的一个或多个指定字段，不存在的字段将被忽略 语法： HDEL key field1 [field2 … ] 返回值：被成功删除字段的数量，不包括被忽略的字段 示例： 2.4.Redis的持久化Redis有两种持久化方案：RDB和AOF 2.4.1.RDB 触发条件 RDB是Redis的默认持久方案，当满足一定的条件时，Redis会自动将内存中的数据全部持久化到硬盘。 条件在redis.conf文件中配置，格式如下： 1save （time）（count） 当满足在time（单位是秒）时间内，至少进行了count次修改后，触发条件，进行RDB快照。 例如，默认的配置如下： 在配置文件中已经预置了3个条件： 1234save 900 1 #15分钟内有至少1个键被更改则进行快照save 300 10 #5分钟内有至少10个键被更改则进行快照save 60 10000 #1分钟内有至少10000个键被更改则进行快照以上条件之间是“或”的关系 基本原理 RDB的流程是这样： Redis使用fork函数来复制一份当前进程(父进程)的副本(子进程) 父进程继续接收并处理请求，子进程开始把内存中的数据写入硬盘中的临时文件 子进程写完后，会使用临时文件代替旧的RDB文件 2.4.2.AOF 基本原理 AOF方式默认是关闭的，需要修改配置来开启： 1appendonly yes # 把默认的no改为yes AOF持久化的策略是，把每一条服务端接收到的写命令都记录下来，每隔一定时间后，写入硬盘的AOF文件中，当服务器重启后，重新执行这些命令，即可恢复数据。 AOF文件写入的频率是可以配置的: 1234567 文件写入默认情况下会先写入到系统的缓存中，系统每30秒同步一次。才是真正的写入到硬盘，如果在这30秒服务器宕机那数据也会丢失的。Redis可以通过配置来修改同步策略: # appendfsync always每次都同步( 最安全但是最慢) appendfsync everysec每秒同步( 默认的同步策略) # appendfsync no 不主动同步，由操作系统来决定(最快但是不安全) AOF文件重写 当记录命令过多，必然会出现对同一个key的多次写操作，此时只需要记录最后一条即可， 前面的记录都毫无意义了。因此，当满足一定条件时，Redis会对AOF文件进行重写，移除对同一个key的多次操作命令，保留最后一条。默认的触发条件: 12345重写策略的参数设置:auto-aof-rewrite-percentage 100当前的AOF文件大小超过上一-次重写时的AOF文件大小的百分之多少时会再次进行重写，如果之前没有重写过，则以启动时的AOF文件大小为依据auto-aof-rewrite-min-size 64mb限制了允许重写的最小AOF文件大小。通常在AOF文件很小的时候即使其中有些冗余的命令也是可以忽略的。 2.5.SpringData Redis之前，我们使用redis都是采用的Jedis客户端，不过既然我们使用springboot，为什么不适用spring对redis封装的套件呢？ 2.5.1.Spring Data Redis官网：http://projects.spring.io/spring-data-redis/ Spring Data Redis，是Spring Data 家族的一部分。 对Jedis客户端进行了封装，与spring进行了整合。可以非常方便的来实现redis的配置和操作。 2.5.2.RedisTemplate基本操作Spring Data Redis 提供了一个工具类：RedisTemplate。里面封装了对于Redis的五种数据结构的各种操作，包括： redisTemplate.opsForValue() ：操作字符串 redisTemplate.opsForHash() ：操作hash redisTemplate.opsForList()：操作list redisTemplate.opsForSet()：操作set redisTemplate.opsForZSet()：操作zset 例如我们队字符串操作比较熟悉的有：get、set等命令，这些方法都在opsForValue( )返回对象中有： 其它一些通用命令，如del通过redisTemplate.xx()来直接调用 5种结构： String：等同于java中的，Map&lt;String,String&gt; list：等同于java中的Map&lt;String,List&lt;String&gt;&gt; set：等同于java中的Map&lt;String,Set&lt;String&gt;&gt; sort_set：可排序的set hash：等同于java中的：`Map&lt;String,Map&lt;String,String&gt;&gt; 2.5.3.StringRedisTemplateRedisTemplate在创建时，可以指定其泛型类型： K：代表key 的数据类型 V: 代表value的数据类型 注意：这里的类型不是Redis中存储的数据类型，而是Java中的数据类型，RedisTemplate会自动将Java类型转为Redis支持的数据类型：字符串、字节、二进制等等。 不过RedisTemplate默认会采用JDK自带的序列化（Serialize）来对对象进行转换。生成的数据十分庞大，因此一般我们都会指定key和value为String类型，这样就由我们自己把对象序列化为json字符串来存储即可。 因为大部分情况下，我们都会使用key和value都为String的RedisTemplate，因此Spring就默认提供了这样一个实现： 2.5.4.测试我们在项目中编写一个测试案例： 首先在项目中引入Redis启动器： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; 然后在配置文件中指定Redis地址： 123spring: redis: host: 192.168.25.128 然后就可以直接注入StringRedisTemplate对象了： 12345678910111213141516171819202122232425262728293031323334353637383940414243@RunWith(SpringRunner.class)@SpringBootTest(classes = LyUserService.class)public class RedisTest &#123; @Autowired private StringRedisTemplate redisTemplate; @Test public void testRedis() &#123; // 存储数据 this.redisTemplate.opsForValue().set("key1", "value1"); // 获取数据 String val = this.redisTemplate.opsForValue().get("key1"); System.out.println("val = " + val); &#125; @Test public void testRedis2() &#123; // 存储数据，并指定剩余生命时间,5小时 this.redisTemplate.opsForValue().set("key2", "value2", 5, TimeUnit.HOURS); &#125; //哈希 @Test public void testHash()&#123; BoundHashOperations&lt;String, Object, Object&gt; hashOps = this.redisTemplate.boundHashOps("user"); // 操作hash数据 hashOps.put("name", "jack"); hashOps.put("age", "21"); // 获取单个数据 Object name = hashOps.get("name"); System.out.println("name = " + name); // 获取所有数据 Map&lt;Object, Object&gt; map = hashOps.entries(); for (Map.Entry&lt;Object, Object&gt; me : map.entrySet()) &#123; System.out.println(me.getKey() + " : " + me.getValue()); &#125; &#125;&#125; 3.聚合数据短信服务3.1.demo注册页面上有短信发送的按钮，当用户点击发送短信，我们需要生成验证码，发送给用户。我们将使用阿里提供的阿里大于来实现短信发送。 参考课前资料的《阿里短信.md》学习demo入门 3.2.创建短信微服务因为系统中不止注册一个地方需要短信发送，因此我们将短信发送抽取为微服务：ly-sm，凡是需要的地方都可以使用。 另外，因为短信发送API调用时长的不确定性，为了提高程序的响应速度，短信发送我们都将采用异步发送方式，即： 短信服务监听MQ消息，收到消息后发送短信。 其它服务要发送短信时，通过MQ通知短信微服务。 3.2.1.创建module创建ly-sm工程 3.2.2.pom12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;leyou&lt;/artifactId&gt; &lt;groupId&gt;com.leyou.parent&lt;/groupId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.service&lt;/groupId&gt; &lt;artifactId&gt;ly-sm&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;net.sf.json-lib&lt;/groupId&gt; &lt;artifactId&gt;json-lib&lt;/artifactId&gt; &lt;version&gt;2.4&lt;/version&gt; &lt;classifier&gt;jdk15&lt;/classifier&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--读取在yml中配置的常量--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot &lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.leyou.common&lt;/groupId&gt; &lt;artifactId&gt;ly-common&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 3.2.3.编写启动类123456@SpringBootApplicationpublic class LySmsApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(LySmsApplication.class, args); &#125;&#125; 3.2.4.编写application.yml12345678910server: port: 8086spring: application: name: sms-service rabbitmq: host: 192.168.25.128 username: 2850105498 password: cxg200888 virtual-host: /leyou 3.3.编写短信工具类3.3.1.属性抽取我们首先把一些常量抽取到application.yml中： 12345ly: sms: url: http://v.juhe.cn/sms/send # 请求接口地址 accessKeySecret: d4eee3375aef4ae683e7782fc4e91f44 # 你自己的key verifyCodeTemplate: 128692 # 模板名称id 然后注入到属性类中com.leyou.sms.config： 12345678910@Data@ConfigurationProperties(prefix = "ly.sms")public class SmsProperties &#123; String accessKeySecret; String url; String verifyCodeTemplate;&#125; 3.3.2.工具类我们把阿里提供的demo进行简化和抽取，封装一个工具类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113@Slf4j@Component@EnableConfigurationProperties(SmsProperties.class)public class SmsUtis&#123; @Autowired private SmsProperties properties; public static final String DEF_CHATSET = "UTF-8"; public static final int DEF_CONN_TIMEOUT = 30000; public static final int DEF_READ_TIMEOUT = 30000; public static String userAgent = "Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/29.0.1547.66 Safari/537.36"; /** * * @param phoneNumber 号码 * @param templateCode 短信模板ID * @param templateParam 发送信息代码 */ public void mobileQuery(String phoneNumber,String templateCode,String templateParam)&#123; String result =null; String url =properties.getUrl();//请求接口地址 Map params = new HashMap();//请求参数 params.put("mobile",phoneNumber);//接受短信的用户手机号码 params.put("tpl_id",templateCode);//您申请的短信模板ID，根据实际情况修改 params.put("tpl_value","#code#="+templateParam);//您设置的模板变量，根据实际情况修改("#code#=123456") params.put("key",properties.getAccessKeySecret());//应用APPKEY(应用详细页查询) try &#123; result = net(url, params, "GET"); JSONObject object = JSONObject.fromObject(result); if(object.getInt("error_code")==0)&#123; System.out.println(object.get("result")); &#125;else&#123; //控制台输出 System.out.println("[短信服务] 发送失败，phoneNumber:" + phoneNumber + ",返回码" + object.get("error_code") + "，原因" + object.get("reason")); //日志记录 log.info("[短信服务] 发送失败，phoneNumber:" + phoneNumber + ",返回码:" + object.get("error_code") + "，原因:" + object.get("reason")); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * * @param strUrl 请求地址 * @param params 请求参数 * @param method 请求方法 * @return 网络请求字符串 * @throws Exception */ public static String net(String strUrl, Map params,String method) throws Exception &#123; HttpURLConnection conn = null; BufferedReader reader = null; String rs = null; try &#123; StringBuffer sb = new StringBuffer(); if(method==null || method.equals("GET"))&#123; strUrl = strUrl+"?"+urlencode(params); &#125; URL url = new URL(strUrl); conn = (HttpURLConnection) url.openConnection(); if(method==null || method.equals("GET"))&#123; conn.setRequestMethod("GET"); &#125;else&#123; conn.setRequestMethod("POST"); conn.setDoOutput(true); &#125; conn.setRequestProperty("User-agent", userAgent); conn.setUseCaches(false); conn.setConnectTimeout(DEF_CONN_TIMEOUT); conn.setReadTimeout(DEF_READ_TIMEOUT); conn.setInstanceFollowRedirects(false); conn.connect(); if (params!= null &amp;&amp; method.equals("POST")) &#123; try &#123; DataOutputStream out = new DataOutputStream(conn.getOutputStream()); out.writeBytes(urlencode(params)); &#125; catch (Exception e) &#123; // TODO: handle exception e.printStackTrace(); &#125; &#125; InputStream is = conn.getInputStream(); reader = new BufferedReader(new InputStreamReader(is, DEF_CHATSET)); String strRead = null; while ((strRead = reader.readLine()) != null) &#123; sb.append(strRead); &#125; rs = sb.toString(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (reader != null) &#123; reader.close(); &#125; if (conn != null) &#123; conn.disconnect(); &#125; &#125; return rs; &#125; //将map型转为请求参数型 public static String urlencode(Map&lt;String,String&gt; data) &#123; StringBuilder sb = new StringBuilder(); for (Map.Entry i : data.entrySet()) &#123; try &#123; sb.append(i.getKey()).append("=").append(URLEncoder.encode(i.getValue()+"","UTF-8")).append("&amp;"); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; &#125; return sb.toString(); &#125;&#125; 注意 根据聚合数据官方文档发送的验证码根式：#code#，所以要如上写的 3.4.编写消息监听器接下来，编写消息监听器，当接收到消息后，我们发送短信。 1234567891011121314151617181920212223242526272829@Component@Slf4jpublic class SmsListener &#123; @Autowired private SmsUtis smsUtis; @Autowired private SmsProperties smsProperties; /** * 发送短信验证码 */ @RabbitListener(bindings = @QueueBinding( value = @Queue(value = "sms.verify.code.queue", durable = "true"), exchange = @Exchange(value = "ly.sms.exchange", type = ExchangeTypes.TOPIC), key = &#123;"sms.verify.code"&#125;)) public void listtenSms(Map&lt;String,String&gt; msg)&#123; if (CollectionUtils.isEmpty(msg))&#123; return; &#125; String phone = msg.remove("phone"); if (StringUtils.isBlank(phone))&#123; return; &#125; String code=msg.get("code"); smsUtis.mobileQuery(phone, smsProperties.getVerifyCodeTemplate(), code); log.info("[短信服务] 发送验证码，手机号：&#123;&#125;",phone); &#125;&#125; 我们注意到，消息体是一个Map，里面有两个属性： phone：电话号码 code：短信验证码 3.5.启动启动项目，然后查看RabbitMQ控制台，发现交换机已经创建： 队列也已经创建： 并且绑定： 3.6.测试创建测试 12345678910111213141516@RunWith(SpringRunner.class)@SpringBootTestpublic class SmsTest &#123; @Autowired private AmqpTemplate amqpTemplate; @Test public void testSms() throws Exception &#123; HashMap&lt;Object, Object&gt; msg = new HashMap&lt;&gt;(); msg.put("phone","18860892543"); msg.put("code","200888"); amqpTemplate.convertAndSend("ly.sms.exchange","sms.verify.code",msg); Thread.sleep(10000L); &#125;&#125; 3.7.改进（短信限流）发短信的时候，在redis中记录手机号，当前系统时间减去记录时间小于60秒，短信拦截 改进工具类SmsUtis.java中的mobileQuery( )方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455@Autowiredprivate StringRedisTemplate redisTemplate;public static final String KEY_PHOME="sms_phone:";public static final String DEF_CHATSET = "UTF-8";public static final int DEF_CONN_TIMEOUT = 30000;public static final int DEF_READ_TIMEOUT = 30000;public static String userAgent = "Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/29.0.1547.66 Safari/537.36";/** * * @param phoneNumber 号码 * @param templateCode 短信模板ID * @param templateParam 发送信息代码 */public void mobileQuery(String phoneNumber,String templateCode,String templateParam)&#123; //号码用于redis中 String key=KEY_PHOME + phoneNumber; //按照手机号码限流 //读取时间 String lastTime = redisTemplate.opsForValue().get(key); if (StringUtils.isNotBlank(lastTime))&#123; Long last = Long.valueOf(lastTime); if (System.currentTimeMillis()-last&lt;60000)&#123; log.info("[短息服务] 发送短信频率过高，被拦截，手机号码：&#123;&#125;",phoneNumber); return ; &#125; &#125; String result =null; String url =properties.getUrl();//请求接口地址 Map params = new HashMap();//请求参数 params.put("mobile",phoneNumber);//接受短信的用户手机号码 params.put("tpl_id",templateCode);//您申请的短信模板ID，根据实际情况修改 params.put("tpl_value","#code#="+templateParam);//您设置的模板变量，根据实际情况修改("#code#=123456") params.put("key",properties.getAccessKeySecret());//应用APPKEY(应用详细页查询) try &#123; result = net(url, params, "GET"); JSONObject object = JSONObject.fromObject(result); if(object.getInt("error_code")==0)&#123; System.out.println(object.get("result")); /** * 发送短信成功后将手机存入redis中,String.valueOf(System.currentTimeMillis())是系统时间 */ redisTemplate.opsForValue().set(key, String.valueOf(System.currentTimeMillis()),1, TimeUnit.MILLISECONDS); log.info("[短信服务] 发送验证码，手机号：&#123;&#125;",phoneNumber); &#125;else&#123; //控制台输出 System.out.println("[短信服务] 发送失败，phoneNumber:" + phoneNumber + ",返回码" + object.get("error_code") + "，原因" + object.get("reason")); //日志记录 log.info("[短信服务] 发送失败，phoneNumber:" + phoneNumber + ",返回码:" + object.get("error_code") + "，原因:" + object.get("reason")); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;]]></content>
      <categories>
        <category>项目实战-微服务商城</category>
        <category>聚合短息</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>聚合短息</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务商城（十四）——Rabbitmq安装及介绍]]></title>
    <url>%2Fday13-rabbitmq.html</url>
    <content type="text"><![CDATA[0.学习目标 了解常见的MQ产品 了解RabbitMQ的5种消息模型 会使用Spring AMQP 利用MQ实现搜索和静态页的数据同步 1.RabbitMQ（消息队列）1.1.搜索与商品服务的问题目前我们已经完成了商品详情和搜索系统的开发。我们思考一下，是否存在问题？ 商品的原始数据保存在数据库中，增删改查都在数据库中完成。 搜索服务数据来源是索引库，如果数据库商品发生变化，索引库数据不能及时更新。 商品详情做了页面静态化，静态页面数据也不会随着数据库商品发生变化。 如果我们在后台修改了商品的价格，搜索页面和商品详情页显示的依然是旧的价格，这样显然不对。该如何解决？ 这里有两种解决方案： 方案1：每当后台对商品做增删改操作，同时要修改索引库数据及静态页面 方案2：搜索服务和商品页面服务对外提供操作接口，后台在商品增删改后，调用接口 以上两种方式都有同一个严重问题：就是代码耦合，后台服务中需要嵌入搜索和商品页面服务，违背了微服务的独立原则。 所以，我们会通过另外一种方式来解决这个问题：消息队列 1.2.消息队列（MQ）1.2.1.什么是消息队列消息队列，即MQ，Message Queue。 消息队列是典型的：生产者、消费者模型。生产者不断向消息队列中生产消息，消费者不断的从队列中获取消息。因为消息的生产和消费都是异步的，而且只关心消息的发送和接收，没有业务逻辑的侵入，这样就实现了生产者和消费者的解耦。 结合前面所说的问题： 商品服务对商品增删改以后，无需去操作索引库或静态页面，只是发送一条消息，也不关心消息被谁接收。 搜索服务和静态页面服务接收消息，分别去处理索引库和静态页面。 如果以后有其它系统也依赖商品服务的数据，同样监听消息即可，商品服务无需任何代码修改。 1.2.2.AMQP和JMSMQ是消息通信的模型，并不是具体实现。现在实现MQ的有两种主流方式：AMQP、JMS。 两者间的区别和联系： JMS是定义了统一的接口，来对消息操作进行统一；AMQP是通过规定协议来统一数据交互的格式 JMS限定了必须使用Java语言；AMQP只是协议，不规定实现方式，因此是跨语言的。 JMS规定了两种消息模型；而AMQP的消息模型更加丰富 1.2.3.常见MQ产品 ActiveMQ：基于JMS RabbitMQ：基于AMQP协议，erlang语言开发，稳定性好 RocketMQ：基于JMS，阿里巴巴产品，目前交由Apache基金会 Kafka：分布式消息系统，高吞吐量 1.2.4.RabbitMQRabbitMQ是基于AMQP的一款消息管理系统 官网： http://www.rabbitmq.com/ 官方教程：http://www.rabbitmq.com/getstarted.html 1.3.下载和安装1.3.1.下载官网下载地址：http://www.rabbitmq.com/download.html 目前最新版本是：3.7.5 我们的课程中使用的是：3.4.1版本 课前资料提供了安装包： 1.3.2.安装详见课前资料中的： 2.五种消息模型RabbitMQ提供了6种消息模型，但是第6种其实是RPC，并不是MQ，因此不予学习。那么也就剩下5种。 但是其实3、4、5这三种都属于订阅模型，只不过进行路由的方式不同。 我们通过一个demo工程来了解下RabbitMQ的工作方式： 导入工程： 导入后： 依赖： 123456789101112131415161718192021222324252627282930&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.itcast.rabbitmq&lt;/groupId&gt; &lt;artifactId&gt;itcast-rabbitmq&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;version&gt;3.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 我们抽取一个建立RabbitMQ连接的工具类，方便其他程序获取连接： 1234567891011121314151617181920212223public class ConnectionUtil &#123; /** * 建立与RabbitMQ的连接 * @return * @throws Exception */ public static Connection getConnection() throws Exception &#123; //定义连接工厂 ConnectionFactory factory = new ConnectionFactory(); //设置服务地址 factory.setHost("192.168.25.128"); //端口 factory.setPort(5672); //设置账号信息，用户名、密码、vhost factory.setVirtualHost("/leyou"); factory.setUsername("2850105498"); factory.setPassword("cxg200888"); // 通过工程获取连接 Connection connection = factory.newConnection(); return connection; &#125;&#125; 2.1.基本消息模型官方介绍： RabbitMQ是一个消息代理：它接受和转发消息。 你可以把它想象成一个邮局：当你把邮件放在邮箱里时，你可以确定邮差先生最终会把邮件发送给你的收件人。 在这个比喻中，RabbitMQ是邮政信箱，邮局和邮递员。 RabbitMQ与邮局的主要区别是它不处理纸张，而是接受，存储和转发数据消息的二进制数据块。 P（producer/ publisher）：生产者，一个发送消息的用户应用程序。 C（consumer）：消费者，消费和接收有类似的意思，消费者是一个主要用来等待接收消息的用户应用程序 queue 队列（红色区域）：rabbitmq内部类似于邮箱的一个概念。虽然消息流经rabbitmq和你的应用程序，但是它们只能存储在队列中。队列只受主机的内存和磁盘限制，实质上是一个大的消息缓冲区。许多生产者可以发送消息到一个队列，许多消费者可以尝试从一个队列接收数据。 总之： 生产者将消息发送到队列，消费者从队列中获取消息，队列是存储消息的缓冲区。 我们将用Java编写两个程序;发送单个消息的生产者，以及接收消息并将其打印出来的消费者。我们将详细介绍Java API中的一些细节，这是一个消息传递的“Hello World”。 我们将调用我们的消息发布者（发送者）Send和我们的消息消费者（接收者）Recv。发布者将连接到RabbitMQ，发送一条消息，然后退出。 2.1.1.生产者发送消息123456789101112131415161718192021222324public class Send &#123; private final static String QUEUE_NAME = "simple_queue"; public static void main(String[] argv) throws Exception &#123; // 获取到连接以及mq通道 Connection connection = ConnectionUtil.getConnection(); // 从连接中创建通道，这是完成大部分API的地方。 Channel channel = connection.createChannel(); // 声明（创建）队列，必须声明队列才能够发送消息，我们可以把消息发送到队列中。 // 声明一个队列是幂等的 - 只有当它不存在时才会被创建 channel.queueDeclare(QUEUE_NAME, false, false, false, null); // 消息内容 String message = "Hello World!"; channel.basicPublish("", QUEUE_NAME, null, message.getBytes()); System.out.println(" [x] Sent '" + message + "'"); //关闭通道和连接 channel.close(); connection.close(); &#125;&#125; 控制台： 2.1.2.管理工具中查看消息进入队列页面，可以看到新建了一个队列：simple_queue 点击队列名称，进入详情页，可以查看消息： 在控制台查看消息并不会将消息消费，所以消息还在。 2.1.3.消费者获取消息12345678910111213141516171819202122232425public class Recv &#123; private final static String QUEUE_NAME = "simple_queue"; public static void main(String[] argv) throws Exception &#123; // 获取到连接 Connection connection = ConnectionUtil.getConnection(); // 创建通道 Channel channel = connection.createChannel(); // 声明队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); // 定义队列的消费者 DefaultConsumer consumer = new DefaultConsumer(channel) &#123; // 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用 @Override public void handleDelivery(String consumerTag, Envelope envelope, BasicProperties properties, byte[] body) throws IOException &#123; // body 即消息体 String msg = new String(body); System.out.println(" [x] received : " + msg + "!"); &#125; &#125;; // 监听队列，第二个参数：是否自动进行消息确认。 channel.basicConsume(QUEUE_NAME, true, consumer); &#125;&#125; 控制台： 这个时候，队列中的消息就没了： 我们发现，消费者已经获取了消息，但是程序没有停止，一直在监听队列中是否有新的消息。一旦有新的消息进入队列，就会立即打印. 2.1.4.消息确认机制（ACK）面试通过刚才的案例可以看出，消息一旦被消费者接收，队列中的消息就会被删除。 那么问题来了：RabbitMQ怎么知道消息被接收了呢？ 如果消费者领取消息后，还没执行操作就挂掉了呢？或者抛出了异常？消息消费失败，但是RabbitMQ无从得知，这样消息就丢失了！ 因此，这就要通过消息确认机制（Acknowlege）。当消费者获取消息后，会向RabbitMQ发送回执ACK，告知消息已经被接收。不过这种回执ACK分两种情况： 自动ACK：消息一旦被接收，消费者自动发送ACK 手动ACK：消息接收后，不会发送ACK，需要手动调用 大家觉得哪种更好呢？ 这需要看消息的重要性： 如果消息不太重要，丢失也没有影响，那么自动ACK会比较方便 如果消息非常重要，不容丢失。那么最好在消费完成后手动ACK，否则接收消息后就自动ACK，RabbitMQ就会把消息从队列中删除。如果此时消费者宕机，那么消息就丢失了。 我们之前的测试都是自动ACK的，如果要手动ACK，需要改动我们的代码： 123456789101112131415161718192021222324252627public class Recv2 &#123; private final static String QUEUE_NAME = "simple_queue"; public static void main(String[] argv) throws Exception &#123; // 获取到连接 Connection connection = ConnectionUtil.getConnection(); // 创建通道 final Channel channel = connection.createChannel(); // 声明队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); // 定义队列的消费者 DefaultConsumer consumer = new DefaultConsumer(channel) &#123; // 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用 @Override public void handleDelivery(String consumerTag, Envelope envelope, BasicProperties properties, byte[] body) throws IOException &#123; // body 即消息体 String msg = new String(body); System.out.println(" [x] received : " + msg + "!"); // 手动进行ACK channel.basicAck(envelope.getDeliveryTag(), false); &#125; &#125;; // 监听队列，第二个参数false，手动进行ACK channel.basicConsume(QUEUE_NAME, false, consumer); &#125;&#125; 注意到最后一行代码： 1channel.basicConsume(QUEUE_NAME, false, consumer); 如果第二个参数为true，则会自动进行ACK；如果为false，则需要手动ACK。方法的声明： 2.1.4.1.自动ACK存在的问题修改消费者，添加异常，如下： 生产者不做任何修改，直接运行，消息发送成功： 运行消费者，程序抛出异常。但是消息依然被消费： 管理界面： 2.1.4.2.演示手动ACK修改消费者，把自动改成手动（去掉之前制造的异常） 生产者不变，再次运行： 运行消费者 但是，查看管理界面，发现： 停掉消费者的程序，发现： 这是因为虽然我们设置了手动ACK，但是代码中并没有进行消息确认！所以消息并未被真正消费掉。 当我们关掉这个消费者，消息的状态再次称为Ready 修改代码手动ACK： 执行： 消息消费成功！ 2.2.work消息模型工作队列或者竞争消费者模式 Work queues,也被称为(Task queues)，任务模型。当消息处理比较耗时的时候，可能生产消息的速度会远远大于消息的消费速度。长此以往，消息就会堆积越来越多，无法及时处理。此时就可以使用work模型:让多个消费者绑定到一个队列，共同消费队列中的消息。队列中的消息一旦消费，就会消失，因此任务是不会被重复执行的。 在第一篇教程中，我们编写了一个程序，从一个命名队列中发送并接受消息。在这里，我们将创建一个工作队列，在多个工作者之间分配耗时任务。 工作队列，又称任务队列。主要思想就是避免执行资源密集型任务时，必须等待它执行完成。相反我们稍后完成任务，我们将任务封装为消息并将其发送到队列。 在后台运行的工作进程将获取任务并最终执行作业。当你运行许多工人时，任务将在他们之间共享，但是一个消息只能被一个消费者获取。 这个概念在Web应用程序中特别有用，因为在短的HTTP请求窗口中无法处理复杂的任务。 接下来我们来模拟这个流程： ​ P：生产者：任务的发布者 ​ C1：消费者，领取任务并且完成任务，假设完成速度较快 ​ C2：消费者2：领取任务并完成任务，假设完成速度慢 面试题：避免消息堆积？ 1） 采用workqueue，多个消费者监听同一队列。 2）接收到消息以后，而是通过线程池，异步消费。 2.2.1.生产者生产者与案例1中的几乎一样： 123456789101112131415161718192021222324public class Send &#123; private final static String QUEUE_NAME = "test_work_queue"; public static void main(String[] argv) throws Exception &#123; // 获取到连接 Connection connection = ConnectionUtil.getConnection(); // 获取通道 Channel channel = connection.createChannel(); // 声明队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); // 循环发布任务 for (int i = 0; i &lt; 50; i++) &#123; // 消息内容 String message = "task .. " + i; channel.basicPublish("", QUEUE_NAME, null, message.getBytes()); System.out.println(" [x] Sent '" + message + "'"); Thread.sleep(i * 2); &#125; // 关闭通道和连接 channel.close(); connection.close(); &#125;&#125; 不过这里我们是循环发送50条消息。 2.2.2.消费者1 2.2.3.消费者2 与消费者1基本类似，就是没有设置消费耗时时间。 这里是模拟有些消费者快，有些比较慢。 接下来，两个消费者一同启动，然后发送50条消息： 可以发现，两个消费者各自消费了25条消息，而且各不相同，这就实现了任务的分发。 2.2.4.能者多劳刚才的实现有问题吗？ 消费者1比消费者2的效率要低，一次任务的耗时较长 然而两人最终消费的消息数量是一样的 消费者2大量时间处于空闲状态，消费者1一直忙碌 现在的状态属于是把任务平均分配，正确的做法应该是消费越快的人，消费的越多。 怎么实现呢？ 我们可以使用basicQos方法和prefetchCount = 1设置。 这告诉RabbitMQ一次不要向工作人员发送多于一条消息。 或者换句话说，不要向工作人员发送新消息，直到它处理并确认了前一个消息。 相反，它会将其分派给不是仍然忙碌的下一个工作人员。 12// 设置每个消费者同时只能处理一条消息channel.basicQos(1); 再次测试： 2.3.订阅模型分类在之前的模式中，我们创建了一个工作队列。 工作队列背后的假设是：每个任务只被传递给一个工作人员。 在这一部分，我们将做一些完全不同的事情 - 我们将会传递一个信息给多个消费者。 这种模式被称为“发布/订阅”。 订阅模型示意图： 解读： 1、1个生产者，多个消费者 2、每一个消费者都有自己的一个队列 3、生产者没有将消息直接发送到队列，而是发送到了交换机 4、每个队列都要绑定到交换机 5、生产者发送的消息，经过交换机到达队列，实现一个消息被多个消费者获取的目的 X（Exchanges）：交换机一方面：接收生产者发送的消息。另一方面：知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于Exchange的类型。 Exchange类型有以下几种： ​ Fanout：广播，将消息交给所有绑定到交换机的队列 ​ Direct：定向，把消息交给符合指定routing key 的队列 ​ Topic：通配符，把消息交给符合routing pattern（路由模式） 的队列 我们这里先学习 ​ Fanout：即广播模式 Exchange（交换机）只负责转发消息，不具备存储消息的能力，因此如果没有任何队列与Exchange绑定，或者没有符合路由规则的队列，那么消息会丢失！ 2.4.订阅模型-FanoutFanout，也称为广播。 流程图： 在广播模式下，消息发送流程是 这样的： 1） 可以有多个消费者 2） 每个消费者有自己的queue（队列） 3） 每个队列都要绑定到Exchange（交换机） 4） 生产者发送的消息，只能发送到交换机，交换机来决定要发给哪个队列，生产者无法决定。 5） 交换机把消息发送给绑定过的所有队列 6） 队列的消费者都能拿到消息。实现一条消息被多个消费者消费 2.4.1.生产者两个变化： 1） 声明Exchange，不再声明Queue 2） 发送消息到Exchange，不再发送到Queue 1234567891011121314151617181920212223public class Send &#123; private final static String EXCHANGE_NAME = "fanout_exchange_test"; public static void main(String[] argv) throws Exception &#123; // 获取到连接 Connection connection = ConnectionUtil.getConnection(); // 获取通道 Channel channel = connection.createChannel(); // 声明exchange，指定类型为fanout channel.exchangeDeclare(EXCHANGE_NAME, "fanout"); // 消息内容 String message = "Hello everyone"; // 发布消息到Exchange channel.basicPublish(EXCHANGE_NAME, "", null, message.getBytes()); System.out.println(" [生产者] Sent '" + message + "'"); channel.close(); connection.close(); &#125;&#125; 2.4.2.消费者112345678910111213141516171819202122232425262728293031public class Recv &#123; private final static String QUEUE_NAME = "fanout_exchange_queue_1"; private final static String EXCHANGE_NAME = "fanout_exchange_test"; public static void main(String[] argv) throws Exception &#123; // 获取到连接 Connection connection = ConnectionUtil.getConnection(); // 获取通道 Channel channel = connection.createChannel(); // 声明队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); // 绑定队列到交换机 channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, ""); // 定义队列的消费者 DefaultConsumer consumer = new DefaultConsumer(channel) &#123; // 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用 @Override public void handleDelivery(String consumerTag, Envelope envelope, BasicProperties properties, byte[] body) throws IOException &#123; // body 即消息体 String msg = new String(body); System.out.println(" [消费者1] received : " + msg + "!"); &#125; &#125;; // 监听队列，自动返回完成 channel.basicConsume(QUEUE_NAME, true, consumer); &#125;&#125; 要注意代码中：队列需要和交换机绑定 2.4.3.消费者212345678910111213141516171819202122232425262728293031public class Recv2 &#123; private final static String QUEUE_NAME = "fanout_exchange_queue_2"; private final static String EXCHANGE_NAME = "fanout_exchange_test"; public static void main(String[] argv) throws Exception &#123; // 获取到连接 Connection connection = ConnectionUtil.getConnection(); // 获取通道 Channel channel = connection.createChannel(); // 声明队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); // 绑定队列到交换机 channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, ""); // 定义队列的消费者 DefaultConsumer consumer = new DefaultConsumer(channel) &#123; // 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用 @Override public void handleDelivery(String consumerTag, Envelope envelope, BasicProperties properties, byte[] body) throws IOException &#123; // body 即消息体 String msg = new String(body); System.out.println(" [消费者2] received : " + msg + "!"); &#125; &#125;; // 监听队列，手动返回完成 channel.basicConsume(QUEUE_NAME, true, consumer); &#125;&#125; 2.4.4.测试我们运行两个消费者，然后发送1条消息： 2.5.订阅模型-Direct说明：​ 在Fanout模式中，一条消息，会被所有订阅的队列都消费。但是，在某些场景下，我们希望不同的消息被不同的队列消费。这时就要用到Direct类型的Exchange。 在Direct模型下： 队列与交换机的绑定，不能是任意绑定了，而是要指定一个RoutingKey（路由key） 消息的发送方在向Exchange发送消息时，也必须指定消息的routing key。 Exchange不 再把消息交给每一个绑定的队列，而是根据消息的Routing Key进行判断，只有队列的Routingkey与消息的Routing key完全一致，才会接收到消息 P：生产者，向Exchange发送消息，发送消息时，会指定一个routing key。 X：Exchange（交换机），接收生产者的消息，然后把消息递交给 与routing key完全匹配的队列 C1：消费者，其所在队列指定了需要routing key 为 error 的消息 C2：消费者，其所在队列指定了需要routing key 为 info、error、warning 的消息 2.5.1.生产者此处我们模拟商品的增删改，发送消息的RoutingKey分别是：insert、update、delete 1234567891011121314151617181920public class Send &#123; private final static String EXCHANGE_NAME = "direct_exchange_test"; public static void main(String[] argv) throws Exception &#123; // 获取到连接 Connection connection = ConnectionUtil.getConnection(); // 获取通道 Channel channel = connection.createChannel(); // 声明exchange，指定类型为direct channel.exchangeDeclare(EXCHANGE_NAME, "direct"); // 消息内容 String message = "商品新增了， id = 1001"; // 发送消息，并且指定routing key 为：insert ,代表新增商品 channel.basicPublish(EXCHANGE_NAME, "insert", null, message.getBytes()); System.out.println(" [商品服务：] Sent '" + message + "'"); channel.close(); connection.close(); &#125;&#125; 2.5.2.消费者1我们此处假设消费者1只接收两种类型的消息：更新商品和删除商品。 12345678910111213141516171819202122232425262728293031public class Recv &#123; private final static String QUEUE_NAME = "direct_exchange_queue_1"; private final static String EXCHANGE_NAME = "direct_exchange_test"; public static void main(String[] argv) throws Exception &#123; // 获取到连接 Connection connection = ConnectionUtil.getConnection(); // 获取通道 Channel channel = connection.createChannel(); // 声明队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); // 绑定队列到交换机，同时指定需要订阅的routing key。假设此处需要update和delete消息 channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, "update"); channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, "delete"); // 定义队列的消费者 DefaultConsumer consumer = new DefaultConsumer(channel) &#123; // 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用 @Override public void handleDelivery(String consumerTag, Envelope envelope, BasicProperties properties, byte[] body) throws IOException &#123; // body 即消息体 String msg = new String(body); System.out.println(" [消费者1] received : " + msg + "!"); &#125; &#125;; // 监听队列，自动ACK channel.basicConsume(QUEUE_NAME, true, consumer); &#125;&#125; 2.5.3.消费者2我们此处假设消费者2接收所有类型的消息：新增商品，更新商品和删除商品。 1234567891011121314151617181920212223242526272829303132public class Recv2 &#123; private final static String QUEUE_NAME = "direct_exchange_queue_2"; private final static String EXCHANGE_NAME = "direct_exchange_test"; public static void main(String[] argv) throws Exception &#123; // 获取到连接 Connection connection = ConnectionUtil.getConnection(); // 获取通道 Channel channel = connection.createChannel(); // 声明队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); // 绑定队列到交换机，同时指定需要订阅的routing key。订阅 insert、update、delete channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, "insert"); channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, "update"); channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, "delete"); // 定义队列的消费者 DefaultConsumer consumer = new DefaultConsumer(channel) &#123; // 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用 @Override public void handleDelivery(String consumerTag, Envelope envelope, BasicProperties properties, byte[] body) throws IOException &#123; // body 即消息体 String msg = new String(body); System.out.println(" [消费者2] received : " + msg + "!"); &#125; &#125;; // 监听队列，自动ACK channel.basicConsume(QUEUE_NAME, true, consumer); &#125;&#125; 2.5.4.测试我们分别发送增、删、改的RoutingKey，发现结果： 2.6.订阅模型-TopicTopic类型的Exchange与Direct相比，都是可以根据RoutingKey把消息路由到不同的队列。只不过Topic类型Exchange可以让队列在绑定Routing key 的时候使用通配符！ Routingkey 一般都是有一个或多个单词组成，多个单词之间以”.”分割，例如： item.insert 通配符规则： ​ #：匹配一个或多个词 ​ *：匹配不多不少恰好1个词 举例： ​ audit.#：能够 匹配audit.irs.corporate 或者 audit.irs ​ audit.*：只能匹配audit.irs 在这个例子中，我们将发送所有描述动物的消息。消息将使用由三个字（两个点）组成的routing key发送。路由关键字中的第一个单词将描述速度，第二个颜色和第三个种类：“..”。 我们创建了三个绑定：Q1绑定了绑定键“ .orange.”，Q2绑定了“..rabbit”和“lazy.＃”。 Q1匹配所有的橙色动物。 Q2匹配关于兔子以及懒惰动物的消息。 练习，生产者发送如下消息，会进入那个队列： quick.orange.rabbit à Q1 Q2 lazy.orange.elephant à Q1 Q2 quick.orange.fox à Q1 lazy.pink.rabbit à Q2 quick.brown.fox à 不匹配任意队列，被丢弃 quick.orange.male.rabbit à orange à 2.6.1.生产者使用topic类型的Exchange，发送消息的routing key有3种： item.isnert、item.update、item.delete： 1234567891011121314151617181920public class Send &#123; private final static String EXCHANGE_NAME = "topic_exchange_test"; public static void main(String[] argv) throws Exception &#123; // 获取到连接 Connection connection = ConnectionUtil.getConnection(); // 获取通道 Channel channel = connection.createChannel(); // 声明exchange，指定类型为topic channel.exchangeDeclare(EXCHANGE_NAME, "topic"); // 消息内容 String message = "新增商品 : id = 1001"; // 发送消息，并且指定routing key 为：insert ,代表新增商品 channel.basicPublish(EXCHANGE_NAME, "item.insert", null, message.getBytes()); System.out.println(" [商品服务：] Sent '" + message + "'"); channel.close(); connection.close(); &#125;&#125; 2.6.2.消费者1我们此处假设消费者1只接收两种类型的消息：更新商品和删除商品 12345678910111213141516171819202122232425262728293031public class Recv &#123; private final static String QUEUE_NAME = "topic_exchange_queue_1"; private final static String EXCHANGE_NAME = "topic_exchange_test"; public static void main(String[] argv) throws Exception &#123; // 获取到连接 Connection connection = ConnectionUtil.getConnection(); // 获取通道 Channel channel = connection.createChannel(); // 声明队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); // 绑定队列到交换机，同时指定需要订阅的routing key。需要 update、delete channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, "item.update"); channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, "item.delete"); // 定义队列的消费者 DefaultConsumer consumer = new DefaultConsumer(channel) &#123; // 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用 @Override public void handleDelivery(String consumerTag, Envelope envelope, BasicProperties properties, byte[] body) throws IOException &#123; // body 即消息体 String msg = new String(body); System.out.println(" [消费者1] received : " + msg + "!"); &#125; &#125;; // 监听队列，自动ACK channel.basicConsume(QUEUE_NAME, true, consumer); &#125;&#125; 2.6.3.消费者2我们此处假设消费者2接收所有类型的消息：新增商品，更新商品和删除商品。 123456789101112131415161718192021222324252627282930313233/** * 消费者2 */public class Recv2 &#123; private final static String QUEUE_NAME = "topic_exchange_queue_2"; private final static String EXCHANGE_NAME = "topic_exchange_test"; public static void main(String[] argv) throws Exception &#123; // 获取到连接 Connection connection = ConnectionUtil.getConnection(); // 获取通道 Channel channel = connection.createChannel(); // 声明队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); // 绑定队列到交换机，同时指定需要订阅的routing key。订阅 insert、update、delete channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, "item.*"); // 定义队列的消费者 DefaultConsumer consumer = new DefaultConsumer(channel) &#123; // 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用 @Override public void handleDelivery(String consumerTag, Envelope envelope, BasicProperties properties, byte[] body) throws IOException &#123; // body 即消息体 String msg = new String(body); System.out.println(" [消费者2] received : " + msg + "!"); &#125; &#125;; // 监听队列，自动ACK channel.basicConsume(QUEUE_NAME, true, consumer); &#125;&#125; 2.7.持久化如何避免消息丢失？ 1） 消费者的ACK机制。可以防止消费者丢失消息。 2） 但是，如果在消费者消费之前，MQ就 宕机了，消息就没了。 是可以将消息进行持久化呢？ 要将消息持久化，前提是：队列、Exchange都持久化 2.7.1.交换机持久化 2.7.2.队列持久化 2.7.3.消息持久化 解决消息丢失？（面试rabbitmq） ack（消息确认） 持久化 发送消息前，将消息持久化到数据库，并记录消息状态（可靠消息服务） 生产确认（publisher confirm） 幂等性（同一个接口被重复执行，其结果一致） 3.Spring AMQP3.1.简介Sprin有很多不同的项目，其中就有对AMQP的支持： Spring AMQP的页面：http://spring.io/projects/spring-amqp 注意这里一段描述： ​ Spring-amqp是对AMQP协议的抽象实现，而spring-rabbit 是对协议的具体实现，也是目前的唯一实现。底层使用的就是RabbitMQ。 2.2.依赖和配置添加AMQP的启动器： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;&lt;/dependency&gt; 在application.yml中添加RabbitMQ地址： 123456spring: rabbitmq: host: 192.168.25.128 username: 2850105498 password: cxg200888 virtual-host: /leyou 2.3.监听者在SpringAmqp中，对消息的消费者进行了封装和抽象，一个普通的JavaBean中的普通方法，只要通过简单的注解，就可以成为一个消费者。 123456789101112131415@Componentpublic class Listener &#123; @RabbitListener(bindings = @QueueBinding( value = @Queue(value = "spring.test.queue", durable = "true"), exchange = @Exchange( value = "spring.test.exchange", ignoreDeclarationExceptions = "true", type = ExchangeTypes.TOPIC ), key = &#123;"#.#"&#125;)) public void listen(String msg)&#123; System.out.println("接收到消息：" + msg); &#125;&#125; @Componet：类上的注解，注册到Spring容器 @RabbitListener：方法上的注解，声明这个方法是一个消费者方法，需要指定下面的属性： bindings：指定绑定关系，可以有多个。值是@QueueBinding的数组。@QueueBinding包含下面属性： value：这个消费者关联的队列。值是@Queue，代表一个队列 exchange：队列所绑定的交换机，值是@Exchange类型 key：队列和交换机绑定的RoutingKey 类似listen这样的方法在一个类中可以写多个，就代表多个消费者。 2.4.AmqpTemplateSpring最擅长的事情就是封装，把他人的框架进行封装和整合。 Spring为AMQP提供了统一的消息处理模板：AmqpTemplate，非常方便的发送消息，其发送方法： 红框圈起来的是比较常用的3个方法，分别是： 指定交换机、RoutingKey和消息体 指定消息 指定RoutingKey和消息，会向默认的交换机发送消息 2.5.测试代码123456789101112131415@RunWith(SpringRunner.class)@SpringBootTest(classes = Application.class)public class MqDemo &#123; @Autowired private AmqpTemplate amqpTemplate; @Test public void testSend() throws InterruptedException &#123; String msg = "hello, Spring boot amqp"; this.amqpTemplate.convertAndSend("spring.test.exchange","a.b", msg); // 等待10秒后再结束 Thread.sleep(10000); &#125;&#125; 运行后查看日志：]]></content>
      <categories>
        <category>项目实战-微服务商城</category>
        <category>RabbitMQ</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务商城（十三）——商品详情、静态化]]></title>
    <url>%2Fday13.%E5%95%86%E5%93%81%E8%AF%A6%E6%83%85%E3%80%81%E5%95%86%E5%93%81%E9%9D%99%E6%80%81%E5%8C%96.html</url>
    <content type="text"><![CDATA[0.学习目标 了解Thymeleaf的基本使用 实现商品详情页的渲染 知道页面静态化的作用 实现页面静态化功能 1.商品详情 当用户搜索到商品，肯定会点击查看，就会进入商品详情页，接下来我们完成商品详情页的展示，商品详情页在leyou-portal中对应的页面是: item.html但是不同的商品，到达item.html需 要展示的内容不同，该怎么做呢? 思路1:统一跳转到item.html页面，然后异步加载商品数据，渲染页面 思路2:将请求交给tomcat处理，在后天完成数据渲染，给不同商品生成不同页面后，返回给用户我们该选哪一种思路? 思路1: 优点:页面加载快，异步处理，用户体验好 缺点:会向后天发起多次数据请求，增加服务端压力 思路2: 优点:后台处理页面后返回，用户拿到是最终数据，不会再次向后台发起数据请求。 缺点:在后台处理页面，服务端压力过大，tomcat并发能力差​ 此处我们选择思路2，现在用tomcat来处理请求，完成服务端的页面渲染，不过后期我们对此进行优化。 以前服务端渲染我们都使用的JSP，不过在SpringBoot中已经不推 荐使用JJsp了，因此我们会使用另外的模板引擎技术: Thymeleaf 1.1.Thymeleaf在商品详情页中，我们会使用到Thymeleaf来渲染页面，所以需要先了解Thymeleaf的语法。 详见课前资料中《Thymeleaf语法入门.md》 1.2.商品详情页服务商品详情浏览量比较大，并发高，我们会独立开启一个微服务，用来展示商品详情。 1.2.1.创建module商品的详情页服务，命名为：ly-page 1.2.2.pom依赖1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;leyou&lt;/artifactId&gt; &lt;groupId&gt;com.leyou.parent&lt;/groupId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.service&lt;/groupId&gt; &lt;artifactId&gt;ly-page&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.leyou.service&lt;/groupId&gt; &lt;artifactId&gt;ly-item-interface&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 1.2.3.编写启动类12345678@SpringBootApplication@EnableDiscoveryClient@EnableFeignClientspublic class LyPageApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(LyPageApplication.class, args); &#125;&#125; 1.2.4.application.yml文件1234567891011121314151617server: port: 8084spring: application: name: page-service thymeleaf: cache: falseeureka: client: service-url: defaultZone: http://127.0.0.1:10086/eureka instance: lease-renewal-interval-in-seconds: 5 # 每隔5秒发送一次心跳 lease-expiration-duration-in-seconds: 10 # 10秒不发送就过期 prefer-ip-address: true ip-address: 127.0.0.1 instance-id: $&#123;spring.application.name&#125;.$&#123;server.port&#125; 1.2.5.页面模板我们从leyou-portal中复制item.html模板到当前项目resource目录下的templates中： 1.3.页面跳转1.3.1.修改页面跳转路径首先我们需要修改搜索结果页的商品地址，目前所有商品的地址都是：http://www.leyou.com/item.html 我们应该跳转到对应的商品的详情页才对。 那么问题来了：商品详情页是一个SKU？还是多个SKU的集合？ 通过详情页的预览，我们知道它是多个SKU的集合，即SPU。 所以，页面跳转时，我们应该携带SPU的id信息。 例如：http://www.leyou.com/item/2314123.html 这里就采用了路径占位符的方式来传递spu的id，我们打开search.html，修改其中的商品路径： 刷新页面后再看： 1.3.2.nginx反向代理接下来，我们要把这个地址指向我们刚刚创建的服务：ly-page，其端口为8084 我们在nginx.conf中添加一段逻辑： 把以/item开头的请求，代理到我们的8084端口。 1.3.3.编写跳转controller在ly-page中编写controller，接收请求，并跳转到商品详情页： 12345678910111213141516@Controller@RequestMapping("item")public class GoodsController &#123; /** * 跳转到商品详情页 * @param model * @param id * @return */ @GetMapping("&#123;id&#125;.html") public String toItemPage(Model model, @PathVariable("id")Long id)&#123; return "item"; &#125;&#125; 1.3.4.测试启动ly-page，点击搜索页面商品，看是能够正常跳转： 现在看到的依然是静态的数据。我们接下来开始页面的渲染 1.4.封装模型数据首先我们一起来分析一下，在这个页面中需要哪些数据 我们已知的条件是传递来的spu的id，我们需要根据spu的id查询到下面的数据： spu信息 spu的详情 spu下的所有sku 品牌 商品三级分类 商品规格参数、规格参数组 1.4.1.商品微服务提供接口1.4.1.1.查询spu以上所需数据中，查询spu的接口目前还没有，我们需要在商品微服务中提供这个接口： GoodsApi 1234567/** * 根据spu的id查询spu * @param id * @return */@GetMapping("spu/&#123;id&#125;")public Spu querySpuById(@PathVariable("id") Long id); GoodsController 123456789/** * 根据spu的id查询spu * @param id * @return */@GetMapping("spu/&#123;id&#125;")public ResponseEntity&lt;Spu&gt; querySpuById(@PathVariable("id")Long id)&#123; return ResponseEntity.ok(goodsService.querySpuById(id));&#125; GoodsService 123456789101112public Spu querySpuById(Long id) &#123; //查询spu Spu spu = spuMapper.selectByPrimaryKey(id); if (spu==null)&#123; throw new LyException(ExceptionEnums.SPU_NOT_FOUND); &#125; //查询sku调用上面的函数querySkuByid() spu.setSkus(querySkuByid(id)); //查询detail spu.setSpuDetail(queryDetailBySpuId(id)); return spu;&#125; 1.4.1.2.查询规格参数组我们在页面展示规格时，需要按组展示： 组内有多个参数，为了方便展示。我们提供一个接口，查询规格组，同时在规格组中持有组内的所有参数。 拓展SpecGroup类： 我们在SpecGroup中添加一个SpecParam的集合，保存该组下所有规格参数 1234567891011121314@Table(name = "tb_spec_group")public class SpecGroup &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; private Long cid; private String name; @Transient//不属于SpecGroup数据库里字段 private List&lt;SpecParam&gt; params; // 该组下的所有规格参数集合&#125; 然后提供查询接口： SpecificationAPI： 1234567/** * 根据分类cid查询规格组 * @param cid * @return */@GetMapping("spec/group")List&lt;SpecGroup&gt; queryListByCid(@RequestParam("cid")Long cid); SpecificationController 123456789/** * 根据分类cid查询规格组 * @param cid * @return */ @GetMapping("group")public ResponseEntity&lt;List&lt;SpecGroup&gt;&gt; queryListByCid(@RequestParam("cid")Long cid)&#123; return ResponseEntity.ok(specificationService.queryListByCid(cid)); &#125; SpecificationService 123456789101112131415161718192021public List&lt;SpecGroup&gt; queryListByCid(Long cid) &#123; //查询规格组 List&lt;SpecGroup&gt; specGroups = queryGroupByCid(cid); //查询当前分类下的规格参数 List&lt;SpecParam&gt; specParams = queryParamByList(null, cid, null, null); //先把规格参数变成map，map的key是规格参数组id，map的值是组下的所有参数 Map&lt;Long,List&lt;SpecParam&gt;&gt; map=new HashMap&lt;&gt;(); for (SpecParam specParam : specParams) &#123; if (!map.containsKey(specParam.getGroupId()))&#123; //这个组id在map中不存在，新增一个list map.put(specParam.getGroupId(),new ArrayList&lt;&gt;()); &#125; map.get(specParam.getGroupId()).add(specParam); &#125; //填充param到group for (SpecGroup specGroup : specGroups) &#123; specGroup.setParams(map.get(specGroup.getId())); &#125; return specGroups; &#125; 在service中，我们调用之前编写过的方法，查询规格组，和规格参数，然后封装返回。 1.4.2.创建FeignClient我们在ly-page服务中，创建FeignClient： BrandClient： 123@FeignClient("item-service")public interface BrandClient extends BrandApi &#123;&#125; CategoryClient 123@FeignClient("item-service")public interface CategoryClient extends CategoryApi &#123;&#125; GoodsClient: 123@FeignClient("item-service")public interface GoodsClient extends GoodsApi &#123;&#125; SpecificationClient： 123@FeignClient(value = "item-service")public interface SpecificationClient extends SpecificationApi&#123;&#125; 1.4.3.封装数据模型我们创建一个GoodsService，在里面来封装数据模型。 这里要查询的数据： SPU：商品 SpuDetail：商品详情 SKU集合 category：商品分类 这里值需要分类的id和name就够了，因此我们查询到以后自己需要封装数据 brand：品牌 spec：规格组 查询规格组的时候，把规格组下所有的参数也一并查出，上面提供的接口中已经实现该功能，我们直接调 sku的特有规格参数 有了规格组，为什么这里还要查询？ 因为在SpuDetail中的SpecialSpec中，是以id作为规格参数id作为key，如图： 我们就需要把id和name一一对应起来，因此需要额外查询sku的特有规格参数，然后变成一个id:name的键值对格式。也就是一个Map，方便将来根据id查找！ Service代码 123456789101112131415161718192021222324252627282930@Servicepublic class PageService &#123; @Autowired private BrandClient brandClient; @Autowired private CategoryClient categoryClient; @Autowired private SpecificationClient specificationClient; @Autowired private GoodsClient goodsClient; public Map&lt;String,Object&gt; loadModel(Long spuId) &#123; Map&lt;String,Object&gt; model=new HashMap&lt;&gt;(); //查询spu Spu spu = goodsClient.querySpuById(spuId); List&lt;Sku&gt; skus = spu.getSkus(); SpuDetail detail = spu.getSpuDetail(); Brand brand = brandClient.queryBrandById(spu.getBrandId()); List&lt;Category&gt; categories = categoryClient.queryCategoryByIds(Arrays.asList(spu.getCid1(), spu.getCid2(), spu.getCid3())); List&lt;SpecGroup&gt; specs = specificationClient.queryListByCid(spu.getCid3()); model.put("spu",spu); model.put("skus",skus); model.put("detail",detail); model.put("brand", brand); model.put("categories",categories); model.put("specs",specs); return model; &#125;&#125; 然后在controller中把数据放入model： 12345678910111213141516@Controllerpublic class PageController &#123; @Autowired private PageService pageService; @GetMapping("item/&#123;id&#125;.html") public String toItemPage(@PathVariable("id") Long spuId, Model model) &#123; //查询模型数据 Map&lt;String,Object&gt; attributes=pageService.loadModel(spuId); //准备模型属性 model.addAllAttributes(attributes); return "item"; &#125;&#125; 1.4.4.页面测试数据我们在页面中先写一段JS，把模型中的数据取出观察，看是否成功： 123456789&lt;script th:inline="javascript"&gt; const b = /*[[$&#123;params&#125;]]*/ []; const c = /*[[$&#123;categories&#125;]]*/ []; const d = /*[[$&#123;spu&#125;]]*/ &#123;&#125;; const e = /*[[$&#123;detail&#125;]]*/ &#123;&#125;; const f = /*[[$&#123;skus&#125;]]*/ []; const g = /*[[$&#123;brand&#125;]]*/ &#123;&#125;;&lt;/script&gt; 然后查看页面源码： 数据都成功查到了！ 1.5.渲染面包屑在商品展示页的顶部，有一个商品分类、品牌、标题的面包屑 其数据有3部分： 商品分类 商品品牌 spu标题 我们的模型中都有，所以直接渲染即可（页面101行开始）： 1234567891011&lt;div class="crumb-wrap"&gt; &lt;ul class="sui-breadcrumb"&gt; &lt;li th:each="category : $&#123;categories&#125;"&gt; &lt;a href="#" th:text="$&#123;categories.name&#125;"&gt;手机&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href="#" th:text="$&#123;brand.name&#125;"&gt;Apple&lt;/a&gt; &lt;/li&gt; &lt;li class="active" th:text="$&#123;spu.title&#125;"&gt;Apple iPhone 6s&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 1.6.渲染商品列表先看下整体效果： 这个部分需要渲染的数据有5块： sku图片 sku标题 副标题 sku价格 特有规格属性列表 其中，sku 的图片、标题、价格，都必须在用户选中一个具体sku后，才能渲染。而特有规格属性列表可以在spuDetail中查询到。而副标题则是在spu中，直接可以在页面渲染 因此，我们先对特有规格属性列表进行渲染。等用户选择一个sku，再通过js对其它sku属性渲染 1.6.1.副标题副标题是在spu中，所以我们直接通过Thymeleaf渲染： 在第146行左右： 1&lt;div class="news"&gt;&lt;span th:utext="$&#123;spu.subTitle&#125;"&gt;&lt;/span&gt;&lt;/div&gt; 副标题中可能会有超链接，因此这里也用th:utext来展示，效果： 1.6.2.渲染规格属性列表规格属性列表将来会有事件和动态效果。我们需要有js代码参与，不能使用Thymeleaf来渲染了。 因此，这里我们用vue，不过需要先把数据放到js对象中，方便vue使用 初始化数据我们在页面的head中，定义一个js标签，然后在里面定义变量，保存与sku相关的一些数据： 12345678910const specialSpec = JSON.parse(/*[[$&#123;detail.specialSpec&#125;]]*/ "");const genericSpec = JSON.parse(/*[[$&#123;detail.genericSpec&#125;]]*/ "");const skus = /*[[$&#123;skus&#125;]]*/ [];const specs = /*[[$&#123;specs&#125;]]*/ [];const params = &#123;&#125;;specs.forEach(group =&gt; &#123; group.params.forEach(param =&gt; &#123; params[param.id] = param.name; &#125;)&#125;); specialSpec：这是SpuDetail中唯一与Sku相关的数据 因此我们并没有保存整个spuDetail，而是只保留了这个属性，而且需要手动转为js对象。 paramMap：规格参数的id和name对，方便页面根据id获取参数名 sku：特有规格参数集合 我们来看下页面获取的数据： 通过Vue渲染我们把刚才获得的几个变量保存在Vue实例中： 然后在页面中渲染： 1234567891011121314&lt;div id="specification" class="summary-wrap clearfix"&gt; &lt;dl v-for="(v,k) in specialSpec" :key="k"&gt; &lt;dt&gt; &lt;div class="fl title"&gt; &lt;i&gt;&#123;&#123;paramMap[k]&#125;&#125;&lt;/i&gt; &lt;/div&gt; &lt;/dt&gt; &lt;dd v-for="(str,j) in v" :key="j"&gt; &lt;a href="javascript:;" class="selected"&gt; &#123;&#123;str&#125;&#125;&lt;span title="点击取消选择"&gt;&amp;nbsp;&lt;/span&gt; &lt;/a&gt; &lt;/dd&gt; &lt;/dl&gt;&lt;/div&gt; 然后刷新页面查看： 数据成功渲染了。不过我们发现所有的规格都被勾选了。这是因为现在，每一个规格都有样式：selected，我们应该只选中一个，让它的class样式为selected才对！ 那么问题来了，我们该如何确定用户选择了哪一个？ 1.6.3.规格属性的筛选分析规格参数的格式是这样的： 每一个规格项是数组中的一个元素，因此我们只要保存被选择的规格项的索引，就能判断哪个是用户选择的了！ 我们需要一个对象来保存用户选择的索引，格式如下： 12345&#123; "4":0, "12":0, "13":0&#125; 但问题是，第一次进入页面时，用户并未选择任何参数。因此索引应该有一个默认值，我们将默认值设置为0。 我们在head的script标签中，对索引对象进行初始化： 然后在vue中保存： 页面改造我们在页面中，通过判断indexes的值来判断当前规格是否被选中，并且给规格绑定点击事件，点击规格项后，修改indexes中的对应值： 1234567891011121314&lt;div id="specification" class="summary-wrap clearfix"&gt; &lt;dl v-for="(options,id) in specialSpec" :key="id"&gt; &lt;dt&gt; &lt;div class="fl title"&gt; &lt;i v-text="params[id]"&gt;&lt;/i&gt; &lt;/div&gt; &lt;/dt&gt; &lt;dd v-for="(o,i) in options" :key="i" @click="selectSku(id,i)"&gt; &lt;a href="javascript:;" :class="&#123;selected:i === indexes[id], locked:locked(id, i)&#125;"&gt; &#123;&#123;o&#125;&#125;&lt;span title="点击取消选择"&gt;&amp;nbsp;&lt;/span&gt; &lt;/a&gt; &lt;/dd&gt; &lt;/dl&gt; &lt;/div&gt; 效果： 1.6.4.确定SKU在我们设计sku数据的时候，就已经添加了一个字段：indexes： 这其实就是规格参数的索引组合。 而我们在页面中，用户点击选择规格后，就会把对应的索引保存起来： 因此，我们可以根据这个indexes来确定用户要选择的sku 我们在vue中定义一个计算属性，来计算与索引匹配的sku： 12345678910computed: &#123; sku() &#123; if (Object.values(this.indexes).includes(null)) &#123; return skus[0]; &#125; // 获取选中的规格参数的索引 const index = Object.values(this.indexes).join("_"); // 去skus集合寻找与index一致的sku return skus.find(s =&gt; s.indexes === index); &#125;, 在浏览器工具中查看： 1.6.5.渲染sku列表既然已经拿到了用户选中的sku，接下来，就可以在页面渲染数据了 图片列表商品图片是一个字符串，以,分割，页面展示比较麻烦，所以我们编写一个计算属性:images()，将图片字符串变成数组： 12345678910111213computed: &#123; sku() &#123; if (Object.values(this.indexes).includes(null)) &#123; return skus[0]; &#125; // 获取选中的规格参数的索引 const index = Object.values(this.indexes).join("_"); // 去skus集合寻找与index一致的sku return skus.find(s =&gt; s.indexes === index); &#125;, images() &#123; return this.sku.images ? this.sku.images.split(",") : []; &#125;, 页面改造： 123456789101112131415161718192021&lt;div class="zoom"&gt; &lt;!--默认第一个预览--&gt; &lt;div id="preview" class="spec-preview"&gt; &lt;span class="jqzoom"&gt; &lt;img :jqimg="images[0]" :src="images[0]" width="400px" height="400px"/&gt; &lt;/span&gt; &lt;/div&gt; &lt;!--下方的缩略图--&gt; &lt;div class="spec-scroll"&gt; &lt;a class="prev"&gt;&amp;lt;&lt;/a&gt; &lt;!--左右按钮--&gt; &lt;div class="items"&gt; &lt;ul&gt; &lt;li v-for="(image, i) in images" :key="i"&gt; &lt;img :src="image" :bimg="image" onmousemove="preview(this)" /&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;a class="next"&gt;&amp;gt;&lt;/a&gt; &lt;/div&gt;&lt;/div&gt; 完整效果 1.7.商品详情商品详情页面如下图所示： 分成上下两部分： 上部：展示的是规格属性列表 下部：展示的是商品详情 1.7.1.属性列表（作业）12345678910&lt;div id="one" class="tab-pane active" &gt;&lt;ul class="goods-intro-list unstyled" style="list-style: none;" v-for="group in specGroups" :key="group.id"&gt;&lt;!--商品的参数--&gt;&lt;li v-for="param in group.params" :key="param.id" &gt;&#123;&#123;param.name&#125;&#125; : &#123;&#123;param.value&#125;&#125;&lt;/li&gt;&lt;/ul&gt;&lt;!--商品详情--&gt;&lt;div class="intro-detail"&gt;&lt;div th:utext="$&#123;detail.description&#125;"&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt; 1.7.2.商品详情商品详情是HTML代码，我们不能使用 th:text，应该使用th:utext 在页面的第444行左右： 123&lt;!--商品详情--&gt;&lt;div class="intro-detail" th:utext="$&#123;spuDetail.description&#125;"&gt;&lt;/div&gt; 最终展示效果： 1.8.规格包装：规格包装分成两部分： 规格参数 包装列表 而且规格参数需要按照组来显示 1.8.1.规格参数最终的效果： 我们模型中有一个groups，跟这个数据结果很像： 分成8个组，组内都有params，里面是所有的参数。不过，这些参数都没有值！ 规格参数的值分为两部分： 通用规格参数：保存在SpuDetail中的genericSpec中 特有规格参数：保存在sku的ownSpec中 我们需要把这两部分值取出来，放到groups中。 把genericSpec引入到Vue实例： 因为sku是动态的，所以我们编写一个计算属性，来进行值的组合： 1234567891011121314specGroups() &#123; // 获取特有规格参数值 const ownSpec = JSON.parse(this.sku.ownSpec); specs.forEach(group =&gt; &#123; group.params.forEach(param =&gt; &#123; if (param.generic) &#123; param.value = genericSpec[param.id]; &#125; else &#123; param.value = ownSpec[param.id]; &#125; &#125;) &#125;) return specs;&#125;, 然后在页面渲染： 1234567891011&lt;div class="Ptable"&gt; &lt;div class="Ptable-item" v-for="group in specGroups" :key="group.id"&gt; &lt;h3 v-text="group.name"&gt;&lt;/h3&gt; &lt;dl&gt; &lt;span v-for="param in group.params" :key="param.id"&gt; &lt;dt v-text="param.name"&gt;&lt;/dt&gt; &lt;dd v-text="param.value + (param.unit || '')"&gt;&lt;/dd&gt; &lt;/span&gt; &lt;/dl&gt; &lt;/div&gt;&lt;/div&gt; 1.8.2.包装列表包装列表在商品详情中，我们一开始并没有赋值到Vue实例中，但是可以通过Thymeleaf来渲染 1234&lt;div class="package-list"&gt; &lt;h3&gt;包装清单&lt;/h3&gt; &lt;p th:text="$&#123;spuDetail.packingList&#125;"&gt;&lt;/p&gt;&lt;/div&gt; 最终效果： 1.9.售后服务售后服务也可以通过Thymeleaf进行渲染： 123&lt;div id="three" class="tab-pane"&gt; &lt;p th:text="$&#123;detail.afterService&#125;"&gt;售后保障&lt;/p&gt;&lt;/div&gt; 效果： 2.页面静态化2.1.简介2.1.1.问题分析现在，我们的页面是通过Thymeleaf模板引擎渲染后返回到客户端。在后台需要大量的数据查询，而后渲染得到HTML页面。会对数据库造成压力，并且请求的响应时间过长，并发能力不高。 大家能想到什么办法来解决这个问题？ 首先我们能想到的就是缓存技术，比如之前学习过的Redis。不过Redis适合数据规模比较小的情况。假如数据量比较大，例如我们的商品详情页。每个页面如果10kb，100万商品，就是10GB空间，对内存占用比较大。此时就给缓存系统带来极大压力，如果缓存崩溃，接下来倒霉的就是数据库了。 所以缓存并不是万能的，某些场景需要其它技术来解决，比如静态化。 2.1.2.什么是静态化静态化是指把动态生成的HTML页面变为静态内容保存，以后用户的请求到来，直接访问静态页面，不再经过服务的渲染。 而静态的HTML页面可以部署在nginx中，从而大大提高并发能力，减小tomcat压力。 2.1.3.如何实现静态化目前，静态化页面都是通过模板引擎来生成，而后保存到nginx服务器来部署。常用的模板引擎比如： Freemarker Velocity Thymeleaf 我们之前就使用的Thymeleaf，来渲染html返回给用户。Thymeleaf除了可以把渲染结果写入Response，也可以写到本地文件，从而实现静态化。 2.2.Thymeleaf实现静态化2.2.1.概念先说下Thymeleaf中的几个概念： Context：运行上下文 TemplateResolver：模板解析器 TemplateEngine：模板引擎 Context 上下文： 用来保存模型数据，当模板引擎渲染时，可以从Context上下文中获取数据用于渲染。 当与SpringBoot结合使用时，我们放入Model的数据就会被处理到Context，作为模板渲染的数据使用。 TemplateResolver 模板解析器：用来读取模板相关的配置，例如：模板存放的位置信息，模板文件名称，模板文件的类型等等。 当与SpringBoot结合时，TemplateResolver已经由其创建完成，并且各种配置也都有默认值，比如模板存放位置，其默认值就是：templates。比如模板文件类型，其默认值就是html。 TemplateEngine 模板引擎：用来解析模板的引擎，需要使用到上下文、模板解析器。分别从两者中获取模板中需要的数据，模板文件。然后利用内置的语法规则解析，从而输出解析后的文件。来看下模板引擎进行处理的函数： 1templateEngine.process("模板名", context, writer); 三个参数： 模板名称 上下文：里面包含模型数据 writer：输出目的地的流 在输出时，我们可以指定输出的目的地，如果目的地是Response的流，那就是网络响应。如果目的地是本地文件，那就实现静态化了。 而在SpringBoot中已经自动配置了模板引擎，因此我们不需要关心这个。现在我们做静态化，就是把输出的目的地改成本地文件即可！ 2.2.2.具体实现 Service代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253@Slf4j@Servicepublic class PageService &#123; @Autowired private BrandClient brandClient; @Autowired private CategoryClient categoryClient; @Autowired private SpecificationClient specificationClient; @Autowired private GoodsClient goodsClient; @Autowired private TemplateEngine templateEngine; public Map&lt;String,Object&gt; loadModel(Long spuId) &#123; Map&lt;String,Object&gt; model=new HashMap&lt;&gt;(); //查询spu Spu spu = goodsClient.querySpuById(spuId); //查询sku List&lt;Sku&gt; skus = spu.getSkus(); //查询商品详情 SpuDetail detail = spu.getSpuDetail(); //查询品牌 Brand brand = brandClient.queryBrandById(spu.getBrandId()); //查询商品分类 List&lt;Category&gt; categories = categoryClient.queryCategoryByIds(Arrays.asList(spu.getCid1(), spu.getCid2(), spu.getCid3())); //查询规格参数 List&lt;SpecGroup&gt; specs = specificationClient.queryListByCid(spu.getCid3()); model.put("spu",spu); model.put("skus",skus); model.put("detail",detail); model.put("brand", brand); model.put("categories",categories); model.put("specs",specs); return model; &#125; public void createHtml(Long spuId)&#123; //上下文 Context context = new Context(); context.setVariables(loadModel(spuId)); //输出流 File file = new File("G:/Java-webspace/LeYou-store/leyou/ly-page/src/main/resources/templates", spuId + ".html"); try (PrintWriter writer=new PrintWriter(file,"utf-8"))&#123; //生成html templateEngine.process("item",context,writer); &#125;catch (Exception e)&#123; log.error("[静态页服务]，生成静态页面异常！",e); &#125; &#125;&#125; 测试： 测试生成141.html 123456789101112@RunWith(SpringRunner.class)@SpringBootTestpublic class PageServiceTest &#123; @Autowired private PageService pageService; @Test public void createHtml() &#123; pageService.createHtml(141L); &#125;&#125; 2.2.3.什么时候创建静态文件我们编写好了创建静态文件的service，那么问题来了：什么时候去调用它呢 想想这样的场景： 假如大部分的商品都有了静态页面。那么用户的请求都会被nginx拦截下来，根本不会到达我们的leyou-goods-web服务。只有那些还没有页面的请求，才可能会到达这里。 因此，如果请求到达了这里，我们除了返回页面视图外，还应该创建一个静态页面，那么下次就不会再来麻烦我们了。 所以，我们在PageController中添加逻辑，去生成静态html文件： 12345678910111213@GetMapping("&#123;id&#125;.html")public String toItemPage(@PathVariable("id")Long id, Model model)&#123; // 加载所需的数据 Map&lt;String, Object&gt; map = this.goodsService.loadModel(id); // 把数据放入数据模型 model.addAllAttributes(map); // 页面静态化 pageService.createHtml(spuId); return "item";&#125; 注意：生成html 的代码不能对用户请求产生影响，所以这里我们使用额外的线程进行异步创建。 2.2.4.重启测试：访问一个商品详情，然后查看nginx目录： 2.3.nginx代理静态页面接下来，我们修改nginx，让它对商品请求进行监听，指向本地静态页面，如果本地没找到，才进行反向代理： 1234567891011121314151617181920212223server &#123; listen 80; server_name www.leyou.com; proxy_set_header X-Forwarded-Host $host; proxy_set_header X-Forwarded-Server $host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; location /item &#123; # 先找本地 root html; if (!-f $request_filename) &#123; #请求的文件不存在，就反向代理 proxy_pass http://192.168.1.104:8084; break; &#125; &#125; location / &#123; proxy_pass http://192.168.1.104:9002; proxy_connect_timeout 600; proxy_read_timeout 600; &#125;&#125; 重启测试： 发现请求速度得到了极大提升：]]></content>
      <categories>
        <category>项目实战-微服务商城</category>
      </categories>
      <tags>
        <tag>Thymeleaf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务商城（十二）——搜索过滤]]></title>
    <url>%2Fday12-%E6%90%9C%E7%B4%A2%E8%BF%87%E6%BB%A4.html</url>
    <content type="text"><![CDATA[0.学习目标 了解过滤功能的基本思路 独立实现分类和品牌展示 了解规格参数展示 实现过滤条件筛选 实现已选过滤项回显 实现取消选择过滤项 1.过滤功能分析首先看下页面要实现的效果： 整个过滤部分有3块： 顶部的导航，已经选择的过滤条件展示： 商品分类面包屑，根据用户选择的商品分类变化 其它已选择过滤参数 过滤条件展示，又包含3部分 商品分类展示 品牌展示 其它规格参数 展开或收起的过滤条件的按钮 顶部导航要展示的内容跟用户选择的过滤条件有关。 比如用户选择了某个商品分类，则面包屑中才会展示具体的分类 比如用户选择了某个品牌，列表中才会有品牌信息。 所以，这部分需要依赖第二部分：过滤条件的展示和选择。因此我们先不着急去做。 展开或收起的按钮是否显示，取决于过滤条件有多少，如果很少，那么就没必要展示。所以也是跟第二部分的过滤条件有关。 这样分析来看，我们必须先做第二部分：过滤条件展示。 2.生成分类和品牌过滤先来看分类和品牌。在我们的数据库中已经有所有的分类和品牌信息。在这个位置，是不是把所有的分类和品牌信息都展示出来呢？ 显然不是，用户搜索的条件会对商品进行过滤，而在搜索结果中，不一定包含所有的分类和品牌，直接展示出所有商品分类，让用户选择显然是不合适的。 无论是分类信息，还是品牌信息，都应该从搜索的结果商品中进行聚合得到。 2.1.扩展返回的结果原来，我们返回的结果是PageResult对象，里面只有total、totalPage、items3个属性。但是现在要对商品分类和品牌进行聚合，数据显然不够用，我们需要对返回的结果进行扩展，添加分类和品牌的数据。 那么问题来了：以什么格式返回呢？ 看页面： 分类：页面显示了分类名称，但背后肯定要保存id信息。所以至少要有id和name 品牌：页面展示的有logo，有文字，当然肯定有id，基本上是品牌的完整数据 我们新建一个类，继承PageResult，然后扩展两个新的属性：分类集合和品牌集合： 123456789101112131415161718@Data@EqualsAndHashCode(callSuper = false)public class SearchResult extends PageResult&lt;Goods&gt; &#123; private List&lt;Category&gt; categories;//分类待选项 private List&lt;Brand&gt; brands;//品牌待选项 public SearchResult()&#123; &#125; public SearchResult(Long total, Long totalPage, List&lt;Goods&gt; items, List&lt;Category&gt; categories, List&lt;Brand&gt; brands) &#123; super(total, totalPage, items); this.categories = categories; this.brands = brands; this.specs = specs; &#125;&#125; 2.2.聚合商品分类和品牌我们修改搜索的业务逻辑，对分类和品牌聚合。 因为索引库中只有id，所以我们根据id聚合，然后再根据id去查询完整数据。 所以，商品微服务需要提供一个接口：根据品牌id集合，批量查询品牌。 2.2.1.提供查询品牌接口BrandApi 123456@RequestMapping("brand")public interface BrandApi &#123; @GetMapping("list") List&lt;Brand&gt; queryBrandByIds(@RequestParam("ids") List&lt;Long&gt; ids);&#125; BrandController 1234567891011/** * 根据多个id查询品牌 * @param ids * @return */@GetMapping("list")public ResponseEntity&lt;List&lt;Brand&gt;&gt; queryBrandByIds(@RequestParam("ids") List&lt;Long&gt; ids)&#123; List&lt;Brand&gt; list = this.brandService.queryBrandByIds(ids); return ResponseEntity.ok(list);&#125; BrandService 1234public List&lt;Brand&gt; queryBrandByIds(List&lt;Long&gt; ids) &#123; return this.brandMapper.selectByIdList(ids);&#125; BrandMapper 继承通用BaseMapper，自己定义的mapper，继承了extends Mapper,IdListMapper&lt;T,Long&gt;, InsertListMapper 123public interface BrandMapper extends BaseMapper&lt;Brand&gt; &#123; &#125; 2.2.2.搜索功能改造添加BrandClient 123@FeignClient("item-service")public interface BrandClient extends BrandApi &#123;&#125; 修改SearchService： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697@Slf4j@Servicepublic class SearchService &#123; @Autowired private GoodsClient goodsClient; @Autowired private SpecificationClient specificationClient; @Autowired private CategoryClient categoryClient; @Autowired private BrandClient brandClient; @Autowired private GoodsRepository goodsRepository; @Autowired private ElasticsearchTemplate elasticsearchTemplate;public SearchResult search(SearchRequest request) &#123; int page=request.getPage()-1; int size = request.getSize(); //1、创建查询构建器 NativeSearchQueryBuilder queryBuilder = new NativeSearchQueryBuilder(); //2、结果过滤 queryBuilder.withSourceFilter(new FetchSourceFilter(new String[]&#123;"id","skus","subTitle"&#125;,null)); //3、分页 queryBuilder.withPageable(PageRequest.of(page,size)); //4、排序 String sortBy=request.getSortBy(); Boolean desc = request.getDescending(); if (StringUtils.isNotBlank(sortBy))&#123; queryBuilder.withSort(SortBuilders.fieldSort(sortBy).order(desc ? SortOrder.DESC : SortOrder.ASC)); &#125; //5、基本搜索条件 queryBuilder.withQuery(QueryBuilders.matchQuery("all",request.getKey())); //6、聚合(分类和品牌) //6.1、聚合分类 queryBuilder.addAggregation(AggregationBuilders.terms("categoryAggName").field("cid3")); //6.2、聚合品牌 queryBuilder.addAggregation(AggregationBuilders.terms("brandAggName").field("brandId")); //7、查询 AggregatedPage&lt;Goods&gt; result = elasticsearchTemplate.queryForPage(queryBuilder.build(), Goods.class); //8、解析结果 long total = result.getTotalElements();//总条数 long totalPages =(total/size)+1;//总页数 List&lt;Goods&gt; goodsList = result.getContent();//当前页结果 //9、解析聚合结果 Aggregations aggs = result.getAggregations(); //9.1、查询品牌和分类 List&lt;Brand&gt; brands=parseBrandAgg(aggs.get("brandAggName")); List&lt;Category&gt; categories=parseCategoryAgg(aggs.get("categoryAggName")); //10、返回结果 return new SearchResult(total,(long)totalPages,goodsList,categories,brands); &#125;&#125;/** * 通过ids取查询分类 * @param terms * @return */ private List&lt;Category&gt; parseCategoryAgg(LongTerms terms) &#123; try &#123; List&lt;Long&gt; ids = terms.getBuckets().stream().map(b -&gt; b.getKeyAsNumber().longValue()).collect(Collectors.toList()); List&lt;Category&gt; categories = categoryClient.queryCategoryByIds(ids); return categories; &#125;catch (Exception e)&#123; log.error("分类错误信息",e); return null; &#125; &#125; /** * 通过ids取查询品牌 * @param terms * @return */ private List&lt;Brand&gt; parseBrandAgg(LongTerms terms) &#123; try &#123; List&lt;Long&gt; ids = terms.getBuckets().stream().map(b -&gt; b.getKeyAsNumber().longValue()).collect(Collectors.toList()); List&lt;Brand&gt; brands = brandClient.queryBrandByIds(ids); return brands; &#125;catch (Exception e)&#123; log.error("品牌错误信息",e); return null; &#125; &#125; 测试： 2.3.页面渲染数据2.3.1.过滤参数数据结构来看下页面的展示效果： 虽然分类、品牌内容都不太一样，但是结构相似，都是key和value的结构。 而且页面结构也极为类似： 所以，我们可以把所有的过滤条件放入一个数组中，然后在页面利用v-for遍历一次生成。 其基本结构是这样的： 123456[ &#123; k:"过滤字段名", options:[&#123;/*过滤字段值对象*/&#125;,&#123;/*过滤字段值对象*/&#125;] &#125;] 我们先在data中定义数组：filter，等待组装过滤参数： 1234567891011data: &#123; ly, search:&#123; key: "", page: 1 &#125;, goodsList:[], // 接收搜索得到的结果 total: 0, // 总条数 totalPage: 0, // 总页数 filters:[] // 过滤参数集合&#125;, 然后在查询搜索结果的回调函数中，对过滤参数进行封装： 然后刷新页面，通过浏览器工具，查看封装的结果： 2.3.2.页面渲染数据首先看页面原来的代码： 我们注意到，虽然页面元素是一样的，但是品牌会比其它搜索条件多出一些样式，因为品牌是以图片展示。需要进行特殊处理。数据展示是一致的，我们采用v-for处理： 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!--品牌、分类--&gt;&lt;!--分类--&gt;&lt;div class="clearfix selector"&gt; &lt;div class="type-wrap" v-for="f in filters" :key="f.k" v-if="f.k !== 'brandId'"&gt; &lt;div class="fl key"&gt;&#123;&#123;f.k ==='cid3'? "分类" : f.k&#125;&#125;&lt;/div&gt; &lt;div class="fl value"&gt; &lt;ul class="type-list"&gt; &lt;li v-for="(o,i) in f.options" :key="i" @click="selectFilter(filter.k, option)"&gt; &lt;a&gt;&#123;&#123;o.name&#125;&#125;&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class="fl ext"&gt;&lt;/div&gt; &lt;/div&gt; &lt;!--品牌--&gt; &lt;div class="type-wrap logo" v-else&gt; &lt;div class="fl key brand"&gt;品牌&lt;/div&gt; &lt;div class="value logos"&gt; &lt;ul class="logo-list" v-for="(o,i) in f.options" :key="i"&gt; &lt;li v-if="o.image" @click="selectFilter(filter.k, option)"&gt; &lt;img :src="o.image"/&gt; &lt;/li&gt; &lt;li style="text-align: center" v-else @click="selectFilter(filter.k, option)"&gt; &lt;a style="line-height: 30px; font-size: 12px" href="#"&gt;&#123;&#123;o.name&#125;&#125;&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class="fl ext"&gt; &lt;a href="javascript:void(0);" class="sui-btn"&gt;多选&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="type-wrap" style="text-align: center"&gt; &lt;v-btn small flat v-show="!show" @click="show=true"&gt; 更多 &lt;!--&lt;v-icon&gt;arrow_drop_down&lt;/v-icon&gt;--&gt; &lt;/v-btn&gt; &lt;v-btn small flat v-show="show" @click="show=false"&gt; 收起 &lt;!--&lt;v-icon&gt;arrow_drop_up&lt;/v-icon&gt;--&gt; &lt;/v-btn&gt; &lt;/div&gt;&lt;/div&gt; 结果： 3.生成规格参数过滤3.1.谋而后动有四个问题需要先思考清楚： 什么时候显示规格参数过滤？ 如何知道哪些规格需要过滤？ 要过滤的参数，其可选值是如何获取的？ 规格过滤的可选值，其数据格式怎样的？ 什么情况下显示有关规格参数的过滤？ 如果用户尚未选择商品分类，或者聚合得到的分类数大于1，那么就没必要进行规格参数的聚合。因为不同分类的商品，其规格是不同的。 因此，我们在后台需要对聚合得到的商品分类数量进行判断，如果等于1，我们才继续进行规格参数的聚合。 如何知道哪些规格需要过滤？ 我们不能把数据库中的所有规格参数都拿来过滤。因为并不是所有的规格参数都可以用来过滤，参数的值是不确定的。 值的庆幸的是，我们在设计规格参数时，已经标记了某些规格可搜索，某些不可搜索。 因此，一旦商品分类确定，我们就可以根据商品分类查询到其对应的规格，从而知道哪些规格要进行搜索。 要过滤的参数，其可选值是如何获取的？ 虽然数据库中有所有的规格参数，但是不能把一切数据都用来供用户选择。 与商品分类和品牌一样，应该是从用户搜索得到的结果中聚合，得到与结果品牌的规格参数可选值。 规格过滤的可选值，其数据格式怎样的？ 我们直接看页面效果： 我们之前存储时已经将数据分段，恰好符合这里的需求 3.3.实战接下来，我们就用代码实现刚才的思路。 总结一下，应该是以下几步： 1）用户搜索得到商品，并聚合出商品分类 2）判断分类数量是否等于1，如果是则进行规格参数聚合 3）先根据分类，查找可以用来搜索的规格 4）对规格参数进行聚合 5）将规格参数聚合结果整理后返回 3.3.1.扩展返回结果返回结果中需要增加新数据，用来保存规格参数过滤条件。这里与前面的品牌和分类过滤的json结构类似： 123456[ &#123; "k":"规格参数名", "options":["规格参数值","规格参数值"] &#125;] 因此，在java中我们用List&lt;Map&lt;String, String&gt;&gt;来表示。 1234567891011121314151617public class SearchResult extends PageResult&lt;Goods&gt;&#123; private List&lt;Category&gt; categories;// 分类过滤条件 private List&lt;Brand&gt; brands; // 品牌过滤条件 private List&lt;Map&lt;String,String&gt;&gt; specs; // 规格参数过滤条件 public SearchResult(Long total, Integer totalPage, List&lt;Goods&gt; items, List&lt;Category&gt; categories, List&lt;Brand&gt; brands, List&lt;Map&lt;String,String&gt;&gt; specs) &#123; super(total, totalPage, items); this.categories = categories; this.brands = brands; this.specs = specs; &#125;&#125; 3.3.2.判断是否需要聚合首先，在聚合得到商品分类后，判断分类的个数，如果是1个则进行规格聚合： 我们将聚合的代码抽取到了一个getSpecs方法中。 3.3.3.获取需要聚合的规格参数然后，我们需要根据商品分类，查询所有可用于搜索的规格参数： 要注意的是，这里我们需要根据id查询规格，而规格参数接口需要从商品微服务提供 3.3.4.聚合规格参数因为规格参数保存时不做分词，因此其名称会自动带上一个.keyword后缀： 3.3.5.解析聚合结果 3.3.6.最终的完整代码修改SearchService.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116 public SearchResult search(SearchRequest request) &#123; int page=request.getPage()-1; int size = request.getSize(); //1、创建查询构建器 NativeSearchQueryBuilder queryBuilder = new NativeSearchQueryBuilder(); //2、结果过滤 queryBuilder.withSourceFilter(new FetchSourceFilter(new String[]&#123;"id","skus","subTitle"&#125;,null)); //3、分页 queryBuilder.withPageable(PageRequest.of(page,size)); //4、排序 String sortBy=request.getSortBy(); Boolean desc = request.getDescending(); if (StringUtils.isNotBlank(sortBy))&#123; queryBuilder.withSort(SortBuilders.fieldSort(sortBy).order(desc ? SortOrder.DESC : SortOrder.ASC)); &#125; //5、基本搜索条件,调用自己写的函数buildBasicQuery QueryBuilder basicQuery = buildBasicQuery(request); queryBuilder.withQuery(basicQuery); //6、聚合(分类和品牌) //6.1、聚合分类 queryBuilder.addAggregation(AggregationBuilders.terms("categoryAggName").field("cid3")); //6.2、聚合品牌 queryBuilder.addAggregation(AggregationBuilders.terms("brandAggName").field("brandId")); //7、查询 AggregatedPage&lt;Goods&gt; result = elasticsearchTemplate.queryForPage(queryBuilder.build(), Goods.class); //8、解析结果 long total = result.getTotalElements();//总条数 long totalPages =(total/size)+1;//总页数 List&lt;Goods&gt; goodsList = result.getContent();//当前页结果 //9、解析聚合结果 Aggregations aggs = result.getAggregations(); //9.1、查询品牌和分类 List&lt;Brand&gt; brands=parseBrandAgg(aggs.get("brandAggName")); List&lt;Category&gt; categories=parseCategoryAgg(aggs.get("categoryAggName")); //10、规格参数聚合 List&lt;Map&lt;String,Object&gt;&gt; specs=null; if (categories!=null&amp;&amp;categories.size()==1)&#123; //商品分类存在并且数量为1，可以聚合规格参数 specs=buildSpecificationAgg(categories.get(0).getId(),basicQuery); &#125; //11、返回结果 return new SearchResult(total,(long)totalPages,goodsList,categories,brands,specs); &#125; /** * 抽取基本搜索函数 * @param request * @return */ private QueryBuilder buildBasicQuery(SearchRequest request) &#123; //创建布尔查询 BoolQueryBuilder queryBuilder = QueryBuilders.boolQuery(); //查询条件 queryBuilder.must(QueryBuilders.matchQuery("all",request.getKey())); //过滤条件 Map&lt;String, String&gt; map = request.getFilter(); //map.entrySet().for for (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123; //字段名 String key = entry.getKey(); if (!"cid3".equals(key)&amp;&amp;!"brandId".equals(key))&#123; key="specs."+key+".keyword"; &#125; String value = entry.getValue(); queryBuilder.filter(QueryBuilders.termQuery(key,value)); &#125; return queryBuilder; &#125;/** * 聚合规格参数 * @param cid * @param basicQuery * @return */ private List&lt;Map&lt;String,Object&gt;&gt; buildSpecificationAgg(Long cid, QueryBuilder basicQuery) &#123; List&lt;Map&lt;String, Object&gt;&gt; specs = new ArrayList&lt;&gt;(); //1 查询需要聚合的规格参数 List&lt;SpecParam&gt; params = specificationClient.queryParamByList(null, cid, true, null); //2 聚合 //2.1 创建构建器 NativeSearchQueryBuilder queryBuilder = new NativeSearchQueryBuilder(); queryBuilder.withQuery(basicQuery); for (SpecParam param : params) &#123; String name = param.getName(); //聚合 queryBuilder.addAggregation(AggregationBuilders.terms(name).field("specs."+name+".keyword")); &#125; //3 获取结果 AggregatedPage&lt;Goods&gt; result = this.elasticsearchTemplate.queryForPage(queryBuilder.build(), Goods.class); //4 解析结果 Aggregations aggs = result.getAggregations(); for (SpecParam param : params) &#123; //规格参数名称 String name = param.getName(); //聚合结果 StringTerms terms = aggs.get(name); List&lt;String&gt; options = terms.getBuckets().stream().map(b -&gt; b.getKeyAsString()).collect(Collectors.toList()); //准备map Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put("k",name); map.put("options",options); specs.add(map); &#125; return specs; &#125; 3.3.7.测试结果 3.4.页面渲染3.4.1.渲染规格过滤条件首先把后台传递过来的specs添加到filters数组： 要注意：分类、品牌的option选项是对象，里面有name属性，而specs中的option是简单的字符串，所以需要进行封装，变为相同的结构： 最后的结果： 3.4.2.展示或收起过滤条件是不是感觉显示的太多了，我们可以通过按钮点击来展开和隐藏部分内容： 我们在data中定义变量，记录展开或隐藏的状态： 然后在按钮绑定点击事件，以改变show的取值： 在展示规格时，对show进行判断： OK！ 4.过滤条件的筛选当我们点击页面的过滤项，要做哪些事情？ 把过滤条件保存在search对象中（watch监控到search变化后就会发送到后台） 在页面顶部展示已选择的过滤项 把商品分类展示到顶部面包屑 4.1.保存过滤项4.1.1.定义属性我们把已选择的过滤项保存在search中： 要注意，在created构造函数中会对search进行初始化，所以要在构造函数中对filter进行初始化： search.filter是一个对象，结构： 123&#123; "过滤项名":"过滤项值"&#125; 4.1.2.绑定点击事件给所有的过滤项绑定点击事件： 要注意，点击事件传2个参数： k：过滤项的key option：当前过滤项对象 修改search.html下methods方法在点击事件中，保存过滤项到selectedFilter： 123456selectFilter(key, option)&#123; //将filter的属性复制到obj中 const &#123;... obj&#125;=this.search.filter; obj[key]=option; this.search.filter=obj;&#125;, 另外，这里search对象中嵌套了filter对象，请求参数格式化时需要进行特殊处理，修改common.js中的一段代码： 我们刷新页面，点击后通过浏览器功能查看search.filter的属性变化： 并且，此时浏览器地址也发生了变化： 1http://www.leyou.com/search.html?key=%E6%89%8B%E6%9C%BA&amp;page=1&amp;filter.%E5%93%81%E7%89%8C=2032&amp;filter.CPU%E5%93%81%E7%89%8C=%E6%B5%B7%E6%80%9D%EF%BC%88Hisilicon%EF%BC%89&amp;filter.CPU%E6%A0%B8%E6%95%B0=%E5%8D%81%E6%A0%B8 网络请求也正常发出： 4.2.后台添加过滤条件既然请求已经发送到了后台，那接下来我们就在后台去添加这些条件： 4.2.1.拓展请求对象我们需要在请求类：SearchRequest中添加属性，接收过滤属性。过滤属性都是键值对格式，但是key不确定，所以用一个map来接收即可。 4.2.2.添加过滤条件目前，我们的基本查询是这样的： 现在，我们要把页面传递的过滤条件也进入进去。 因此不能在使用普通的查询，而是要用到BooleanQuery，基本结构是这样的： 1234567891011GET /heima/_search&#123; "query":&#123; "bool":&#123; "must":&#123; "match": &#123; "title": "小米手机",operator:"and"&#125;&#125;, "filter":&#123; "range":&#123;"price":&#123;"gt":2000.00,"lt":3800.00&#125;&#125; &#125; &#125; &#125;&#125; 所以，我们对原来的基本查询进行改造： 因为比较复杂，我们将其封装到一个方法中： 1234567891011121314151617181920212223242526/** * 抽取基本搜索函数 * @param request * @return */private QueryBuilder buildBasicQuery(SearchRequest request) &#123; //创建布尔查询 BoolQueryBuilder queryBuilder = QueryBuilders.boolQuery(); //查询条件 queryBuilder.must(QueryBuilders.matchQuery("all",request.getKey())); //过滤条件 Map&lt;String, String&gt; map = request.getFilter(); //map.entrySet().for for (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123; //字段名 String key = entry.getKey(); if (!"cid3".equals(key)&amp;&amp;!"brandId".equals(key))&#123; key="specs."+key+".keyword"; &#125; String value = entry.getValue(); queryBuilder.filter(QueryBuilders.termQuery(key,value)); &#125; return queryBuilder;&#125; 其它不变。 4.3.页面测试我们先不点击过滤条件，直接搜索手机： 总共184条 接下来，我们点击一个过滤条件： 得到的结果： 5.页面展示选择的过滤项(作业)5.1.商品分类面包屑当用户选择一个商品分类以后，我们应该在过滤模块的上方展示一个面包屑，把三级商品分类都显示出来。 用户选择的商品分类就存放在search.filter中，但是里面只有第三级分类的id：cid3 我们需要根据它查询出所有三级分类的id及名称 5.1.1.提供查询分类接口我们在商品微服务中提供一个根据三级分类id查询1~3级分类集合的方法： Controller 12345678910111213/** * 根据3级分类id，查询1~3级的分类 * @param id * @return */@GetMapping("all/level")public ResponseEntity&lt;List&lt;Category&gt;&gt; queryAllByCid3(@RequestParam("id") Long id)&#123; List&lt;Category&gt; list = this.categoryService.queryAllByCid3(id); if (list == null || list.size() &lt; 1) &#123; return new ResponseEntity&lt;&gt;(HttpStatus.NOT_FOUND); &#125; return ResponseEntity.ok(list);&#125; Service 123456public List&lt;Category&gt; queryAllByCid3(Long id) &#123; Category c3 = this.categoryMapper.selectByPrimaryKey(id); Category c2 = this.categoryMapper.selectByPrimaryKey(c3.getParentId()); Category c1 = this.categoryMapper.selectByPrimaryKey(c2.getParentId()); return Arrays.asList(c1,c2,c3);&#125; 测试： 5.1.2.页面展示面包屑后台提供了接口，下面的问题是，我们在哪里去查询接口？ 大家首先想到的肯定是当用户点击以后。 但是我们思考一下：用户点击以后，就会重新发起请求，页面刷新，那么你渲染的结果就没了。 因此，应该是在页面重新加载完毕后，此时因为过滤条件中加入了商品分类的条件，所以查询的结果中只有1个分类。 我们判断商品分类是否只有1个，如果是，则查询三级商品分类，添加到面包屑即可。 渲染： 刷新页面： 5.2.其它过滤项接下来，我们需要在页面展示用户已选择的过滤项，如图： 我们知道，所有已选择过滤项都保存在search.filter中，因此在页面遍历并展示即可。 但这里有个问题，filter中数据的格式： 基本有四类数据： 商品分类：这个不需要展示，分类展示在面包屑位置 品牌：这个要展示，但是其key和值不合适，我们不能显示一个id在页面。需要找到其name值 数值类型规格：这个展示的时候，需要把单位查询出来 非数值类型规格：这个直接展示其值即可 因此，我们在页面上这样处理： 1234567&lt;!--已选择过滤项--&gt;&lt;ul class="tags-choose"&gt; &lt;li class="tag" v-for="(v,k) in search.filter" v-if="k !== 'cid3'" :key="k"&gt; &#123;&#123;k === 'brandId' ? '品牌' : k&#125;&#125;:&lt;span style="color: red"&gt;&#123;&#123;getFilterValue(k,v)&#125;&#125;&lt;/span&gt;&lt;/span&gt;&lt;i class="sui-icon icon-tb-close"&gt;&lt;/i&gt;&lt;/li&gt;&lt;/ul&gt; 判断如果 k === &#39;cid3&#39;说明是商品分类，直接忽略 判断k === &#39;brandId&#39;说明是品牌，页面显示品牌，其它规格则直接显示k的值 值的处理比较复杂，我们用一个方法getFilterValue(k,v)来处理，调用时把k和v都传递 方法内部： 12345678910111213getFilterValue(k,v)&#123; // 如果没有过滤参数，我们跳过展示 if(!this.filters || this.filters.length === 0)&#123; return null; &#125; let filter = null; // 判断是否是品牌 if(k === 'brandId')&#123; // 返回品牌名称 return this.filters.find(f =&gt; f.k === 'brandId').options[0].name; &#125; return v;&#125; 然后刷新页面，即可看到效果： 5.3.隐藏已经选择的过滤项现在，我们已经实现了已选择过滤项的展示，但是你会发现一个问题： 已经选择的过滤项，在过滤列表中依然存在： 这些已经选择的过滤项，应该从列表中移除。 怎么做呢？ 你必须先知道用户选择了什么。用户选择的项保存在search.filter中： 我们可以编写一个计算属性，把filters中的 已经被选择的key过滤掉： 123456789101112computed:&#123; remainFilters()&#123; const keys = Object.keys(this.search.filter); if(this.search.filter.cid3)&#123; keys.push("cid3") &#125; if(this.search.filter.brandId)&#123; keys.push("brandId") &#125; return this.filters.filter(f =&gt; !keys.includes(f.k)); &#125;&#125; 然后页面不再直接遍历filters，而是遍历remainFilters 刷新页面： 最后发现，还剩下一堆没选过的。但是都只有一个可选项，此时再过滤没有任何意义，应该隐藏，所以，在刚才的过滤条件中，还应该添加一条：如果只剩下一个可选项，不显示 6.取消过滤项（作业）我们能够看到，每个过滤项后面都有一个小叉，当点击后，应该取消对应条件的过滤。 思路非常简单： 给小叉绑定点击事件 点击后把过滤项从search.filter中移除，页面会自动刷新，OK 绑定点击事件： 绑定点击事件时，把k传递过去，方便删除 删除过滤项 123456deleteFilter(k)&#123; //将filter的属性复制到obj中 const &#123;... obj&#125;=this.search.filter; delete obj[k]; this.search.filter=obj; &#125; 7.优化搜索系统需要优化的点： 查询规格参数部分可以添加缓存 聚合计算interval变化频率极低，所以可以设计为定时任务计算（周期为天），然后缓存起来。 elasticsearch本身有查询缓存，可以不进行优化 商品图片应该采用缩略图，减少流量，提高页面加载速度 图片采用延迟加载 图片还可以采用CDN服务器 sku信息应该在页面异步加载，而不是放到索引库]]></content>
      <categories>
        <category>项目实战-微服务商城</category>
        <category>Elasticsearch</category>
      </categories>
      <tags>
        <tag>Elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务商城（十一）——Elasticsearch安装及介绍二]]></title>
    <url>%2Fday11-elasticsearch2.html</url>
    <content type="text"><![CDATA[0.学习目标 独立编写数据导入功能 独立实现基本搜索 独立实现页面分页 独立实现结果排序 1.索引库数据导入昨天我们学习了Elasticsearch的基本应用。今天就学以致用，搭建搜索微服务，实现搜索功能。 1.1.创建搜索服务创建module： Pom文件： 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;leyou&lt;/artifactId&gt; &lt;groupId&gt;com.leyou.parent&lt;/groupId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.search&lt;/groupId&gt; &lt;artifactId&gt;leyou-search&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;!-- web --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- elasticsearch --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-elasticsearch&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- eureka --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- feign --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.leyou.service&lt;/groupId&gt; &lt;artifactId&gt;ly-item-interface&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; application.yml： 1234567891011121314151617181920server: port: 8083spring: application: name: search-service data: elasticsearch: cluster-name: elasticsearch cluster-nodes: 192.168.25.128:9300eureka: client: service-url: defaultZone: http://127.0.0.1:10086/eureka registry-fetch-interval-seconds: 5 #拉取5秒 instance: lease-renewal-interval-in-seconds: 5 # 每隔5秒发送一次心跳 lease-expiration-duration-in-seconds: 10 # 10秒不发送就过期 prefer-ip-address: true ip-address: 127.0.0.1 instance-id: $&#123;spring.application.name&#125;:$&#123;server.port&#125; 启动类： 123456789@SpringBootApplication@EnableDiscoveryClient@EnableFeignClientspublic class LySearchService &#123; public static void main(String[] args) &#123; SpringApplication.run(LySearchService.class, args); &#125;&#125; 1.2.索引库数据格式分析接下来，我们需要商品数据导入索引库，便于用户搜索。 那么问题来了，我们有SPU和SKU，到底如何保存到索引库？ 1.2.1.以结果为导向大家来看下搜索结果页： 可以看到，每一个搜索结果都有至少1个商品，当我们选择大图下方的小图，商品会跟着变化。 因此，搜索的结果是SPU，即多个SKU的集合。 既然搜索的结果是SPU，那么我们索引库中存储的应该也是SPU，但是却需要包含SKU的信息。 1.2.2.需要什么数据再来看看页面中有什么数据： 直观能看到的：图片、价格、标题、副标题属于sku的数据（用来展示的数据） 暗藏的数据：spu的id，sku的id 另外，页面还有过滤条件： 这些过滤条件也都需要存储到索引库中，包括： 商品分类、品牌、可用来搜索的规格参数等 综上所述，我们需要的数据格式有： spuId、SkuId、商品分类id、品牌id、图片、价格、商品的创建时间、sku信息集、可搜索的规格参数 1.2.3.最终的数据结构我们创建一个类，封装要保存到索引库的数据，并设置映射属性： 123456789101112131415161718@Document(indexName = "goods", type = "docs", shards = 1, replicas = 0)public class Goods &#123; @Id private Long id; // spuId @Field(type = FieldType.Text, analyzer = "ik_max_word") private String all; // 所有需要被搜索的信息，包含标题，分类，甚至品牌 @Field(type = FieldType.keyword, index = false) private String subTitle;// 卖点 private Long brandId;// 品牌id private Long cid1;// 1级分类id private Long cid2;// 2级分类id private Long cid3;// 3级分类id private Date createTime;// 创建时间 private List&lt;Long&gt; price;// 价格 @Field(type = FieldType.keyword, index = false) private String skus;// sku信息的json结构 private Map&lt;String, Object&gt; specs;// 可搜索的规格参数，key是参数名，值是参数值&#125; 一些特殊字段解释： all：用来进行全文检索的字段，里面包含标题、商品分类信息 price：价格数组，是所有sku的价格集合。方便根据价格进行筛选过滤 skus：用于页面展示的sku信息，不索引，不搜索。包含skuId、image、price、title字段 specs：所有规格参数的集合。key是参数名，值是参数值。 例如：我们在specs中存储 内存：4G,6G，颜色为红色，转为json就是： 123456&#123; "specs":&#123; "内存":[4G,6G], "颜色":"红色" &#125;&#125; 当存储到索引库时，elasticsearch会处理为两个字段： specs.内存：[4G,6G] specs.颜色：红色 另外， 对于字符串类型，还会额外存储一个字段，这个字段不会分词，用作聚合。 specs.颜色.keyword：红色 1.3.商品微服务提供接口索引库中的数据来自于数据库，我们不能直接去查询商品的数据库，因为真实开发中，每个微服务都是相互独立的，包括数据库也是一样。所以我们只能调用商品微服务提供的接口服务。 先思考我们需要的数据： SPU信息 SKU信息 SPU的详情 商品分类名称（拼接all字段） 规格参数key 品牌 再思考我们需要哪些服务： 第一：分批查询spu的服务，已经写过。 第二：根据spuId查询sku的服务，已经写过 第三：根据spuId查询SpuDetail的服务，已经写过 第四：根据商品分类id，查询商品分类名称，没写过 第五：根据商品品牌id，查询商品的品牌，没写过 因此我们需要额外提供一个查询商品分类名称的接口。 1.3.1.商品分类，品牌查询 商品分类查询 CategoryController： 123456789/** * 根据ids集合查询商品分类 * @param ids * @return */@GetMapping("list/ids")public ResponseEntity&lt;List&lt;Category&gt;&gt; queryCategoryByIds(@RequestParam("ids")List&lt;Long&gt; ids)&#123; return ResponseEntity.ok(categoryService.queryByIds(ids));&#125; CategoryService 123456789101112/** * 根据ids集合查询商品分类 * @param ids * @return */public List&lt;Category&gt; queryByIds(List&lt;Long&gt; ids)&#123; List&lt;Category&gt; list = categoryMapper.selectByIdList(ids); if (CollectionUtils.isEmpty(list))&#123; throw new LyException(ExceptionEnums.CATEGORY_NOT_FOND); &#125; return list;&#125; 测试： 品牌查询 BrandController： 123456789/** * 根据id查询品牌 * @param id * @return */ @GetMapping("&#123;id&#125;")public ResponseEntity&lt;Brand&gt; queryBrandById(@PathVariable("id")Long id)&#123; return ResponseEntity.ok(brandService.queryById(id)); &#125; BrandService 123456789101112/** * 根据id查询品牌 * @param id * @return */public Brand queryById(Long id)&#123; Brand brand = brandMapper.selectByPrimaryKey(id); if (brand==null)&#123; throw new LyException(ExceptionEnums.BRAND_NOT_FOUND); &#125; return brand;&#125; 测试： 1.3.2.编写FeignClient（远程调用别的服务）1.3.2.1.普通问题展现操作leyou-search工程 现在，我们要在搜索微服务调用商品微服务的接口。 第一步要引入商品微服务依赖：ly-item-interface。 123456&lt;!--商品微服务--&gt;&lt;dependency&gt; &lt;groupId&gt;com.leyou.service&lt;/groupId&gt; &lt;artifactId&gt;ly-item-interface&lt;/artifactId&gt; &lt;version&gt;$&#123;leyou.latest.version&#125;&lt;/version&gt;&lt;/dependency&gt; 第二步，编写GoodsFeignClient 1234567891011121314151617181920212223242526272829303132333435@FeignClient("item-service")public interface GoodsClient &#123; /** * 根据spuid查询商品详情 * @param spuId * @return */ @GetMapping("spu/detail/&#123;id&#125;") public SpuDetail queryDetailBySpuId(@PathVariable("id")Long spuId); /** * 根据spuid查询sku * @param spuId * @return */ @GetMapping("sku/list") public List&lt;Sku&gt; querySkuByid(@RequestParam("id")Long spuId); /** * 分页查询商品信息 * @param page * @param rows * @param saleable * @param key * @return */ @GetMapping("spu/page") @ResponseBody public PageResult&lt;Spu&gt; querySpuByPage( @RequestParam(value = "page", defaultValue = "1") Integer page, @RequestParam(value = "rows", defaultValue = "5") Integer rows, @RequestParam(value = "saleable", required = false) Boolean saleable, @RequestParam(value = "key", required = false) String key);&#125; 第三步，编写CategoryFeignClient 123456789101112@FeignClient("item-service")public interface CategoryClient &#123; /** * 根据ids集合查询商品分类 * 不写实现直接写接口 * @param ids * @return */ @GetMapping("category/list/ids") List&lt;Category&gt; queryCategoryByIds(@RequestParam("ids")List&lt;Long&gt; ids);&#125; 以上的这些代码直接从商品微服务中拷贝而来，完全一致。差别就是没有方法的具体实现。大家觉得这样有没有问题？ 而FeignClient代码遵循SpringMVC的风格，因此与商品微服务的Controller完全一致。这样就存在一定的问题： 代码冗余。尽管不用写实现，只是写接口，但服务调用方要写与服务controller一致的代码，有几个消费者就要写几次。 增加开发成本。调用方还得清楚知道接口的路径，才能编写正确的FeignClient。 1.3.2.2.（优化）解决方案因此，一种比较友好的实践是这样的： 我们的服务提供方不仅提供实体类，还要提供api接口声明 调用方不用字自己编写接口方法声明，直接继承提供方给的Api接口即可， 第一步：服务的提供方在ly-item-interface中提供API接口，并编写接口声明： 商品分类服务接口：CategoryAPI 12345678910public interface CategoryAPI &#123; /** * 根据ids集合查询商品分类 * 不写实现直接写接口 * @param ids * @return */ @GetMapping("category/list/ids") List&lt;Category&gt; queryCategoryByIds(@RequestParam("ids")List&lt;Long&gt; ids);&#125; 商品服务接口：GoodsAPI 12345678910111213141516171819202122232425262728293031323334public interface GoodsAPI &#123; /** * 根据spuid查询商品详情 * @param spuId * @return */ @GetMapping("spu/detail/&#123;id&#125;") public SpuDetail queryDetailBySpuId(@PathVariable("id")Long spuId); /** * 根据spuid查询sku * @param spuId * @return */ @GetMapping("sku/list") public List&lt;Sku&gt; querySkuByid(@RequestParam("id")Long spuId); /** * 分页查询商品信息 * @param page * @param rows * @param saleable * @param key * @return */ @GetMapping("spu/page") @ResponseBody public PageResult&lt;Spu&gt; querySpuByPage( @RequestParam(value = "page", defaultValue = "1") Integer page, @RequestParam(value = "rows", defaultValue = "5") Integer rows, @RequestParam(value = "saleable", required = false) Boolean saleable, @RequestParam(value = "key", required = false) String key);&#125; 品牌服务接口：BrandAPI 123456789public interface BrandAPI &#123; /** * 根据id查询品牌 * @param id * @return */ @GetMapping("brand/&#123;id&#125;") public Brand queryBrandById(@PathVariable("id")Long id);&#125; 商品详情接口：SpecificationAPI 12345678910111213141516171819public interface SpecificationAPI &#123; /** * 通过规格组的gid查询规格参数 * 通过商品分类cid查询规格参数 * required=false：表示不传值的时候给null * @param gid 规格组id * @param cid 商品分类id * @param searching 是否用于搜索关键字 * @param generic 是否是sku通用属性 * @return */ @GetMapping("spec/params") List&lt;SpecParam&gt; queryParamByList( @RequestParam(value = "gid",required = false) Long gid, @RequestParam(value = "cid",required = false)Long cid, @RequestParam(value = "searching",required = false)Boolean searching, @RequestParam(value="generic", required = false) Boolean generic );&#125; 需要引入springMVC及ly-common的依赖： 123456789101112131415161718192021222324252627&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper-core&lt;/artifactId&gt; &lt;version&gt;1.0.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.7&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;5.1.0.RC3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;5.1.0.RC3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.leyou.common&lt;/groupId&gt; &lt;artifactId&gt;ly-common&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 第二步：在调用方ly-search中编写FeignClient，但不要写方法声明了，直接继承ly-item-interface提供的api接口： 商品的FeignClient：GoodsClient 123@FeignClient(value = "item-service")public interface GoodsClient extends GoodsApi &#123;&#125; 商品分类的FeignClient：CategoryClient 123@FeignClient(value = "item-service")public interface CategoryClient extends CategoryApi &#123;&#125; 品牌的FeignClient：BrandClient 1234@FeignClient("item-service")public interface BrandClient extends BrandAPI&#123;&#125; 商品详情FeignClient：SpecificationClient 1234@FeignClient(&quot;item-service&quot;)public interface SpecificationClient extends SpecificationAPI&#123;&#125; 是不是简单多了？ 项目结构： 1.3.2.3.测试在leyou-search中引入springtest依赖： 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 创建测试类： 在接口上按快捷键：Ctrl + Shift + T 测试代码： 12345678910111213@RunWith(SpringRunner.class)@SpringBootTest(classes = LeyouSearchApplication.class)public class CategoryClientTest &#123; @Autowired private CategoryClient categoryClient; @Test public void testQueryCategories() &#123; List&lt;String&gt; names = this.categoryClient.queryNameByIds(Arrays.asList(1L, 2L, 3L)); names.forEach(System.out::println); &#125;&#125; 结果： 1.4.导入数据导入数据只做一次,以后的更新删除等操作通过消息队列来操作索引库 1.4.1.创建GoodsRepository在ly-search中创建 java代码： 12public interface GoodsRepository extends ElasticsearchRepository&lt;Goods, Long&gt; &#123;&#125; 1.4.2.创建索引我们新建一个测试类，在里面进行数据的操作： 1234567891011121314@RunWith(SpringRunner.class)@SpringBootTestpublic class GoodsRepositoryTest &#123; @Autowired private GoodsRepository goodsRepository; @Autowired private ElasticsearchTemplate elasticsearchTemplate; @Test public void testCreateIndex()&#123; elasticsearchTemplate.createIndex(Goods.class); elasticsearchTemplate.putMapping(Goods.class); &#125;&#125; 通过kibana查看： 1.4.3.导入数据导入数据其实就是查询数据，然后把查询到的Spu转变为Goods来保存，因此我们先编写一个SearchService，然后在里面定义一个方法， 把Spu转为Goods 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798/** * @version V1.0 * @ClassName:$&#123;file_name&#125; * @Description:把查询到的Spu转变为Goods来保存 * @author:cxg * @Date:$&#123;time&#125; */@Servicepublic class SearchService &#123; @Autowired private GoodsClient goodsClient; @Autowired private SpecificationClient specificationClient; @Autowired private CategoryClient categoryClient; @Autowired private BrandClient brandClient; public Goods buildGoods(Spu spu) &#123; //1.查询分类 List&lt;Category&gt; categories = categoryClient.queryCategoryByIds(Arrays.asList(spu.getCid1(), spu.getCid2(), spu.getCid3())); //1.1.获取到分类的名字(查询集合的时候这样用) List&lt;String&gt; categoryName = categories.stream().map(Category::getName).collect(Collectors.toList()); //2.查询品牌 Brand brand = brandClient.queryBrandById(spu.getBrandId()); //3.搜索字段 String all = spu.getTitle()+ StringUtils.join(categoryName," ")+brand.getName(); //4.查询sku List&lt;Sku&gt; skuList = goodsClient.querySkuByid(spu.getId()); //4.1.处理sku List&lt;Map&lt;String, Object&gt;&gt; skus = new ArrayList&lt;&gt;(); //4.2.处理价格 List&lt;Long&gt; priceList=new ArrayList&lt;&gt;(); for (Sku sku : skuList) &#123; Map&lt;String,Object&gt; map=new HashMap&lt;&gt;(); map.put("id",sku.getId()); map.put("title",sku.getTitle()); map.put("price",sku.getPrice()); map.put("images",StringUtils.substringBefore(sku.getImages(),","));//截取逗号之前的第一个 skus.add(map); priceList.add(sku.getPrice()); &#125; //5.商品规格 //5.1.查询规格参数 List&lt;SpecParam&gt; params = specificationClient.queryParamByList(null, spu.getCid3(), true, null); //6.商品详情 SpuDetail spuDetail = goodsClient.queryDetailBySpuId(spu.getId()); //6.1.获取通用规格参数（参数类型为：Map&lt;String, String&gt;） String jsonGeneric = spuDetail.getGenericSpec(); Map&lt;Long, String&gt; genericSpec = JsonUtils.toMap(jsonGeneric, Long.class, String.class); //6.2.获取特有规格参数 (参数类型为： Map&lt;String, List&lt;String&gt;&gt;这种类型) String jsonSpecial=spuDetail.getSpecialSpec(); Map&lt;Long, List&lt;String&gt;&gt; specialSpec = JsonUtils.nativeRead(jsonSpecial, new TypeReference&lt;Map&lt;Long, List&lt;String&gt;&gt;&gt;() &#123; &#125;); //6.3.规格参数，key是规格参数的名字，值是规格参数的值 Map&lt;String,Object&gt; specs=new HashMap&lt;&gt;(); for (SpecParam param : params) &#123; //规格名称 String key = param.getName(); Object value=""; //判断是否通用规格参数 if(param.getGeneric())&#123; value=genericSpec.get(param.getId()); if (param.getNumeric())&#123; //调用chooseSegment方法 value=chooseSegment(value.toString(),param); &#125; &#125; else &#123; value=specialSpec.get(param.getId()); &#125; //存入Map中 specs.put(key,value); &#125; Goods goods = new Goods(); goods.setId(spu.getId()); goods.setSubTitle(spu.getSubTitle()); goods.setBrandId(spu.getBrandId()); goods.setCid1(spu.getCid1()); goods.setCid2(spu.getCid2()); goods.setCid3(spu.getCid3()); goods.setCreateTime(spu.getCreateTime()); goods.setAll(all); // TODO 搜索字段，包含标题，分类，品牌 ，规格 goods.setPrice(priceList); // TODO 所有sku的价格集合 goods.setSkus(JsonUtils.toString(skus)); //TODO 所有sku的集合的json goods.setSpecs(specs); //TODO 所有的可搜索的规格参数 return goods; &#125; &#125; 因为过滤参数中有一类比较特殊，就是数值区间： 所以我们在存入时要进行处理： 123456789101112131415161718192021222324252627282930313233 /** * 将下面进行分段 * 0-500,500-1000,1000-1500,1500-2000,2500- * @param value * @param p * @return */private String chooseSegment(String value, SpecParam p) &#123; double val = NumberUtils.toDouble(value); String result = "其它"; // 保存数值段 for (String segment : p.getSegments().split(",")) &#123; String[] segs = segment.split("-"); // 获取数值范围 double begin = NumberUtils.toDouble(segs[0]); double end = Double.MAX_VALUE; if(segs.length == 2)&#123; end = NumberUtils.toDouble(segs[1]); &#125; // 判断是否在范围内 if(val &gt;= begin &amp;&amp; val &lt; end)&#123; if(segs.length == 1)&#123; result = segs[0] + p.getUnit() + "以上"; &#125;else if(begin == 0)&#123; result = segs[1] + p.getUnit() + "以下"; &#125;else&#123; result = segment + p.getUnit(); &#125; break; &#125; &#125; return result;&#125; 然后编写一个测试类，循环查询Spu，然后调用IndexService中的方法，把SPU变为Goods，然后写入索引库： 123456789101112131415161718192021222324252627282930@Testpublic void loadData()&#123; // 创建索引 this.elasticsearchTemplate.createIndex(Goods.class); // 配置映射 this.elasticsearchTemplate.putMapping(Goods.class); int page = 1; int rows = 100; int size = 0; do &#123; // 查询分页数据 PageResult&lt;SpuBo&gt; result = this.goodsClient.querySpuByPage(page, rows, true, null); List&lt;SpuBo&gt; spus = result.getItems(); size = spus.size(); // 创建Goods集合 List&lt;Goods&gt; goodsList = new ArrayList&lt;&gt;(); // 遍历spu for (SpuBo spu : spus) &#123; try &#123; Goods goods = this.searchService.buildGoods(spu); goodsList.add(goods); &#125; catch (Exception e) &#123; break; &#125; &#125; this.goodsRepository.saveAll(goodsList); page++; &#125; while (size == 100);&#125; 通过kibana查询， 可以看到数据成功导入： 2.实现基本搜索2.1.页面分析2.1.1.页面跳转在首页的顶部，有一个输入框： 当我们输入任何文本，点击搜索，就会跳转到搜索页search.html了： 并且将搜索关键字以请求参数携带过来： 我们打开search.html，在最下面会有提前定义好的Vue实例： 1234567891011&lt;script type="text/javascript"&gt; var vm = new Vue(&#123; el: "#searchApp", data: &#123; &#125;, components:&#123; // 加载页面顶部组件 lyTop: () =&gt; import("./js/pages/top.js") &#125; &#125;);&lt;/script&gt; 这个Vue实例中，通过import导入的方式，加载了另外一个js：top.js并作为一个局部组件。top其实是页面顶部导航组件，我们暂时不管 2.1.2.发起异步请求要想在页面加载后，就展示出搜索结果。我们应该在页面加载时，获取地址栏请求参数，并发起异步请求，查询后台数据，然后在页面渲染。 我们在data中定义一个对象，记录请求的参数： 12345data: &#123; search:&#123; key:"", // 搜索页面的关键字 &#125;&#125; 我们通过钩子函数created，在页面加载时获取请求参数，并记录下来。 12345678910111213created()&#123; // 判断是否有请求参数 if(!location.search)&#123; return; &#125; // 将请求参数转为对象 const search = ly.parse(location.search.substring(1)); // 记录在data的search对象中 this.search = search; // 发起请求，根据条件搜索 this.loadData();&#125; 然后发起请求，搜索数据。 12345678methods: &#123; loadData()&#123; // ly.http.post("/search/page", ly.stringify(this.search)).then(resp=&gt;&#123; ly.http.post("/search/page", this.search).then(resp=&gt;&#123; console.log(resp); &#125;); &#125;&#125; 我们这里使用ly是common.js中定义的工具对象。 这里使用的是post请求，这样可以携带更多参数，并且以json格式发送 在leyou-gateway中，添加允许信任域名： 并添加网关映射： 刷新页面试试： 因为后台没有提供接口，所以无法访问。没关系，接下来我们实现后台接口 2.2.后台提供搜索接口2.2.1.controller首先分析几个问题： 请求方式：Post 请求路径：/search/page，不过前面的/search应该是网关的映射路径，因此真实映射路径page，代表分页查询 请求参数：json格式，目前只有一个属性：key-搜索关键字，但是搜索结果页一定是带有分页查询的，所以将来肯定会有page属性，因此我们可以用一个对象来接收请求的json数据： 1234567891011121314151617181920212223242526272829303132public class SearchRequest &#123; private String key;// 搜索条件 private Integer page;// 当前页 private static final Integer DEFAULT_SIZE = 20;// 每页大小，不从页面接收，而是固定大小 private static final Integer DEFAULT_PAGE = 1;// 默认页 public String getKey() &#123; return key; &#125; public void setKey(String key) &#123; this.key = key; &#125; public Integer getPage() &#123; if(page == null)&#123; return DEFAULT_PAGE; &#125; // 获取页码时做一些校验，不能小于1 return Math.max(DEFAULT_PAGE, page); &#125; public void setPage(Integer page) &#123; this.page = page; &#125; public Integer getSize() &#123; return DEFAULT_SIZE; &#125;&#125; 返回结果：作为分页结果，一般都两个属性：当前页数据、总条数信息，我们可以使用之前定义的PageResult类 代码： 12345678@RestControllerpublic class SearchController &#123; @Autowired private SearchService searchService; @PostMapping("page") public ResponseEntity&lt;PageResult&lt;Goods&gt;&gt; search(@RequestBody SearchRequest request) &#123; return ResponseEntity.ok(searchService.search(request)); &#125; 2.2.2.service123456789101112131415161718192021222324252627282930public PageResult&lt;Goods&gt; search(SearchRequest request) &#123; int page=request.getPage()-1; int size = request.getSize(); //创建查询构建器 NativeSearchQueryBuilder queryBuilder = new NativeSearchQueryBuilder(); //结果过滤 queryBuilder.withSourceFilter(new FetchSourceFilter(new String[]&#123;"id","skus","subTitle"&#125;,null)); //分页 queryBuilder.withPageable(PageRequest.of(page,size)); //排序 String sortBy=request.getSortBy(); Boolean desc = request.getDescending(); if (StringUtils.isNotBlank(sortBy))&#123; queryBuilder.withSort(SortBuilders.fieldSort(sortBy).order(desc ? SortOrder.DESC : SortOrder.ASC)); &#125; //过滤 queryBuilder.withQuery(QueryBuilders.matchQuery("all",request.getKey())); //查询 Page&lt;Goods&gt; search = goodsRepository.search(queryBuilder.build()); //解析结果 long total = search.getTotalElements();//总条数 long totalPages =(total/size)+1;//总页数 List&lt;Goods&gt; goodsList = search.getContent();//当前页结果 return new PageResult&lt;&gt;(total,(long)totalPages,goodsList); &#125; 注意点：我们要设置SourceFilter，来选择要返回的结果，否则返回一堆没用的数据，影响查询效率。 2.2.3.测试刷新页面测试： 数据是查到了，但是因为我们只查询部分字段，所以结果json 数据中有很多null，这很不优雅。 解决办法很简单，在leyou-search的application.yml中添加一行配置，json处理时忽略空值： 123spring: jackson: default-property-inclusion: non_null # 配置json处理时忽略空值 结果： 2.3.页面渲染页面已经拿到了结果，接下来就要渲染样式了。在leyou-portal中的search.html中 2.3.1.保存搜索结果首先，在data中定义属性，保存搜索的结果： 在loadData的异步查询中，将结果赋值给goodsList： 2.3.2.循环展示商品在search.html的中部，有一个div，用来展示所有搜索到的商品： 可以看到，div中有一个无序列表ul，内部的每一个li就是一个商品spu了。 我们删除多余的，只保留一个li，然后利用vue的循环来展示搜索到的结果： 2.3.3.多sku展示2.3.3.1.分析接下来展示具体的商品信息，来看图： 这里我们可以发现，一个商品位置，是多个sku的信息集合。当用户鼠标选择某个sku，对应的图片、价格、标题会随之改变！ 我们先来实现sku的选择，才能去展示不同sku的数据。 可以看到，在列表中默认第一个是被选中的，那我们就需要做两件事情： 在搜索到数据时，先默认把第一个sku作为被选中的，记录下来 记录当前被选中的是哪一个sku，记录在哪里比较合适呢？显然是遍历到的goods对象自己内部，因为每一个goods都会有自己的sku信息。 2.3.3.2.初始化sku查询出的结果集skus是一个json类型的字符串，不是js对象 我们在查询成功的回调函数中，对goods进行遍历，把skus转化成对象，并添加一个selected属性保存被选中的sku： 2.3.3.3.多sku图片列表接下来，我们看看多个sku的图片列表位置： 看到又是一个无序列表，这里我们也一样删掉多余的，保留一个li，需要注意选中的项有一个样式类：selected 我们的代码： 12345678910&lt;!--展示图片有bug，什么时候出现bug？当一个sku有多个图片时--&gt;&lt;!--实际后台传的是images--&gt;&lt;img :src=&quot;goods.selected.images&quot; height=&quot;200&quot;/&gt;&lt;/a&gt;&lt;!--多sku图片列表--&gt;&lt;ul class=&quot;skus&quot;&gt; &lt;li :class=&quot;&#123;selected: sku.id == goods.selected.id&#125;&quot; v-for=&quot;sku in goods.skus&quot; :key=&quot;sku.id&quot; @mouseEnter=&quot;goods.selected=sku&quot;&gt; &lt;img :src=&quot;sku.images&quot;&gt; &lt;/li&gt;&lt;/ul&gt; 注意： class样式通过 goods.selected的id是否与当前sku的id一致来判断 绑定了鼠标事件，鼠标进入后把当前sku赋值到goods.selected 2.3.4.展示sku其它属性现在，我们已经可以通过goods.selected获取用户选中的sku，那么我们就可以在页面展示了： 刷新页面： 看起来很完美是吧！ 但其实有一些瑕疵 2.3.5.几个问题2.3.5.1.价格显示的是分首先价格显示就不正确，我们数据库中存放的是以分为单位，所以这里要格式化。 好在我们之前common.js中定义了工具类，可以帮我们转换。 改造： 结果报错： 为啥？ 因为在Vue范围内使用任何变量，都会默认去Vue实例中寻找，我们使用ly，但是Vue实例中没有这个变量。所以解决办法就是把ly记录到Vue实例： 然后刷新页面： 2.3.5.2.标题过长标题内容太长了，已经无法完全显示，怎么办？ 截取一下： 最好在加个悬停展示所有内容的效果 2.3.5.3.sku点击不切换还有一个错误比较隐蔽，不容易被发现。我们点击sku 的图片列表，发现没有任何变化。 这不科学啊，为什么？ 通过控制台观察，发现数据其实是变化了，但是Vue却没有重新渲染视图。 这是因为Vue的自动渲染是基于对象的属性变化的。比如页面使用GoodsList进行渲染，如果GoodsList变化，或者其内部的任何子对象变化，都会Vue感知，从而从新渲染页面。 然而，这一切有一个前提，那就是当你第一次渲染时，对象中有哪些属性，Vue就只监视这些属性，后来添加的属性发生改变，是不会被监视到的。 而我们的goods对象中，本身是没有selected属性的，是我们后来才添加进去的： 这段代码稍微改造一下，即可： 也就是说，我们先把selected属性初始化完毕，然后才把整个对象赋值给goodsList，这样，goodsList已初始化时就有selected属性，以后就会被正常监控了。 3.页面分页效果刚才的查询中，我们默认了查询的页码和每页大小，因此所有的分页功能都无法使用，接下来我们一起看看分页功能条该如何制作。 这里要分两步， 第一步：如何生成分页条 第二步：点击分页按钮，我们做什么 3.1.如何生成分页条先看下页面关于分页部分的代码： 3.1.1.需要的数据分页数据应该是根据总页数、当前页、总条数等信息来计算得出。 当前页：肯定是由页面来决定的，点击按钮会切换到对应的页 总页数：需要后台传递给我们 总条数：需要后台传递给我们 我们首先在data中记录下这几个值：page-当前页，total-总条数，totalPage-总页数 12345678910data: &#123; ly, search:&#123; key: "", page: 1 &#125;, goodsList:[], // 接收搜索得到的结果 total: 0, // 总条数 totalPage: 0 // 总页数&#125; 因为page是搜索条件之一，所以记录在search对象中。 要注意：我们在created钩子函数中，会读取url路径的参数，然后赋值给search。如果是第一次请求页面，page是不存在的。因此为了避免page被覆盖，我们应该这么做： 不过，这个时候我们自己的search对象中的值就可有可无了 3.1.2.后台提供数据后台返回的结果中，要包含total和totalPage，我们改造下刚才的接口： 在我们返回的PageResult对象中，其实是有totalPage字段的： 页面测试一下： OK 3.1.3.页面计算分页条首先，把后台提供的数据保存在data中： 然后看下我们要实现的效果： 这里最复杂的是中间的1~5的分页按钮，它需要动态变化。 思路分析： 最多有5个按钮，因此我们可以用v-for循环从1到5即可 但是分页条不一定是从1开始： 如果当前页值小于等于3的时候，分页条位置从1开始到5结束 如果总页数小于等于5的时候，分页条位置从1开始到5结束 如果当前页码大于3，应该从page-3开始 但是如果当前页码大于totalPage-3，应该从totalPage-5开始 所以，我们的页面这样来做： a标签中的分页数字通过index函数来计算，需要把i传递过去： 1234567891011index(i)&#123; if(this.search.page &lt;= 3 || this.totalPage &lt;= 5)&#123; // 如果当前页小于等于3或者总页数小于等于5 return i; &#125; else if(this.search.page &gt; 3) &#123; // 如果当前页大于3 return this.search.page - 3 + i; &#125; else &#123; return this.totalPage - 5 + i; &#125;&#125; 需要注意的是，如果总页数不足5页，我们就不应该遍历1~5，而是1~总页数，稍作改进： 分页条的其它部分就比较简单了： 12345678910111213141516171819202122&lt;div class=&quot;sui-pagination pagination-large&quot;&gt; &lt;ul style=&quot;width: 550px&quot;&gt; &lt;li :class=&quot;&#123;prev:true,disabled:search.page === 1&#125;&quot;&gt; &lt;a href=&quot;#&quot;&gt;«上一页&lt;/a&gt; &lt;/li&gt; &lt;li :class=&quot;&#123;active: index(i) === search.page&#125;&quot; v-for=&quot;i in Math.min(5,totalPage)&quot; :key=&quot;i&quot;&gt; &lt;a href=&quot;#&quot;&gt;&#123;&#123;index(i)&#125;&#125;&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;dotted&quot; v-show=&quot;totalPage &gt; 5&quot;&gt;&lt;span&gt;...&lt;/span&gt;&lt;/li&gt; &lt;li :class=&quot;&#123;next:true,disabled:search.page === totalPage&#125;&quot;&gt; &lt;a href=&quot;#&quot;&gt;下一页»&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;div&gt; &lt;span&gt;共&#123;&#123;totalPage&#125;&#125;页&amp;nbsp;&lt;/span&gt; &lt;span&gt; 到第 &lt;input type=&quot;text&quot; class=&quot;page-num&quot; :value=&quot;search.page&quot;&gt; 页 &lt;button class=&quot;page-confirm&quot; onclick=&quot;alert(1)&quot;&gt;确定&lt;/button&gt; &lt;/span&gt; &lt;/div&gt;&lt;/div&gt; 3.1.4.页面跳转 在methon中编写方法newPage 3.2.点击分页做什么点击分页按钮后，自然是要修改page的值 所以，我们在上一页、下一页按钮添加点击事件，对page进行修改，在数字按钮上绑定点击事件，点击直接修改page： 12345678910prevPage()&#123; if(this.search.page &gt; 1)&#123; this.search.page-- &#125;&#125;,nextPage()&#123; if(this.search.page &lt; this.totalPage)&#123; this.search.page++ &#125;&#125; 当page发生变化，我们应该去后台重新查询数据。 不过，如果我们直接发起ajax请求，那么浏览器的地址栏中是不会有变化的，没有记录下分页信息。如果用户刷新页面，那么就会回到第一页。 这样不太友好，我们应该把搜索条件记录在地址栏的查询参数中。 因此，我们监听search的变化，然后把search的过滤字段拼接在url路径后： 123456789watch:&#123; search:&#123; deep:true, handler(val)&#123; // 把search对象变成请求参数，拼接在url路径 window.location.href = "http://www.leyou.com/search.html?" + ly.stringify(val); &#125; &#125;&#125;, 刷新页面测试，然后就出现重大bug：页面无限刷新！为什么？ 因为Vue实例初始化的钩子函数中，我们读取请求参数，赋值给search的时候，也触发了watch监视！也就是说，每次页面创建完成，都会触发watch，然后就会去修改window.location路径，然后页面被刷新，再次触发created钩子，又触发watch，周而复始，无限循环。 所以，我们需要在watch中进行监控，如果发现是第一次初始化，则不继续向下执行。 那么问题是，如何判断是不是第一次？ 第一次初始化时，search中的key值肯定是空的，所以，我们这么做： 12345678910111213watch:&#123; search:&#123; deep:true, handler(val,old)&#123; if(!old || !old.key)&#123; // 如果旧的search值为空，或者search中的key为空，证明是第一次 return; &#125; // 把search对象变成请求参数，拼接在url路径 window.location.href = "http://www.leyou.com/search.html?" + ly.stringify(val); &#125; &#125;&#125; 再次刷新，OK了！ 3.3.页面顶部分页条在页面商品列表的顶部，也有一个分页条： 我们把这一部分，也加上点击事件： 4.排序(作业)4.1.页面搜索排序条件在搜索商品列表的顶部，有这么一部分内容： 这是用来做排序的，默认按照综合排序。点击新品，应该按照商品创建时间排序，点击价格应该按照价格排序。因为我们没有统计销量和评价，这里咱们以新品和价格为例，进行讲解，做法是想通的。 排序需要知道两个内容： 排序的字段 排序的方式 因此，我们首先在search中记录这两个信息，因为created钩子函数会对search进行覆盖，因此我们在钩子函数中对这两个信息进行初始化即可： 然后，在页面上给按钮绑定点击事件，修改sortBy和descending的值： 1234567891011121314151617181920212223&lt;!--排序字段--&gt;&lt;ul class=&quot;sui-nav&quot;&gt; &lt;li :class=&quot;&#123;active:!search.sortBy&#125;&quot; @click=&quot;search.sortBy=&apos;&apos;&quot;&gt; &lt;a href=&quot;#&quot;&gt;综合&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;销量&lt;/a&gt; &lt;/li&gt; &lt;li @click=&quot;search.sortBy=&apos;createTime&apos;&quot; :class=&quot;&#123;active: search.sortBy===&apos;createTime&apos;&#125;&quot;&gt; &lt;a href=&quot;#&quot;&gt;新品&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;评价&lt;/a&gt; &lt;/li&gt; &lt;li @click=&quot;search.sortBy=&apos;price&apos;; search.descending = !search.descending&quot; :class=&quot;&#123;active: search.sortBy===&apos;price&apos;&#125;&quot;&gt; &lt;a href=&quot;#&quot;&gt; 价格 &lt;v-icon v-show=&quot;search.descending&quot;&gt;arrow_drop_down&lt;/v-icon&gt; &lt;v-icon v-show=&quot;!search.descending&quot;&gt;arrow_drop_up&lt;/v-icon&gt; &lt;/a&gt; &lt;/li&gt;&lt;/ul&gt; 可以看到，页面请求参数中已经有了排序字段了： 4.2.后台添加排序逻辑接下来，后台需要接收请求参数中的排序信息，然后在搜索中加入排序的逻辑。 现在，我们的请求参数对象SearchRequest中，只有page、key两个字段。需要进行扩展： 然后在搜索业务逻辑中，添加排序条件： 注意，因为我们存储在索引库中的的价格是一个数组，因此在按照价格排序时，会进行智能处理： 如果是价格降序，则会把数组中的最大值拿来排序 如果是价格升序，则会把数组中的最小值拿来排序 修改search.html中的searchFromServer方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748searchFromServer() &#123; ly.http.post("/search/page",this.search).then((resp) =&gt; &#123; resp.data.items.forEach(goods =&gt; &#123; let max = 0; let min = 0; //转换skus:把字符串转变为对象 goods.skus = JSON.parse(goods.skus); //添加默认选中项,如果按价格排序则选出skus中价格最低的或者最高的，否则选skus中的第一个 if (this.search.sortBy === "price")&#123; if (this.search.descending === true)&#123; //降序，则skus中价格选最高的 goods.skus.forEach(sku =&gt; &#123; if (sku.price &gt; max)&#123; max = sku.price; &#125; &#125;); goods.skus.forEach(sku =&gt; &#123; if (sku.price === max)&#123; goods.selected = sku; &#125; &#125;); &#125; else &#123; //升序，则skus中价格选最低的 min = goods.skus[0].price; goods.skus.forEach(sku =&gt; &#123; if (sku.price &lt; min)&#123; min = sku.price; &#125; &#125;); goods.skus.forEach(sku =&gt; &#123; if (sku.price === min)&#123; goods.selected = sku; &#125; &#125;); &#125; &#125; else &#123; goods.selected = goods.skus[0]; &#125; &#125;); this.goodsList = resp.data.items; this.total = resp.data.total; this.totalPage = resp.data.totalPage; &#125;); &#125;]]></content>
      <categories>
        <category>项目实战-微服务商城</category>
        <category>Elasticsearch</category>
      </categories>
      <tags>
        <tag>Elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务商城（十一）——Elasticsearch安装及介绍一]]></title>
    <url>%2Fday10-elasticsearch.html</url>
    <content type="text"><![CDATA[独立安装Elasticsearch 会使用Rest的API操作索引 会使用Rest的API查询数据 会使用Rest的API聚合数据 掌握Spring Data Elasticsearch使用 1.Elasticsearch介绍和安装用户访问我们的首页，一般都会直接搜索来寻找自己想要购买的商品。 而商品的数量非常多，而且分类繁杂。如果能正确的显示出用户想要的商品，并进行合理的过滤，尽快促成交易，是搜索系统要研究的核心。 面对这样复杂的搜索业务和数据量，使用传统数据库搜索就显得力不从心，一般我们都会使用全文检索技术，比如之前大家学习过的Solr。 不过今天，我们要讲的是另一个全文检索技术：Elasticsearch。 1.1.简介1.1.1.ElasticElastic官网：https://www.elastic.co/cn/ Elastic有一条完整的产品线及解决方案：Elasticsearch、Kibana、Logstash等，前面说的三个就是大家常说的ELK技术栈。 1.1.2.ElasticsearchElasticsearch官网：https://www.elastic.co/cn/products/elasticsearch 如上所述，Elasticsearch具备以下特点： 分布式，无需人工搭建集群（solr就需要人为配置，使用Zookeeper作为注册中心） Restful风格，一切API都遵循Rest原则，容易上手 近实时搜索，数据更新在Elasticsearch中几乎是完全同步的。 1.1.3.版本目前Elasticsearch最新的版本是6.3.1，我们就使用6.3.0 需要虚拟机JDK1.8及以上 1.2.安装和配置为了模拟真实场景，我们将在linux下安装Elasticsearch。 1.2.1.新建一个用户leyou出于安全考虑，elasticsearch默认不允许以root账号运行。 创建用户： 1useradd leyou 设置密码： 1passwd leyou 设置权限： 123将ElasticSearch的权限改成leyou的[root@localhost leyou]# chown leyou:leyou elasticsearch/ -R 切换用户： 1su - leyou 1.2.2.上传安装包,并解压我们将安装包上传到：/home/leyou目录 解压缩： 1tar -zxvf elasticsearch-6.3.0.tar.gz 我们把目录重命名： 1mv elasticsearch-6.3.0/ elasticsearch 进入，查看目录结构： 1.2.3.修改配置我们进入config目录：cd config 需要修改的配置文件有两个： jvm.options Elasticsearch基于Lucene的，而Lucene底层是java实现，因此我们需要配置jvm参数。 编辑jvm.options： 1vim jvm.options 默认配置如下： 12-Xms1g-Xmx1g 内存占用太多了，我们调小一些： 12-Xms512m-Xmx512m elasticsearch.yml 1vim elasticsearch.yml 修改数据和日志目录： 12path.data: /home/leyou/elasticsearch/data # 数据目录位置path.logs: /home/leyou/elasticsearch/logs # 日志目录位置 我们把data和logs目录修改指向了elasticsearch的安装目录。但是这两个目录并不存在，因此我们需要创建出来。 进入elasticsearch的根目录，然后创建： 12mkdir datamkdir logs 修改绑定的ip： 1network.host: 0.0.0.0 # 绑定到0.0.0.0，允许任何ip来访问 默认只允许本机访问，修改为0.0.0.0后则可以远程访问 目前我们是做的单机安装，如果要做集群，只需要在这个配置文件中添加其它节点信息即可。 elasticsearch.yml的其它可配置信息： 属性名 说明 cluster.name 配置elasticsearch的集群名称，默认是elasticsearch。建议修改成一个有意义的名称。 node.name 节点名，es会默认随机指定一个名字，建议指定一个有意义的名称，方便管理 path.conf 设置配置文件的存储路径，tar或zip包安装默认在es根目录下的config文件夹，rpm安装默认在/etc/ elasticsearch path.data 设置索引数据的存储路径，默认是es根目录下的data文件夹，可以设置多个存储路径，用逗号隔开 path.logs 设置日志文件的存储路径，默认是es根目录下的logs文件夹 path.plugins 设置插件的存放路径，默认是es根目录下的plugins文件夹 bootstrap.memory_lock 设置为true可以锁住ES使用的内存，避免内存进行swap network.host 设置bind_host和publish_host，设置为0.0.0.0允许外网访问 http.port 设置对外服务的http端口，默认为9200。 transport.tcp.port 集群结点之间通信端口 discovery.zen.ping.timeout 设置ES自动发现节点连接超时的时间，默认为3秒，如果网络延迟高可设置大些 discovery.zen.minimum_master_nodes 主结点数量的最少值 ,此值的公式为：(master_eligible_nodes / 2) + 1 ，比如：有3个符合要求的主结点，那么这里要设置为2 1.3.运行进入elasticsearch/bin目录，可以看到下面的执行文件： 然后输入命令： 1./elasticsearch 发现报错了，启动失败： 1.3.1.错误1：内核过低 我们使用的是centos6，其linux内核版本为2.6。而Elasticsearch的插件要求至少3.5以上版本。不过没关系，我们禁用这个插件即可。 修改elasticsearch.yml文件，在最下面添加如下配置： 1bootstrap.system_call_filter: false 然后重启 1.3.2.错误2：文件权限不足再次启动，又出错了： 1[1]: max file descriptors [4096] for elasticsearch process likely too low, increase to at least [65536] 我们用的是leyou用户，而不是root，所以文件权限不足。 首先用root用户登录。 然后修改配置文件: 1vim /etc/security/limits.conf 添加下面的内容： 1234567* soft nofile 65536* hard nofile 131072* soft nproc 4096* hard nproc 4096 1.3.3.错误3：线程数不够刚才报错中，还有一行： 1[1]: max number of threads [1024] for user [leyou] is too low, increase to at least [4096] 这是线程数不够。 继续修改配置： 1vim /etc/security/limits.d/90-nproc.conf 修改下面的内容： 1* soft nproc 1024 改为： 1* soft nproc 4096 1.3.4.错误4：进程虚拟内存1[3]: max virtual memory areas vm.max_map_count [65530] likely too low, increase to at least [262144] vm.max_map_count：限制一个进程可以拥有的VMA(虚拟内存区域)的数量，继续修改配置文件， ： 1vim /etc/sysctl.conf 添加下面内容： 1vm.max_map_count=655360 然后执行命令： 1sysctl -p 1.3.5.重启终端窗口所有错误修改完毕，一定要重启你的 Xshell终端，否则配置无效。 1.3.6.启动再次启动，终于成功了！ 123切换用户，然后进入安装目录，启动elasticsearch服务cd /home/leyou/elasticsearch/bin./elasticsearch 可以看到绑定了两个端口: 9300：集群节点间通讯接口 9200：客户端访问接口 我们在浏览器中访问：http://192.168.25.128:9200 1.4.安装kibana1.4.1.什么是Kibana？ Kibana是一个基于Node.js的Elasticsearch索引库数据统计工具，可以利用Elasticsearch的聚合功能，生成各种图表，如柱形图，线状图，饼图等。 而且还提供了操作Elasticsearch索引数据的控制台，并且提供了一定的API提示，非常有利于我们学习Elasticsearch的语法。 1.4.2.安装因为Kibana依赖于node，我们的虚拟机没有安装node，而window中安装过。所以我们选择在window下使用kibana。 最新版本与elasticsearch保持一致，也是6.3.0 解压到特定目录即可C:\Program Files (x86)\Apache Software Foundation\kibana 1.4.3.配置运行 配置 进入安装目录下的config目录，修改kibana.yml文件： 修改elasticsearch服务器的地址： 1elasticsearch.url: &quot;http://192.168.25.128:9200&quot; 运行 进入安装目录下的bin目录： 双击运行： 发现kibana的监听端口是5601 我们访问：http://127.0.0.1:5601 1.4.4.控制台选择左侧的DevTools菜单，即可进入控制台页面： 在页面右侧，我们就可以输入请求，访问Elasticsearch了。 1.5.安装ik分词器Lucene的IK分词器早在2012年已经没有维护了，现在我们要使用的是在其基础上维护升级的版本，并且开发为ElasticSearch的集成插件了，与Elasticsearch一起维护升级，版本也保持一致，最新版本：6.3.0 1.5.1.安装上传课前资料中的zip包，解压到Elasticsearch目录的plugins目录中： 使用unzip命令解压并且改名为ik-analyzer： 1unzip elasticsearch-analysis-ik-6.3.0.zip -d ik-analyzer 设置成leyou权限 1[root@localhost plugins]# chown leyou:leyou ik-analyzer/ -R 然后重启elasticsearch： 1.5.2.测试大家先不管语法，我们先测试一波。 在kibana控制台输入下面的请求： 12345POST _analyze&#123; &quot;analyzer&quot;: &quot;ik_max_word&quot;, &quot;text&quot;: &quot;我是中国人&quot;&#125; 运行得到结果： 123456789101112131415161718192021222324252627282930313233343536373839&#123; &quot;tokens&quot;: [ &#123; &quot;token&quot;: &quot;我&quot;, &quot;start_offset&quot;: 0, &quot;end_offset&quot;: 1, &quot;type&quot;: &quot;CN_CHAR&quot;, &quot;position&quot;: 0 &#125;, &#123; &quot;token&quot;: &quot;是&quot;, &quot;start_offset&quot;: 1, &quot;end_offset&quot;: 2, &quot;type&quot;: &quot;CN_CHAR&quot;, &quot;position&quot;: 1 &#125;, &#123; &quot;token&quot;: &quot;中国人&quot;, &quot;start_offset&quot;: 2, &quot;end_offset&quot;: 5, &quot;type&quot;: &quot;CN_WORD&quot;, &quot;position&quot;: 2 &#125;, &#123; &quot;token&quot;: &quot;中国&quot;, &quot;start_offset&quot;: 2, &quot;end_offset&quot;: 4, &quot;type&quot;: &quot;CN_WORD&quot;, &quot;position&quot;: 3 &#125;, &#123; &quot;token&quot;: &quot;国人&quot;, &quot;start_offset&quot;: 3, &quot;end_offset&quot;: 5, &quot;type&quot;: &quot;CN_WORD&quot;, &quot;position&quot;: 4 &#125; ]&#125; 1.7.APIElasticsearch提供了Rest风格的API，即http请求接口，而且也提供了各种语言的客户端API 1.7.1.Rest风格API文档地址：https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html 1.7.2.客户端APIElasticsearch支持的客户端非常多：https://www.elastic.co/guide/en/elasticsearch/client/index.html 点击Java Rest Client后，你会发现又有两个： Low Level Rest Client是低级别封装，提供一些基础功能，但更灵活 High Level Rest Client，是在Low Level Rest Client基础上进行的高级别封装，功能更丰富和完善，而且API会变的简单 1.7.3.如何学习建议先学习Rest风格API，了解发起请求的底层实现，请求体格式等。 2.操作索引2.1.基本概念Elasticsearch也是基于Lucene的全文检索库，本质也是存储数据，很多概念与MySQL类似的。 对比关系： ElasticSearch————————————–Mysql 索引（indices）——————————–Databases 数据库 ​ 类型（type）—————————–Table 数据表 ​ 文档（Document）—————-Row 行 ​ 字段（Field）——————-Columns 列 详细说明： 概念 说明 索引库（indices) indices是index的复数，代表许多的索引， 类型（type） 类型是模拟mysql中的table概念，一个索引库下可以有不同类型的索引，比如商品索引，订单索引，其数据格式不同。不过这会导致索引库混乱，因此未来版本中会移除这个概念 文档（document） 存入索引库原始的数据。比如每一条商品信息，就是一个文档 字段（field） 文档中的属性 映射配置（mappings） 字段的数据类型、属性、是否索引、是否存储等特性 是不是与Lucene和solr中的概念类似。 另外，在SolrCloud中，有一些集群相关的概念，在Elasticsearch也有类似的： 索引集（Indices，index的复数）：逻辑上的完整索引 分片（shard）：数据拆分后的各个部分 副本（replica）：每个分片的复制 要注意的是：Elasticsearch本身就是分布式的，因此即便你只有一个节点，Elasticsearch默认也会对你的数据进行分片和副本操作，当你向集群添加新数据时，数据也会在新加入的节点中进行平衡。 2.2.创建索引2.2.1.语法Elasticsearch采用Rest风格API，因此其API就是一次http请求，你可以用任何工具发起http请求 创建索引的请求格式： 请求方式：PUT 请求路径：/索引库名 请求参数：json格式： 123456&#123; "settings": &#123; "number_of_shards": 3, "number_of_replicas": 2 &#125;&#125; settings：索引库的设置 number_of_shards：分片数量 number_of_replicas：副本数量 2.2.2.测试我们先用RestClient来试试 响应： 可以看到索引创建成功了。 2.2.3.使用kibana创建kibana的控制台，可以对http请求进行简化，示例： 相当于是省去了elasticsearch的服务器地址 而且还有语法提示，非常舒服。 2.3.查看索引设置 语法 Get请求可以帮我们查看索引信息，格式： 1GET /索引库名 或者，我们可以使用*来查询所有索引库配置： 2.4.删除索引删除索引使用DELETE请求 语法 1DELETE /索引库名 示例 再次查看heima2： 当然，我们也可以用HEAD请求，查看索引是否存在： 2.5.映射配置索引有了，接下来肯定是添加数据。但是，在添加数据之前必须定义映射。 什么是映射？ ​ 映射是定义文档的过程，文档包含哪些字段，这些字段是否保存，是否索引，是否分词等 只有配置清楚，Elasticsearch才会帮我们进行索引库的创建（不一定） 2.5.1.创建映射字段 语法 请求方式依然是PUT 1234567891011PUT /索引库名/_mapping/类型名称&#123; &quot;properties&quot;: &#123; &quot;字段名&quot;: &#123; &quot;type&quot;: &quot;类型&quot;, &quot;index&quot;: true， &quot;store&quot;: true， &quot;analyzer&quot;: &quot;分词器&quot; &#125; &#125;&#125; 类型名称：就是前面将的type的概念，类似于数据库中的不同表字段名：任意填写 ，可以指定许多属性，例如： type：类型，可以是text、long、short、date、integer、object等 index：是否索引，默认为true store：是否存储，默认为false analyzer：分词器，这里的ik_max_word即使用ik分词器 示例 发起请求： 12345678910111213141516PUT /heima/_mapping/goods&#123; "properties": &#123; "title": &#123; "type": "text", "analyzer": "ik_max_word" &#125;, "images": &#123; "type": "keyword", "index": "false" &#125;, "price": &#123; "type": "float" &#125; &#125;&#125; 响应结果： 123&#123; &quot;acknowledged&quot;: true&#125; 2.5.2.查看映射关系 语法： 1GET /索引库名/_mapping 示例： 1GET /heima/_mapping 响应： 123456789101112131415161718192021&#123; "heima": &#123; "mappings": &#123; "goods": &#123; "properties": &#123; "images": &#123; "type": "keyword", "index": false &#125;, "price": &#123; "type": "float" &#125;, "title": &#123; "type": "text", "analyzer": "ik_max_word" &#125; &#125; &#125; &#125; &#125;&#125; 2.5.3.字段属性详解2.5.3.1.typeElasticsearch中支持的数据类型非常丰富： 我们说几个关键的： String类型，又分两种： text：可分词，不可参与聚合 keyword：不可分词，数据会作为完整字段进行匹配，可以参与聚合 Numerical：数值类型，分两类 基本数据类型：long、interger、short、byte、double、float、half_float 浮点数的高精度类型：scaled_float 需要指定一个精度因子，比如10或100。elasticsearch会把真实值乘以这个因子后存储，取出时再还原。 Date：日期类型 elasticsearch可以对日期格式化为字符串存储，但是建议我们存储为毫秒值，存储为long，节省空间。 存的是对象： {girl:{name=”rose”,age:21}} 会处理成两个字段：girl.name和girl.age 2.5.3.2.indexindex影响字段的索引情况。 true：字段会被索引，则可以用来进行搜索。默认值就是true false：字段不会被索引，不能用来搜索 index的默认值就是true，也就是说你不进行任何配置，所有字段都会被索引。 但是有些字段是我们不希望被索引的，比如商品的图片信息，就需要手动设置index为false。 2.5.3.3.store是否将数据进行额外存储。 在学习lucene和solr时，我们知道如果一个字段的store设置为false，那么在文档列表中就不会有这个字段的值，用户的搜索结果中不会显示出来。 但是在Elasticsearch中，即便store设置为false，也可以搜索到结果。 原因是Elasticsearch在创建文档索引时，会将文档中的原始数据备份，保存到一个叫做_source的属性中。而且我们可以通过过滤_source来选择哪些要显示，哪些不显示。 而如果设置store为true，就会在_source以外额外存储一份数据，多余，因此一般我们都会将store设置为false，事实上，store的默认值就是false。 2.5.3.4.boost激励因子，这个与lucene中一样 其它的不再一一讲解，用的不多，大家参考官方文档： 2.6.新增数据2.6.1.随机生成id通过POST请求，可以向一个已经存在的索引库中添加数据。 语法： 1234POST /索引库名/类型名&#123; &quot;key&quot;:&quot;value&quot;&#125; 示例： 1234567891011121314//默认idPOST /heima/goods/&#123; "title":"小米手机", "images":"http://image.leyou.com/12479122.jpg", "price":2699.00&#125;//自定义idPOST /heima/goods/1&#123; "title":"小米手机2", "images":"http://image.leyou.com/12479122.jpg", "price":2666.00&#125; 响应： 1234567891011121314&#123; "_index": "heima", "_type": "goods", "_id": "r9c1KGMBIhaxtY5rlRKv", "_version": 1, "result": "created", "_shards": &#123; "total": 3, "successful": 1, "failed": 0 &#125;, "_seq_no": 0, "_primary_term": 2&#125; 通过kibana查看数据： 1234GET /heima/_search&#123; "query": &#123;"match_all": &#123;&#125;&#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738&#123; "took": 194, "timed_out": false, "_shards": &#123; "total": 5, "successful": 5, "skipped": 0, "failed": 0 &#125;, "hits": &#123; "total": 2, "max_score": 1, "hits": [ &#123; "_index": "heima", "_type": "goods", "_id": "HA7CpmcB-AoaT0cuqrW4", "_score": 1, "_source": &#123; "title": "小米手机", "images": "http://image.leyou.com/12479122.jpg", "price": 2699 &#125; &#125;, &#123; "_index": "heima", "_type": "goods", "_id": "1", "_score": 1, "_source": &#123; "title": "1小米手机", "images": "http://image.leyou.com/12479122.jpg", "price": 12699 &#125; &#125; ] &#125;&#125; _source：源文档信息，所有的数据都在里面。 _id：这条文档的唯一标示，与文档自己的id字段没有关联 2.6.2.自定义id如果我们想要自己新增的时候指定id，可以这么做： 1234POST /索引库名/类型/id值&#123; ...&#125; 示例： 123456POST /heima/goods/2&#123; "title":"大米手机", "images":"http://image.leyou.com/12479122.jpg", "price":2899.00&#125; 得到的数据： 1234567891011&#123; "_index": "heima", "_type": "goods", "_id": "2", "_score": 1, "_source": &#123; "title": "大米手机", "images": "http://image.leyou.com/12479122.jpg", "price": 2899 &#125;&#125; 2.6.3.智能判断在学习Solr时我们发现，我们在新增数据时，只能使用提前配置好映射属性的字段，否则就会报错。 不过在Elasticsearch中并没有这样的规定。 事实上Elasticsearch非常智能，你不需要给索引库设置任何mapping映射，它也可以根据你输入的数据来判断类型，动态添加数据映射。 测试一下： 123456789POST /heima/goods/3&#123; "title":"超米手机", "images":"http://image.leyou.com/12479122.jpg", "price":2899.00, "stock": 200, "saleable":true， &#125; 我们额外添加了stock库存，和saleable是否上架两个字段。 来看结果： 1234567891011121314&#123; "_index": "heima", "_type": "goods", "_id": "3", "_version": 1, "_score": 1, "_source": &#123; "title": "超米手机", "images": "http://image.leyou.com/12479122.jpg", "price": 2899, "stock": 200, "saleable": true &#125;&#125; 在看下索引库的映射关系: 123456789101112131415161718192021222324252627&#123; "heima": &#123; "mappings": &#123; "goods": &#123; "properties": &#123; "images": &#123; "type": "keyword", "index": false &#125;, "price": &#123; "type": "float" &#125;, "saleable": &#123; "type": "boolean" &#125;, "stock": &#123; "type": "long" &#125;, "title": &#123; "type": "text", "analyzer": "ik_max_word" &#125; &#125; &#125; &#125; &#125;&#125; stock和saleable都被成功映射了。 如果存储的是string类型的数据，ES无智能判断，他会存入两个字符，例如： 存入一个那么字段，智能形成两个字段： name：text类型 name.keyword：keyword类型 2.7.修改数据把刚才新增的请求方式改为PUT，就是修改了。不过修改必须指定id， id对应文档存在，则修改 id对应文档不存在，则新增 比如，我们把id为3的数据进行修改： 12345678PUT /heima/goods/3&#123; "title":"超大米手机", "images":"http://image.leyou.com/12479122.jpg", "price":3899.00, "stock": 100, "saleable":true&#125; 结果： 1234567891011121314151617181920212223242526272829&#123; "took": 17, "timed_out": false, "_shards": &#123; "total": 9, "successful": 9, "skipped": 0, "failed": 0 &#125;, "hits": &#123; "total": 1, "max_score": 1, "hits": [ &#123; "_index": "heima", "_type": "goods", "_id": "3", "_score": 1, "_source": &#123; "title": "超大米手机", "images": "http://image.leyou.com/12479122.jpg", "price": 3899, "stock": 100, "saleable": true &#125; &#125; ] &#125;&#125; 2.8.删除数据删除使用DELETE请求，同样，需要根据id进行删除： 语法 1DELETE /索引库名/类型名/id值 示例： 3.查询我们从4块来讲查询： 基本查询 _source过滤 结果过滤 高级查询 排序 3.1.基本查询： 基本语法 12345678GET /索引库名/_search&#123; "query":&#123; "查询类型":&#123; "查询条件":"查询条件值" &#125; &#125;&#125; 这里的query代表一个查询对象，里面可以有不同的查询属性 查询类型： 例如：match_all， match，term ， range 等等 查询条件：查询条件会根据类型的不同，写法也有差异，后面详细讲解 3.1.1 查询所有（match_all) 示例： 123456GET /heima/_search&#123; "query":&#123; "match_all": &#123;&#125;//很多搜索类型 &#125;&#125; query：代表查询对象 match_all：代表查询所有 结果： 1234567891011121314151617181920212223242526272829303132333435363738&#123; "took": 2, "timed_out": false, "_shards": &#123; "total": 3, "successful": 3, "skipped": 0, "failed": 0 &#125;, "hits": &#123; "total": 2, "max_score": 1, "hits": [ &#123; "_index": "heima", "_type": "goods", "_id": "2", "_score": 1, "_source": &#123; "title": "大米手机", "images": "http://image.leyou.com/12479122.jpg", "price": 2899 &#125; &#125;, &#123; "_index": "heima", "_type": "goods", "_id": "r9c1KGMBIhaxtY5rlRKv", "_score": 1, "_source": &#123; "title": "小米手机", "images": "http://image.leyou.com/12479122.jpg", "price": 2699 &#125; &#125; ] &#125;&#125; took：查询花费时间，单位是毫秒 time_out：是否超时 _shards：分片信息 hits：搜索结果总览对象 total：搜索到的总条数 max_score：所有结果中文档得分的最高分 hits：搜索结果的文档对象数组，每个元素是一条搜索到的文档信息 _index：索引库 _type：文档类型 _id：文档id _score：文档得分 _source：文档的源数据 例子： 3.1.2 匹配查询（match）我们先加入一条数据，便于测试： 123456PUT /heima/goods/3&#123; "title":"小米电视4A", "images":"http://image.leyou.com/12479122.jpg", "price":3899.00&#125; 现在，索引库中有2部手机，1台电视： or关系 match类型查询，会把查询条件进行分词，然后进行查询,多个词条之间是or的关系 12345678GET /heima/_search&#123; "query":&#123; "match":&#123; "title":"小米电视" &#125; &#125;&#125; 结果： 12345678910111213141516171819202122232425262728"hits": &#123; "total": 2, "max_score": 0.6931472, "hits": [ &#123; "_index": "heima", "_type": "goods", "_id": "tmUBomQB_mwm6wH_EC1-", "_score": 0.6931472, "_source": &#123; "title": "小米手机", "images": "http://image.leyou.com/12479122.jpg", "price": 2699 &#125; &#125;, &#123; "_index": "heima", "_type": "goods", "_id": "3", "_score": 0.5753642, "_source": &#123; "title": "小米电视4A", "images": "http://image.leyou.com/12479122.jpg", "price": 3899 &#125; &#125; ]&#125; 在上面的案例中，不仅会查询到电视，而且与小米相关的都会查询到，多个词之间是or的关系。 and关系 某些情况下，我们需要更精确查找，我们希望这个关系变成and，可以这样做： 1234567891011GET /heima/_search&#123; "query":&#123; "match": &#123; "title": &#123; "query": "小米电视", "operator": "and" &#125; &#125; &#125;&#125; 结果： 123456789101112131415161718192021222324252627&#123; "took": 2, "timed_out": false, "_shards": &#123; "total": 3, "successful": 3, "skipped": 0, "failed": 0 &#125;, "hits": &#123; "total": 1, "max_score": 0.5753642, "hits": [ &#123; "_index": "heima", "_type": "goods", "_id": "3", "_score": 0.5753642, "_source": &#123; "title": "小米电视4A", "images": "http://image.leyou.com/12479122.jpg", "price": 3899 &#125; &#125; ] &#125;&#125; 本例中，只有同时包含小米和电视的词条才会被搜索到。 or和and之间？ 在 or 与 and 间二选一有点过于非黑即白。 如果用户给定的条件分词后有 5 个查询词项，想查找只包含其中 4 个词的文档，该如何处理？将 operator 操作符参数设置成 and 只会将此文档排除。 有时候这正是我们期望的，但在全文搜索的大多数应用场景下，我们既想包含那些可能相关的文档，同时又排除那些不太相关的。换句话说，我们想要处于中间某种结果。 match 查询支持 minimum_should_match 最小匹配参数， 这让我们可以指定必须匹配的词项数用来表示一个文档是否相关。我们可以将其设置为某个具体数字，更常用的做法是将其设置为一个百分数，因为我们无法控制用户搜索时输入的单词数量： 1234567891011GET /heima/_search&#123; "query":&#123; "match":&#123; "title":&#123; "query":"小米曲面电视", "minimum_should_match": "75%" &#125; &#125; &#125;&#125; 本例中，搜索语句可以分为3个词，如果使用and关系，需要同时满足3个词才会被搜索到。这里我们采用最小品牌数：75%，那么也就是说只要匹配到总词条数量的75%即可，这里3*75% 约等于2。所以只要包含2个词条就算满足条件了。 结果： 3.1.3 多字段查询（multi_match）multi_match与match类似，不同的是它可以在多个字段中查询 123456789GET /heima/_search&#123; "query":&#123; "multi_match": &#123; "query": "小米", "fields": [ "title", "subTitle" ] &#125; &#125;&#125; 本例中，我们会在title字段和subtitle字段中查询小米这个词 3.1.4 词条匹配(term)term 查询被用于精确值 匹配，这些精确值可能是数字、时间、布尔或者那些未分词的字符串 12345678GET /heima/_search&#123; "query":&#123; "term":&#123; "price":2699.00 &#125; &#125;&#125; 结果： 123456789101112131415161718192021222324252627&#123; "took": 2, "timed_out": false, "_shards": &#123; "total": 3, "successful": 3, "skipped": 0, "failed": 0 &#125;, "hits": &#123; "total": 1, "max_score": 1, "hits": [ &#123; "_index": "heima", "_type": "goods", "_id": "r9c1KGMBIhaxtY5rlRKv", "_score": 1, "_source": &#123; "title": "小米手机", "images": "http://image.leyou.com/12479122.jpg", "price": 2699 &#125; &#125; ] &#125;&#125; 3.1.5 多词条精确匹配(terms)terms 查询和 term 查询一样，但它允许你指定多值进行匹配。如果这个字段包含了指定值中的任何一个值，那么这个文档满足条件： 12345678GET /heima/_search&#123; "query":&#123; "terms":&#123; "price":[2699.00,2899.00,3899.00] &#125; &#125;&#125; 结果： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&#123; "took": 4, "timed_out": false, "_shards": &#123; "total": 3, "successful": 3, "skipped": 0, "failed": 0 &#125;, "hits": &#123; "total": 3, "max_score": 1, "hits": [ &#123; "_index": "heima", "_type": "goods", "_id": "2", "_score": 1, "_source": &#123; "title": "大米手机", "images": "http://image.leyou.com/12479122.jpg", "price": 2899 &#125; &#125;, &#123; "_index": "heima", "_type": "goods", "_id": "r9c1KGMBIhaxtY5rlRKv", "_score": 1, "_source": &#123; "title": "小米手机", "images": "http://image.leyou.com/12479122.jpg", "price": 2699 &#125; &#125;, &#123; "_index": "heima", "_type": "goods", "_id": "3", "_score": 1, "_source": &#123; "title": "小米电视4A", "images": "http://image.leyou.com/12479122.jpg", "price": 3899 &#125; &#125; ] &#125;&#125; 3.2.结果过滤（指定返回结果）默认情况下，elasticsearch在搜索的结果中，会把文档中保存在_source的所有字段都返回。 如果我们只想获取其中的部分字段，我们可以添加_source的过滤 3.2.1.直接指定字段示例： 123456789GET /heima/_search&#123; "_source": ["title","price"], "query": &#123; "term": &#123; "price": 2699 &#125; &#125;&#125; 返回的结果： 1234567891011121314151617181920212223242526&#123; "took": 12, "timed_out": false, "_shards": &#123; "total": 3, "successful": 3, "skipped": 0, "failed": 0 &#125;, "hits": &#123; "total": 1, "max_score": 1, "hits": [ &#123; "_index": "heima", "_type": "goods", "_id": "r9c1KGMBIhaxtY5rlRKv", "_score": 1, "_source": &#123; "price": 2699, "title": "小米手机" &#125; &#125; ] &#125;&#125; 3.2.2.指定includes和excludes我们也可以通过： includes：来指定想要显示的字段 excludes：来指定不想要显示的字段 二者都是可选的。 示例： 1234567891011GET /heima/_search&#123; "_source": &#123; "includes":["title","price"] &#125;, "query": &#123; "term": &#123; "price": 2699 &#125; &#125;&#125; 与下面的结果将是一样的： 1234567891011GET /heima/_search&#123; "_source": &#123; "excludes": ["images"] &#125;, "query": &#123; "term": &#123; "price": 2699 &#125; &#125;&#125; 3.3 高级查询3.3.1 布尔组合（bool)bool把各种其它查询通过must（与）、must_not（非）、should（或）的方式进行组合 12345678910GET /heima/_search&#123; "query":&#123; "bool":&#123; "must": &#123; "match": &#123; "title": "大米" &#125;&#125;, "must_not": &#123; "match": &#123; "title": "电视" &#125;&#125;, "should": &#123; "match": &#123; "title": "手机" &#125;&#125; &#125; &#125;&#125; 结果： 123456789101112131415161718192021222324252627&#123; "took": 10, "timed_out": false, "_shards": &#123; "total": 3, "successful": 3, "skipped": 0, "failed": 0 &#125;, "hits": &#123; "total": 1, "max_score": 0.5753642, "hits": [ &#123; "_index": "heima", "_type": "goods", "_id": "2", "_score": 0.5753642, "_source": &#123; "title": "大米手机", "images": "http://image.leyou.com/12479122.jpg", "price": 2899 &#125; &#125; ] &#125;&#125; 3.3.2 范围查询(range)range 查询找出那些落在指定区间内的数字或者时间 1234567891011GET /heima/_search&#123; "query":&#123; "range": &#123; "price": &#123; "gte": 1000.0, "lt": 2800.00 &#125; &#125; &#125;&#125; range查询允许以下字符： 操作符 说明 gt 大于 gte 大于等于 lt 小于 lte 小于等于 3.3.3 模糊查询(fuzzy)我们新增一个商品： 123456POST /heima/goods/4&#123; "title":"apple手机", "images":"http://image.leyou.com/12479122.jpg", "price":6899.00&#125; fuzzy 查询是 term 查询的模糊等价。它允许用户搜索词条与实际词条的拼写出现偏差，但是偏差的编辑距离不得超过2： 12345678GET /heima/_search&#123; "query": &#123; "fuzzy": &#123; "title": "appla" &#125; &#125;&#125; 上面的查询，也能查询到apple手机 我们可以通过fuzziness来指定允许的编辑距离： 1234567891011GET /heima/_search&#123; "query": &#123; "fuzzy": &#123; "title": &#123; "value":"appla", "fuzziness":1 &#125; &#125; &#125;&#125; 3.4 过滤(filter) 条件查询中进行过滤 所有的查询都会影响到文档的评分及排名。如果我们需要在查询结果中进行过滤，并且不希望过滤条件影响评分，那么就不要把过滤条件作为查询条件来用。而是使用filter方式： 1234567891011GET /heima/_search&#123; "query":&#123; "bool":&#123; "must":&#123; "match": &#123; "title": "小米手机" &#125;&#125;, "filter":&#123; "range":&#123;"price":&#123;"gt":2000.00,"lt":3800.00&#125;&#125; &#125; &#125; &#125;&#125; 注意：filter中还可以再次进行bool组合条件过滤。 无查询条件，直接过滤 如果一次查询只有过滤，没有查询条件，不希望进行评分，我们可以使用constant_score取代只有 filter 语句的 bool 查询。在性能上是完全相同的，但对于提高查询简洁性和清晰度有很大帮助。 123456789GET /heima/_search&#123; "query":&#123; "constant_score": &#123; "filter": &#123; "range":&#123;"price":&#123;"gt":2000.00,"lt":3000.00&#125;&#125; &#125; &#125;&#125; 3.5 排序3.4.1 单字段排序sort 可以让我们按照不同的字段进行排序，并且通过order指定排序的方式 123456789101112131415GET /heima/_search&#123; "query": &#123; "match": &#123; "title": "小米手机" &#125; &#125;, "sort": [ &#123; "price": &#123; "order": "desc" &#125; &#125; ]&#125; 3.4.2 多字段排序假定我们想要结合使用 price和 _score（得分） 进行查询，并且匹配的结果首先按照价格排序，然后按照相关性得分排序： 123456789101112131415GET /goods/_search&#123; "query":&#123; "bool":&#123; "must":&#123; "match": &#123; "title": "小米手机" &#125;&#125;, "filter":&#123; "range":&#123;"price":&#123;"gt":200000,"lt":300000&#125;&#125; &#125; &#125; &#125;, "sort": [ &#123; "price": &#123; "order": "desc" &#125;&#125;, &#123; "_score": &#123; "order": "desc" &#125;&#125; ]&#125; 4. 聚合aggregations聚合可以让我们极其方便的实现对数据的统计、分析。例如： 什么品牌的手机最受欢迎？ 这些手机的平均价格、最高价格、最低价格？ 这些手机每月的销售情况如何？ 实现这些统计功能的比数据库的sql要方便的多，而且查询速度非常快，可以实现实时搜索效果。 4.1 基本概念Elasticsearch中的聚合，包含多种类型，最常用的两种，一个叫桶，一个叫度量： 桶（bucket） 桶的作用，是按照某种方式对数据进行分组，每一组数据在ES中称为一个桶，例如我们根据国籍对人划分，可以得到中国桶、英国桶，日本桶……或者我们按照年龄段对人进行划分：0~10,10~20,20~30,30~40等。 Elasticsearch中提供的划分桶的方式有很多： Date Histogram Aggregation：根据日期阶梯分组，例如给定阶梯为周，会自动每周分为一组 Histogram Aggregation：根据数值阶梯分组，与日期类似 Terms Aggregation：根据词条内容分组，词条内容完全匹配的为一组 Range Aggregation：数值和日期的范围分组，指定开始和结束，然后按段分组 …… 综上所述，我们发现bucket aggregations 只负责对数据进行分组，并不进行计算，因此往往bucket中往往会嵌套另一种聚合：metrics aggregations即度量 度量（metrics） 分组完成以后，我们一般会对组中的数据进行聚合运算，例如求平均值、最大、最小、求和等，这些在ES中称为度量 比较常用的一些度量聚合方式： Avg Aggregation：求平均值 Max Aggregation：求最大值 Min Aggregation：求最小值 Percentiles Aggregation：求百分比 Stats Aggregation：同时返回avg、max、min、sum、count等 Sum Aggregation：求和 Top hits Aggregation：求前几 Value Count Aggregation：求总数 …… 为了测试聚合，我们先批量导入一些数据 创建索引库： 12345678910111213141516171819PUT /cars&#123; "settings": &#123; "number_of_shards": 1, "number_of_replicas": 0 &#125;, "mappings": &#123; "transactions": &#123; "properties": &#123; "color": &#123; "type": "keyword" &#125;, "make": &#123; "type": "keyword" &#125; &#125; &#125; &#125;&#125; 注意：在ES中，需要进行聚合、排序、过滤的字段其处理方式比较特殊，因此不能被分词。这里我们将color和make这两个文字类型的字段设置为keyword类型，这个类型不会被分词，将来就可以参与聚合 导入数据 1234567891011121314151617POST /cars/transactions/_bulk&#123; "index": &#123;&#125;&#125;&#123; "price" : 10000, "color" : "red", "make" : "honda", "sold" : "2014-10-28" &#125;&#123; "index": &#123;&#125;&#125;&#123; "price" : 20000, "color" : "red", "make" : "honda", "sold" : "2014-11-05" &#125;&#123; "index": &#123;&#125;&#125;&#123; "price" : 30000, "color" : "green", "make" : "ford", "sold" : "2014-05-18" &#125;&#123; "index": &#123;&#125;&#125;&#123; "price" : 15000, "color" : "blue", "make" : "toyota", "sold" : "2014-07-02" &#125;&#123; "index": &#123;&#125;&#125;&#123; "price" : 12000, "color" : "green", "make" : "toyota", "sold" : "2014-08-19" &#125;&#123; "index": &#123;&#125;&#125;&#123; "price" : 20000, "color" : "red", "make" : "honda", "sold" : "2014-11-05" &#125;&#123; "index": &#123;&#125;&#125;&#123; "price" : 80000, "color" : "red", "make" : "bmw", "sold" : "2014-01-01" &#125;&#123; "index": &#123;&#125;&#125;&#123; "price" : 25000, "color" : "blue", "make" : "ford", "sold" : "2014-02-12" &#125; 4.2 聚合为桶首先，我们按照 汽车的颜色color来划分桶 1234567891011GET /cars/_search&#123; "size" : 0, "aggs" : &#123; "popular_colors" : &#123; "terms" : &#123; "field" : "color" &#125; &#125; &#125;&#125; size： 查询条数，这里设置为0，因为我们不关心搜索到的数据，只关心聚合结果，提高效率 aggs：声明这是一个聚合查询，是aggregations的缩写 popular_colors：给这次聚合起一个名字，任意。 terms：划分桶的方式，这里是根据词条划分 field：划分桶的字段 结果： 1234567891011121314151617181920212223242526272829303132333435&#123; "took": 1, "timed_out": false, "_shards": &#123; "total": 1, "successful": 1, "skipped": 0, "failed": 0 &#125;, "hits": &#123; "total": 8, "max_score": 0, "hits": [] &#125;, "aggregations": &#123; "popular_colors": &#123; "doc_count_error_upper_bound": 0, "sum_other_doc_count": 0, "buckets": [ &#123; "key": "red", "doc_count": 4 &#125;, &#123; "key": "blue", "doc_count": 2 &#125;, &#123; "key": "green", "doc_count": 2 &#125; ] &#125; &#125;&#125; hits：查询结果为空，因为我们设置了size为0 aggregations：聚合的结果 popular_colors：我们定义的聚合名称 buckets：查找到的桶，每个不同的color字段值都会形成一个桶 key：这个桶对应的color字段的值 doc_count：这个桶中的文档数量 通过聚合的结果我们发现，目前红色的小车比较畅销！ 4.3 桶内度量前面的例子告诉我们每个桶里面的文档数量，这很有用。 但通常，我们的应用需要提供更复杂的文档度量。 例如，每种颜色汽车的平均价格是多少？ 因此，我们需要告诉Elasticsearch使用哪个字段，使用何种度量方式进行运算，这些信息要嵌套在桶内，度量的运算会基于桶内的文档进行 现在，我们为刚刚的聚合结果添加 求价格平均值的度量： 123456789101112131415161718GET /cars/_search&#123; "size" : 0, "aggs" : &#123; "popular_colors" : &#123; "terms" : &#123; "field" : "color" &#125;, "aggs":&#123; "avg_price": &#123; "avg": &#123; "field": "price" &#125; &#125; &#125; &#125; &#125;&#125; aggs：我们在上一个aggs(popular_colors)中添加新的aggs。可见度量也是一个聚合,度量是在桶内的聚合 avg_price：聚合的名称 avg：度量的类型，这里是求平均值 field：度量运算的字段 结果： 12345678910111213141516171819202122232425262728293031... "aggregations": &#123; "popular_colors": &#123; "doc_count_error_upper_bound": 0, "sum_other_doc_count": 0, "buckets": [ &#123; "key": "red", "doc_count": 4, "avg_price": &#123; "value": 32500 &#125; &#125;, &#123; "key": "blue", "doc_count": 2, "avg_price": &#123; "value": 20000 &#125; &#125;, &#123; "key": "green", "doc_count": 2, "avg_price": &#123; "value": 21000 &#125; &#125; ] &#125; &#125;... 可以看到每个桶中都有自己的avg_price字段，这是度量聚合的结果 4.4 桶内嵌套桶刚刚的案例中，我们在桶内嵌套度量运算。事实上桶不仅可以嵌套运算， 还可以再嵌套其它桶。也就是说在每个分组中，再分更多组。 比如：我们想统计每种颜色的汽车中，分别属于哪个制造商，按照make字段再进行分桶 1234567891011121314151617181920212223GET /cars/_search&#123; "size" : 0, "aggs" : &#123; "popular_colors" : &#123; "terms" : &#123; "field" : "color" &#125;, "aggs":&#123; "avg_price": &#123; "avg": &#123; "field": "price" &#125; &#125;, "maker":&#123; "terms":&#123; "field":"make" &#125; &#125; &#125; &#125; &#125;&#125; 原来的color桶和avg计算我们不变 maker：在嵌套的aggs下新添一个桶，叫做maker terms：桶的划分类型依然是词条 filed：这里根据make字段进行划分 部分结果： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374...&#123;"aggregations": &#123; "popular_colors": &#123; "doc_count_error_upper_bound": 0, "sum_other_doc_count": 0, "buckets": [ &#123; "key": "red", "doc_count": 4, "maker": &#123; "doc_count_error_upper_bound": 0, "sum_other_doc_count": 0, "buckets": [ &#123; "key": "honda", "doc_count": 3 &#125;, &#123; "key": "bmw", "doc_count": 1 &#125; ] &#125;, "avg_price": &#123; "value": 32500 &#125; &#125;, &#123; "key": "blue", "doc_count": 2, "maker": &#123; "doc_count_error_upper_bound": 0, "sum_other_doc_count": 0, "buckets": [ &#123; "key": "ford", "doc_count": 1 &#125;, &#123; "key": "toyota", "doc_count": 1 &#125; ] &#125;, "avg_price": &#123; "value": 20000 &#125; &#125;, &#123; "key": "green", "doc_count": 2, "maker": &#123; "doc_count_error_upper_bound": 0, "sum_other_doc_count": 0, "buckets": [ &#123; "key": "ford", "doc_count": 1 &#125;, &#123; "key": "toyota", "doc_count": 1 &#125; ] &#125;, "avg_price": &#123; "value": 21000 &#125; &#125; ] &#125; &#125;&#125;... 我们可以看到，新的聚合maker被嵌套在原来每一个color的桶中。 每个颜色下面都根据 make字段进行了分组 我们能读取到的信息： 红色车共有4辆 红色车的平均售价是 $32，500 美元。 其中3辆是 Honda 本田制造，1辆是 BMW 宝马制造。 4.5.划分桶的其它方式前面讲了，划分桶的方式有很多，例如： Date Histogram Aggregation：根据日期阶梯分组，例如给定阶梯为周，会自动每周分为一组 Histogram Aggregation：根据数值阶梯分组，与日期类似 Terms Aggregation：根据词条内容分组，词条内容完全匹配的为一组 Range Aggregation：数值和日期的范围分组，指定开始和结束，然后按段分组 刚刚的案例中，我们采用的是Terms Aggregation，即根据词条划分桶。 接下来，我们再学习几个比较实用的： 4.5.1.阶梯分桶Histogram 原理： histogram是把数值类型的字段，按照一定的阶梯大小进行分组。你需要指定一个阶梯值（interval）来划分阶梯大小。 举例： 比如你有价格字段，如果你设定interval的值为200，那么阶梯就会是这样的： 0，200，400，600，… 上面列出的是每个阶梯的key，也是区间的启点。 如果一件商品的价格是450，会落入哪个阶梯区间呢？计算公式如下： 1bucket_key = Math.floor((value - offset) / interval) * interval + offset value：就是当前数据的值，本例中是450 offset：起始偏移量，默认为0 interval：阶梯间隔，比如200 因此你得到的key = Math.floor((450 - 0) / 200) * 200 + 0 = 400 操作一下： 比如，我们对汽车的价格进行分组，指定间隔interval为5000： 123456789101112GET /cars/_search&#123; "size":0, "aggs":&#123; "price":&#123; "histogram": &#123; "field": "price", "interval": 5000 &#125; &#125; &#125;&#125; 结果： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&#123; "took": 21, "timed_out": false, "_shards": &#123; "total": 5, "successful": 5, "skipped": 0, "failed": 0 &#125;, "hits": &#123; "total": 8, "max_score": 0, "hits": [] &#125;, "aggregations": &#123; "price": &#123; "buckets": [ &#123; "key": 10000, "doc_count": 2 &#125;, &#123; "key": 15000, "doc_count": 1 &#125;, &#123; "key": 20000, "doc_count": 2 &#125;, &#123; "key": 25000, "doc_count": 1 &#125;, &#123; "key": 30000, "doc_count": 1 &#125;, &#123; "key": 35000, "doc_count": 0 &#125;, &#123; "key": 40000, "doc_count": 0 &#125;, &#123; "key": 45000, "doc_count": 0 &#125;, &#123; "key": 50000, "doc_count": 0 &#125;, &#123; "key": 55000, "doc_count": 0 &#125;, &#123; "key": 60000, "doc_count": 0 &#125;, &#123; "key": 65000, "doc_count": 0 &#125;, &#123; "key": 70000, "doc_count": 0 &#125;, &#123; "key": 75000, "doc_count": 0 &#125;, &#123; "key": 80000, "doc_count": 1 &#125; ] &#125; &#125;&#125; 你会发现，中间有大量的文档数量为0 的桶，看起来很丑。 我们可以增加一个参数min_doc_count为1，来约束最少文档数量为1，这样文档数量为0的桶会被过滤 示例： 12345678910111213GET /cars/_search&#123; "size":0, "aggs":&#123; "price":&#123; "histogram": &#123; "field": "price", "interval": 5000, "min_doc_count": 1 &#125; &#125; &#125;&#125; 结果： 123456789101112131415161718192021222324252627282930313233343536373839404142434445&#123; "took": 15, "timed_out": false, "_shards": &#123; "total": 5, "successful": 5, "skipped": 0, "failed": 0 &#125;, "hits": &#123; "total": 8, "max_score": 0, "hits": [] &#125;, "aggregations": &#123; "price": &#123; "buckets": [ &#123; "key": 10000, "doc_count": 2 &#125;, &#123; "key": 15000, "doc_count": 1 &#125;, &#123; "key": 20000, "doc_count": 2 &#125;, &#123; "key": 25000, "doc_count": 1 &#125;, &#123; "key": 30000, "doc_count": 1 &#125;, &#123; "key": 80000, "doc_count": 1 &#125; ] &#125; &#125;&#125; 完美，！ 如果你用kibana将结果变为柱形图，会更好看： 4.5.2.范围分桶range范围分桶与阶梯分桶类似，也是把数字按照阶段进行分组，只不过range方式需要你自己指定每一组的起始和结束大小。 5.Spring Data ElasticsearchElasticsearch提供的Java客户端有一些不太方便的地方： 很多地方需要拼接Json字符串，在java中拼接字符串有多恐怖你应该懂的 需要自己把对象序列化为json存储 查询到结果也需要自己反序列化为对象 因此，我们这里就不讲解原生的Elasticsearch客户端API了。 而是学习Spring提供的套件：Spring Data Elasticsearch。 5.1.简介Spring Data Elasticsearch是Spring Data项目下的一个子模块。 查看 Spring Data的官网：http://projects.spring.io/spring-data/ Spring Data的使命是为数据访问提供熟悉且一致的基于Spring的编程模型，同时仍保留底层数据存储的特殊特性。 它使得使用数据访问技术，关系数据库和非关系数据库，map-reduce框架和基于云的数据服务变得容易。这是一个总括项目，其中包含许多特定于给定数据库的子项目。这些令人兴奋的技术项目背后，是由许多公司和开发人员合作开发的。 Spring Data 的使命是给各种数据访问提供统一的编程接口，不管是关系型数据库（如MySQL），还是非关系数据库（如Redis），或者类似Elasticsearch这样的索引数据库。从而简化开发人员的代码，提高开发效率。 包含很多不同数据操作的模块： Spring Data Elasticsearch的页面：https://projects.spring.io/spring-data-elasticsearch/ 特征： 支持Spring的基于@Configuration的java配置方式，或者XML配置方式 提供了用于操作ES的便捷工具类ElasticsearchTemplate。包括实现文档到POJO之间的自动智能映射。 利用Spring的数据转换服务实现的功能丰富的对象映射 基于注解的元数据映射方式，而且可扩展以支持更多不同的数据格式 根据持久层接口自动生成对应实现方法，无需人工编写基本操作代码（类似mybatis，根据接口自动得到实现）。当然，也支持人工定制查询 5.2.创建Demo工程我们新建一个demo，学习Elasticsearch pom依赖： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.demo&lt;/groupId&gt; &lt;artifactId&gt;elasticsearch&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;elasticsearch&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.4.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-elasticsearch&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; application.yml文件配置： 12345spring: data: elasticsearch: cluster-name: elasticsearch cluster-nodes: 192.168.25.128:9300 5.3.实体类及注解首先我们准备好实体类： 12345678public class Item &#123; Long id; String title; //标题 String category;// 分类 String brand; // 品牌 Double price; // 价格 String images; // 图片地址&#125; 映射 Spring Data通过注解来声明字段的映射属性，有下面的三个注解： @Document 作用在类，标记实体类为文档对象，一般有两个属性 indexName：对应索引库名称 type：对应在索引库中的类型 shards：分片数量，默认5 replicas：副本数量，默认1 @Id 作用在成员变量，标记一个字段作为id主键 @Field 作用在成员变量，标记为文档的字段，并指定字段映射属性： type：字段类型，取值是枚举：FieldType index：是否索引，布尔类型，默认是true store：是否存储，布尔类型，默认是false analyzer：分词器名称 示例： 123456789101112131415161718@Data@Document(indexName = "heima3",type = "item",shards = 1)public class Item &#123; @Id @Field(type = FieldType.Long) Long id; @Field(type = FieldType.Text,analyzer = "ik_smart") String title; //标题 @Field(type = FieldType.Keyword) String category;// 分类 @Field(type = FieldType.Keyword) String brand; // 品牌 @Field(type = FieldType.Double) Double price; // 价格 @Field(type = FieldType.Keyword,index = false) String images; // 图片地址&#125; 5.4.Template索引操作5.4.1.创建索引和映射 创建索引 ElasticsearchTemplate中提供了创建索引的API： 可以根据类的信息自动生成，也可以手动指定indexName和Settings 映射 映射相关的API： 可以根据类的字节码信息（注解配置）来生成映射，或者手动编写映射 我们这里采用类的字节码信息创建索引并映射： 123456789101112131415@RunWith(SpringRunner.class)@SpringBootTest(classes = ItcastElasticsearchApplication.class)public class IndexTest &#123; @Autowired private ElasticsearchTemplate elasticsearchTemplate; @Test public void testCreate()&#123; // 创建索引，会根据Item类的@Document注解信息来创建 elasticsearchTemplate.createIndex(Item.class); // 配置映射，会根据Item类中的id、Field等字段来自动完成映射 elasticsearchTemplate.putMapping(Item.class); &#125;&#125; 结果： 123456789101112131415161718192021222324252627282930313233343536373839404142434445GET heima3/_mapping&#123; "item": &#123; "aliases": &#123;&#125;, "mappings": &#123; "docs": &#123; "properties": &#123; "brand": &#123; "type": "keyword" &#125;, "category": &#123; "type": "keyword" &#125;, "images": &#123; "type": "keyword", "index": false &#125;, "price": &#123; "type": "double" &#125;, "title": &#123; "type": "text", "analyzer": "ik_max_word" &#125; &#125; &#125; &#125;, "settings": &#123; "index": &#123; "refresh_interval": "1s", "number_of_shards": "1", "provided_name": "item", "creation_date": "1525405022589", "store": &#123; "type": "fs" &#125;, "number_of_replicas": "0", "uuid": "4sE9SAw3Sqq1aAPz5F6OEg", "version": &#123; "created": "6020499" &#125; &#125; &#125; &#125;&#125; 5.3.2.删除索引删除索引的API： 可以根据类名或索引名删除。 示例： 1234@Testpublic void deleteIndex() &#123; esTemplate.deleteIndex("heima");&#125; 结果： 5.5.Repository文档操作（重要）Spring Data 的强大之处，就在于你不用写任何DAO处理，自动根据方法名或类的信息进行CRUD操作。只要你定义一个接口，然后继承Repository提供的一些子接口，就能具备各种基本的CRUD功能。 我们只需要定义接口，然后继承它就OK了。 源码如下： 来看下Repository的继承关系： 我们看到有一个ElasticsearchRepository接口： 只要我们继承ElasticsearchRepositor&lt;T,ID&gt;就可以使用ElasticSearch T：实体类 ID：id数据类型 在es-test中的repository中创建 12public interface ItemRepository extends ElasticsearchRepository&lt;Item,Long&gt; &#123;&#125; 5.5.1.新增文档123456789@Autowiredprivate ItemRepository itemRepository;@Testpublic void index() &#123; Item item = new Item(1L, "小米手机7", " 手机", "小米", 3499.00, "http://image.leyou.com/13123.jpg"); itemRepository.save(item);&#125; 去页面查询看看： 1GET /item/_search 结果： 123456789101112131415161718192021222324252627282930&#123; "took": 14, "timed_out": false, "_shards": &#123; "total": 1, "successful": 1, "skipped": 0, "failed": 0 &#125;, "hits": &#123; "total": 1, "max_score": 1, "hits": [ &#123; "_index": "item", "_type": "docs", "_id": "1", "_score": 1, "_source": &#123; "id": 1, "title": "小米手机7", "category": " 手机", "brand": "小米", "price": 3499, "images": "http://image.leyou.com/13123.jpg" &#125; &#125; ] &#125;&#125; 5.5.2.批量新增代码： 12345678@Testpublic void indexList() &#123; List&lt;Item&gt; list = new ArrayList&lt;&gt;(); list.add(new Item(2L, "坚果手机R1", " 手机", "锤子", 3699.00, "http://image.leyou.com/123.jpg")); list.add(new Item(3L, "华为META10", " 手机", "华为", 4499.00, "http://image.leyou.com/3.jpg")); // 接收对象集合，实现批量新增 itemRepository.saveAll(list);&#125; 再次去页面查询： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&#123; "took": 5, "timed_out": false, "_shards": &#123; "total": 1, "successful": 1, "skipped": 0, "failed": 0 &#125;, "hits": &#123; "total": 3, "max_score": 1, "hits": [ &#123; "_index": "item", "_type": "docs", "_id": "2", "_score": 1, "_source": &#123; "id": 2, "title": "坚果手机R1", "category": " 手机", "brand": "锤子", "price": 3699, "images": "http://image.leyou.com/13123.jpg" &#125; &#125;, &#123; "_index": "item", "_type": "docs", "_id": "3", "_score": 1, "_source": &#123; "id": 3, "title": "华为META10", "category": " 手机", "brand": "华为", "price": 4499, "images": "http://image.leyou.com/13123.jpg" &#125; &#125;, &#123; "_index": "item", "_type": "docs", "_id": "1", "_score": 1, "_source": &#123; "id": 1, "title": "小米手机7", "category": " 手机", "brand": "小米", "price": 3499, "images": "http://image.leyou.com/13123.jpg" &#125; &#125; ] &#125;&#125; 5.5.3.修改文档修改和新增是同一个接口，区分的依据就是id，这一点跟我们在页面发起PUT请求是类似的。 5.5.4.基本查询ElasticsearchRepository提供了一些基本的查询方法： 我们来试试查询所有： 123456@Testpublic void testFind()&#123; // 查询全部，并安装价格降序排序 Iterable&lt;Item&gt; items = this.itemRepository.findAll(Sort.by(Sort.Direction.DESC, "price")); items.forEach(item-&gt; System.out.println(item));&#125; 结果： 5.5.5.自定义方法Spring Data 的另一个强大功能，是根据方法名称自动实现功能。 比如：你的方法名叫做：findByTitle，那么它就知道你是根据title查询，然后自动帮你完成，无需写实现类。 当然，方法名称要符合一定的约定： Keyword Sample Elasticsearch Query String And findByNameAndPrice {&quot;bool&quot; : {&quot;must&quot; : [ {&quot;field&quot; : {&quot;name&quot; : &quot;?&quot;}}, {&quot;field&quot; : {&quot;price&quot; : &quot;?&quot;}} ]}} Or findByNameOrPrice {&quot;bool&quot; : {&quot;should&quot; : [ {&quot;field&quot; : {&quot;name&quot; : &quot;?&quot;}}, {&quot;field&quot; : {&quot;price&quot; : &quot;?&quot;}} ]}} Is findByName {&quot;bool&quot; : {&quot;must&quot; : {&quot;field&quot; : {&quot;name&quot; : &quot;?&quot;}}}} Not findByNameNot {&quot;bool&quot; : {&quot;must_not&quot; : {&quot;field&quot; : {&quot;name&quot; : &quot;?&quot;}}}} Between findByPriceBetween {&quot;bool&quot; : {&quot;must&quot; : {&quot;range&quot; : {&quot;price&quot; : {&quot;from&quot; : ?,&quot;to&quot; : ?,&quot;include_lower&quot; : true,&quot;include_upper&quot; : true}}}}} LessThanEqual findByPriceLessThan {&quot;bool&quot; : {&quot;must&quot; : {&quot;range&quot; : {&quot;price&quot; : {&quot;from&quot; : null,&quot;to&quot; : ?,&quot;include_lower&quot; : true,&quot;include_upper&quot; : true}}}}} GreaterThanEqual findByPriceGreaterThan {&quot;bool&quot; : {&quot;must&quot; : {&quot;range&quot; : {&quot;price&quot; : {&quot;from&quot; : ?,&quot;to&quot; : null,&quot;include_lower&quot; : true,&quot;include_upper&quot; : true}}}}} Before findByPriceBefore {&quot;bool&quot; : {&quot;must&quot; : {&quot;range&quot; : {&quot;price&quot; : {&quot;from&quot; : null,&quot;to&quot; : ?,&quot;include_lower&quot; : true,&quot;include_upper&quot; : true}}}}} After findByPriceAfter {&quot;bool&quot; : {&quot;must&quot; : {&quot;range&quot; : {&quot;price&quot; : {&quot;from&quot; : ?,&quot;to&quot; : null,&quot;include_lower&quot; : true,&quot;include_upper&quot; : true}}}}} Like findByNameLike {&quot;bool&quot; : {&quot;must&quot; : {&quot;field&quot; : {&quot;name&quot; : {&quot;query&quot; : &quot;?*&quot;,&quot;analyze_wildcard&quot; : true}}}}} StartingWith findByNameStartingWith {&quot;bool&quot; : {&quot;must&quot; : {&quot;field&quot; : {&quot;name&quot; : {&quot;query&quot; : &quot;?*&quot;,&quot;analyze_wildcard&quot; : true}}}}} EndingWith findByNameEndingWith {&quot;bool&quot; : {&quot;must&quot; : {&quot;field&quot; : {&quot;name&quot; : {&quot;query&quot; : &quot;*?&quot;,&quot;analyze_wildcard&quot; : true}}}}} Contains/Containing findByNameContaining {&quot;bool&quot; : {&quot;must&quot; : {&quot;field&quot; : {&quot;name&quot; : {&quot;query&quot; : &quot;**?**&quot;,&quot;analyze_wildcard&quot; : true}}}}} In findByNameIn(Collection&lt;String&gt;names) {&quot;bool&quot; : {&quot;must&quot; : {&quot;bool&quot; : {&quot;should&quot; : [ {&quot;field&quot; : {&quot;name&quot; : &quot;?&quot;}}, {&quot;field&quot; : {&quot;name&quot; : &quot;?&quot;}} ]}}}} NotIn findByNameNotIn(Collection&lt;String&gt;names) {&quot;bool&quot; : {&quot;must_not&quot; : {&quot;bool&quot; : {&quot;should&quot; : {&quot;field&quot; : {&quot;name&quot; : &quot;?&quot;}}}}}} Near findByStoreNear Not Supported Yet ! True findByAvailableTrue {&quot;bool&quot; : {&quot;must&quot; : {&quot;field&quot; : {&quot;available&quot; : true}}}} False findByAvailableFalse {&quot;bool&quot; : {&quot;must&quot; : {&quot;field&quot; : {&quot;available&quot; : false}}}} OrderBy findByAvailableTrueOrderByNameDesc {&quot;sort&quot; : [{ &quot;name&quot; : {&quot;order&quot; : &quot;desc&quot;} }],&quot;bool&quot; : {&quot;must&quot; : {&quot;field&quot; : {&quot;available&quot; : true}}}} 例如，我们来按照价格区间查询，定义这样的一个方法： 12345678910public interface ItemRepository extends ElasticsearchRepository&lt;Item,Long&gt; &#123; /** * 根据价格区间查询 * @param price1 * @param price2 * @return */ List&lt;Item&gt; findByPriceBetween(double price1, double price2);&#125; 然后添加一些测试数据： 1234567891011@Testpublic void indexList() &#123; List&lt;Item&gt; list = new ArrayList&lt;&gt;(); list.add(new Item(1L, "小米手机7", "手机", "小米", 3299.00, "http://image.leyou.com/13123.jpg")); list.add(new Item(2L, "坚果手机R1", "手机", "锤子", 3699.00, "http://image.leyou.com/13123.jpg")); list.add(new Item(3L, "华为META10", "手机", "华为", 4499.00, "http://image.leyou.com/13123.jpg")); list.add(new Item(4L, "小米Mix2S", "手机", "小米", 4299.00, "http://image.leyou.com/13123.jpg")); list.add(new Item(5L, "荣耀V10", "手机", "华为", 2799.00, "http://image.leyou.com/13123.jpg")); // 接收对象集合，实现批量新增 itemRepository.saveAll(list);&#125; 不需要写实现类，然后我们直接去运行： 1234567@Testpublic void queryByPriceBetween()&#123; List&lt;Item&gt; list = this.itemRepository.findByPriceBetween(2000.00, 3500.00); for (Item item : list) &#123; System.out.println("item = " + item); &#125;&#125; 结果： 虽然基本查询和自定义方法已经很强大了，但是如果是复杂查询（模糊、通配符、词条查询等）就显得力不从心了。此时，我们只能使用原生查询。 5.6.高级查询5.6.1.基本查询先看看基本玩法 12345678@Testpublic void testQuery()&#123; // 词条查询 MatchQueryBuilder queryBuilder = QueryBuilders.matchQuery("title", "小米"); // 执行查询 Iterable&lt;Item&gt; items = this.itemRepository.search(queryBuilder); items.forEach(System.out::println);&#125; Repository的search方法需要QueryBuilder参数，elasticSearch为我们提供了一个对象QueryBuilders： QueryBuilders提供了大量的静态方法，用于生成各种不同类型的查询对象，例如：词条、模糊、通配符等QueryBuilder对象。 结果： elasticsearch提供很多可用的查询方式，但是不够灵活。如果想玩过滤或者聚合查询等就很难了。 5.6.2.自定义查询先来看最基本的match query： 123456789101112131415@Testpublic void testNativeQuery()&#123; // 构建查询条件 NativeSearchQueryBuilder queryBuilder = new NativeSearchQueryBuilder(); // 添加基本的分词查询 queryBuilder.withQuery(QueryBuilders.matchQuery("title", "小米")); // 执行搜索，获取结果 Page&lt;Item&gt; items = this.itemRepository.search(queryBuilder.build()); // 打印总条数 long total=items.getTotalElements(); System.out.println("total="+total) for(Item item:items)&#123; System.out.println(item); &#125;&#125; NativeSearchQueryBuilder：Spring提供的一个查询条件构建器，帮助构建json格式的请求体 Page&lt;item&gt;：默认是分页查询，因此返回的是一个分页的结果对象，包含属性： totalElements：总条数 totalPages：总页数 Iterator：迭代器，本身实现了Iterator接口，因此可直接迭代得到当前页的数据 其它属性： 结果： 5.6.4.分页查询利用NativeSearchQueryBuilder可以方便的实现分页： 12345678910111213141516171819202122232425@Testpublic void testNativeQuery()&#123; // 构建查询条件 NativeSearchQueryBuilder queryBuilder = new NativeSearchQueryBuilder(); // 添加基本的分词查询（过滤） queryBuilder.withQuery(QueryBuilders.termQuery("category", "手机")); // 初始化分页参数 int page = 0;//从0开始 int size = 3; // 设置分页参数 queryBuilder.withPageable(PageRequest.of(page, size)); // 执行搜索，获取结果 Page&lt;Item&gt; items = this.itemRepository.search(queryBuilder.build()); // 打印总条数 System.out.println(items.getTotalElements()); // 打印总页数 System.out.println(items.getTotalPages()); // 每页大小 System.out.println(items.getSize()); // 当前页 System.out.println(items.getNumber()); items.forEach(System.out::println);&#125; 结果： 可以发现，Elasticsearch中的分页是从第0页开始。 5.6.5.排序排序也通用通过NativeSearchQueryBuilder完成： 12345678910111213141516@Testpublic void testSort()&#123; // 构建查询条件 NativeSearchQueryBuilder queryBuilder = new NativeSearchQueryBuilder(); // 添加基本的分词查询 queryBuilder.withQuery(QueryBuilders.termQuery("category", "手机")); // 排序 queryBuilder.withSort(SortBuilders.fieldSort("price").order(SortOrder.DESC)); // 执行搜索，获取结果 Page&lt;Item&gt; items = this.itemRepository.search(queryBuilder.build()); // 打印总条数 System.out.println(items.getTotalElements()); items.forEach(System.out::println);&#125; 结果： 5.7.聚合5.7.1.聚合为桶桶就是分组，比如这里我们按照品牌brand进行分组： 12345678910111213141516171819202122232425262728293031@Test public void testAgg()&#123; NativeSearchQueryBuilder queryBuilder = new NativeSearchQueryBuilder(); // 不查询任何结果 queryBuilder.withSourceFilter(new FetchSourceFilter(new String[]&#123;""&#125;, null)); // 1、添加一个新的聚合，聚合类型为terms，聚合名称为popularBrand，聚合字段为brand queryBuilder.addAggregation(AggregationBuilders.terms("popularBrand").field("brand")); // 2、查询,需要把结果强转为AggregatedPage类型 //AggregatedPage&lt;Item&gt; aggPage = (AggregatedPage&lt;Item&gt;) this.itemRepository.search(queryBuilder.build()); AggregatedPage&lt;Item&gt; aggPage = elasticsearchTemplate.queryForPage(queryBuilder.build(), Item.class); // 3、解析 // 3.1、从结果中取出名为brands的那个聚合， // 因为是利用String类型字段来进行的term聚合，所以结果要强转为StringTerm类型 Aggregations aggs = aggPage.getAggregations(); StringTerms terms = aggs.get("popularBrand"); // 3.2、获取桶 List&lt;StringTerms.Bucket&gt; buckets = terms.getBuckets(); // 3.3、遍历 for (StringTerms.Bucket bucket : buckets) &#123; // 3.4、获取桶中的key，即品牌名称 System.out.println("key = "+bucket.getKeyAsString()); // 3.5、获取桶中的文档数量 System.out.println("docCount = "+bucket.getDocCount()); &#125; &#125; 显示的结果： 关键API： AggregationBuilders：聚合的构建工厂类。所有聚合都由这个类来构建，看看他的静态方法： AggregatedPage：聚合查询的结果类。它是Page&lt;T&gt;的子接口： AggregatedPage在Page功能的基础上，拓展了与聚合相关的功能，它其实就是对聚合结果的一种封装，大家可以对照聚合结果的JSON结构来看。 而返回的结果都是Aggregation类型对象，不过根据字段类型不同，又有不同的子类表示 我们看下页面的查询的JSON结果与Java类的对照关系： 5.7.2.嵌套聚合，求平均值代码： 1234567891011121314151617181920212223242526272829@Testpublic void testSubAgg()&#123; NativeSearchQueryBuilder queryBuilder = new NativeSearchQueryBuilder(); // 不查询任何结果 queryBuilder.withSourceFilter(new FetchSourceFilter(new String[]&#123;""&#125;, null)); // 1、添加一个新的聚合，聚合类型为terms，聚合名称为brands，聚合字段为brand queryBuilder.addAggregation( AggregationBuilders.terms("brands").field("brand") .subAggregation(AggregationBuilders.avg("priceAvg").field("price")) // 在品牌聚合桶内进行嵌套聚合，求平均值 ); // 2、查询,需要把结果强转为AggregatedPage类型 AggregatedPage&lt;Item&gt; aggPage = (AggregatedPage&lt;Item&gt;) this.itemRepository.search(queryBuilder.build()); // 3、解析 // 3.1、从结果中取出名为brands的那个聚合， // 因为是利用String类型字段来进行的term聚合，所以结果要强转为StringTerm类型 StringTerms agg = (StringTerms) aggPage.getAggregation("brands"); // 3.2、获取桶 List&lt;StringTerms.Bucket&gt; buckets = agg.getBuckets(); // 3.3、遍历 for (StringTerms.Bucket bucket : buckets) &#123; // 3.4、获取桶中的key，即品牌名称 3.5、获取桶中的文档数量 System.out.println(bucket.getKeyAsString() + "，共" + bucket.getDocCount() + "台"); // 3.6.获取子聚合结果： InternalAvg avg = (InternalAvg) bucket.getAggregations().asMap().get("priceAvg"); System.out.println("平均售价：" + avg.getValue()); &#125;&#125; 结果：]]></content>
      <categories>
        <category>项目实战-微服务商城</category>
        <category>Elasticsearch</category>
      </categories>
      <tags>
        <tag>Elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务商城（十）——商品管理二]]></title>
    <url>%2Fday09-%E5%95%86%E5%93%81%E7%AE%A1%E7%90%86.html</url>
    <content type="text"><![CDATA[独立实现商品新增后台 独立实现商品编辑后台 独立搭建前台系统页面 1.商品新增1.1.页面预览当我们点击新增商品按钮： 就会出现一个弹窗： 里面把商品的数据分为了4部分来填写： 基本信息：主要是一些简单的文本数据，包含了SPU和SpuDetail的部分数据，如 商品分类：是SPU中的cid1，cid2，cid3属性 品牌：是spu中的brandId属性 标题：是spu中的title属性 子标题：是spu中的subTitle属性 售后服务：是SpuDetail中的afterService属性 包装列表：是SpuDetail中的packingList属性 商品描述：是SpuDetail中的description属性，数据较多，所以单独放一个页面 规格参数：商品规格信息，对应SpuDetail中的genericSpec属性 SKU属性：spu下的所有Sku信息 对应到页面中的四个stepper-content： 1.2.弹窗事件弹窗是一个独立组件： 并且在Goods组件中已经引用它： 并且在GoodsForm.vue页面中渲染： 在新增商品按钮的点击事件中，改变这个dialog的show属性： 1.3.基本数据我们先来看下基本数据： 1.3.1.商品分类商品分类信息查询我们之前已经做过，所以这里的级联选框已经实现完成： 刷新页面，可以看到请求已经发出： 效果： 1.3.2.品牌选择1.3.2.1页面品牌也是一个下拉选框，不过其选项是不确定的，只有当用户选择了商品分类，才会把这个分类下的所有品牌展示出来。 所以页面编写了watch函数，监控商品分类的变化，每当商品分类值有变化，就会发起请求，查询品牌列表： 选择商品分类后，可以看到请求发起： 接下来，我们只要编写后台接口，根据商品分类id，查询对应品牌即可。 1.2.2.2后台接口页面需要去后台查询品牌信息，我们自然需要提供： 请求方式：GET 请求路径：/brand/cid/{cid} 请求参数：cid 响应数据：List 涉及的表：tb_brand，tb_category_brand BrandController 12345678910/** * 根据商品分类cid查询品牌分类 * 涉及tb_brand，tb_category_brand表 * @param cid * @return */ @GetMapping("cid/&#123;cid&#125;")public ResponseEntity&lt;List&lt;Brand&gt;&gt; queryBrandByCid(@PathVariable("cid")Long cid)&#123; return ResponseEntity.ok(brandService.queryBrandByCid(cid)); &#125; BrandService 在BrandService中 12345678910111213/** * 根据商品分类cid查询品牌分类 * 涉及tb_brand，tb_category_brand表 * @param cid * @return */public List&lt;Brand&gt; queryBrandByCid(Long cid) &#123; List&lt;Brand&gt; brands = brandMapper.queryBrandByCid(cid); if (CollectionUtils.isEmpty(brands))&#123; throw new LyException(ExceptionEnums.BRAND_NOT_FOUND); &#125; return brands;&#125; BrandMapper 根据分类查询品牌有中间表，需要自己编写Sql： 12@Select("SELECT * FROM tb_brand WHERE id IN (SELECT brand_id FROM tb_category_brand WHERE category_id = #&#123;cid&#125;)") List&lt;Brand&gt; queryBrandByCid(@Param("cid")Long cid); 效果： 1.3.3.其它文本框GoodsForm.vue剩余的几个属性：标题、子标题等都是普通文本框，我们直接填写即可，没有需要特别注意的。 1.4.商品描述商品描述信息比较复杂，而且图文并茂，甚至包括视频。 这样的内容，一般都会使用富文本编辑器。 1.4.1.什么是富文本编辑器百度百科： 通俗来说：富文本，就是比较丰富的文本编辑器。普通的框只能输入文字，而富文本还能给文字加颜色样式等。 富文本编辑器有很多，例如：KindEditor、Ueditor。但并不原生支持vue 但是我们今天要说的，是一款支持Vue的富文本编辑器：vue-quill-editor 1.4.2.Vue-Quill-EditorGitHub的主页：https://github.com/surmon-china/vue-quill-editor Vue-Quill-Editor是一个基于Quill的富文本编辑器：Quill的官网 1.4.3.使用指南使用非常简单： 第一步：安装，使用npm命令： 1npm install vue-quill-editor --save 第二步：加载，在js中引入： 全局引入： 123456import Vue from 'vue'import VueQuillEditor from 'vue-quill-editor'const options = &#123;&#125;; /* &#123; default global options &#125; */Vue.use(VueQuillEditor, options); // options可选 局部引入： 1234567891011import 'quill/dist/quill.core.css'import 'quill/dist/quill.snow.css'import 'quill/dist/quill.bubble.css'import &#123;quillEditor&#125; from 'vue-quill-editor'var vm = new Vue(&#123; components:&#123; quillEditor &#125;&#125;) 我们这里采用局部引用： 第三步：页面使用： 1&lt;quill-editor v-model="goods.spuDetail.description" :options="editorOption"/&gt; 1.4.4.自定义的富文本编辑器不过这个组件有个小问题，就是图片上传的无法直接上传到后台，因此我们对其进行了封装，支持了图片的上传。 使用也非常简单： 在GoodsForm.vue中 1234&lt;!--2、商品描述--&gt;&lt;v-stepper-content step="2"&gt; &lt;v-editor v-model="goods.spuDetail.description" upload-url="/upload/image"/&gt;&lt;/v-stepper-content&gt; upload-url：是图片上传的路径 v-model：双向绑定，将富文本编辑器的内容绑定到goods.spuDetail.description 1.4.5.效果 1.5.商品规格参数规格参数的查询我们之前也已经编写过接口，因为商品规格参数也是与商品分类绑定，所以需要在商品分类变化后去查询，我们也是通过watch监控来实现： 可以看到这里是根据商品分类id查询规格参数：SpecParam。我们之前写过一个根据gid（分组id）来查询规格参数的接口，我们接下来完成根据分类id查询规格参数。 改造查询规格参数接口 修改SpecificationController中的queryParamByGid( )改成queryParamByList( ) 我们在原来的根据 gid（规格组id)查询规格参数的接口上，添加一个参数：cid，即商品分类id。 等一下， 考虑到以后可能还会根据是否搜索、是否为通用属性等条件过滤，我们多添加generic、searching 过滤条件： 12345678910111213141516171819/** * 通过规格组的gid查询规格参数 * 通过商品分类cid查询规格参数 * required=false：表示不传值的时候给null * @param gid 规格组id * @param cid 商品分类id * @param searching 是否用于搜索关键字 * @param generic 是否是sku通用属性 * @return */ @GetMapping("params") public ResponseEntity&lt;List&lt;SpecParam&gt;&gt; queryParamByList( @RequestParam(value = "gid",required = false) Long gid, @RequestParam(value = "cid",required = false)Long cid, @RequestParam(value = "searching",required = false)Boolean searching, @RequestParam(value="generic", required = false) Boolean generic ) &#123; return ResponseEntity.ok(specificationService.queryParamByList(gid,cid,searching,generic)); &#125; 改造service： 修改SpecificationService 12345678910111213141516171819202122/** * 通过规格组的gid查询规格参数 * 通过商品分类cid查询规格参数 * required=false：表示不传值的时候给null * @param gid 规格组id * @param cid 商品分类id * @param searching 是否用于搜索关键字 * @param generic 是否是sku通用属性 * @return */ public List&lt;SpecParam&gt; queryParamByList(Long gid,Long cid,Boolean searching,Boolean generic) &#123; SpecParam param = new SpecParam(); param.setGroupId(gid); param.setCid(cid); param.setSearching(searching); param.setGeneric(generic); List&lt;SpecParam&gt; list = specParamMapper.select(param); if (CollectionUtils.isEmpty(list))&#123; throw new LyException(ExceptionEnums.SPEC_PARAM_NOT_FOUND); &#125; return list; &#125; 如果param中有属性为null，则不会吧属性作为查询条件，因此该方法具备通用性，即可根据gid查询，也可根据cid查询。 测试： 刷新页面测试： 1.6.SKU信息Sku属性是SPU下的每个商品的不同特征，如图： 当我们填写一些属性后，会在页面下方生成一个sku表格，大家可以计算下会生成多少个不同属性的Sku呢？ 当你选择了上图中的这些选项时： 颜色共2种：迷夜黑，勃艮第红，绚丽蓝 内存共2种：4GB，6GB 机身存储1种：64GB，128GB 此时会产生多少种SKU呢？ 应该是 3 2 2 = 12种，这其实就是在求笛卡尔积。 我们会在页面下方生成一个sku的表格： 1.7.页面表单提交在sku列表的下方，有一个提交按钮： 并且绑定了点击事件： 点击后会组织数据并向后台提交： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465submit() &#123; // 表单校验。 if(!this.$refs.basic.validate)&#123; this.$message.error("请先完成表单内容！"); &#125; // 先处理goods，用结构表达式接收,除了categories外，都接收到goodsParams中 const &#123; categories: [&#123; id: cid1 &#125;, &#123; id: cid2 &#125;, &#123; id: cid3 &#125;], ...goodsParams &#125; = this.goods; // 处理规格参数 const specs = &#123;&#125;; this.specs.forEach((&#123; id,v &#125;) =&gt; &#123; specs[id] = v; &#125;); // 处理特有规格参数模板 const specTemplate = &#123;&#125;; this.specialSpecs.forEach((&#123; id, options &#125;) =&gt; &#123; specTemplate[id] = options; &#125;); // 处理sku const skus = this.skus .filter(s =&gt; s.enable) .map((&#123; price, stock, enable, images, indexes, ...rest &#125;) =&gt; &#123; // 标题，在spu的title基础上，拼接特有规格属性值 const title = goodsParams.title + " " + Object.values(rest).map(v =&gt; v.v).join(" "); const obj = &#123;&#125;; Object.values(rest).forEach(v =&gt; &#123; obj[v.id] = v.v; &#125;); return &#123; price: this.$format(price), // 价格需要格式化 stock, indexes, enable, title, // 基本属性 images: images ? images.join(",") : '', // 图片 ownSpec: JSON.stringify(obj) // 特有规格参数 &#125;; &#125;); Object.assign(goodsParams, &#123; cid1, cid2, cid3, // 商品分类 skus // sku列表 &#125;); goodsParams.spuDetail.genericSpec = JSON.stringify(specs); goodsParams.spuDetail.specialSpec = JSON.stringify(specTemplate); // 提交到后台 this.$http(&#123; method: this.isEdit ? "put" : "post", url: "/item/goods", data: goodsParams &#125;) .then(() =&gt; &#123; // 成功，关闭窗口 this.$emit("close"); // 提示成功 this.$message.success("保存成功了"); &#125;) .catch(() =&gt; &#123; this.$message.error("保存失败！"); &#125;);&#125; 点击提交，查看控制台提交的数据格式： 整体是一个json格式数据，包含Spu表所有数据： brandId：品牌id cid1、cid2、cid3：商品分类id subTitle：副标题 title：标题 spuDetail：是一个json对象，代表商品详情表数据 afterService：售后服务 description：商品描述 packingList：包装列表 specialSpec：sku规格属性模板 genericSpec：通用规格参数 skus：spu下的所有sku数组，元素是每个sku对象： title：标题 images：图片 price：价格 stock：库存 ownSpec：特有规格参数 indexes：特有规格参数的下标 1.8.后台实现1.8.1.实体类SPU和SpuDetail实体类已经添加过，添加Sku和Stock对象： Sku 123456789101112131415161718@Data@Table(name = "tb_sku")public class Sku &#123; @Id @KeySql(useGeneratedKeys = true) private Long id; private Long spuId; private String title; private String images; private Long price; private String ownSpec;// 商品特殊规格的键值对 private String indexes;// 商品特殊规格的下标 private Boolean enable;// 是否有效，逻辑删除用 private Date createTime;// 创建时间 private Date lastUpdateTime;// 最后修改时间 @Transient private Integer stock;// 库存&#125; 注意：这里保存了一个库存字段，在数据库中是另外一张表保存的，方便查询。 Stock 123456789@Data@Table(name = "tb_stock")public class Stock &#123; @Id private Long skuId; private Integer seckillStock;// 秒杀可用库存 private Integer seckillTotal;// 已秒杀数量 private Integer stock;// 正常库存&#125; 1.8.2.GoodsController请求方式：POST 请求路径：/goods 请求参数：Spu的json格式的对象，spu中包含spuDetail和Sku集合。这里我们该怎么接收？我们之前定义了一个Spu对象，作为业务对象。这里也可以用它，不过需要再扩展spuDetail和skus字段： 123456789101112131415@Table(name = "tb_spu")@Datapublic class Spu &#123; //新添加的skus、spuDetail @Transient private List&lt;Sku&gt; skus; @Transient SpuDetail spuDetail;// 商品详情 // 省略getter和setter&#125; 返回类型：无 代码： 1234567891011/** * 新增商品信息 * 涉及表：tb_spu，tb_sku，tb_stock，tb_spu_detail * @param spu * @return */@PostMapping("goods")public ResponseEntity&lt;Void&gt; saveGoods(@RequestBody Spu spu)&#123; goodsService.saveGoods(spu); return ResponseEntity.status(HttpStatus.OK).build();&#125; 注意：通过@RequestBody注解来接收Json请求 1.8.3.GoodsService这里的逻辑比较复杂，我们除了要对SPU新增以外，还要对SpuDetail、Sku、Stock进行保存 1234567891011121314151617181920212223public void saveGoods(Spu spu) &#123; //新增spu spu.setCreateTime(new Date()); spu.setLastUpdateTime(spu.getCreateTime()); spu.setSaleable(true); spu.setValid(true); int insert = spuMapper.insert(spu); if (insert!=1)&#123; throw new LyException(ExceptionEnums.BRAND_NOT_FOUND); &#125; //新增detail SpuDetail spuDetail = spu.getSpuDetail(); spuDetail.setSpuId(spu.getId()); int insert1 = spuDetailMapper.insert(spuDetail); if (insert1!=1)&#123; throw new LyException(ExceptionEnums.SPU_ADD_ERROR); &#125; //抽离出来的新增sku和stock方法 AddSkuAndStock(spu); &#125; AddSkuAndStock() 123456789101112131415161718192021//新增sku和stockprivate void saveSkuAndStock(Spu spu) &#123; //新增sku List&lt;Stock&gt; stockList=new ArrayList&lt;&gt;(); List&lt;Sku&gt; skus = spu.getSkus(); for (Sku sku : skus) &#123; sku.setCreateTime(new Date()); sku.setLastUpdateTime(sku.getCreateTime()); sku.setSpuId(spu.getId()); int insert2 = skuMapper.insert(sku); if (insert2!=1)&#123; throw new LyException(ExceptionEnums.SKU_ADD_ERROR); &#125; Stock stock = new Stock(); stock.setSkuId(sku.getId()); stock.setStock(sku.getStock()); stockMapper.insert(stock); &#125;&#125; 在ly-common中的vo创建BaseMapper 自定义的mapper，IdListMapper&lt;T,Long&gt;,InsertListMapper&lt;T&gt;批量处理 T：表示要实现的pojo 123@RegisterMapperpublic interface BaseMapper&lt;T&gt; extends Mapper&lt;T&gt;,IdListMapper&lt;T,Long&gt;,InsertListMapper&lt;T&gt; &#123;&#125; 1.8.4.Mapper12public interface SkuMapper extends BaseMapper&lt;Sku&gt; &#123;&#125; StockMapper继承自定义的BaseMapper 12public interface StockMapper extends BaseMapper&lt;Stock&gt; &#123;&#125; 2.商品修改2.1.编辑按钮点击事件在商品详情页，每一个商品后面，都会有一个编辑按钮： 点击这个按钮，就会打开一个商品编辑窗口，我们看下它所绑定的点击事件： 对应的方法： 可以看到这里发起了两个请求，在查询商品详情和sku信息。 因为在商品列表页面，只有spu的基本信息：id、标题、品牌、商品分类等。比较复杂的商品详情（spuDetail)和sku信息都没有，编辑页面要回显数据，就需要查询这些内容。 因此，接下来我们就编写后台接口，提供查询服务接口。 2.2.查询SpuDetail接口 GoodsController 需要分析的内容： 请求方式：GET 请求路径：/spu/detail/{id} 请求参数：id，应该是spu的id 返回结果：SpuDetail对象 12345678910/** * 根据spuid查询商品详情(回显) * @param spuId * @return */@GetMapping("spu/detail/&#123;id&#125;")public ResponseEntity&lt;SpuDetail&gt; queryDetailBySpuId(@PathVariable("id")Long spuId)&#123; return ResponseEntity.ok(goodsService.queryDetailBySpuId(spuId));&#125; GoodsService 1234567public SpuDetail queryDetailBySpuId(Long spuId) &#123; SpuDetail spuDetail = spuDetailMapper.selectByPrimaryKey(spuId); if (spuDetail==null)&#123; throw new LyException(ExceptionEnums.SPU_DETAIL_NOT_FOUND); &#125; return spuDetail; &#125; 测试 2.3.查询sku 分析 请求方式：Get 请求路径：/sku/list 请求参数：id，应该是spu的id 返回结果：sku的集合 GoodsController 123456789/** * 根据spuid查询sku(回显) * @param spuId * @return */@GetMapping("sku/list")public ResponseEntity&lt;List&lt;Sku&gt;&gt; querySkuByid(@RequestParam("id")Long spuId)&#123; return ResponseEntity.ok(goodsService.querySkuByid(spuId));&#125; GoodsService 需要注意的是，为了页面回显方便，我们一并把sku的库存stock也查询出来 12345678910public List&lt;Sku&gt; querySkuByid(Long spuId) &#123; Sku sku = new Sku(); sku.setSpuId(spuId); List&lt;Sku&gt; skuLists = skuMapper.select(sku); for (Sku skuList : skuLists) &#123; Stock stock = stockMapper.selectByPrimaryKey(skuList.getId()); sku.setStock(stock.getStock()); &#125; return skuLists;&#125; 测试： 2.4.页面回显随便点击一个编辑按钮，发现数据回显完成： 2.5.页面提交这里的保存按钮与新增其实是同一个，因此提交的逻辑也是一样的，这里不再赘述。 随便修改点数据，然后点击保存，可以看到浏览器已经发出请求： 2.6.后台实现接下来，我们编写后台，实现修改商品接口。 2.6.1.Controller 请求方式：PUT 请求路径：/ 请求参数：Spu对象 返回结果：无 1234567891011/** * 修改商品信息 * 涉及表：tb_spu，tb_sku，tb_stock，tb_spu_detail * @param spu * @return */@PutMapping("goods")public ResponseEntity&lt;Void&gt; uploadGoods(@RequestBody Spu spu)&#123; goodsService.uploadGoods(spu); return ResponseEntity.status(HttpStatus.NO_CONTENT).build();&#125; 2.6.2.Servicespu数据可以修改，但是SKU数据无法修改，因为有可能之前存在的SKU现在已经不存在了，或者以前的sku属性都不存在了。比如以前内存有4G，现在没了。 因此这里直接删除以前的SKU，然后新增即可。 代码： 12345678910111213141516171819202122232425262728293031@Transactional public void uploadGoods(Spu spu) &#123; if (spu.getId()==null)&#123; throw new LyException(ExceptionEnums.SPU_ID_NOT_NULL); &#125; //查询sku Sku sku = new Sku(); sku.setSpuId(spu.getId()); List&lt;Sku&gt; skuList = skuMapper.select(sku); if (!CollectionUtils.isEmpty(skuList)) &#123; //删除sku skuMapper.delete(sku); //获取sku的id集合 List&lt;Long&gt; ids = skuList.stream().map(Sku::getId).collect(Collectors.toList()); //删除stock stockMapper.deleteByIdList(ids); &#125; // 更新spu spu.setLastUpdateTime(new Date()); spu.setCreateTime(null); spu.setValid(null); spu.setSaleable(null); int count = spuMapper.updateByPrimaryKeySelective(spu); if(count!=1)&#123; throw new LyException(ExceptionEnums.GOODS_UPDATE_ERROR); &#125; //修改detail spuDetailMapper.updateByPrimaryKeySelective(spu.getSpuDetail()); //新增sku和stock saveSkuAndStock(spu); &#125; 2.6.3.mapper与以前一样。 2.7.商品删除 前端分析： 查看==Goods.vue== 点击删除deleteGood事件 后台 controller 在==GoodsController== 分析： 请求方式：PUT 请求路径：/spec/delete 请求参数：spuId 返回值：void 123456789101112/** * 通过spuId删除 * 涉及表：tb_spu，tb_sku，tb_stock，tb_spu_detail * @param spuId * @return */@ResponseBody@PutMapping("spu/delete/&#123;id&#125;")public ResponseEntity&lt;Void&gt; deleteGood(@PathVariable("id")Long spuId)&#123; goodsService.deleteGood(spuId); return ResponseEntity.status(HttpStatus.OK).build();&#125; service 在==GoodsService== 123456789101112131415161718192021222324252627282930313233343536@Transactionalpublic void deleteGood(Long spuId) &#123; //查询sku Sku sku = new Sku(); sku.setSpuId(spuId); //查询到skuList List&lt;Sku&gt; skuList = skuMapper.select(sku); //判断skuList是否存在 if (!CollectionUtils.isEmpty(skuList))&#123; //删除sku skuMapper.delete(sku); &#125; //得到sku的ids集合 List&lt;Long&gt; ids = skuList.stream().map(Sku::getId).collect(Collectors.toList()); //查询库存stocks List&lt;Stock&gt; stocks = stockMapper.selectByIdList(ids); //判断是否存在 if (!CollectionUtils.isEmpty(stocks)) &#123; //删除stocks stockMapper.deleteByIdList(ids); &#125; //查询商品详情 SpuDetail spuDetail = spuDetailMapper.selectByPrimaryKey(spuId); if (spuDetail!=null) &#123; //删除商品详情 spuDetailMapper.deleteByPrimaryKey(spuId); &#125; //查询spu Spu spu = spuMapper.selectByPrimaryKey(spuId); if (spu!=null) &#123; //删除spu spuMapper.deleteByPrimaryKey(spuId); &#125;&#125; 2.8.商品的上架下架 前端分析： 查看==Goods.vue== 上架 GoodsController 分析： 请求方式：PUT 请求路径：/spec/up/{id} 请求参数：spuId 返回值：void 12345678910/** * 商品上架 * @param spuId * @return */ @PutMapping("spu/up/&#123;id&#125;") public ResponseEntity&lt;Void&gt; upGood(@PathVariable("id")Long spuId)&#123; goodsService.upGood(spuId); return ResponseEntity.status(HttpStatus.OK).build(); &#125; GoodService 123456 public void upGood(Long spuId) &#123; Spu spu = new Spu(); spu.setSaleable(true); spu.setId(spuId); spuMapper.updateByPrimaryKeySelective(spu);&#125; 下架 前端分析： 查看==SpecParam.vue== 后台 GoodController 分析： 请求方式：POST 请求路径：spu/down/{id} 请求参数：spuId 返回值：void 12345678910/** * 商品下架 * @param spuId * @return */@PostMapping("spu/down/&#123;id&#125;")public ResponseEntity&lt;Void&gt; downGood(@PathVariable("id")Long spuId)&#123; goodsService.downGood(spuId); return ResponseEntity.status(HttpStatus.OK).build();&#125; GoodService 123456public void downGood(Long spuId) &#123; Spu spu = new Spu(); spu.setSaleable(false); spu.setId(spuId); spuMapper.updateByPrimaryKeySelective(spu);&#125; 3.搭建前台系统后台系统的内容暂时告一段落，有了商品，接下来我们就要在页面展示商品，给用户提供浏览和购买的入口，那就是我们的门户系统。 门户系统面向的是用户，安全性很重要，而且搜索引擎对于单页应用并不友好。因此我们的门户系统不再采用与后台系统类似的SPA（单页应用）。 依然是前后端分离，不过前端的页面会使用独立的html，在每个页面中使用vue来做页面渲染。 3.1.静态资源webpack打包多页应用配置比较繁琐，项目结构也相对复杂。这里为了简化开发（毕竟我们不是专业的前端人员），我们不再使用webpack，而是直接编写原生的静态HTML。 3.1.1.导入工程3.1.2.导入静态资源将课前资料中的leyou-portal解压，并复制到这个项目下 解压缩： 项目结构： 3.2.live-server没有webpack，我们就无法使用webpack-dev-server运行这个项目，实现热部署。 所以，这里我们使用另外一种热部署方式：live-server， 3.2.1.简介地址；https://www.npmjs.com/package/live-server 这是一款带有热加载功能的小型开发服务器。用它来展示你的HTML / JavaScript / CSS，但不能用于部署最终的网站。 3.2.2.安装和运行参数安装，使用npm命令即可，这里建议全局安装，以后任意位置可用 1npm install -g live-server 运行时，直接输入命令： 1live-server 另外，你可以在运行命令后，跟上一些参数以配置： --port=NUMBER - 选择要使用的端口，默认值：PORT env var或8080 --host=ADDRESS - 选择要绑定的主机地址，默认值：IP env var或0.0.0.0（“任意地址”） --no-browser - 禁止自动Web浏览器启动 --browser=BROWSER - 指定使用浏览器而不是系统默认值 --quiet | -q - 禁止记录 --verbose | -V - 更多日志记录（记录所有请求，显示所有侦听的IPv4接口等） --open=PATH - 启动浏览器到PATH而不是服务器root --watch=PATH - 用逗号分隔的路径来专门监视变化（默认值：观看所有内容） --ignore=PATH- 要忽略的逗号分隔的路径字符串（anymatch -compatible definition） --ignorePattern=RGXP-文件的正则表达式忽略（即.*\.jade）（不推荐使用赞成--ignore） --middleware=PATH - 导出要添加的中间件功能的.js文件的路径; 可以是没有路径的名称，也可以是引用middleware文件夹中捆绑的中间件的扩展名 --entry-file=PATH - 提供此文件（服务器根目录）代替丢失的文件（对单页应用程序有用） --mount=ROUTE:PATH - 在定义的路线下提供路径内容（可能有多个定义） --spa - 将请求从/ abc转换为/＃/ abc（方便单页应用） --wait=MILLISECONDS - （默认100ms）等待所有更改，然后重新加载 --htpasswd=PATH - 启用期待位于PATH的htpasswd文件的http-auth --cors - 为任何来源启用CORS（反映请求源，支持凭证的请求） --https=PATH - 到HTTPS配置模块的路径 --proxy=ROUTE:URL - 代理ROUTE到URL的所有请求 --help | -h - 显示简洁的使用提示并退出 --version | -v - 显示版本并退出 3.2.3.测试我们进入leyou-portal目录，输入命令： 1live-server --port=9002 3.3.域名访问现在我们访问只能通过：http://127.0.0.1:9002 我们希望用域名访问：http://www.leyou.com 第一步，修改hosts文件，添加一行配置： 1192.168.25.153 www.leyou.com 第二步，修改nginx配置，将www.leyou.com反向代理到192.168.25.153:9002 123456789101112131415161718192021 server&#123; listen 9002; server_name www.leyou.com; location /&#123; proxy_pass http://192.168.1.104:9002; &#125; &#125; server &#123; listen 80; server_name www.leyou.com; proxy_set_header X-Forwarded-Host $host; proxy_set_header X-Forwarded-Server $host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; location / &#123;proxy_pass http://192.168.1.104:9002;proxy_connect_timeout 600;proxy_read_timeout 600; &#125; &#125; 重新加载nginx配置：nginx -s reload 3.4.common.js为了方便后续的开发，我们在前台系统中定义了一些工具，放在了common.js中： 部分代码截图： 首先对axios进行了一些全局配置，请求超时时间，请求的基础路径，是否允许跨域操作cookie等 定义了对象 ly ，也叫leyou，包含了下面的属性： getUrlParam(key)：获取url路径中的参数 http：axios对象的别名。以后发起ajax请求，可以用ly.http.get() store：localstorage便捷操作，后面用到再详细说明 formatPrice：格式化价格，如果传入的是字符串，则扩大100被并转为数字，如果传入是数字，则缩小100倍并转为字符串 formatDate(val, pattern)：对日期对象val按照指定的pattern模板进行格式化 stringify：将对象转为参数字符串 parse：将参数字符串变为js对象]]></content>
      <categories>
        <category>项目实战-微服务商城</category>
      </categories>
      <tags>
        <tag>FastDFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务商城（十）——商品管理一]]></title>
    <url>%2Fday08-%E5%95%86%E5%93%81%E7%AE%A1%E7%90%86.html</url>
    <content type="text"><![CDATA[商品规格都在ly-item中操作 了解商品规格数据结构设计思路 实现商品规格查询 了解SPU和SKU数据结构设计思路 实现商品查询 了解商品新增的页面实现 独立编写商品新增后台功能 1.商品规格数据结构商品中都有属性，不同商品，属性往往不同，这一部分数据很重要，我们一起看看： 1.1.规格属性内容我们看下京东中商品的规格属性： 一款华为手机属性： 一款空调的属性： 我们发现，不同商品的属性名称竟然不同，假如我们要把属性放入一张表去保存，表字段该如何设计别着急，我们在看另一个手机属性： 三星手机： 我们发现，虽然不同商品，规格不同，但是同一分类的商品，比如都是手机，其规格是一致，但是值不一样，也就是说，商品的规格参数应该是与分类绑定。每一个分类都有统一的规格参数模板，但不同商品其参数值可能不同。 因此： 规格参数的名称（key）与值（value）应该分开来保存 一个分类，对应一套规格参数模板，只有规格参数key，没有值 一个分类对应多个商品，每个商品的规格值不同，每个商品对应一套规格的值 1.2.横表和竖表值我们暂且不管，新增商品时，在来填写规格参数值，我们考虑规格参数模板（key）该如何设计 来看下规格参数的结构： 规格数据首先要分组，组内再有不同的规格参数 不同分类，其分组名称不同 不同分类，组内属性也不同 这样就意味着:有多少分类，就有多少分组，至少有数千数据，组内属性也是一样，数量更多。如果按照传统设计，我们会以规格参数作为数据库字段名，如品牌、型号等都是字段，那么表的字段会无限多。这样的表称为横表。一条信息，描述所有数据。例如: id 品牌 型号 入网型号 上市时间 上市月份 机身颜色 机身长度 1 华为 P20 LLD_AL20 2018 2 红 190 我们不这么做，我们一条信息，只描述一条规格属性，也就是把规格参数作为字段的值，而非字段本身，这样设计称为竖表设计例如： id 分类id 参数名称 1 1 品牌 2 1 型号 3 1 入网型号 4 1 上市时间 5 1 上市月份 6 1 机身颜色 7 1 机身长度 不过，规格和规格组也要单独保存，都采用竖表设计。所以我们有两张表: 规格组: tb_ spec group 一个商品分类下有多个规格组 规格参数: tb_ spec_ param 一个规格组下，有多个规格参数 1.3.规格参数表1.3.1.规格组 规格参数分组tb_spec_group： 1234567CREATE TABLE `tb_spec_group` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &apos;主键&apos;, `cid` bigint(20) NOT NULL COMMENT &apos;商品分类id，一个分类下有多个规格组&apos;, `name` varchar(50) NOT NULL COMMENT &apos;规格组的名称&apos;, PRIMARY KEY (`id`), KEY `key_category` (`cid`)) ENGINE=InnoDB AUTO_INCREMENT=14 DEFAULT CHARSET=utf8 COMMENT=&apos;规格参数的分组表，每个商品分类下有多个规格参数组&apos; 规格组有3个字段 id：主键 cid：商品分类id，一个分类下有多个模板 name ：该规格组的名称 1.3.2.规格参数表1234567891011121314CREATE TABLE tb_spec_param ( `id` BIGINT(20) NOT NULL AUTO_INCREMENT COMMENT &apos;主键&apos;, `cid` BIGINT(20) NOT NULL COMMENT &apos;商品分类id&apos;, `group_id` BIGINT(20) NOT NULL , `name` VARCHAR(255) NOT NULL COMMENT &apos;参数名&apos;,`numeric` TINYINT(1) NOT NULL COMMENT &apos;是否为数字类型参数,true或false&apos;, `unit` VARCHAR(255) DEFAULT &apos;&apos; COMMENT &apos;数字类型参数单位,非数字类型可以为空&apos;, `generic` TINYINT(1) NOT NULL COMMENT &apos;是否为sku通用属性,true或false&apos;, `searching` TINYINT(1) NOT NULL COMMENT &apos;是否用于搜索过滤,true或false&apos;, `segments` VARCHAR(1000) DEFAULT &apos;&apos; COMMENT &apos;数值类型参数,如果需要搜索,则添加分段间隔值,如cpu频率间隔&apos;, PRIMARY KEY (`id`), KEY `key_group` (`group_id`), KEY `key_category` (`cid`)) ENGINE=INNODB AUTO_INCREMENT=24 DEFAULT CHARSET=utf8 COMMENT=&apos;规格参数组下的参数名&apos;; 1.3.2.1数值类型基本信息中由机身长度，宽度，厚度 我们有两个字段来描述： numberic：是否为数值类型 true：数字类型 false：不是数值类型 unit：参数的单位 ###1.3.2.2.打开一个搜索页，我们来看看过滤的条件： 你会发现，过滤条件中的屏幕尺寸、运行内存、网路、机身内存、电池容量、CPU核数等，在规格参数中都能找到： 也就是说，规格参数中的数据，将来会有一部分作为搜索条件来使用。我们可以在设计时，将这部分属性标记出来，将来做搜索的时候，作为过滤条件。 与搜索相关的两个字段： searching：标记是否用作过滤 true：用于过滤搜索 false：不用与过滤 segments：某些数值类型的参数，在搜索时需要按区间来划分，这里提前确定好划分区间 比如电池容量，0-2000mAh，2000mAh-3000mAh ， 3000mAh-4000mAh 乐优商城是一个全品类的电商网站，因此商品的种类多，没一件商品，其属性又有差别，为了更准确描述商品及细分差别，抽象出来两个概念，spu和sku： 1.3.2.3.通用属性 有一个generic属性，代表通用属性，我们在商品数据结构时在聊 2.商品规格参数管理2.1.页面实现页面比较复杂，这里就不带着大家去实现完整页面效果了，我们一起分析一下即可。 2.1.1.整体布局打开规格参数页面，看到如下内容： 点击手机后会去查表tb_spec_group中商品分类号为76的 因为规格是跟商品分类绑定的，因此首先会展现商品分类树，并且提示你要选择商品分类，才能看到规格参数的模板。一起了解下页面的实现： 这里使用v-layout来完成页面布局，并且添加了row属性，代表接下来的内容是行布局 可以看出页面分成3个部分： &lt;v-flex xs3&gt;：左侧，内部又分两部分：商品分类树和标题 v-card-title：标题部分，这里是提示信息，告诉用户要先选择分类，才能看到模板 v-tree：这里用到的是我们之前讲过的树组件，展示商品分类树，不过现在是假数据。 &lt;v-flex xs9 class=&quot;px-1&gt;&quot;： 右侧，内部是规格参数展示 2.1.2.右侧规格当我们点击一个分类时，最终要达到的效果 可以看到右侧分为上下两部分： 上部分：面包屑，显示当前选中分类 下部分：table，显示规格参数信息 可以看到右侧并不是我们熟悉的v-data-table，而是一个spec-group组件和spec-param组件，这是我们自定义的独立组件 在SpecGroup中定义了表格： 2.2规格组的查询2.2.1.规格组和规格参数的切换当我们点击规格参数组，表格中的数据会变为该组下的规格参数“ 两者怎么切换时如何实现的呢？ 我们看到spec-group和spec-pram中，通过v-show来控制显示，对应属性：showGroup showGroup为true，则展示分组；false，则展示组内参数 2.2.2.树节点的点击事件当我们点击树节点时，要将v-dialog打开，因此必须绑定一个点击事件： 我们来看下handleClick方法： 点击事件发生时，发生了两件事： 记录当前选中的节点，选中的就是商品分类 showGroup被置为true，则规格组就会显示 同时，我们把选中的节点（商品分类）的id传递给SpecGroup组件 2.2.3.页面查询规格组来看下SpecGroup.vue中实现： 我们查看页面控制台，可以看到请求已发 2.2.4.后端代码(规格组查询)在ly-item-interface中添加实体类： 实体类 123456789@Table(name = "tb_spec_group")@Datapublic class SpecGroup &#123; @Id @KeySql(useGeneratedKeys=true) private Long id; private Long cid; private String name;&#125; mapper 12public interface SpecGroupMapper extends Mapper&lt;SpecGroup&gt; &#123;&#125; controller 先分析下需要的东西，在页面的ajax请求中可以看出： 请求方式：查询，肯定是get 请求路径：/spec/groups/{cid} ，这里通过路径占位符传递商品分类的id 请求参数：商品分类id 返回结果：页面是直接把resp.data赋值给了specifications： 那么我们返回的应该是规格参数的字符串 代码： 1234567891011121314151617@RestController@RequestMapping("spec")public class SpecificationController &#123; @Autowired private SpecificationService specificationService; /** * 根据分类id查询规格组 * @param cid * @return */ @GetMapping("groups/&#123;cid&#125;") public ResponseEntity&lt;List&lt;SpecGroup&gt;&gt; queryGroupByCid(@PathVariable("cid")Long cid)&#123; return ResponseEntity.ok(specificationService.queryGroupByCid(cid)); &#125;&#125; service: 1234567891011121314151617@Servicepublic class SpecificationService &#123; @Autowired private SpecGroupMapper specGroupMapper; public List&lt;SpecGroup&gt; queryGroupByCid(Long cid) &#123; //查询条件 SpecGroup group = new SpecGroup(); group.setCid(cid); //查询 List&lt;SpecGroup&gt; list = specGroupMapper.select(group); if (CollectionUtils.isEmpty(list))&#123; //没查到 throw new LyException(ExceptionEnums.SPEC_GROUP_NOT_FOUND); &#125; return list; &#125;&#125; 页面访问测试： 查询的是tb_spec_group表 我们访问：http://api.leyou.com/api/item/spec/groups/76 然后在后台系统中测试： 2.3.规格组的增、删、改增删改的作业就留给大家去完成了。页面中接口都已定义，你要做的就是实现后台接口。 2.3.1.规格组的添加前端SpecGroup.vue： 注意： 我们在这里使用$qs.stringify来转换 JS的Object与QueryString，如此就可以将数据传输给后台 结果形如：name=jack&amp;age=21进行 ##controller： 在SpecificationController 12345678910/** * 新增规格组 * @param specGroup * @return */@PutMapping("group")public ResponseEntity&lt;Void&gt; addGroup(SpecGroup specGroup)&#123; specificationService.addGroup(specGroup); return ResponseEntity.status(HttpStatus.OK).build();&#125; ##service： 在SpecificationService 12345678/** * 新增规格组 * @param specGroup * @return */public void addGroup(SpecGroup specGroup) &#123; specGroupMapper.insert(specGroup);&#125; 2.3.2规格组的删除前端SpecGroup.vue controller 在SpecificationController 12345678910/** * 根据id删除规格组 * @param id * @return */@DeleteMapping("group/&#123;id&#125;")public ResponseEntity&lt;Void&gt; deleteGroup(@PathVariable("id")Long id)&#123; specificationService.deleteGroup(id); return ResponseEntity.status(HttpStatus.OK).build();&#125; service 在SpecificationService 123456789101112/** * 根据id删除规格组 * @param id */ public void deleteGroup(Long id) &#123; SpecGroup group = new SpecGroup(); group.setId(id); int delete = specGroupMapper.delete(group); if (delete!=1)&#123; throw new LyException(ExceptionEnums.SPEC_GROUP_DELETE_ERROR); &#125; &#125; 2.3.3规格组的修改前端SpecGroup.vue controller 在SpecificationController 1234567891011 /** * 修改规格组 * * @param specGroup * @return */@PutMapping("group")public ResponseEntity&lt;Void&gt; editGroup(SpecGroup specGroup) &#123; specificationService.editGroup(specGroup); return ResponseEntity.status(HttpStatus.OK).build();&#125; service 在SpecificationService 1234567891011/** * 修改规格组 * @param specGroup */ public void editGroup(SpecGroup specGroup) &#123; int update = specGroupMapper.updateByPrimaryKeySelective(specGroup); if (update!=1)&#123; throw new LyException(ExceptionEnums.SPEC_GROUP_UPLOAD_ERROR); &#125; &#125; 2.4.规格参数查询2.4.1.表格切换当我们点击规格组名称时，会切换到规格参数显示，在规格组中绑定了点击事件 前端页面 我们看下事件处理： 可以看到这里是使用了父子通信，子组件触发了select事件： 在看看父组件的事件绑定Specification.vue： selectGroup( ) 的方法处理： 这里我们记录选中的分组，并且标记设置为false，这样规格组就不显示，而是显示：SpecParam 并且我们把group也传递到spec-param组件中 2.4.2.页面查询规格参数我们来看==SpecParam.vue== 可以查看到控制台发起的请求： 2.4.3.后台实现 实体类 1234567891011121314151617@Data@Table(name = "tb_spec_param")public class SpecParam &#123; @Id @KeySql(useGeneratedKeys = true) private Long id; private Long cid; private Long groupId; private String name; @Column(name = "`numeric`") private Boolean numeric; private String unit; private Boolean generic; private Boolean searching; private String segments;&#125; @Column(name = “numeric“)，是将numeric变成字符串，==numeric==在sql是数据类型 controller 在==SpecificationController== 分析： 请求方式：GET 请求路径：/spec/params?gid= ( http://api.leyou.com/api/item/spec/params?gid=1) 请求参数：规格组gid ，规格分组cid 返回值：List 123456789/** * 通过规格组的gid查询规格参数 * @param gid * @return */@GetMapping("params")public ResponseEntity&lt;List&lt;SpecParam&gt;&gt; queryParamByGid(@RequestParam("gid")Long gid)&#123; return ResponseEntity.ok(specificationService.queryParamByGid(gid));&#125; service 在==SpecParamService== 123456789101112131415 /** * 通过规格组的gid查询规格参数 * @param gid * @return */ public List&lt;SpecParam&gt; queryParamByGid(Long gid) &#123; SpecParam param = new SpecParam(); param.setGroupId(gid); List&lt;SpecParam&gt; list = specParamMapper.select(param); if (CollectionUtils.isEmpty(list))&#123; throw new LyException(ExceptionEnums.SPEC_PARAM_NOT_FOUND); &#125; return list; &#125;&#125; mapper 12public interface SpecParamMapper extends Mapper&lt;SpecParam&gt; &#123;&#125; 2.5.规格参数添加，修改，删除2.5.1.规格参数的添加 前端分析： 查看==SpecParam.vue== 点击事件addParam()： 数据填写后提交事件save( ) ： 点击addParam事件：isEdi=false，restful：post 填写数据后，点击保存 通过==$qs.stringify==方法将数据转换成name=jack&amp;age=21………，这样就将数据传输给后台 controller 在==SpecificationController== 分析： 请求方式：POST 请求路径：/spec/param ( http://api.leyou.com/api/item/spec/param) 请求参数： 返回值：void 12345678910/** * 添加规格参数 * @param specParam * @return */ @PostMapping("param") public ResponseEntity&lt;Void&gt; addParam(SpecParam specParam)&#123; specificationService.addParam(specParam); return ResponseEntity.status(HttpStatus.OK).build(); &#125; service 在==SpecificationService== 1234567891011/** * 添加规格参数 * @param specParam * @return */public void addParam(SpecParam specParam) &#123; int insert = specParamMapper.insert(specParam); if (insert!=1)&#123; throw new LyException(ExceptionEnums.SPEC_PARAM_ADD_ERROR); &#125;&#125; 2.5.2.规格参数的修改 前端分析： 查看==SpecParam.vue== 点击修改editParam触发事件： this.param=param将数据回显this.isEdit = true传递到save事件后restful：put save事件 后台 controller 在==SpecificationController== 分析： 请求方式：PUT 请求路径：/spec/param (http://api.leyou.com/api/item/spec/param) 传递参数：specParam 返回值： 12345678910/** * 规格参数修改 * @param specParam * @return */@PutMapping("param")public ResponseEntity&lt;Void&gt; editParam(SpecParam specParam)&#123; specificationService.editParam(specParam); return ResponseEntity.status(HttpStatus.OK).build();&#125; service 在==SpecificationService== 1234567891011 /** * 规格参数修改 * @param specParam * @return */public void editParam(SpecParam specParam) &#123; int update = specParamMapper.updateByPrimaryKeySelective(specParam); if (update!=1)&#123; throw new LyException(ExceptionEnums.SPEC_PARAM_UPLOAD_ERROR); &#125;&#125; 2.5.3.规格参数的删除 前端分析： 查看==SpecParam.vue== 后台 controller 在==SpecificationController== 分析： 请求方式：DELETE 请求路径：/spec/param/{id} ( http://api.leyou.com/api/item/spec/param/id) 请求参数：id 返回值：void 12345678910/** * 根据id删除规格参数 * @param id * @return */@DeleteMapping("param")public ResponseEntity&lt;Void&gt; deleteParam(@PathVariable("id")Long id)&#123; specificationService.deleteParam(id); return ResponseEntity.status(HttpStatus.OK).build();&#125; service 在==SpecificationService== 12345678910111213 /** * 根据id删除规格参数 * @param id * @return */public void deleteParam(Long id) &#123; SpecParam param = new SpecParam(); param.setId(id); int delete = specParamMapper.delete(param); if (delete!=1)&#123; throw new LyException(ExceptionEnums.SPEC_PARAM_DELETE_ERROR); &#125;&#125; 3.SPU和SKU数据结构规格确定以后，就可以添加商品了,先看下数据库表 3.1.什么事SPU和SKUSPU：Standard Product Unit （标准产品单位） ，一组具有共同属性的商品集 SKU：Stock Keeping Unit（库存量单位），SPU商品集因具体特性不同而细分的每个商品 以图为例来看： 本页的 华为Mate10 就是一个商品集（SPU） 因为颜色、内存等不同，而细分出不同的Mate10，如亮黑色128G版。（SKU） 可以看出： SPU是一个抽象的商品集概念，为了方便后台的管理。 SKU才是具体要销售的商品，每一个SKU的价格、库存可能会不一样，用户购买的是SKU而不是SPU 3.2.数据库设计分析3.2.1.思考分析弄清楚了SPU和SKU的概念区分，接下来我们一起思考一下该如何设计数据库表。 首先来看SPU，大家一起思考下SPU应该有哪些字段来描述？ 123456789id:主键title：标题description：描述specification：规格packaging_list：包装after_service：售后服务comment：评价category_id：商品分类brand_id：品牌 似乎并不复杂，但是大家仔细思考一下，商品的规格字段你如何填写？ 不同商品的规格不一定相同，数据库中要如何保存？ 再看下SKU，大家觉得应该有什么字段？ 12345678id：主键spu_id：关联的spuprice：价格images：图片stock：库存颜色？内存？硬盘？ 碰到难题了，不同的商品分类，可能属性是不一样的，比如手机有内存，衣服有尺码，我们是全品类的电商网站，这些不同的商品的不同属性，如何设计到一张表中？ 另外，我们之前说过商品的规格字段分为key和value保存，key已经设计完成，那么值要在商品中保存，你如何填写？ 商品规格参数已经与分类绑定，但是值不一定相同，数据库中如何保存？ 也就是说，现在的问题有两个： 规格参数值如何保存 sku的属性是动态变化的 3.2.2.SKU的特有属性SPU中会有一些特殊属性，用来区分不同的SKU，我们称为SKU特有属性。如华为META10的颜色、内存属性。 不同种类的商品，一个手机，一个衣服，其SKU属性不相同。 同一种类的商品，比如都是衣服，SKU属性基本是一样的，都是颜色、尺码等。 这样说起来，似乎SKU的特有属性也是与分类相关的？事实上，仔细观察你会发现，SKU的特有属性是商品规格参数的一部分： 也就是说，我们没必要单独对SKU的特有属性进行设计，它可以看做是规格参数中的一部分。这样规格参数中的属性可以标记成两部分： 所有sku共享的规格属性（称为全局属性），我们记录在spu表中 每个sku不同的规格属性（称为特有属性），我们记录到sku表中 回一下之前 我们设计的tb_spec_param表，是不是有一个字段，名为generic，标记通用和特有属性，就是为了这里使用。 3.3.SPU表3.3.1.表结构1234567891011121314CREATE TABLE `tb_spu` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &apos;spu id&apos;, `name` varchar(128) NOT NULL DEFAULT &apos;&apos; COMMENT &apos;商品名称&apos;, `sub_title` varchar(256) DEFAULT &apos;&apos; COMMENT &apos;子标题&apos;, `cid1` bigint(20) NOT NULL COMMENT &apos;1级类目id&apos;, `cid2` bigint(20) NOT NULL COMMENT &apos;2级类目id&apos;, `cid3` bigint(20) NOT NULL COMMENT &apos;3级类目id&apos;, `brand_id` bigint(20) NOT NULL COMMENT &apos;商品所属品牌id&apos;, `saleable` tinyint(1) NOT NULL DEFAULT &apos;1&apos; COMMENT &apos;是否上架，0下架，1上架&apos;, `valid` tinyint(1) NOT NULL DEFAULT &apos;1&apos; COMMENT &apos;是否有效，0已删除，1有效&apos;, `create_time` datetime DEFAULT NULL COMMENT &apos;添加时间&apos;, `last_update_time` datetime DEFAULT NULL COMMENT &apos;最后修改时间&apos;, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=195 DEFAULT CHARSET=utf8 COMMENT=&apos;spu表，该表描述的是一个抽象性的商品，比如 iphone8&apos; 与我们前面分析的基本类似，但是似乎少了一些字段，比如商品描述。 我们做了表的垂直拆分，将SPU的详情放到了另一张表：tb_spu_detail 123456789CREATE TABLE `tb_spu_detail` ( `spu_id` bigint(20) NOT NULL, `description` text COMMENT &apos;商品描述信息&apos;, `generic_spec` varchar(2048) NOT NULL DEFAULT &apos;&apos; COMMENT &apos;通用规格参数数据&apos;, `special_spec` varchar(1024) NOT NULL COMMENT &apos;特有规格参数及可选值信息，json格式&apos;, `packing_list` varchar(1024) DEFAULT &apos;&apos; COMMENT &apos;包装清单&apos;, `after_service` varchar(1024) DEFAULT &apos;&apos; COMMENT &apos;售后服务&apos;, PRIMARY KEY (`spu_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 这张表中的数据都比较大，为了不影响主表的查询效率我们拆分出这张表。 需要注意的是这两个字段：geneirc_spec和special_spec。 3.3.2.SPU中的规格参数前面讲过规格参数与商品分类绑定，一个分类下的所有SPU具有类似的规格参数。SPU下的SKU可能会有不同的规格参数，因此我们计划是这样： SPU中保存全局的规格参数信息。 SKU中保存特有规格参数。 3.3.2.1.generic_spec字段首先是generice_spec，其中保存全部规格参数信息的值，使用json格式 整体来看： json结构，其中都是键值对： key：对应的规格组spec_param的id value：对应规格参数的值 3.3.2.3.special_spec字段我们说spu中只保存通用规格参数，那么为什么有多出了一个special_spec字段？ 以手机为例，品牌、操作系统等肯定是全局属性，内存、颜色等肯定是特有属性。 当你确定了一个SPU，比如小米的：红米4X 全局属性举例： 12品牌：小米型号：红米4X 特有属性举例： 123颜色：[香槟金, 樱花粉, 磨砂黑]内存：[2G, 3G]机身存储：[16GB, 32GB] 颜色、内存、机身存储，作为sku特有属性，key虽然一样，但是spu下的每一个sku，其值都不一样，所以值会有很多，形成数组。 我们在spu中，会把特有属性的所有值记录下来，形成一个数组： 里面又有哪些内容？ 看数据格式： 也是json结构： key：规格参数id value：spu属性的数组 那么问题来了：特有规格参数应该在sku中记录才对，为什么在spu中也要记录一份？ 因为我们有时候需要把所有规格参数查询出来，而不是只查询一个sku中属性。比如，商品详情页展示可选的规格参数： 刚好符合我们的结构，这样页面渲染就非常方便。 3.2.SKU表3.2.1.表结构1234567891011121314CREATE TABLE `tb_sku` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &apos;sku id&apos;, `spu_id` bigint(20) NOT NULL COMMENT &apos;spu id&apos;, `title` varchar(256) NOT NULL COMMENT &apos;商品标题&apos;, `images` varchar(1024) DEFAULT &apos;&apos; COMMENT &apos;商品的图片，多个图片以‘,’分割&apos;, `price` bigint(15) NOT NULL DEFAULT &apos;0&apos; COMMENT &apos;销售价格，单位为分&apos;, `indexes` varchar(32) DEFAULT &apos;&apos; COMMENT &apos;特有规格属性在spu属性模板中的对应下标组合（索引）&apos;, `own_spec` varchar(1024) DEFAULT &apos;&apos; COMMENT &apos;sku的特有规格参数键值对，json格式，反序列化时请使用linkedHashMap，保证有序&apos;, `enable` tinyint(1) NOT NULL DEFAULT &apos;1&apos; COMMENT &apos;是否有效，0无效，1有效&apos;, `create_time` datetime NOT NULL COMMENT &apos;添加时间&apos;, `last_update_time` datetime NOT NULL COMMENT &apos;最后修改时间&apos;, PRIMARY KEY (`id`), KEY `key_spu_id` (`spu_id`) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=27359021729 DEFAULT CHARSET=utf8 COMMENT=&apos;sku表,该表表示具体的商品实体,如黑色的 64g的iphone 8&apos; 还有一张表，代表库存（读写很高）： 1234567CREATE TABLE `tb_stock` ( `sku_id` bigint(20) NOT NULL COMMENT &apos;库存对应的商品sku id&apos;, `seckill_stock` int(9) DEFAULT &apos;0&apos; COMMENT &apos;可秒杀库存&apos;, `seckill_total` int(9) DEFAULT &apos;0&apos; COMMENT &apos;秒杀总数量&apos;, `stock` int(9) NOT NULL COMMENT &apos;库存数量&apos;, PRIMARY KEY (`sku_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&apos;库存表，代表库存，秒杀库存等信息&apos; 问题：为什么要将库存独立一张表？ 因为库存字段写频率较高，而SKU的其它字段以读为主，因此我们将两张表分离，读写不会干扰。 特别需要注意的是sku表中的indexes字段和own_spec字段。sku中应该保存特有规格参数的值，就在这两个字段中。 3.2.2.sku中的特有规格参数3.2.2.1.indexes字段在SPU表中，已经对特有规格参数及可选项进行了保存，结构如下： 123456789101112131415&#123; "机身颜色": [ "香槟金", "樱花粉", "磨砂黑" ], "内存": [ "2GB", "3GB" ], "机身存储": [ "16GB", "32GB" ]&#125; 这些特有属性如果排列组合，会产生12个不同的SKU，而不同的SKU，其属性就是上面备选项中的一个。 比如： 红米4X，香槟金，2GB内存，16GB存储 红米4X，磨砂黑，2GB内存，32GB存储 你会发现，每一个属性值，对应于SPUoptions数组的一个选项，如果我们记录下角标，就是这样： 红米4X，0,0,0 红米4X，2,0,1 既然如此，我们是不是可以将不同角标串联起来，作为SPU下不同SKU的标示。这就是我们的indexes字段。 这个设计在商品详情页会特别有用： 当用户点击选中一个特有属性，你就能根据 角标快速定位到sku。 3.2.2.2.own_spec字段看结构： 1&#123;"机身颜色":"香槟金","内存":"2GB","机身存储":"16GB"&#125; 保存的是特有属性的键值对。 SPU中保存的是可选项，但不确定具体的值，而SKU中的保存的就是具体的键值对了。 这样，在页面展示规格参数信息时，就可以根据key来获取值，用于显示。 3.3.导入图片信息现在商品表中虽然有数据，但是所有的图片信息都是无法访问的，我们需要把图片导入到虚拟机： 首先，把课前资料提供的数据上传到虚拟机下：/leyou/static目录： 然后，使用命令解压缩： 1unzip images.zip 修改Nginx配置，使nginx反向代理这些图片地址： 1vim /opt/nginx/config/nginx.conf 修改成如下配置： 12345678910111213141516171819server &#123; listen 80; server_name image.leyou.com; # 监听域名中带有group的，交给FastDFS模块处理 location ~/group([0-9])/ &#123; ngx_fastdfs_module; &#125; # 将其它图片代理指向本地的/leyou/static目录 location / &#123; root /leyou/static/; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125;&#125; 4.商品查询4.1.效果预览接下来，我们实现商品管理的页面，先看下我们要实现的效果： 可以看出整体是一个table，然后有新增按钮。是不是跟昨天写品牌管理很像？ 模板代码在分别在Goods.vue ——从0开始（可看前端自己写步骤）接下来，我们自己来实现一下，新建两个组件：MyGoods.vue和MyGoodsForm.vue 内容先随意： 1234567891011121314151617181920&lt;template&gt; &lt;v-card&gt; MyGoods &lt;/v-card&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: &quot;my-goods&quot;, data() &#123; return &#123; &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 然后修改menu.js,新建一个菜单： 修改router/index.js，添加一个路由： 预览一下： —–页面实现（可看前端自己写步骤）1.页面基本表格商品列表页与品牌列表页几乎一样，我们可以直接去复制一份过来，然后进行一些修改。 首先，字段不一样，商品列表也展示的SPU信息，包含以下字段： 1234id：title：标题cname：商品分类名称bname：品牌名称 完整代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142&lt;template&gt; &lt;v-card&gt; &lt;v-card-title&gt; &lt;v-btn color="primary" @click="addGoods"&gt;新增商品&lt;/v-btn&gt; &lt;!--搜索框，与search属性关联--&gt; &lt;v-spacer/&gt; &lt;v-text-field label="输入关键字搜索" v-model.lazy="search" append-icon="search" hide-details/&gt; &lt;/v-card-title&gt; &lt;v-divider/&gt; &lt;v-data-table :headers="headers" :items="goodsList" :search="search" :pagination.sync="pagination" :total-items="totalGoods" :loading="loading" class="elevation-1" &gt; &lt;template slot="items" slot-scope="props"&gt; &lt;td&gt;&#123;&#123; props.item.id &#125;&#125;&lt;/td&gt; &lt;td class="text-xs-center"&gt;&#123;&#123; props.item.title &#125;&#125;&lt;/td&gt; &lt;td class="text-xs-center"&gt;&#123;&#123;props.item.cname&#125;&#125;&lt;/td&gt; &lt;td class="text-xs-center"&gt;&#123;&#123; props.item.bname &#125;&#125;&lt;/td&gt; &lt;td class="justify-center layout"&gt; &lt;v-btn color="info" @click="editGoods(props.item)"&gt;编辑&lt;/v-btn&gt; &lt;v-btn color="warning"&gt;删除&lt;/v-btn&gt; &lt;v-btn &gt;下架&lt;/v-btn&gt; &lt;/td&gt; &lt;/template&gt; &lt;/v-data-table&gt; &lt;!--弹出的对话框--&gt; &lt;v-dialog max-width="500" v-model="show" persistent&gt; &lt;v-card&gt; &lt;!--对话框的标题--&gt; &lt;v-toolbar dense dark color="primary"&gt; &lt;v-toolbar-title&gt;&#123;&#123;isEdit ? '修改' : '新增'&#125;&#125;商品&lt;/v-toolbar-title&gt; &lt;v-spacer/&gt; &lt;!--关闭窗口的按钮--&gt; &lt;v-btn icon @click="closeWindow"&gt;&lt;v-icon&gt;close&lt;/v-icon&gt;&lt;/v-btn&gt; &lt;/v-toolbar&gt; &lt;!--对话框的内容，表单--&gt; &lt;v-card-text class="px-5"&gt; &lt;my-goods-form :oldGoods="oldGoods" /&gt; &lt;/v-card-text&gt; &lt;/v-card&gt; &lt;/v-dialog&gt; &lt;/v-card&gt;&lt;/template&gt;&lt;script&gt; // 导入自定义的表单组件 import MyGoodsForm from './MyGoodsForm' export default &#123; name: "my-goods", data() &#123; return &#123; search: '', // 搜索过滤字段 totalGoods: 0, // 总条数 goodsList: [], // 当前页品牌数据 loading: true, // 是否在加载中 pagination: &#123;&#125;, // 分页信息 headers: [ &#123;text: 'id', align: 'center', value: 'id'&#125;, &#123;text: '标题', align: 'center', sortable: false, value: 'title'&#125;, &#123;text: '商品分类', align: 'center', sortable: false, value: 'cname'&#125;, &#123;text: '品牌', align: 'center', value: 'bname', sortable: false,&#125;, &#123;text: '操作', align: 'center', sortable: false&#125; ], show: false,// 控制对话框的显示 oldGoods: &#123;&#125;, // 即将被编辑的商品信息 isEdit: false, // 是否是编辑 &#125; &#125;, mounted() &#123; // 渲染后执行 // 查询数据 this.getDataFromServer(); &#125;, watch: &#123; pagination: &#123; // 监视pagination属性的变化 deep: true, // deep为true，会监视pagination的属性及属性中的对象属性变化 handler() &#123; // 变化后的回调函数，这里我们再次调用getDataFromServer即可 this.getDataFromServer(); &#125; &#125;, search: &#123; // 监视搜索字段 handler() &#123; this.getDataFromServer(); &#125; &#125; &#125;, methods: &#123; getDataFromServer() &#123; // 从服务的加载数的方法。 // 发起请求 this.$http.get("/item/spu/page", &#123; params: &#123; key: this.search, // 搜索条件 page: this.pagination.page,// 当前页 rows: this.pagination.rowsPerPage,// 每页大小 sortBy: this.pagination.sortBy,// 排序字段 desc: this.pagination.descending// 是否降序 &#125; &#125;).then(resp =&gt; &#123; // 这里使用箭头函数 this.goodsList = resp.data.items; this.totalGoods = resp.data.total; // 完成赋值后，把加载状态赋值为false this.loading = false; &#125;) &#125;, addGoods() &#123; // 修改标记 this.isEdit = false; // 控制弹窗可见： this.show = true; // 把oldBrand变为null this.oldBrand = null; &#125;, editGoods(oldGoods)&#123; // 修改标记 this.isEdit = true; // 控制弹窗可见： this.show = true; // 获取要编辑的brand this.oldGoods = oldGoods; &#125;, closeWindow()&#123; // 重新加载数据 this.getDataFromServer(); // 关闭窗口 this.show = false; &#125; &#125;, components:&#123; MyGoodsForm &#125; &#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 主要的改动点： 页面的v-data-table中的属性绑定修改。items指向goodsList，totalItems指向totalGoods 页面渲染的字段名修改：字段改成商品的SPU字段：id、title，cname(商品分类名称),bname（品牌名称） data属性修改了以下属性： goodsList：当前页商品数据 totalGoods：商品总数 headers：头信息，需要修改头显示名称 oldGoods：准备要修改的商品 加载数据的函数：getDataFromServer，请求的路径进行了修改，另外去除了跟排序相关的查询。SPU查询不排序 新增商品的事件函数：清除了一些数据查询接口，只保留弹窗 查看效果： 因为没有编写查询功能，表格一直处于loading状态。 接下来看弹窗： 2.上下架状态按钮另外，似乎页面少了对上下架商品的过滤，在原始效果图中是有的： 这在Vuetify中是一组按钮，我们查看帮助文档： 查看实例得到以下信息： v-btn：一个按钮 v-btn-toggle：按钮组，内部可以有多个按钮，点击切换，有以下属性： multiple：是否支持多选，默认是false value：选中的按钮的值，如果是多选，结果是一个数组；单选，结果是点击的v-btn中的value值，因此按钮组的每个btn都需要指定value属性 改造页面： 首先在data中定义一个属性，记录按钮的值。 1234filter:&#123; saleable: false, // 上架还是下架 search: '', // 搜索过滤字段&#125; 这里我们的做法是定义一个filter属性，内部在定义search来关联过滤字段，saleable来关联上下架情况。 这样watch就必须监听filter，而不是只监听search了： 123456filter: &#123;// 监视搜索字段 handler() &#123; this.getDataFromServer(); &#125;, deep:true&#125; 另外，页面中与search有关的所有字段都需要修改成filter.search: 12&lt;!--搜索框，与search属性关联--&gt;&lt;v-text-field label="输入关键字搜索" v-model.lazy="filter.search" append-icon="search" hide-details/&gt; 然后，在页面中添加按钮组： 1234567891011121314 &lt;v-flex xs3&gt; 状态： &lt;v-btn-toggle v-model="filter.saleable"&gt; &lt;v-btn flat&gt; 全部 &lt;/v-btn&gt; &lt;v-btn flat :value="true"&gt; 上架 &lt;/v-btn&gt; &lt;v-btn flat :value="false"&gt; 下架 &lt;/v-btn&gt; &lt;/v-btn-toggle&gt;&lt;/v-flex&gt; 最后，不要忘了在查询时，将saleable携带上： 12345678910111213141516getDataFromServer() &#123; // 从服务的加载数的方法。 // 发起请求 this.$http.get("/item/spu/page", &#123; params: &#123; key: this.filter.search, // 搜索条件 saleable: this.filter.saleable, // 上下架 page: this.pagination.page,// 当前页 rows: this.pagination.rowsPerPage,// 每页大小 &#125; &#125;).then(resp =&gt; &#123; // 这里使用箭头函数 this.goodsList = resp.data.items; this.totalGoods = resp.data.total; // 完成赋值后，把加载状态赋值为false this.loading = false; &#125;)&#125; 4.2.页面请求先看完整页面结构： 并且在Vue实例挂载时就会发起查询 查询商品数据的请求： ​ 4.4.后台提供接口页面已经准备好，接下来在后台提供分页查询SPU的功能： 4.4.1.实体类 SPU 123456789101112131415161718@Table(name = "tb_spu")@Datapublic class Spu &#123; @Id @KeySql(useGeneratedKeys = true) private Long id; private Long brandId; private Long cid1;// 1级类目 private Long cid2;// 2级类目 private Long cid3;// 3级类目 private String title;// 标题 private String subTitle;// 子标题 private Boolean saleable;// 是否上架 private Boolean valid;// 是否有效，逻辑删除用 private Date createTime;// 创建时间 private Date lastUpdateTime;// 最后修改时间 // 省略getter和setter&#125; SPU详情 123456789101112@Data@Table(name="tb_spu_detail")public class SpuDetail &#123; @Id private Long spuId;// 对应的SPU的id private String description;// 商品描述 private String specialSpec;// 商品特殊规格的名称及可选值模板 private String genericSpec;// 商品的全局规格属性 private String packingList;// 包装清单 private String afterService;// 售后服务 // 省略getter和setter&#125; 4.4.2.controller先分析： 请求方式：GET 请求路径：/spu/page 请求参数： page：当前页 rows：每页大小 key：过滤条件 saleable：上架或下架 返回结果：商品SPU的分页信息PageResult&lt;Spu&gt; 。 要注意，页面展示的是商品分类和品牌名称，而数据库中保存的是id，怎么办？ 我们可以拓展cname和bname属性，写到ly-item-interface 12345678910111213141516171819202122232425262728293031@Table(name = "tb_spu")@Datapublic class Spu &#123; @Id @KeySql(useGeneratedKeys = true) private Long id; private Long brandId; private Long cid1;// 1级类目 private Long cid2;// 2级类目 private Long cid3;// 3级类目 private String title;// 标题 private String subTitle;// 子标题 private Boolean saleable;// 是否上架 //返回字段的时候忽略lastUpdateTime @JsonIgnore private Boolean valid;// 是否有效，逻辑删除用 private Date createTime;// 创建时间 //返回字段的时候忽略lastUpdateTime @JsonIgnore private Date lastUpdateTime;// 最后修改时间 @Transient//不是数据库字段的 private String bname; @Transient//不是数据库字段的 private String cname; // 省略getter和setter &#125; 编写controller代码： 我们把与商品相关的一切业务接口都放到一起，起名为GoodsController，业务层也是这样 12345678910111213141516/** * 分页查询 * @param page * @param rows * @param saleable * @param key * @return */@GetMapping("page")public ResponseEntity&lt;PageResult&lt;Spu&gt;&gt; querySpuByPage( @RequestParam(value = "page", defaultValue = "1") Integer page, @RequestParam(value = "rows", defaultValue = "5") Integer rows, @RequestParam(value = "saleable", required = false) Boolean saleable, @RequestParam(value = "key", required = false) String key)&#123; return ResponseEntity.ok(goodsService.querySpuByPage(page,rows,saleable,key));&#125; 4.4.3.service所有商品相关的业务（包括SPU和SKU）放到一个业务下：GoodsService。 1234567891011121314151617181920212223242526272829public PageResult&lt;Spu&gt; querySpuByPage(Integer page, Integer rows, Boolean saleable, String key) &#123; //1.分页 PageHelper.startPage(page,rows); //2.过滤 Example example = new Example(Spu.class); Example.Criteria criteria = example.createCriteria(); //3.搜索过滤字段 if (StringUtils.isNotBlank(key))&#123; criteria.andLike("title","%"+key+"%"); &#125; //4.上下架过滤 if (saleable!=null)&#123; criteria.andEqualTo("saleable",saleable); &#125; //5.默认排序 example.setOrderByClause("last_update_time DESC"); //6.查询 List&lt;Spu&gt; spus = spuMapper.selectByExample(example); //7.判断 if (CollectionUtils.isEmpty(spus))&#123; throw new LyException(ExceptionEnums.GOODS_NOT_FOUND); &#125; //8.解析分类和品牌的名称(方法抽离) loadCategoryAndBrandName(spus); //9.解析分页结果 PageInfo&lt;Spu&gt; info = new PageInfo&lt;&gt;(spus); return new PageResult&lt;&gt;(info.getTotal(),spus);&#125; loadCategoryAndBrandName方法 在GoodsService中添加loadCategoryAndBrandName方法，用于查询商品分类和商品的品牌： 12345678910111213141516//解析分类和品牌的名称 private void loadCategoryAndBrandName(List&lt;Spu&gt; spus) &#123; for (Spu spu : spus) &#123; //1.处理分类名称 List&lt;String&gt; cname = categoryService.queryByIds(Arrays.asList( spu.getCid1(), spu.getCid2(), spu.getCid3())) .stream().map(Category::getName).collect(Collectors.toList()); //1.1集合拼成字符串，通过“/”分隔 spu.setCname(StringUtils.join(cname,"/")); //2.处理品牌 String bname = brandService.queryById(spu.getBrandId()).getName(); spu.setBname(bname); &#125; &#125; .stream().map(Category::getName).collect(Collectors.toList());得到catgory的name输出流 queryByIds()方法 查询商品分类名称，在CategoryService中添加 selectByIdList是查询id的集合，必须在CategoryMapper中扩展IdListMapper 123456789101112/** * 根据ids集合查询商品分类 * @param ids * @return */public List&lt;Category&gt; queryByIds(List&lt;Long&gt; ids)&#123; List&lt;Category&gt; list = categoryMapper.selectByIdList(ids); if (CollectionUtils.isEmpty(list))&#123; throw new LyException(ExceptionEnums.CATEGORY_NOT_FOND); &#125; return list;&#125; 修改CategoryMapper 12345//IdListMapper&lt;T,PK&gt; T:要查询的pojo，PK:是什么数据类型public interface CategoryMapper extends Mapper&lt;Category&gt;,IdListMapper&lt;Category,Long&gt;&#123; @Select("SELECT * FROM tb_category WHERE id IN (SELECT category_id FROM tb_category_brand WHERE brand_id = #&#123;bid&#125;)") List&lt;Category&gt; queryCategoryListByBid(@Param("bid")Long bid);&#125; 4.4.4.mapper12public interface SpuMapper extends Mapper&lt;Spu&gt; &#123;&#125; 4.5.测试刷新页面，查看效果： 基本与预览的效果一致，OK！]]></content>
      <categories>
        <category>项目实战-微服务商城</category>
      </categories>
      <tags>
        <tag>FastDFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务商城（九）——品牌管理]]></title>
    <url>%2Fday07-%E5%93%81%E7%89%8C%E7%AE%A1%E7%90%86.html</url>
    <content type="text"><![CDATA[0.学习目标 独立实现品牌新增 实现图片上传 了解FastDFS的安装 使用FastDFS客户端实现上传 1.品牌的新增（自己看）昨天我们完成了品牌的查询，接下来就是新增功能。 1.1.页面实现1.1.1.初步编写弹窗当我们点击新增按钮，应该出现一个弹窗，然后在弹窗中出现一个表格，我们就可以填写品牌信息了。 我们查看Vuetify官网，弹窗是如何实现： 另外，我们可以通过文档看到对话框的一些属性： value：控制窗口的可见性，true可见，false，不可见 max-width：控制对话框最大宽度 scrollable ：是否可滚动，要配合v-card来使用，默认是false persistent ：点击弹窗以外的地方不会关闭弹窗，默认是false 现在，我们来使用一下。 首先，我们在data中定义一个show属性，来控制对话框的显示状态： 然后，在页面添加一个v-dialog 12345678910111213&lt;!--弹出的对话框--&gt;&lt;v-dialog max-width="500" v-model="show" persistent&gt; &lt;v-card&gt; &lt;!--对话框的标题--&gt; &lt;v-toolbar dense dark color="primary"&gt; &lt;v-toolbar-title&gt;新增品牌&lt;/v-toolbar-title&gt; &lt;/v-toolbar&gt; &lt;!--对话框的内容，表单--&gt; &lt;v-card-text class="px-5"&gt; 我是表单 &lt;/v-card-text&gt; &lt;/v-card&gt;&lt;/v-dialog&gt; 说明： 我们给dialog指定了3个属性，分别是 max-width：限制宽度 v-model：value值双向绑定到show变量，用来控制窗口显示 persisitent：控制窗口不会被意外关闭 因为可滚动需要配合v-card使用，因此我们在对话框中加入了一个v-card 在v-card的头部添加了一个 v-toolbar，作为窗口的头部，并且写了标题为：新增品牌 dense：紧凑显示 dark：黑暗主题 color：颜色，primary就是整个网站的主色调，蓝色 在v-card的内容部分，暂时空置，等会写表单 class=“px-5&quot;：vuetify的内置样式，含义是padding的x轴设置为5，这样表单内容会缩进一些，而不是顶着边框 基本语法：{property}{direction}-{size} property：属性，有两种padding和margin p：对应padding m：对应margin direction：只padding和margin的作用方向， t - 对应margin-top或者padding-top属性 b - 对应margin-bottom or padding-bottom l - 对应margin-left or padding-left r - 对应margin-right or padding-right x - 同时对应*-left和*-right属性 y - 同时对应*-top和*-bottom属性 size：控制空间大小，基于$spacer进行倍增，$spacer默认是16px 0：将margin或padding的大小设置为0 1 - 将margin或者padding属性设置为$spacer * .25 2 - 将margin或者padding属性设置为$spacer * .5 3 - 将margin或者padding属性设置为$spacer 4 - 将margin或者padding属性设置为$spacer * 1.5 5 - 将margin或者padding属性设置为$spacer * 3 1.1.2.实现弹窗的可见和关闭 窗口可见 接下来，我们要在点击新增品牌按钮时，将窗口显示，因此要给新增按钮绑定事件。 1&lt;v-btn color="primary" @click="addBrand"&gt;新增品牌&lt;/v-btn&gt; 然后定义一个addBrand方法： 1234addBrand()&#123; // 控制弹窗可见： this.show = true;&#125; 效果： 窗口关闭 现在，悲剧发生了，因为我们设置了persistent属性，窗口无法被关闭了。除非把show属性设置为false 因此我们需要给窗口添加一个关闭按钮： 1234567&lt;!--对话框的标题--&gt;&lt;v-toolbar dense dark color="primary"&gt; &lt;v-toolbar-title&gt;新增品牌&lt;/v-toolbar-title&gt; &lt;v-spacer/&gt; &lt;!--关闭窗口的按钮--&gt; &lt;v-btn icon @click="closeWindow"&gt;&lt;v-icon&gt;close&lt;/v-icon&gt;&lt;/v-btn&gt;&lt;/v-toolbar&gt; 并且，我们还给按钮绑定了点击事件，回调函数为closeWindow。 接下来，编写closeWindow函数： 1234closeWindow()&#123; // 关闭窗口 this.show = false;&#125; 效果： 1.1.3.新增品牌的表单页接下来就是写表单了。我们有两种选择： 直接在dialog对话框中编写表单代码 另外编写一个组件，组件内写表单代码。然后在对话框引用组件 选第几种？ 我们选第二种方案，优点： 表单代码独立组件，可拔插，方便后期的维护。 代码分离，可读性更好。 我们新建一个MyBrandForm.vue组件： 将MyBrandForm引入到MyBrand中，这里使用局部组件的语法： 先导入自定义组件： 12// 导入自定义的表单组件import MyBrandForm from './MyBrandForm' 然后通过components属性来指定局部组件： 123components:&#123; MyBrandForm&#125; 然后在页面中引用： 页面效果： 1.1.4.编写表单1.1.4.1.表单查看文档，找到关于表单的部分： v-form，表单组件，内部可以有许多输入项。v-form有下面的属性： value：true，代表表单验证通过；false，代表表单验证失败 v-form提供了两个方法： reset：重置表单数据 validate：校验整个表单数据，前提是你写好了校验规则。返回Boolean表示校验成功或失败 我们在data中定义一个valid属性，跟表单的value进行双向绑定，观察表单是否通过校验，同时把等会要跟表单关联的品牌brand对象声明出来： 1234567891011121314export default &#123; name: "my-brand-form", data() &#123; return &#123; valid:false, // 表单校验结果标记 brand:&#123; name:'', // 品牌名称 letter:'', // 品牌首字母 image:'',// 品牌logo categories:[], // 品牌所属的商品分类数组 &#125; &#125; &#125;&#125; 然后，在页面先写一个表单： 123&lt;v-form v-model="valid"&gt;&lt;/v-form&gt; 1.1.4.2.文本框我们的品牌总共需要这些字段： 名称 首字母 商品分类，有很多个 LOGO 表单项主要包括文本框、密码框、多选框、单选框、文本域、下拉选框、文件上传等。思考下我们的品牌需要哪些？ 文本框：品牌名称、品牌首字母都属于文本框 文件上传：品牌需要图片，这个是文件上传框 下拉选框：商品分类提前已经定义好，这里需要通过下拉选框展示，提供给用户选择。 先看文本框，昨天已经用过的，叫做v-text-field： 查看文档，v-text-field有以下关键属性： append-icon：文本框后追加图标，需要填写图标名称。无默认值 clearable：是否添加一个清空图标，点击会清空文本框。默认是false color：颜色 counter：是否添加一个文本计数器，在角落显示文本长度，指定true或允许的组大长度。无默认值 dark：是否应用黑暗色调，默认是false disable：是否禁用，默认是false flat：是否移除默认的动画效果，默认是false full-width：指定宽度为全屏，默认是false hide-details：是否因此错误提示，默认是false hint：输入框的提示文本 label：输入框的标签 multi-line：是否转为文本域，默认是false。文本框和文本域可以自由切换 placeholder：输入框占位符文本，focus后消失 required：是否为必填项，如果是，会在label后加*，不具备校验功能。默认是false rows：文本域的行数，multi-line为true时才有效 rules：指定校验规则及错误提示信息，数组结构。默认[] single-line：是否单行文本显示，默认是false suffix：显示后缀 接下来，我们先添加两个字段：品牌名称、品牌的首字母，校验规则暂时不写： 1234&lt;v-form v-model="valid"&gt; &lt;v-text-field v-model="brand.name" label="请输入品牌名称" required /&gt; &lt;v-text-field v-model="brand.letter" label="请输入品牌首字母" required /&gt;&lt;/v-form&gt; 千万不要忘了通过v-model把表单项与brand的属性关联起来。 效果： 1.1.4.3.级联下拉选框接下来就是商品分类了，按照刚才的分析，商品分类应该是下拉选框。 但是大家仔细思考，商品分类包含三级。在展示的时候，应该是先由用户选中1级，才显示2级；选择了2级，才显示3级。形成一个多级分类的三级联动效果。 这个时候，就不是普通的下拉选框，而是三级联动的下拉选框！ 这样的选框，在Vuetify中并没有提供（它提供的是基本的下拉框）。因此我已经给大家编写了一个无限级联动的下拉选框，能够满足我们的需求。 具体请参考课前资料的《自定义组件用法指南.md》 我们在代码中使用： 123456&lt;v-cascader url="/item/category/list" multiple required v-model="brand.categories" label="请选择商品分类"/&gt; url：加载商品分类选项的接口路径 multiple：是否多选，这里设置为true，因为一个品牌可能有多个分类 requried：是否是必须的，这里为true，会在提示上加*，提醒用户 v-model：关联我们brand对象的categories属性 label：文字说明 效果： data中获取的结果： 1.1.4.4.文件上传项在Vuetify中，也没有文件上传的组件。 还好，我已经给大家写好了一个文件上传的组件： 详细用法，参考《自定义组件使用指南.md》 我们添加上传的组件： 1234567891011121314&lt;v-layout row&gt; &lt;v-flex xs3&gt; &lt;span style="font-size: 16px; color: #444"&gt;品牌LOGO：&lt;/span&gt; &lt;/v-flex&gt; &lt;v-flex&gt; &lt;v-upload v-model="brand.image" url="/upload" :multiple="false" :pic-width="250" :pic-height="90" /&gt; &lt;/v-flex&gt;&lt;/v-layout&gt; 注意： 文件上传组件本身没有提供文字提示。因此我们需要自己添加一段文字说明 我们要实现文字和图片组件左右放置，因此这里使用了v-layout布局组件： layout添加了row属性，代表这是一行，如果是column，代表是多行 layout下面有v-flex组件，是这一行的单元，我们有2个单元 &lt;v-flex xs3&gt; ：显示文字说明，xs3是响应式布局，代表占12格中的3格 剩下的部分就是图片上传组件了 v-upload：图片上传组件，包含以下属性： v-model：将上传的结果绑定到brand的image属性 url：上传的路径，我们先随便写一个。 multiple：是否运行多图片上传，这里是false。因为品牌LOGO只有一个 pic-width和pic-height：可以控制l图片上传后展示的宽高 最终结果： 1.1.4.5.按钮上面已经把所有的表单项写完。最后就差提交和清空的按钮了。 在表单的最下面添加两个按钮： 12345&lt;v-layout class="my-4" row&gt; &lt;v-spacer/&gt; &lt;v-btn @click="submit" color="primary"&gt;提交&lt;/v-btn&gt; &lt;v-btn @click="clear" &gt;重置&lt;/v-btn&gt;&lt;/v-layout&gt; 通过layout来进行布局，my-4增大上下边距 v-spacer占用一定空间，将按钮都排挤到页面右侧 两个按钮分别绑定了submit和clear事件 我们先将方法定义出来： 12345678methods:&#123; submit()&#123; // 提交表单 &#125;, clear()&#123; // 重置表单 &#125;&#125; 重置表单相对简单，因为v-form组件已经提供了reset方法，用来清空表单数据。只要我们拿到表单组件对象，就可以调用方法了。 我们可以通过$refs内置对象来获取表单组件。 首先，在表单上定义ref属性： 然后，在页面查看this.$refs属性： 看到this.$refs中只有一个属性，就是myBrandForm 我们在clear中来获取表单对象并调用reset方法： 123456789101112methods:&#123; submit()&#123; // 提交表单 console.log(this); &#125;, clear()&#123; // 重置表单 this.$refs.myBrandForm.reset(); // 需要手动清空商品分类 this.categories = []; &#125;&#125; 要注意的是，这里我们还手动把this.categories清空了，因为我写的级联选择组件并没有跟表单结合起来。需要手动清空。 1.1.5.表单校验1.1.5.1.校验规则Vuetify的表单校验，是通过rules属性来指定的： 校验规则的写法： 说明： 规则是一个数组 数组中的元素是一个函数，该函数接收表单项的值作为参数，函数返回值两种情况： 返回true，代表成功， 返回错误提示信息，代表失败 1.1.5.2.项目中代码我们有四个字段： name：做非空校验和长度校验，长度必须大于1 letter：首字母，校验长度为1，非空。 image：图片，不做校验，图片可以为空 categories：非空校验，自定义组件已经帮我们完成，不用写了 首先，我们定义规则： 12345678nameRules:[ v =&gt; !!v || "品牌名称不能为空", v =&gt; v.length &gt; 1 || "品牌名称至少2位"],letterRules:[ v =&gt; !!v || "首字母不能为空", v =&gt; /^[A-Z]&#123;1&#125;$/.test(v) || "品牌字母只能是A~Z的大写字母"] 然后，在页面标签中指定： 12&lt;v-text-field v-model="brand.name" label="请输入品牌名称" required :rules="nameRules" /&gt;&lt;v-text-field v-model="brand.letter" label="请输入品牌首字母" required :rules="letterRules" /&gt; 效果： 1.1.6.表单提交在submit方法中添加表单提交的逻辑： 1234567891011121314151617181920submit() &#123; // 1、表单校验 if (this.$refs.myBrandForm.validate()) &#123; // 2、定义一个请求参数对象，通过解构表达式来获取brand中的属性 const &#123;categories ,letter ,...params&#125; = this.brand; // 3、数据库中只要保存分类的id即可，因此我们对categories的值进行处理,只保留id，并转为字符串 params.cids = categories.map(c =&gt; c.id).join(","); // 4、将字母都处理为大写 params.letter = letter.toUpperCase(); // 5、将数据提交到后台 this.$http.post('/item/brand', params) .then(() =&gt; &#123; // 6、弹出提示 this.$message.success("保存成功！"); &#125;) .catch(() =&gt; &#123; this.$message.error("保存失败！"); &#125;); &#125;&#125; 1、通过this.$refs.myBrandForm选中表单，然后调用表单的validate方法，进行表单校验。返回boolean值，true代表校验通过 2、通过解构表达式来获取brand中的值，categories和letter需要处理，单独获取。其它的存入params对象中 3、品牌和商品分类的中间表只保存两者的id，而brand.categories中保存的数对象数组，里面有id和name属性，因此这里通过数组的map功能转为id数组，然后通过join方法拼接为字符串 4、首字母都处理为大写保存 5、发起请求 6、弹窗提示成功还是失败，这里用到的是我们的自定义组件功能message组件： 这个插件把$message对象绑定到了Vue的原型上，因此我们可以通过this.$message来直接调用。 包含以下常用方法： info、error、success、warning等，弹出一个带有提示信息的窗口，色调与为普通（灰）、错误（红色）、成功（绿色）和警告（黄色）。使用方法：this.$message.info(“msg”) confirm：确认框。用法：this.$message.confirm(&quot;确认框的提示信息&quot;)，返回一个Promise 1.2.后台实现新增1.2.1.controller还是一样，先分析四个内容： 请求方式：刚才看到了是POST 请求路径：/brand 请求参数：brand对象，外加商品分类的id数组cids 返回值：无 代码： 12345678910/** * 新增品牌 * @param brand * @return */@PostMappingpublic ResponseEntity&lt;Void&gt; saveBrand(Brand brand, @RequestParam("cids") List&lt;Long&gt; cids) &#123; this.brandService.saveBrand(brand, cids); return new ResponseEntity&lt;&gt;(HttpStatus.CREATED);&#125; 1.2.2.Service这里要注意，我们不仅要新增品牌，还要维护品牌和商品分类的中间表。 123456789@Transactionalpublic void saveBrand(Brand brand, List&lt;Long&gt; cids) &#123; // 新增品牌信息 this.brandMapper.insertSelective(brand); // 新增品牌和分类中间表 for (Long cid : cids) &#123; this.brandMapper.insertCategoryBrand(cid, brand.getId()); &#125;&#125; 这里调用了brandMapper中的一个自定义方法，来实现中间表的数据新增 1.2.3.Mapper通用Mapper只能处理单表，也就是Brand的数据，因此我们手动编写一个方法及sql，实现中间表的新增： 12345678910public interface BrandMapper extends Mapper&lt;Brand&gt; &#123; /** * 新增商品分类和品牌中间表数据 * @param cid 商品分类id * @param bid 品牌id * @return */ @Insert("INSERT INTO tb_category_brand (category_id, brand_id) VALUES (#&#123;cid&#125;,#&#123;bid&#125;)") int insertCategoryBrand(@Param("cid") Long cid, @Param("bid") Long bid);&#125; 1.3.请求参数格式错误1.3.1.原因分析我们填写表单并提交，发现报错了： 查看控制台的请求详情： 发现请求的数据格式是JSON格式。 原因分析： axios处理请求体的原则会根据请求数据的格式来定： 如果请求体是对象：会转为json发送 如果请求体是String：会作为普通表单请求发送，但需要我们自己保证String的格式是键值对。 如：name=jack&amp;age=12 1.3.2.QS工具（数据传输给后台方法重要）QS是一个第三方库，我们可以用npm install qs --save来安装。不过我们在项目中已经集成了，大家无需安装： 这个工具的名字：QS，即Query String，请求参数字符串。 什么是请求参数字符串？例如： name=jack&amp;age=21 QS工具可以便捷的实现 JS的Object与QueryString的转换。 在我们的项目中，将QS注入到了Vue的原型对象中，我们可以通过this.$qs来获取这个工具： 我们将this.$qs对象打印到控制台： 123created()&#123; console.log(this.$qs);&#125; 发现其中有3个方法： 这里我们要使用的方法是stringify，它可以把Object转为QueryString。 测试一下，使用浏览器工具，把qs对象保存为一个临时变量： 然后调用stringify方法： 成功将person对象变成了 name=jack&amp;age=21的字符串了 1.3.3.解决问题修改页面，对参数处理后发送： 然后再次发起请求： 发现请求成功： 参数格式： 数据库： 1.4.新增完成后关闭窗口我们发现有一个问题：新增不管成功还是失败，窗口都一致在这里，不会关闭。 这样很不友好，我们希望如果新增失败，窗口保持；但是新增成功，窗口关闭才对。 因此，我们需要在新增的ajax请求完成以后，关闭窗口 但问题在于，控制窗口是否显示的标记在父组件：MyBrand.vue中。子组件如何才能操作父组件的属性？或者告诉父组件该关闭窗口了？ 之前我们讲过一个父子组件的通信，有印象吗？ 第一步，在父组件中定义一个函数，用来关闭窗口，不过之前已经定义过了，我们优化一下，关闭的同时重新加载数据： 123456closeWindow()&#123; // 关闭窗口 this.show = false; // 重新加载数据 this.getDataFromServer();&#125; 第二步，父组件在使用子组件时，绑定事件，关联到这个函数： 1234&lt;!--对话框的内容，表单--&gt;&lt;v-card-text class="px-5"&gt; &lt;my-brand-form @close="closeWindow"/&gt;&lt;/v-card-text&gt; 第三步，子组件通过this.$emit调用父组件的函数： 测试一下 2.实现图片上传刚才的新增实现中，我们并没有上传图片，接下来我们一起完成图片上传逻辑。 文件的上传并不只是在品牌管理中有需求，以后的其它服务也可能需要，因此我们创建一个独立的微服务，专门处理各种上传。 2.1.搭建项目2.1.1.创建module 2.1.2.依赖我们需要EurekaClient和web依赖： 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;leyou&lt;/artifactId&gt; &lt;groupId&gt;com.leyou.parent&lt;/groupId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.service&lt;/groupId&gt; &lt;artifactId&gt;ly-upload&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--ly-common依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;com.leyou.common&lt;/groupId&gt; &lt;artifactId&gt;ly-common&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;!--FastDFS依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.tobato&lt;/groupId&gt; &lt;artifactId&gt;fastdfs-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 2.1.3.编写配置12345678910111213141516171819server: port: 8082spring: application: name: upload-service servlet: multipart: max-file-size: 5MB # 限制文件上传的大小# Eurekaeureka: client: service-url: defaultZone: http://127.0.0.1:10086/eureka instance: lease-renewal-interval-in-seconds: 5 # 每隔5秒发送一次心跳 lease-expiration-duration-in-seconds: 10 # 10秒不发送就过期 prefer-ip-address: true ip-address: 127.0.0.1 instance-id: $&#123;spring.application.name&#125;:$&#123;server.port&#125; 需要注意的是，我们应该添加了限制文件大小的配置 2.1.4.启动类1234567@SpringBootApplication@EnableDiscoveryClientpublic class LyUploadService &#123; public static void main(String[] args) &#123; SpringApplication.run(LyUploadService.class, args); &#125;&#125; 结构： 2.2.编写上传功能2.2.1.controller编写controller需要知道4个内容： 请求方式：上传肯定是POST 请求路径：/upload/image 请求参数：文件，参数名是file，SpringMVC会封装为一个接口：MultipleFile 返回结果：上传成功后得到的文件的url路径 代码如下： 12345678910111213141516@RestController@RequestMapping("upload")public class UploadController &#123; @Autowired private UploadService uploadService; /** * 上传图片功能 * @param file * @return */ @PostMapping("image") public ResponseEntity&lt;String&gt; uploadImage(@RequestParam("file")MultipartFile file)&#123; return ResponseEntity.ok(uploadService.uploadImage(file)); &#125;&#125; 2.2.2.service（图片在本地存储）在上传文件过程中，我们需要对上传的内容进行校验： 校验文件大小 校验文件的媒体类型 校验文件的内容 文件大小在Spring的配置文件中设置，因此已经会被校验，我们不用管。 具体代码： 1234567891011121314151617181920212223242526272829303132333435363738394041@Servicepublic class UploadService &#123; private static final Logger logger = LoggerFactory.getLogger(UploadController.class); // 支持的文件类型 private static final List&lt;String&gt; suffixes = Arrays.asList("image/png", "image/jpeg"); public String upload(MultipartFile file) &#123; try &#123; // 1、图片信息校验 // 1)校验文件类型 String type = file.getContentType(); if (!suffixes.contains(type)) &#123; logger.info("上传失败，文件类型不匹配：&#123;&#125;", type); return null; &#125; // 2)校验图片内容 BufferedImage image = ImageIO.read(file.getInputStream()); if (image == null) &#123; logger.info("上传失败，文件内容不符合要求"); return null; &#125; // 2、保存图片 // 2.1、生成保存目录 File dir = new File("D:\\heima\\upload"); if (!dir.exists()) &#123; dir.mkdirs(); &#125; // 2.2、保存图片 file.transferTo(new File(dir, file.getOriginalFilename())); // 2.3、拼接图片地址 String url = "http://image.leyou.com/upload/" + file.getOriginalFilename(); return url; &#125; catch (Exception e) &#123; return null; &#125; &#125;&#125; 这里有一个问题：为什么图片地址需要使用另外的url？ 图片不能保存在服务器内部，这样会对服务器产生额外的加载负担 一般静态资源都应该使用独立域名，这样访问静态资源时不会携带一些不必要的cookie，减小请求的数据量 2.2.3.测试上传我们通过RestClient工具来测试： 结果： 去目录下查看： 上传成功！ ###2.2.4.忽略路由前缀 zuul的路由功能中，会忽略路由匹配的路径前缀，不过我们的Controller中由/upload路径，此时如果通过网关访问，我们的地址应该是：http://api.leyou.com/api/upload/upload/image，这是因为路由匹配的前/upload在请求转发时会自动忽略。 123456789zuul: prefix: /api # 添加路由前缀 routes: item-service: /item/** #将商品微服务映射到/item/** upload-service: #将上传微服务映射到/upload/** #忽略/upload/** path: /upload/** serviceId: upload-service strip-prefix: false 这样，路由前缀也会作为地址一部分转发到微服务，那么我们可以这样访问 http://api.leyou.com/api/upload/image 2.2.5.绕过网关缓存默认情况下，所有的请求经过zuul网关的代理，默认会通过springMVC预先对请求进行处理，缓存。普通请求并不会有什么影响，但是对于文件上传，造成不必要的网络负担，在高并发时，可能导致网络阻塞，Zuul网关不可用。这样我们的整个系统就瘫痪了。 所以，我们上传文件的请求就不经过网关来处理了。 2.2.5.1.Nginx的rewrite指令现在，我们修改页面的访问路径： 123456&lt;v-upload v-model="brand.image" url="/upload/image" :multiple="false" :pic-width="250" :pic-height="90" /&gt; 查看页面的请求路径： 可以看到这个地址不对，依然是去找Zuul网关，因为我们的系统全局配置了URL地址。怎么办？ 有同学会想：修改页面请求地址不就好了。 注意：原则上，我们是不能把除了网关以外的服务对外暴露的，不安全。 既然不能修改页面请求，那么就只能在Nginx反向代理上做文章了。 我们修改nginx配置，将以/api/upload开头的请求拦截下来，转交到真实的服务地址: 123location /api/upload &#123; rewrite "^/(.*)$" /zuul/$1;&#125; 这样写大家觉得对不对呢？ 显然是不对的，因为ip和端口虽然对了，但是路径没变，依然是：http://127.0.0.1:8002/api/upload/image 前面多了一个/api Nginx提供了rewrite指令，用于对地址进行重写，语法规则： 1rewrite &quot;用来匹配路径的正则&quot; 重写后的路径 [指令]; 我们的案例： 12345678910111213141516171819server &#123; listen 80; server_name api.leyou.com; proxy_set_header X-Forwarded-Host $host; proxy_set_header X-Forwarded-Server $host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; # 上传路径的映射 location /api/upload &#123; rewrite "^/(.*)$" /zuul/$1; &#125; location / &#123; proxy_pass http://192.168.1.101:10010; proxy_connect_timeout 600; proxy_read_timeout 600; &#125; &#125; 首先，我们映射路径是/api/upload，而下面一个映射路径是 / ，根据最长路径匹配原则，/api/upload优先级更高。也就是说，凡是以/api/upload开头的路径，都会被第一个配置处理 proxy_pass：反向代理，这次我们代理到8082端口，也就是upload-service服务 rewrite &quot;^/(.*)$&quot; /zuul/$1，路径重写： &quot;^/(.*)$&quot;：匹配路径的正则表达式，用了分组语法，把/api/以后的所有部分当做1组 /zuul/$1：重写的目标路径，这里用$1引用前面正则表达式匹配到的分组（组编号从1开始），即/api/后面的所有。这样新的路径就是除去/api/以外的所有，就达到了去除/api前缀的目的 2.2.6.之前上传的缺陷先思考一下，之前上传的功能，有没有什么问题？ 上传本身没有任何问题，问题出在保存文件的方式，我们是保存在服务器机器，就会有下面的问题： 单机器存储，存储能力有限 无法进行水平扩展，因为多台机器的文件无法共享,会出现访问不到的情况 数据没有备份，有单点故障风险 并发能力差 这个时候，最好使用分布式文件存储来代替本地文件存储。 3.FastDFS3.1.什么是分布式文件系统分布式文件系统（Distributed File System）是指文件系统管理的物理存储资源不一定直接连接在本地节点上，而是通过计算机网络与节点相连。 通俗来讲： 传统文件系统管理的文件就存储在本机。 分布式文件系统管理的文件存储在很多机器，这些机器通过网络连接，要被统一管理。无论是上传或者访问文件，都需要通过管理中心来访问 3.2.什么是FastDFSFastDFS是由淘宝的余庆先生所开发的一个轻量级、高性能的开源分布式文件系统。用纯C语言开发，功能丰富： 文件存储 文件同步 文件访问（上传、下载） 存取负载均衡 在线扩容 适合有大容量存储需求的应用或系统。同类的分布式文件系统有谷歌的GFS、HDFS（Hadoop）、TFS（淘宝）等。 3.3.FastDFS的架构3.3.1.架构图先上图： FastDFS两个主要的角色：Tracker Server 和 Storage Server 。 Tracker Server：跟踪服务器，主要负责调度storage节点与client通信，在访问上起负载均衡的作用，和记录storage节点的运行状态，是连接client和storage节点的枢纽。 Storage Server：存储服务器，保存文件和文件的meta data（元数据），每个storage server会启动一个单独的线程主动向Tracker cluster中每个tracker server报告其状态信息，包括磁盘使用情况，文件同步情况及文件上传下载次数统计等信息 Group：文件组，多台Storage Server的集群。上传一个文件到同组内的一台机器上后，FastDFS会将该文件即时同步到同组内的其它所有机器上，起到备份的作用。不同组的服务器，保存的数据不同，而且相互独立，不进行通信。 Tracker Cluster：跟踪服务器的集群，有一组Tracker Server（跟踪服务器）组成。 Storage Cluster ：存储集群，有多个Group组成。 3.3.2.上传和下载流程 上传 Client通过Tracker server查找可用的Storage server。 Tracker server向Client返回一台可用的Storage server的IP地址和端口号。 Client直接通过Tracker server返回的IP地址和端口与其中一台Storage server建立连接并进行文件上传。 上传完成，Storage server返回Client一个文件ID，文件上传结束。 下载 Client通过Tracker server查找要下载文件所在的的Storage server。 Tracker server向Client返回包含指定文件的某个Storage server的IP地址和端口号。 Client直接通过Tracker server返回的IP地址和端口与其中一台Storage server建立连接并指定要下载文件。 下载文件成功。 3.4.安装和使用参考课前资料的：《centos安装FastDFS.md》 3.5.java客户端余庆先生提供了一个Java客户端，但是作为一个C程序员，写的java代码可想而知。而且已经很久不维护了。 这里推荐一个开源的FastDFS客户端，支持最新的SpringBoot2.0。 配置使用极为简单，支持连接池，支持自动生成缩略图，狂拽酷炫吊炸天啊，有木有。 地址：tobato/FastDFS_client 3.5.1.引入依赖在父工程中，我们已经管理了依赖，版本为： 1&lt;fastDFS.client.version&gt;1.26.2&lt;/fastDFS.client.version&gt; 因此，这里我们直接引入坐标即可： 1234&lt;dependency&gt; &lt;groupId&gt;com.github.tobato&lt;/groupId&gt; &lt;artifactId&gt;fastdfs-client&lt;/artifactId&gt;&lt;/dependency&gt; 3.5.2.引入配置类纯java配置： 123456@Configuration@Import(FdfsClientConfig.class)// 解决jmx重复注册bean的问题@EnableMBeanExport(registration = RegistrationPolicy.IGNORE_EXISTING)public class FastClientImporter &#123;&#125; 3.5.3.编写FastDFS属性12345678fdfs: so-timeout: 1501 connect-timeout: 601 thumb-image: # 缩略图 width: 60 height: 60 tracker-list: # tracker地址 - 192.168.25.128:22122 #fdfs虚拟机ip地址 3.5.4.测试12345678910111213141516171819202122232425262728293031323334353637@RunWith(SpringRunner.class)@SpringBootTestpublic class FdfsTest &#123; @Autowired private FastFileStorageClient storageClient; @Autowired private ThumbImageConfig thumbImageConfig; @Test public void testUpload() throws FileNotFoundException &#123; File file = new File("G:/Java-webspace/LeYou-store/image/athor.jpg"); // 上传并且生成缩略图 StorePath storePath = this.storageClient.uploadFile( new FileInputStream(file), file.length(), "jpg", null); // 带分组的路径 System.out.println(storePath.getFullPath()); // 不带分组的路径 System.out.println(storePath.getPath()); &#125; @Test public void testUploadAndCreateThumb() throws FileNotFoundException &#123; File file = new File("G:/Java-webspace/LeYou-store/image/athor.jpg"); // 上传并且生成缩略图 StorePath storePath = this.storageClient.uploadImageAndCrtThumbImage( new FileInputStream(file), file.length(), "jpg", null); // 带分组的路径 System.out.println(storePath.getFullPath()); // 不带分组的路径 System.out.println(storePath.getPath()); // 获取缩略图路径 String path = thumbImageConfig.getThumbImagePath(storePath.getPath()); System.out.println(path); &#125;&#125; 结果： 123group1/M00/00/00/wKg4ZVro5eCAZEMVABfYcN8vzII630.pngM00/00/00/wKg4ZVro5eCAZEMVABfYcN8vzII630.pngM00/00/00/wKg4ZVro5eCAZEMVABfYcN8vzII630_60x60.png 访问第一个路径： 访问最后一个路径（缩略图路径），注意加组名： 3.5.5.改造上传逻辑定义错误信息在ly-common中 1234567891011121314@Getter@NoArgsConstructor@AllArgsConstructorpublic enum ExceptionEnums &#123; PRICE_CANNOT_BE_NULL(400, "价格不能为空"), CATEGORY_NOT_FOND(404,"没查询到"), BRAND_NOT_FOUND(500,"品牌查不到或者不存在"), BRAND_SAVE_ERROR(500,"新增品牌失败" ), UPLOAD_FILE_ERROR(500,"文件上传失败"), Invalid_file_type(500,"无效文件类型" ), ; private int code; private String msg;&#125; 修改ly-upload的UploadService 123456789101112131415161718192021222324252627282930313233@Service@Slf4jpublic class UploadService &#123; @Autowired private FastFileStorageClient fileStorageClient; //定义文件类型 private static final List&lt;String&gt; ALLOW_TYPES = Arrays.asList("image/png", "image/jpeg","image/bmp"); public String uploadImage(MultipartFile file) &#123; try &#123; //校验文件类型 String contentType=file.getContentType();//获取文件类型 if (!ALLOW_TYPES.contains(contentType))&#123; throw new LyException(ExceptionEnums.Invalid_file_type); &#125; //校验文件内容 BufferedImage image = ImageIO.read(file.getInputStream()); if (image==null)&#123; throw new LyException(ExceptionEnums.Invalid_file_type); &#125; // 2、将图片上传到FastDFS // 2.1、获取文件后缀名 String extension = StringUtils.substringAfterLast(file.getOriginalFilename(), "."); StorePath storePath = fileStorageClient.uploadFile(file.getInputStream(), file.getSize(), extension, null); //返回路径 return "http://image.leyou.com/" + storePath.getFullPath(); &#125; catch (IOException e) &#123; log.error("上传文件失败",e); throw new LyException(ExceptionEnums.UPLOAD_FILE_ERROR); &#125; &#125;&#125; 只需要把原来保存文件的逻辑去掉，然后上传到FastDFS即可。 3.5.6.测试通过RestClient测试： 3.6.页面测试上传发现上传成功： 不过，当我们访问页面时： 这是因为我们图片是上传到虚拟机的，ip为：192.168.25.128 因此，我们需要将image.leyou.com映射到192.168.25.128 修改我们的hosts： 再次上传： 3.7添加nginx图片上传大小在nginx的nginx.conf配置文件下添加到http{。。。。。。}的#access_log logs/access.log main;下 1client_max_body_size:10m 3.8.将图片导入到虚拟机中 将images.zip上传到虚拟机/leyou/static中 修改nginx.conf 4.修改品牌（作业）修改的难点在于回显。 当我们点击编辑按钮，希望弹出窗口的同时，看到原来的数据： 4.1.点击编辑出现弹窗这个比较简单，修改show属性为true即可实现，我们绑定一个点击事件： 1&lt;v-btn color="info" @click="editBrand"&gt;编辑&lt;/v-btn&gt; 然后编写事件，改变show 的状态： 如果仅仅是这样，编辑按钮与新增按钮将没有任何区别，关键在于，如何回显呢？ 4.2.回显数据回显数据，就是把当前点击的品牌数据传递到子组件（MyBrandForm）。而父组件给子组件传递数据，通过props属性。 第一步：在编辑时获取当前选中的品牌信息，并且记录到data中 先在data中定义属性，用来接收用来编辑的brand数据： 我们在页面触发编辑事件时，把当前的brand传递给editBrand方法： 1&lt;v-btn color="info" @click="editBrand(props.item)"&gt;编辑&lt;/v-btn&gt; 然后在editBrand中接收数据，赋值给oldBrand： 123456editBrand(oldBrand)&#123; // 控制弹窗可见： this.show = true; // 获取要编辑的brand this.oldBrand = oldBrand;&#125;, 第二步：把获取的brand数据 传递给子组件 1234&lt;!--对话框的内容，表单--&gt;&lt;v-card-text class="px-5"&gt; &lt;my-brand-form @close="closeWindow" :oldBrand="oldBrand"/&gt;&lt;/v-card-text&gt; 第三步：在子组件中通过props接收要编辑的brand数据，Vue会自动完成回显 接收数据： 通过watch函数监控oldBrand的变化，把值copy到本地的brand： 12345678910111213141516171819watch: &#123; oldBrand: &#123;// 监控oldBrand的变化 handler(val) &#123; if(val)&#123; // 注意不要直接复制，否则这边的修改会影响到父组件的数据，copy属性即可 this.brand = Object.deepCopy(val) &#125;else&#123; // 为空，初始化brand this.brand = &#123; name: '', letter: '', image: '', categories: [], &#125; &#125; &#125;, deep: true &#125;&#125; Object.deepCopy 自定义的对对象进行深度复制的方法。 需要判断监听到的是否为空，如果为空，应该进行初始化 测试：发现数据回显了，除了商品分类以外： 4.3.商品分类回显为什么商品分类没有回显？ 因为品牌中并没有商品分类数据。我们需要在进入编辑页面之前，查询商品分类信息： 4.3.1.后台提供接口 controller 在CategoryController中添加 12345678910/** * 根据品牌id查询商品分类 * @param bid * @return */@GetMapping("bid/&#123;bid&#125;")public ResponseEntity&lt;List&lt;Category&gt;&gt; editCategoryListByBid(@PathVariable("bid")Long bid)&#123; return ResponseEntity.ok(categoryService.editCategoryListByBid(bid));&#125; Service 123456789101112/** * 根据品牌id查询商品分类 * @param bid * @return */public List&lt;Category&gt; editCategoryListByBid(Long bid) &#123; List&lt;Category&gt; list = categoryMapper.queryCategoryListByBid(bid); if (CollectionUtils.isEmpty(list))&#123; throw new LyException(ExceptionEnums.CATEGORY_NOT_FOND); &#125; return list;&#125; mapper 因为需要通过中间表进行子查询，所以这里要手写Sql： 1234public interface CategoryMapper extends Mapper&lt;Category&gt;&#123; @Select("SELECT * FROM tb_category WHERE id IN (SELECT category_id FROM tb_category_brand WHERE brand_id = #&#123;bid&#125;)") List&lt;Category&gt; queryCategoryListByBid(@Param("bid")Long bid);&#125; 4.3.2.前台查询分类并渲染我们在编辑页面打开之前，先把数据查询完毕： 123456789101112editBrand(oldBrand)&#123; // 根据品牌信息查询商品分类 this.$http.get("/item/category/bid/" + oldBrand.id) .then((&#123;data&#125;) =&gt; &#123; // 控制弹窗可见： this.show = true; // 获取要编辑的brand this.oldBrand = oldBrand // 回显商品分类 this.oldBrand.categories = data; &#125;)&#125; 再次测试：数据成功回显了 4.3.3.新增窗口数据干扰但是，此时却产生了新问题：新增窗口竟然也有数据？ 原因： ​ 如果之前打开过编辑，那么在父组件中记录的oldBrand会保留。下次再打开窗口，如果是编辑窗口到没问题，但是新增的话，就会再次显示上次打开的品牌信息了。 解决： ​ 新增窗口打开前，把数据置空。 123456addBrand() &#123; // 控制弹窗可见： this.show = true; // 把oldBrand变为null this.oldBrand = null;&#125; 4.3.4.提交表单时判断是新增还是修改新增和修改是同一个页面，我们该如何判断？ 父组件中点击按钮弹出新增或修改的窗口，因此父组件非常清楚接下来是新增还是修改。 因此，最简单的方案就是，在父组件中定义变量，记录新增或修改状态，当弹出页面时，把这个状态也传递给子组件。 第一步：在父组件中记录状态： 第二步：在新增和修改前，更改状态： 第三步：传递给子组件 第四步，子组件接收标记： 标题的动态化： 表单提交动态： axios除了除了get和post外，还有一个通用的请求方式： 1234567891011121314// 将数据提交到后台// this.$http.post('/item/brand', this.$qs.stringify(params))this.$http(&#123; method: this.isEdit ? 'put' : 'post', // 动态判断是POST还是PUT url: '/item/brand', data: this.$qs.stringify(this.brand)&#125;).then(() =&gt; &#123; // 关闭窗口 this.$emit("close"); this.$message.success("保存成功！");&#125;) .catch(() =&gt; &#123; this.$message.error("保存失败！");&#125;); 4.4.品牌修改后台 ##controller 在BrandController 12345678910/** * 更新品牌 * @param brand * @return */@PutMappingpublic ResponseEntity&lt;Void&gt; editBrand(Brand brand)&#123; brandService.editBrand(brand); return ResponseEntity.status(HttpStatus.OK).build();&#125; service 在BrandService 1234567891011/** * 更新品牌 * @param brand * @return */public void editBrand(Brand brand) &#123; int update = brandMapper.updateByPrimaryKeySelective(brand); if (update!=1)&#123; throw new LyException(ExceptionEnums.BRAND_UPLOAD_ERROR); &#125;&#125; 5.删除品牌5.1前端在中Brand.vue 在表格中添加 12345678&lt;td class=&quot;justify-center layout px-0&quot;&gt; &lt;v-btn icon @click=&quot;editBrand(props.item)&quot;&gt; &lt;i class=&quot;el-icon-edit&quot;/&gt; &lt;/v-btn&gt; &lt;v-btn icon @click=&quot;deleteBrand(props.item)&quot;&gt; &lt;i class=&quot;el-icon-delete&quot;/&gt; &lt;/v-btn&gt; &lt;/td&gt; js如下 1234567891011121314//删除单个 deleteBrand(oldBrand)&#123; this.$message.confirm("此操作将永久删除"+oldBrand.id+"品牌, 是否继续?").then(() =&gt; &#123; // 发起删除请求 this.$http.delete("/item/brand/bid/" + oldBrand.id) .then(() =&gt; &#123; // 删除成功，重新加载数据 this.$message.success("删除成功！"); this.getDataFromServer(); &#125;) &#125;).catch(() =&gt; &#123; this.$message.info("删除已取消！"); &#125;); &#125; 5.2.controller12345678910/** * 根据id删除品牌信息 * @param bid * @return */ @DeleteMapping("bid/&#123;bid&#125;") public ResponseEntity&lt;Void&gt; delete(@PathVariable("bid")Long bid)&#123; brandService.delete(bid); return ResponseEntity.status(HttpStatus.OK).build(); &#125; 5.3.service1234public void delete(Long bid) &#123; brandMapper.deleteByPrimaryKey(bid); brandMapper.deleteByBid(bid);&#125; 5.3.mapper12@Delete("delete from tb_category_brand where brand_id=#&#123;bid&#125;")void deleteByBid(@Param("bid")Long bid);]]></content>
      <categories>
        <category>项目实战-微服务商城</category>
      </categories>
      <tags>
        <tag>FastDFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务商城（八）——搭建管理系统页面]]></title>
    <url>%2Fday06-%E6%90%AD%E5%BB%BA%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E9%A1%B5%E9%9D%A2.html</url>
    <content type="text"><![CDATA[0.学习目标 使用资料搭建后台系统 会使用nginx进行反向代理 实现商品分类查询功能 掌握cors解决跨域 实现品牌查询功能 1.使用域名访问本地项目1.1.统一环境我们现在访问页面使用的是：http://localhost:9001 有没有什么问题？ 实际开发中，会有不同的环境： 开发环境：自己的电脑 测试环境：提供给测试人员使用的环境 预发布环境：数据是和生成环境的数据一致，运行最新的项目代码进去测试 生产环境：项目最终发布上线的环境 如果不同环境使用不同的ip去访问，可能会出现一些问题。为了保证所有环境的一致，我们会在各种环境下都使用域名来访问。 我们将使用以下域名： 主域名是：www.leyou.com， 管理系统域名：manage.leyou.com 网关域名：api.leyou.com … 但是最终，我们希望这些域名指向的还是我们本机的某个端口。 那么，当我们在浏览器输入一个域名时，浏览器是如何找到对应服务的ip和端口的呢？ 1.2.域名解析一个域名一定会被解析为一个或多个ip。这一般会包含两步： 本地域名解析 浏览器会首先在本机的hosts文件中查找域名映射的IP地址，如果查找到就返回IP ，没找到则进行域名服务器解析，一般本地解析都会失败，因为默认这个文件是空的。 Windows下的hosts文件地址：C:/Windows/System32/drivers/etc/hosts Linux下的hosts文件所在路径： /etc/hosts 样式： 1234# My hosts127.0.0.1 localhost0.0.0.0 account.jetbrains.com127.0.0.1 www.xmind.net 域名服务器解析 本地解析失败，才会进行域名服务器解析，域名服务器就是网络中的一台计算机，里面记录了所有注册备案的域名和ip映射关系，一般只要域名是正确的，并且备案通过，一定能找到。 1.3.解决域名解析问题我们不可能去购买一个域名，因此我们可以伪造本地的hosts文件，实现对域名的解析。修改本地的host为： 12127.0.0.1 api.leyou.com127.0.0.1 manage.leyou.com 这样就实现了域名的关系映射了。 每次在C盘寻找hosts文件并修改是非常麻烦的，给大家推荐一个快捷修改host的工具，在课前资料中可以找到： 效果： 我们添加了两个映射关系： 127.0.0.1 api.leyou.com ：我们的网关Zuul 127.0.0.1 manage.leyou.com：我们的后台系统地址 现在，ping一下域名试试是否畅通： OK！ 1.4.nginx解决端口问题虽然域名解决了，但是现在如果我们要访问，还得自己加上端口：http://manage.leyou.com:9001。 这就不够优雅了。我们希望的是直接域名访问：http://manage.leyou.com。这种情况下端口默认是80，如何才能把请求转移到9001端口呢？ 这里就要用到反向代理工具：Nginx 1.4.1.什么是Nginx NIO：not-blocking-io 非阻塞IO BIO：blocking-IO 阻塞IO nginx可以作为web服务器，但更多的时候，我们把它作为网关，因为它具备网关必备的功能： 反向代理 负载均衡 动态路由 请求过滤 1.4.2.nginx作为web服务器Web服务器分2类： web应用服务器，如： tomcat resin jetty web服务器，如： Apache 服务器 Nginx IIS 区分：web服务器不能解析jsp等页面，只能处理js、css、html等静态资源。并发：web服务器的并发能力远高于web应用服务器。 Nginx + tomcat 1.4.3.nginx作为反向代理什么是反向代理？ 代理：通过客户机的配置，实现让一台服务器代理客户机，客户的所有请求都交给代理服务器处理。 反向代理：用一台服务器，代理真实服务器，用户访问时，不再是访问真实服务器，而是代理服务器。 nginx可以当做反向代理服务器来使用： 我们需要提前在nginx中配置好反向代理的规则，不同的请求，交给不同的真实服务器处理 当请求到达nginx，nginx会根据已经定义的规则进行请求的转发，从而实现路由功能 利用反向代理，就可以解决我们前面所说的端口问题，如图 1.5虚拟机安装nginx###1.5.1安装nginx 创建一个leyou文件 1[root@localhost home]# mkdir leyou 将资料目录FastDFS下的nginx复制到leyou目录下 1[root@localhost ~]# cp nginx-1.10.0.tar.gz /home/leyou 解压nginx： 1[root@localhost leyou]# tar -xvf nginx-1.10.0.tar.gz 改名字： 1[root@localhost leyou]# mv nginx-1.10.0 nginx 配置nginx 123[root@localhost leyou]#cd nginx//安装[root@localhost nginx]# ./configure --prefix=/opt/nginx --sbin-path=/usr/bin/nginx 指定安装目录为：/opt/nginx 目录下 编译安装 1[root@localhost nginx]# make &amp;&amp; make install 启动： 1[root@localhost nginx]# nginx 停止和重新加载 在存放nginx的目录下/home/leyou/nginx操作 停止 ：[root@localhost nginx]# nginx -s stop 重新加载：[root@localhost nginx]# nginx -s reload ###1.5.2反向代理配置 这里我们安装的nginx在 ” /opt/nginx “目录下 修改/opt/nginx/conf目下的nginx.conf 示例： nginx中的每个server就是一个反向代理配置，可以有多个server 完整配置： 1234567891011121314151617181920212223242526272829303132333435363738394041424344#user nobody;worker_processes 1;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; # gzip on; server &#123; listen 80; server_name manage.leyou.com; proxy_set_header X-Forwarded-Host $host; proxy_set_header X-Forwarded-Server $host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; location / &#123; proxy_pass http://192.168.1.106:9001;//本地电脑开发的ip地址 proxy_connect_timeout 600; proxy_read_timeout 600; &#125; &#125; server &#123; listen 80; server_name api.leyou.com; proxy_set_header X-Forwarded-Host $host; proxy_set_header X-Forwarded-Server $host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; location / &#123; proxy_pass http://192.168.1.106:10010; proxy_connect_timeout 600; proxy_read_timeout 600; &#125; &#125;&#125; 默认我们的前端项目绑定的host是：localhost ，因此只能在本机访问，要通过虚拟机访问，就是必须修改host绑定地址。 修改leyou-manage-web下的config的index.jsp ###1.5.3测试使用域名访问 使用软件：SwitchHosts 结果 流程： 浏览器准备发起请求，访问http://mamage.leyou.com，但需要进行域名解析 优先进行本地域名解析，因为我们修改了hosts，所以解析成功，得到地址：192.168.25.153 请求被发往解析得到的ip，并且默认使用80端口：http://192.168.2.153:80 本机的nginx一直监听80端口，因此捕获这个请求 nginx中配置了反向代理规则，将manage.leyou.com代理到192.168.1.103:9001，因此请求被转发 后台系统的webpack server监听的端口是9001，得到请求并处理，完成后将响应返回到nginx nginx将得到的结果返回到浏览器 2.实现商品分类查询商城的核心自然是商品，而商品多了以后，肯定要进行分类，并且不同的商品会有不同的品牌信息，其关系如图所示： 一个商品分类下有很多商品 一个商品分类下有很多品牌 而一个品牌，可能属于不同的分类 一个品牌下也会有很多商品 因此，我们需要依次去完成：商品分类、品牌、商品的开发。 2.1.导入数据首先导入课前资料提供的sql： 我们先看商品分类表： 123456789CREATE TABLE `tb_category` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &apos;类目id&apos;, `name` varchar(20) NOT NULL COMMENT &apos;类目名称&apos;, `parent_id` bigint(20) NOT NULL COMMENT &apos;父类目id,顶级类目填0&apos;, `is_parent` tinyint(1) NOT NULL COMMENT &apos;是否为父节点，0为否，1为是&apos;, `sort` int(4) NOT NULL COMMENT &apos;排序指数，越小越靠前&apos;, PRIMARY KEY (`id`), KEY `key_parent_id` (`parent_id`) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=1424 DEFAULT CHARSET=utf8 COMMENT=&apos;商品类目表，类目和商品(spu)是一对多关系，类目与品牌是多对多关系&apos;; 因为商品分类会有层级关系，因此这里我们加入了parent_id字段，对本表中的其它分类进行自关联。 2.2.页面实现2.2.1.页面分析首先我们看下要实现的效果： 商品分类之间是会有层级关系的，采用树结构去展示是最直观的方式。 一起来看页面，对应的是/pages/item/Category.vue： 页面模板： 123456789101112&lt;v-card&gt; &lt;v-flex xs12 sm10&gt; &lt;v-tree url="/item/category/list" :treeData="treeData" :isEdit="isEdit" @handleAdd="handleAdd" @handleEdit="handleEdit" @handleDelete="handleDelete" @handleClick="handleClick" /&gt; &lt;/v-flex&gt;&lt;/v-card&gt; v-card：卡片，是vuetify中提供的组件，提供一个悬浮效果的面板，一般用来展示一组数据。 v-flex：布局容器，用来控制响应式布局。与BootStrap的栅格系统类似，整个屏幕被分为12格。我们可以控制所占的格数来控制宽度： 本例中，我们用sm10控制在小屏幕及以上时，显示宽度为10格 v-tree：树组件。Vuetify并没有提供树组件，这个是我们自己编写的自定义组件： 里面涉及一些vue的高级用法，大家暂时不要关注其源码，会用即可。 2.2.2.树组件的用法也可参考课前资料中的：《自定义Vue组件的用法.md》 这里我贴出树组件的用法指南。 属性列表： 属性名称 说明 数据类型 默认值 url 用来加载数据的地址，即延迟加载 String - isEdit 是否开启树的编辑功能 boolean false treeData 整颗树数据，这样就不用远程加载了 Array - 这里推荐使用url进行延迟加载，每当点击父节点时，就会发起请求，根据父节点id查询子节点信息。 当有treeData属性时，就不会触发url加载 远程请求返回的结果格式： 12345678910111213141516[ &#123; "id": 74, "name": "手机", "parentId": 0, "isParent": true, "sort": 2 &#125;, &#123; "id": 75, "name": "家用电器", "parentId": 0, "isParent": true, "sort": 3 &#125;] 事件： 事件名称 说明 回调参数 handleAdd 新增节点时触发，isEdit为true时有效 新增节点node对象，包含属性：name、parentId和sort handleEdit 当某个节点被编辑后触发，isEdit为true时有效 被编辑节点的id和name handleDelete 当删除节点时触发，isEdit为true时有效 被删除节点的id handleClick 点击某节点时触发 被点击节点的node对象,包含全部信息 完整node的信息 回调函数中返回完整的node节点会包含以下数据： 12345678&#123; "id": 76, // 节点id "name": "手机", // 节点名称 "parentId": 75, // 父节点id "isParent": false, // 是否是父节点 "sort": 1, // 顺序 "path": ["手机", "手机通讯", "手机"] // 所有父节点的名称数组&#125; 2.3.实现功能2.3.1.url异步请求给大家的页面中，treeData是假数据，我们删除数据treeData属性，只保留url看看会发生什么： 1234567&lt;v-tree url="/item/category/list" :isEdit="isEdit" @handleAdd="handleAdd" @handleEdit="handleEdit" @handleDelete="handleDelete" @handleClick="handleClick" /&gt; 刷新页面，可以看到： 页面中的树没有了，并且发起了一条请求：http://localhost/api/item/category/list?pid=0 大家可能会觉得很奇怪，我们明明是使用的相对路径，讲道理发起的请求地址应该是： http://manage.leyou.com/item/category/list 但实际却是： http://localhost/api/item/category/list?pid=0 这是因为，我们有一个全局的配置文件，对所有的请求路径进行了约定： 路径是localhost，并且默认加上了/api的前缀，这恰好与我们的网关设置匹配，我们只需要把地址改成网关的地址即可,因为我们使用了nginx反向代理，这里可以写域名： 再次查看页面，发现地址已经变成了正确的地址了： 接下来，我们要做的事情就是编写后台接口，返回对应的数据即可。 2.3.2.实体类在ly-item-interface中添加category实体类： 123456789101112@Table(name="tb_category")public class Category &#123; @Id @KeySql(userGeneratedKey) private Long id; private String name; private Long parentId; private Boolean isParent; private Integer sort; // getter和setter略 // 注意isParent的get和set方法&#125; 需要注意的是，这里要用到jpa的注解，因此我们在ly-item-iterface中添加jpa依赖 12345&lt;dependency&gt; &lt;groupId&gt;javax.persistence&lt;/groupId&gt; &lt;artifactId&gt;persistence-api&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt;&lt;/dependency&gt; 结构： 2.3.3.controller编写一个controller一般需要知道四个内容： 请求方式：决定我们用GetMapping还是PostMapping 请求路径：决定映射路径 请求参数：决定方法的参数 返回值结果：决定方法的返回值 在刚才页面发起的请求中，我们就能得到绝大多数信息： 请求方式：Get 请求路径：/api/item/category/list。其中/api是网关前缀，/item是网关的路由映射，真实的路径应该是/category/list 请求参数：pid=0，根据tree组件的说明，应该是父节点的id，第一次查询为0，那就是查询一级类目 返回结果：？？ 根据前面tree组件的用法我们知道，返回的应该是json数组： 12345678910111213141516[ &#123; "id": 74, "name": "手机", "parentId": 0, "isParent": true, "sort": 2 &#125;, &#123; "id": 75, "name": "家用电器", "parentId": 0, "isParent": true, "sort": 3 &#125;] 对应的java类型可以是List集合，里面的元素就是类目对象了。 在ly-item-service中的web中创建 controller代码： 123456789101112131415161718@RestController@RequestMapping("category")public class CategoryController &#123; @Autowired private CategoryService categoryService; /** * 根据父节点查询商品分类 * ResponseEntity&lt;List&lt;Category&gt;&gt;：是restful风格 * @param pid * @return */ @GetMapping("list") public ResponseEntity&lt;List&lt;Category&gt;&gt; queryCategoryListByPid(@RequestParam("pid")Long pid)&#123; return ResponseEntity.ok(categoryService.queryCategoryListByPid(pid)); &#125;&#125; 2.3.4.service在ly-item-service中的service中创建 一般service层我们会定义接口和实现类，不过这里我们就偷懒一下，直接写实现类了： 12345678910111213141516171819202122@Servicepublic class CategoryService &#123; @Autowired private CategoryMapper categoryMapper; /** * 根据父节点查询商品分类 * ResponseEntity&lt;List&lt;Category&gt;&gt;：是restful风格 * @param pid * @return */ public List&lt;Category&gt; queryCategoryListByPid(Long pid) &#123; //查询条件，mapper会把对象中的非空属性作为查询条件 Category category = new Category(); category.setParentId(pid); List&lt;Category&gt; list = categoryMapper.select(category); if(CollectionUtils.isEmpty(list))&#123; //自定义的错误返回 throw new LyException(ExceptionEnums.CATEGORY_NOT_FOND); &#125; return list; &#125;&#125; 2.3.5.mapper在ly-item-service中的mapper中添加 我们使用通用mapper来简化开发： 12public interface CategoryMapper extends Mapper&lt;Category&gt; &#123;&#125; 要注意，我们并没有在mapper接口上声明@Mapper注解，那么mybatis如何才能找到接口呢？ 我们在启动类上添加一个扫描包功能： 在ly-item-service中LyItemService.java添加： 12345678@SpringBootApplication@EnableDiscoveryClient@MapperScan("com.leyou.item.mapper") // 扫描mapper包public class LyItemService &#123; public static void main(String[] args) &#123; SpringApplication.run(LyItemService.class, args); &#125;&#125; 2.3.6.启动并测试我们不经过网关，直接访问： 然后试试网关是否畅通： 一切OK！ 然后刷新页面查看： 发现报错了！ 浏览器直接访问没事，但是这里却报错，什么原因？ 2.4.跨域问题2.4.1.什么是跨域跨域是指跨域名的访问，以下情况都属于跨域： 跨域原因说明 示例 域名不同 www.jd.com 与 www.taobao.com 域名相同，端口不同 www.jd.com:8080 与 www.jd.com:8081 二级域名不同 item.jd.com 与 miaosha.jd.com 如果域名和端口都相同，但是请求路径不同，不属于跨域，如： www.jd.com/item www.jd.com/goods 而我们刚才是从manage.leyou.com去访问api.leyou.com，这属于二级域名不同，跨域了。 2.4.2.为什么有跨域问题？跨域不一定会有跨域问题。 因为跨域问题是浏览器对于ajax请求的一种安全限制：一个页面发起的ajax请求，只能是于当前页同域名的路径，这能有效的阻止跨站攻击。 因此：跨域问题 是针对ajax的一种限制。 但是这却给我们的开发带来了不变，而且在实际生成环境中，肯定会有很多台服务器之间交互，地址和端口都可能不同，怎么办？ 2.4.3.解决跨域问题的方案目前比较常用的跨域解决方案有3种： Jsonp 最早的解决方案，利用script标签可以跨域的原理实现。 限制： 需要服务的支持 只能发起GET请求 nginx反向代理 思路是：利用nginx反向代理把跨域为不跨域，支持各种请求方式 缺点：需要在nginx进行额外配置，语义不清晰 CORS 规范化的跨域请求解决方案，安全可靠。 优势： 在服务端进行控制是否允许跨域，可自定义规则 支持各种请求方式 缺点： 会产生额外的请求 我们这里会采用cors的跨域方案。 2.5.cors解决跨域2.5.1.什么是corsCORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。 它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。 CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。 浏览器端： 目前，所有浏览器都支持该功能（IE10以下不行）。整个CORS通信过程，都是浏览器自动完成，不需要用户参与。 服务端： CORS通信与AJAX没有任何差别，因此你不需要改变以前的业务逻辑。只不过，浏览器会在请求中携带一些头信息，我们需要以此判断是否运行其跨域，然后在响应头中加入一些信息即可。这一般通过过滤器完成即可。 2.5.2.原理有点复杂浏览器会将ajax请求分为两类，其处理方案略有差异：简单请求、特殊请求。 简单请求只要同时满足以下两大条件，就属于简单请求。： （1) 请求方法是以下三种方法之一： HEAD GET POST （2）HTTP的头信息不超出以下几种字段： Accept Accept-Language Content-Language Last-Event-ID Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain 当浏览器发现发现的ajax请求是简单请求时，会在请求头中携带一个字段：Origin. Origin中会指出当前请求属于哪个域（协议+域名+端口）。服务会根据这个值决定是否允许其跨域。 如果服务器允许跨域，需要在返回的响应头中携带下面信息： 123Access-Control-Allow-Origin: http://manage.leyou.comAccess-Control-Allow-Credentials: trueContent-Type: text/html; charset=utf-8 Access-Control-Allow-Origin：可接受的域，是一个具体域名或者*，代表任意 Access-Control-Allow-Credentials：是否允许携带cookie，默认情况下，cors不会携带cookie，除非这个值是true 注意： 如果跨域请求要想操作cookie，需要满足3个条件： 服务的响应头中需要携带Access-Control-Allow-Credentials并且为true。 浏览器发起ajax需要指定withCredentials 为true 响应头中的Access-Control-Allow-Origin一定不能为*，必须是指定的域名 特殊请求不符合简单请求的条件，会被浏览器判定为特殊请求,，例如请求方式为PUT。 预检请求 特殊请求会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）。 浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。 一个“预检”请求的样板： 12345678OPTIONS /cors HTTP/1.1Origin: http://manage.leyou.comAccess-Control-Request-Method: PUTAccess-Control-Request-Headers: X-Custom-HeaderHost: api.leyou.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0... 与简单请求相比，除了Origin以外，多了两个头： Access-Control-Request-Method：接下来会用到的请求方式，比如PUT Access-Control-Request-Headers：会额外用到的头信息 预检请求的响应 服务的收到预检请求，如果许可跨域，会发出响应： 1234567891011121314HTTP/1.1 200 OKDate: Mon, 01 Dec 2008 01:15:39 GMTServer: Apache/2.0.61 (Unix)Access-Control-Allow-Origin: http://manage.leyou.comAccess-Control-Allow-Credentials: trueAccess-Control-Allow-Methods: GET, POST, PUTAccess-Control-Allow-Headers: X-Custom-HeaderAccess-Control-Max-Age: 1728000Content-Type: text/html; charset=utf-8Content-Encoding: gzipContent-Length: 0Keep-Alive: timeout=2, max=100Connection: Keep-AliveContent-Type: text/plain 除了Access-Control-Allow-Origin和Access-Control-Allow-Credentials以外，这里又额外多出3个头： Access-Control-Allow-Methods：允许访问的方式 Access-Control-Allow-Headers：允许携带的头 Access-Control-Max-Age：本次许可的有效时长，单位是秒，过期之前的ajax请求就无需再次进行预检了 如果浏览器得到上述响应，则认定为可以跨域，后续就跟简单请求的处理是一样的了。 2.5.3.实现非常简单虽然原理比较复杂，但是前面说过： 浏览器端都有浏览器自动完成，我们无需操心 服务端可以通过拦截器统一实现，不必每次都去进行跨域判定的编写。 事实上，SpringMVC已经帮我们写好了CORS的跨域过滤器：CorsFilter ,内部已经实现了刚才所讲的判定逻辑，我们直接用就好了。 在ly-gateway中编写一个配置类，并且注册CorsFilter： 1234567891011121314151617181920212223242526272829303132333435import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.cors.CorsConfiguration;import org.springframework.web.cors.UrlBasedCorsConfigurationSource;import org.springframework.web.filter.CorsFilter;@Configurationpublic class GlobalCorsConfig &#123; @Bean public CorsFilter corsFilter() &#123; //1.添加CORS配置信息 CorsConfiguration config = new CorsConfiguration(); //1) 允许的域,不要写*，否则cookie就无法使用了 config.addAllowedOrigin("http://manage.leyou.com"); //2) 是否发送Cookie信息 config.setAllowCredentials(true); //3) 允许的请求方式 config.addAllowedMethod("OPTIONS"); config.addAllowedMethod("HEAD"); config.addAllowedMethod("GET"); config.addAllowedMethod("PUT"); config.addAllowedMethod("POST"); config.addAllowedMethod("DELETE"); config.addAllowedMethod("PATCH"); // 4）允许的头信息 config.addAllowedHeader("*"); //2.添加映射路径，我们拦截一切请求 UrlBasedCorsConfigurationSource configSource = new UrlBasedCorsConfigurationSource(); configSource.registerCorsConfiguration("/**", config); //3.返回新的CorsFilter. return new CorsFilter(configSource); &#125;&#125; 结构： 4.5.4.重启测试： 访问正常： 页面也OK了： 分类的增删改功能暂时就不做了，页面已经预留好了事件接口，有兴趣的同学可以完成一下。 3.品牌的查询（结合3.1-3.7一起看，先修改前端后修改后端）商品分类完成以后，自然轮到了品牌功能了。 先看看我们要实现的效果： 接下来，我们从0开始，实现下从前端到后端的完整开发。 3.1.从0开始为了方便看到效果，我们新建一个MyBrand.vue（注意先停掉服务器），从0开始搭建。 内容初始化一下： 123456789101112131415&lt;template&gt; &lt;span&gt; hello &lt;/span&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: &quot;my-brand&quot; &#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 改变router新的index.js，将路由地址指向MyBrand.vue 打开服务器，再次查看页面： 干干净净了。 3.2.品牌查询页面3.2.1.data-tables组件大家看到这个原型页面肯定能看出，其主体就是一个table。我们去Vuetify查看有关table的文档： 仔细阅读，发现v-data-table中有以下核心属性： dark：是否使用黑暗色彩主题，默认是false expand：表格的行是否可以展开，默认是false headers：定义表头的数组，数组的每个元素就是一个表头信息对象，结构： 12345678&#123; text: string, // 表头的显示文本 value: string, // 表头对应的每行数据的key align: 'left' | 'center' | 'right', // 位置 sortable: boolean, // 是否可排序 class: string[] | string,// 样式 width: string,// 宽度&#125; items：表格的数据的数组，数组的每个元素是一行数据的对象，对象的key要与表头的value一致 loading：是否显示加载数据的进度条，默认是false no-data-text：当没有查询到数据时显示的提示信息，string类型，无默认值 pagination.sync：包含分页和排序信息的对象，将其与vue实例中的属性关联，表格的分页或排序按钮被触发时，会自动将最新的分页和排序信息更新。对象结构： 123456&#123; page: 1, // 当前页 rowsPerPage: 5, // 每页大小 sortBy: '', // 排序字段 descending:false, // 是否降序&#125; total-items：分页的总条数信息，number类型，无默认值 select-all ：是否显示每一行的复选框，Boolean类型，无默认值 value：当表格可选的时候，返回选中的行 我们向下翻，找找有没有看起来牛逼的案例。 找到这样一条： 其它的案例都是由Vuetify帮我们对查询到的当前页数据进行排序和分页，这显然不是我们想要的。我们希望能在服务端完成对整体品牌数据的排序和分页，而这个案例恰好合适。 点击按钮，我们直接查看源码，然后直接复制到MyBrand.vue中 模板： 12345678910111213141516171819202122&lt;template&gt; &lt;div&gt; &lt;v-data-table :headers=&quot;headers&quot; :items=&quot;desserts&quot; :search=&quot;search&quot; :pagination.sync=&quot;pagination&quot; :total-items=&quot;totalDesserts&quot; :loading=&quot;loading&quot; class=&quot;elevation-1&quot; &gt; &lt;template slot=&quot;items&quot; slot-scope=&quot;props&quot;&gt; &lt;td&gt;&#123;&#123; props.item.name &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-right&quot;&gt;&#123;&#123; props.item.calories &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-right&quot;&gt;&#123;&#123; props.item.fat &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-right&quot;&gt;&#123;&#123; props.item.carbs &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-right&quot;&gt;&#123;&#123; props.item.protein &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-right&quot;&gt;&#123;&#123; props.item.iron &#125;&#125;&lt;/td&gt; &lt;/template&gt; &lt;/v-data-table&gt; &lt;/div&gt;&lt;/template&gt; 3.2.2.分析接下来，就分析一下案例中每一部分是什么意思，搞清楚了，我们也可以自己玩了。 先看模板中table上的一些属性： 12345678910&lt;v-data-table :headers=&quot;headers&quot; :items=&quot;desserts&quot; :search=&quot;search&quot; :pagination.sync=&quot;pagination&quot; :total-items=&quot;totalDesserts&quot; :loading=&quot;loading&quot; class=&quot;elevation-1&quot; &gt;&lt;/v-data-table&gt; headers：表头信息，是一个数组 items：要在表格中展示的数据，数组结构，每一个元素是一行 search：搜索过滤字段，用不到，暂时不管 pagination.sync：分页信息，包含了当前页，每页大小，排序字段，排序方式等。加上.sync代表服务端排序，当用户点击分页条时，该对象的值会跟着变化。监控这个值，并在这个值变化时去服务端查询，即可实现页面数据动态加载了。 total-items：总条数 loading：boolean类型，true：代表数据正在加载，会有进度条。false：数据加载完毕。 另外，在v-data-tables中，我们还看到另一段代码： 12345678&lt;template slot=&quot;items&quot; slot-scope=&quot;props&quot;&gt; &lt;td&gt;&#123;&#123; props.item.name &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-right&quot;&gt;&#123;&#123; props.item.calories &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-right&quot;&gt;&#123;&#123; props.item.fat &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-right&quot;&gt;&#123;&#123; props.item.carbs &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-right&quot;&gt;&#123;&#123; props.item.protein &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-right&quot;&gt;&#123;&#123; props.item.iron &#125;&#125;&lt;/td&gt;&lt;/template&gt; 这段就是在渲染每一行的数据。Vue会自动遍历上面传递的items属性，并把得到的对象传递给这段template中的props.item属性。我们从中得到数据，渲染在页面即可。 我们需要做的事情，主要有两件： 给items和totalItems赋值 当pagination变化时，重新获取数据，再次给items和totalItems赋值 3.2.3.初步实现我们先弄点假品牌数据： 1234567891011121314151617181920212223242526272829303132[ &#123; "id": 2032, "name": "OPPO", "image": "http://img10.360buyimg.com/popshop/jfs/t2119/133/2264148064/4303/b8ab3755/56b2f385N8e4eb051.jpg", "letter": "O" &#125;, &#123; "id": 2033, "name": "飞利浦（PHILIPS）", "image": "http://img12.360buyimg.com/popshop/jfs/t18361/122/1318410299/1870/36fe70c9/5ac43a4dNa44a0ce0.jpg", "letter": "F" &#125;, &#123; "id": 2034, "name": "华为（HUAWEI）", "image": "http://img10.360buyimg.com/popshop/jfs/t5662/36/8888655583/7806/1c629c01/598033b4Nd6055897.jpg", "letter": "H" &#125;, &#123; "id": 2036, "name": "酷派（Coolpad）", "image": "http://img10.360buyimg.com/popshop/jfs/t2521/347/883897149/3732/91c917ec/5670cf96Ncffa2ae6.jpg", "letter": "K" &#125;, &#123; "id": 2037, "name": "魅族（MEIZU）", "image": "http://img13.360buyimg.com/popshop/jfs/t3511/131/31887105/4943/48f83fa9/57fdf4b8N6e95624d.jpg", "letter": "M" &#125;] 品牌中有id,name,image,letter字段。 修改模板123456789101112131415161718192021&lt;div&gt; &lt;v-data-table :headers=&quot;headers&quot; :items=&quot;brands&quot; :search=&quot;search&quot; :pagination.sync=&quot;pagination&quot; :total-items=&quot;totalBrands&quot; :loading=&quot;loading&quot; class=&quot;elevation-1&quot; &gt; &lt;template slot=&quot;items&quot; slot-scope=&quot;props&quot;&gt; &lt;td&gt;&#123;&#123; props.item.id &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.name &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt; &lt;img v-if=&quot;props.item.image&quot; :src=&quot;props.item.image&quot; width=&quot;130&quot; height=&quot;40&quot;&gt; &lt;span v-else&gt;无&lt;/span&gt; &lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.letter &#125;&#125;&lt;/td&gt; &lt;/template&gt; &lt;/v-data-table&gt;&lt;/div&gt; 我们修改了以下部分： items：指向一个brands变量，等下在js代码中定义 total-items：指向了totalBrands变量，等下在js代码中定义 template模板中，渲染了四个字段： id： name image，注意，我们不是以文本渲染，而是赋值到一个img标签的src属性中，并且做了非空判断 letter 编写数据接下来编写要用到的数据： 1234567891011121314151617&#123; data() &#123; return &#123; search: '', // 搜索过滤字段 totalBrands: 0, // 总条数 brands: [], // 当前页品牌数据 loading: true, // 是否在加载中 pagination: &#123;&#125;, // 分页信息 headers: [ // 头信息 &#123;text: 'id', align: 'center', value: 'id'&#125;, &#123;text: '名称', align: 'center', sortable: false, value: 'name'&#125;, &#123;text: 'LOGO', align: 'center', sortable: false, value: 'image'&#125;, &#123;text: '首字母', align: 'center', value: 'letter', sortable: true,&#125; ] &#125; &#125;&#125; 编写函数，初始化数据接下来就是对brands和totalBrands完成赋值动作了。 我们编写一个函数来完成赋值，提高复用性： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950methods:&#123; getDataFromServer()&#123; // 从服务的加载数据的方法。 // 伪造假数据 const brands = [ &#123; "id": 2032, "name": "OPPO", "image": "http://img10.360buyimg.com/popshop/jfs/t2119/133/2264148064/4303/b8ab3755/56b2f385N8e4eb051.jpg", "letter": "O", "categories": null &#125;, &#123; "id": 2033, "name": "飞利浦（PHILIPS）", "image": "http://img12.360buyimg.com/popshop/jfs/t18361/122/1318410299/1870/36fe70c9/5ac43a4dNa44a0ce0.jpg", "letter": "F", "categories": null &#125;, &#123; "id": 2034, "name": "华为（HUAWEI）", "image": "http://img10.360buyimg.com/popshop/jfs/t5662/36/8888655583/7806/1c629c01/598033b4Nd6055897.jpg", "letter": "H", "categories": null &#125;, &#123; "id": 2036, "name": "酷派（Coolpad）", "image": "http://img10.360buyimg.com/popshop/jfs/t2521/347/883897149/3732/91c917ec/5670cf96Ncffa2ae6.jpg", "letter": "K", "categories": null &#125;, &#123; "id": 2037, "name": "魅族（MEIZU）", "image": "http://img13.360buyimg.com/popshop/jfs/t3511/131/31887105/4943/48f83fa9/57fdf4b8N6e95624d.jpg", "letter": "M", "categories": null &#125; ]; // 模拟延迟一段时间，随后进行赋值 setTimeout(() =&gt; &#123; // 然后赋值给brands this.brands = brands; this.totalBrands = brands.length; // 完成赋值后，把加载状态赋值为false this.loading = false; &#125;,400) &#125;&#125; 然后使用钩子函数，在Vue实例初始化完毕后调用这个方法，这里使用mounted（渲染后）函数： 1234mounted()&#123; // 渲染后执行 // 查询数据 this.getDataFromServer();&#125; 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899&lt;template&gt; &lt;div&gt; &lt;v-data-table :headers=&quot;headers&quot; :items=&quot;brands&quot; :search=&quot;search&quot; :pagination.sync=&quot;pagination&quot; :total-items=&quot;totalBrands&quot; :loading=&quot;loading&quot; class=&quot;elevation-1&quot; &gt; &lt;template slot=&quot;items&quot; slot-scope=&quot;props&quot;&gt; &lt;td&gt;&#123;&#123; props.item.id &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.name &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&lt;img :src=&quot;props.item.image&quot;&gt;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.letter &#125;&#125;&lt;/td&gt; &lt;/template&gt; &lt;/v-data-table&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: &quot;my-brand&quot;, data() &#123; return &#123; search: &apos;&apos;, // 搜索过滤字段 totalBrands: 0, // 总条数 brands: [], // 当前页品牌数据 loading: true, // 是否在加载中 pagination: &#123;&#125;, // 分页信息 headers: [ &#123;text: &apos;id&apos;, align: &apos;center&apos;, value: &apos;id&apos;&#125;, &#123;text: &apos;名称&apos;, align: &apos;center&apos;, sortable: false, value: &apos;name&apos;&#125;, &#123;text: &apos;LOGO&apos;, align: &apos;center&apos;, sortable: false, value: &apos;image&apos;&#125;, &#123;text: &apos;首字母&apos;, align: &apos;center&apos;, value: &apos;letter&apos;, sortable: true,&#125; ] &#125; &#125;, mounted()&#123; // 渲染后执行 // 查询数据 this.getDataFromServer(); &#125;, methods:&#123; getDataFromServer()&#123; // 从服务的加载数的方法。 // 伪造假数据 const brands = [ &#123; &quot;id&quot;: 2032, &quot;name&quot;: &quot;OPPO&quot;, &quot;image&quot;: &quot;http://img10.360buyimg.com/popshop/jfs/t2119/133/2264148064/4303/b8ab3755/56b2f385N8e4eb051.jpg&quot;, &quot;letter&quot;: &quot;O&quot;, &quot;categories&quot;: null &#125;, &#123; &quot;id&quot;: 2033, &quot;name&quot;: &quot;飞利浦（PHILIPS）&quot;, &quot;image&quot;: &quot;http://img12.360buyimg.com/popshop/jfs/t18361/122/1318410299/1870/36fe70c9/5ac43a4dNa44a0ce0.jpg&quot;, &quot;letter&quot;: &quot;F&quot;, &quot;categories&quot;: null &#125;, &#123; &quot;id&quot;: 2034, &quot;name&quot;: &quot;华为（HUAWEI）&quot;, &quot;image&quot;: &quot;http://img10.360buyimg.com/popshop/jfs/t5662/36/8888655583/7806/1c629c01/598033b4Nd6055897.jpg&quot;, &quot;letter&quot;: &quot;H&quot;, &quot;categories&quot;: null &#125;, &#123; &quot;id&quot;: 2036, &quot;name&quot;: &quot;酷派（Coolpad）&quot;, &quot;image&quot;: &quot;http://img10.360buyimg.com/popshop/jfs/t2521/347/883897149/3732/91c917ec/5670cf96Ncffa2ae6.jpg&quot;, &quot;letter&quot;: &quot;K&quot;, &quot;categories&quot;: null &#125;, &#123; &quot;id&quot;: 2037, &quot;name&quot;: &quot;魅族（MEIZU）&quot;, &quot;image&quot;: &quot;http://img13.360buyimg.com/popshop/jfs/t3511/131/31887105/4943/48f83fa9/57fdf4b8N6e95624d.jpg&quot;, &quot;letter&quot;: &quot;M&quot;, &quot;categories&quot;: null &#125; ]; // 模拟延迟一段时间，随后进行赋值 setTimeout(() =&gt; &#123; // 然后赋值给brands this.brands = brands; this.totalBrands = brands.length; // 完成赋值后，把加载状态赋值为false this.loading = false; &#125;,400) &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 刷新页面查看： 3.2.4.优化页面编辑和删除按钮我们将来要对品牌进行增删改，需要给每一行数据添加 修改删除的按钮，一般放到改行的最后一列： 其实就是多了一列，只是这一列没有数据，而是两个按钮而已。 我们先在头（headers）中添加一列： 1234567headers: [ &#123;text: 'id', align: 'center', value: 'id'&#125;, &#123;text: '名称', align: 'center', sortable: false, value: 'name'&#125;, &#123;text: 'LOGO', align: 'center', sortable: false, value: 'image'&#125;, &#123;text: '首字母', align: 'center', value: 'letter', sortable: true,&#125;, &#123;text: '操作', align: 'center', value: 'id', sortable: false&#125;] 然后在模板中添加按钮： 123456789&lt;template slot=&quot;items&quot; slot-scope=&quot;props&quot;&gt; &lt;td&gt;&#123;&#123; props.item.id &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.name &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&lt;img :src=&quot;props.item.image&quot;&gt;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.letter &#125;&#125;&lt;/td&gt; &lt;td class=&quot;justify-center&quot;&gt; 编辑/删除 &lt;/td&gt;&lt;/template&gt; 因为不知道按钮怎么写，先放个普通文本看看： 然后在官方文档中找到按钮的用法： 修改我们的模板： 12345678910&lt;template slot=&quot;items&quot; slot-scope=&quot;props&quot;&gt; &lt;td&gt;&#123;&#123; props.item.id &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.name &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&lt;img :src=&quot;props.item.image&quot;&gt;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.letter &#125;&#125;&lt;/td&gt; &lt;td class=&quot;justify-center layout&quot;&gt; &lt;v-btn color=&quot;info&quot;&gt;编辑&lt;/v-btn&gt; &lt;v-btn color=&quot;warning&quot;&gt;删除&lt;/v-btn&gt; &lt;/td&gt;&lt;/template&gt; 新增按钮因为新增根某个品牌无关，是独立的，因此我们可以放到表格的外面： 效果： 布局v-layout、v-flex1234567891011121314151617181920212223242526&lt;div&gt; &lt;v-layout class=&quot;px-2&quot;&gt; &lt;v-flex xs2&gt; &lt;v-btn color=&quot;info&quot; &gt;新增品牌&lt;/v-btn&gt; &lt;/v-flex&gt; &lt;/v-layout&gt; &lt;v-data-table :headers=&quot;headers&quot; :items=&quot;brands&quot; :search=&quot;search&quot; :pagination.sync=&quot;pagination&quot; :total-items=&quot;totalBrands&quot; :loading=&quot;loading&quot; class=&quot;elevation-1&quot; &gt; &lt;template slot=&quot;items&quot; slot-scope=&quot;props&quot;&gt; &lt;td&gt;&#123;&#123; props.item.id &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.name &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&lt;img :src=&quot;props.item.image&quot;&gt;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.letter &#125;&#125;&lt;/td&gt; &lt;td class=&quot;justify-center layout&quot;&gt; &lt;v-btn color=&quot;info&quot;&gt;编辑&lt;/v-btn&gt; &lt;v-btn color=&quot;warning&quot;&gt;删除&lt;/v-btn&gt; &lt;/td&gt; &lt;/template&gt; &lt;/v-data-table&gt; 效果： 添加搜索框我们还可以在卡片头部添加一个搜索框，其实就是一个文本输入框。 查看官网中，文本框的用法： name：字段名，表单中会用到 label：提示文字 value：值。可以用v-model代替，实现双向绑定 修改模板，添加输入框： 123&lt;v-flex xs4&gt; &lt;v-text-field label="输入关键字搜索" v-model="key" append-icon="search" hide-details /&gt;&lt;/v-flex&gt; 效果： 发现输入框变的超级长！！！ 这个时候，我们可以使用Vuetify提供的一个空间隔离工具： 修改代码： 12345678910&lt;v-layout class="px-2"&gt; &lt;v-flex xs2&gt; &lt;v-btn color="info" &gt;新增品牌&lt;/v-btn&gt; &lt;/v-flex&gt; &lt;!--撑开一个空间--&gt; &lt;v-spacer/&gt; &lt;v-flex xs4&gt; &lt;v-text-field label="输入关键字搜索" v-model="key" append-icon="search" hide-details /&gt; &lt;/v-flex&gt;&lt;/v-layout&gt; 给搜索框添加搜索图标查看textfiled的文档，发现： 通过append-icon属性可以为 输入框添加后置图标，所有可用图标名称可以到 material-icons官网去查看。 修改我们的代码： 1&lt;v-text-field label="输入关键字搜索" v-model="search" append-icon="search"/&gt; 把文本框变紧凑搜索框看起来高度比较高，页面不够紧凑。这其实是因为默认在文本框下面预留有错误提示空间。通过下面的属性可以取消提示： 修改代码： 1&lt;v-text-field label="输入关键字搜索" v-model="search" append-icon="search" hide-details/&gt; 效果： 几乎已经达到了原来一样的效果了吧！ 3.3.异步查询工具axios异步查询数据，自然是通过ajax查询，大家首先想起的肯定是jQuery。但jQuery与MVVM的思想不吻合，而且ajax只是jQuery的一小部分。因此不可能为了发起ajax请求而去引用这么大的一个库。 3.3.1.axios入门Vue官方推荐的ajax请求框架叫做：axios，看下demo： axios的Get请求语法： 123456789101112131415axios.get("/item/category/list?pid=0") // 请求路径和请求参数拼接 .then(function(resp)&#123; // 成功回调函数 &#125;) .catch(function()&#123; // 失败回调函数 &#125;)// 参数较多时，可以通过params来传递参数axios.get("/item/category/list", &#123; params:&#123; pid:0 &#125; &#125;) .then(function(resp)&#123;&#125;)// 成功时的回调 .catch(function(error)&#123;&#125;)// 失败时的回调 axios的POST请求语法： 比如新增一个用户 123456axios.post("/user",&#123; name:"Jack", age:21 &#125;) .then(function(resp)&#123;&#125;) .catch(function(error)&#123;&#125;) 注意，POST请求传参，不需要像GET请求那样定义一个对象，在对象的params参数中传参。post()方法的第二个参数对象，就是将来要传递的参数 PUT和DELETE请求与POST请求类似 3.3.2.axios的全局配置而在我们的项目中，已经引入了axios，并且进行了简单的封装，在src下的http.js中： http.js中对axios进行了一些默认配置： 12345678import Vue from 'vue'import axios from 'axios'import config from './config'// config中定义的基础路径是：http://api.leyou.com/apiaxios.defaults.baseURL = config.api; // 设置axios的基础请求路径axios.defaults.timeout = 2000; // 设置axios的请求时间Vue.prototype.$http = axios;// 将axios赋值给Vue原型的$http属性，这样所有vue实例都可使用该对象 http.js中导入了config的配置，还记得吗？ http.js对axios进行了全局配置：baseURL=config.api，即http://api.leyou.com/api。因此以后所有用axios发起的请求，都会以这个地址作为前缀。 通过Vue.property.$http = axios，将axios赋值给了 Vue原型中的$http。这样以后所有的Vue实例都可以访问到$http，也就是访问到了axios了。 3.3.3.测试一下：我们在组件MyBrand.vue的loadBrands()方法，通过$http发起get请求，测试查询品牌的接口，看是否能获取到数据： 网络监视： 控制台结果： 可以看到，在请求成功的返回结果response中，有一个data属性，里面就是真正的响应数据。 响应结果中与我们设计的一致，包含3个内容： total：总条数，目前是165 items：当前页数据 totalPage：总页数，我们没有返回 3.4.异步加载品牌数据虽然已经通过ajax请求获取了品牌数据，但是刚才的请求没有携带任何参数，这样显然不对。我们后端接口需要5个参数： page：当前页，int rows：每页大小，int sortBy：排序字段，String desc：是否为降序，boolean key：搜索关键词，String 而页面中分页信息应该是在pagination对象中，我们通过浏览器工具，查看pagination中有哪些属性： 分别是： descending：是否是降序，对应请求参数的desc page：当前页，对应参数的page rowsPerpage：每页大小，对应参数中的rows sortBy：排序字段，对应参数的sortBy 缺少一个搜索关键词，这个应该是通过v-model与输入框绑定的属性：search。这样，所有参数就都有了。 另外，不要忘了把查询的结果赋值给brands和totalBrands属性，Vuetify会帮我们渲染页面。 接下来，我们在loadBrands()方法中完善请求参数： 12345678910111213141516// 发起请求this.$http.get("/item/brand/page",&#123; params:&#123; key: this.search, // 搜索条件 page: this.pagination.page,// 当前页 rows: this.pagination.rowsPerPage,// 每页大小 sortBy: this.pagination.sortBy,// 排序字段 desc: this.pagination.descending// 是否降序 &#125; &#125;).then(resp =&gt; &#123; // 这里使用箭头函数 // 将得到的数据赋值给本地属性 this.brands = resp.data.items; this.totalBrands = resp.data.total; // 完成赋值后，把加载状态赋值为false this.loading = false; &#125;) 查看网络请求： 效果： 3.5.完成分页和过滤3.5.1.分页现在我们实现了页面加载时的第一次查询，你会发现你点击分页或搜索不会发起新的请求，怎么办？ 虽然点击分页，不会发起请求，但是通过浏览器工具查看，会发现pagination对象的属性一直在变化： 我们可以利用Vue的监视功能：watch，当pagination发生改变时，会调用我们的回调函数，我们在回调函数中进行数据的查询即可！ 具体实现： 成功实现分页功能： 3.5.2.过滤分页实现了，过滤也很好实现了。过滤字段对应的是key属性，我们只要监视这个属性即可: 查看网络请求： 页面结果： 3.6.前端完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102&lt;template&gt; &lt;div&gt; &lt;v-layout class=&quot;px-2&quot;&gt; &lt;v-flex xs2&gt; &lt;v-btn color=&quot;info&quot; &gt;新增品牌&lt;/v-btn&gt; &lt;/v-flex&gt; &lt;!--撑开一个空间--&gt; &lt;v-spacer/&gt; &lt;v-flex xs4&gt; &lt;v-text-field label=&quot;输入关键字搜索&quot; v-model=&quot;key&quot; append-icon=&quot;search&quot; hide-details /&gt; &lt;/v-flex&gt; &lt;/v-layout&gt; &lt;!--v-data-table表格，pagination：分页信息，total-items：查出来总数 ,loading：进度条--&gt; &lt;v-data-table :headers=&quot;headers&quot; :items=&quot;brands&quot; :pagination.sync=&quot;pagination&quot; :total-items=&quot;totalBrands&quot; :loading=&quot;loading&quot; class=&quot;elevation-1&quot; &gt; &lt;template slot=&quot;items&quot; slot-scope=&quot;props&quot;&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.id &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.name &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&lt;img v-if=&quot;props.item.image&quot; :src=&quot;props.item.image&quot; width=&quot;130&quot; height=&quot;40&quot;&gt;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.letter &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt; &lt;v-btn color=&quot;warning&quot;&gt;删除&lt;/v-btn&gt; &lt;v-btn color=&quot;info&quot;&gt;修改&lt;/v-btn&gt; &lt;/td&gt; &lt;/template&gt; &lt;/v-data-table&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: &quot;Mybrand.vue&quot;, data()&#123; return&#123; headers:[ &#123;text: &apos;品牌id&apos;,value: &apos;id&apos;,align: &apos;center&apos;,sortable: true&#125;, &#123;text: &apos;品牌名称&apos;,value: &apos;name&apos;,align: &apos;center&apos;,sortable: false&#125;, &#123;text: &apos;品牌LOGO&apos;,value: &apos;image&apos;,align: &apos;center&apos;,sortable: false&#125;, &#123;text: &apos;品牌首字母&apos;,value: &apos;letter&apos;,align: &apos;center&apos;,sortable: true&#125;, &#123;text: &apos;操作&apos;,value: &apos;id&apos;,align: &apos;center&apos;,sortable: false&#125;, ], brands:[], //当前页品牌数 pagination:&#123;&#125;, //分页信息 totalBrands:0, //查询出来的总数据条数 loading:false, //是否加载 key:&quot;&quot;, //搜索关键字 &#125; &#125;, //1、立马加载 created()&#123; this.totalBrands=15; //去后台查询品牌 this.loadBrands(); &#125;, //2、监控,数据变化后就立马加载 watch:&#123; //监控搜索关键词 key:&#123; handler() &#123; this.loadBrands(); this.pagination.page=1; &#125; &#125;, pagination:&#123; deep:true,//深度监控 handler()&#123; this.loadBrands(); &#125; &#125; &#125;, //3、与后台数据交互 methods:&#123; loadBrands()&#123; this.loading=true; this.$http.get(&quot;/item/brand/page&quot;,&#123; params:&#123; key:this.key,//搜索条件 page:this.pagination.page,//当前页 row:this.pagination.rowsPerPage,//每页大小 sortBy:this.pagination.sortBy,//排序字段 desc:this.pagination.descending,//是否降序 &#125; &#125;).then(resp =&gt; &#123; this.brands=resp.data.items; this.totalBrands=resp.data.total; this.loading=false; &#125;) &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 3.7.后台提供查询接口前台页面已经准备好，接下来就是后台提供数据接口了。 3.7.1.数据库表1234567CREATE TABLE `tb_brand` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &apos;品牌id&apos;, `name` varchar(50) NOT NULL COMMENT &apos;品牌名称&apos;, `image` varchar(200) DEFAULT &apos;&apos; COMMENT &apos;品牌图片地址&apos;, `letter` char(1) DEFAULT &apos;&apos; COMMENT &apos;品牌的首字母&apos;, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=325400 DEFAULT CHARSET=utf8 COMMENT=&apos;品牌表，一个品牌下有多个商品（spu），一对多关系&apos;; 简单的四个字段，不多解释。 这里需要注意的是，品牌和商品分类之间是多对多关系。因此我们有一张中间表，来维护两者间关系： 12345CREATE TABLE `tb_category_brand` ( `category_id` bigint(20) NOT NULL COMMENT &apos;商品类目id&apos;, `brand_id` bigint(20) NOT NULL COMMENT &apos;品牌id&apos;, PRIMARY KEY (`category_id`,`brand_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&apos;商品分类和品牌的中间表，两者是多对多关系&apos;; 但是，你可能会发现，这张表中并没有设置外键约束，似乎与数据库的设计范式不符。为什么这么做？ 外键会严重影响数据库读写的效率 数据删除时会比较麻烦 在电商行业，性能是非常重要的。我们宁可在代码中通过逻辑来维护表关系，也不设置外键。 3.7.2.实体类在ly-item-interface中创建Brand类 1234567891011@Table(name = "tb_brand")@Datapublic class Brand &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; private String name;// 品牌名称 private String image;// 品牌图片 private Character letter; // getter setter 略&#125; 3.7.3.mapperly-item-service的mapper中创建 通用mapper来简化开发： 12public interface BrandMapper extends Mapper&lt;Brand&gt; &#123;&#125; 3.7.4.controllerly-item-service的web中创建 编写controller先思考四个问题，这次没有前端代码，需要我们自己来设定 请求方式：查询，肯定是Get 请求路径：分页查询，/brand/page 请求参数：根据我们刚才编写的页面，有分页功能，有排序功能，有搜索过滤功能，因此至少要有5个参数： page：当前页，int rows：每页大小，int sortBy：排序字段，String desc：是否为降序，boolean key：搜索关键词，String 响应结果：分页结果一般至少需要两个数据 total：总条数 items：当前页数据 totalPage：有些还需要总页数 这里我们封装一个类，来表示分页结果： 1234567891011121314151617181920@Datapublic class PageResult&lt;T&gt; &#123; private Long total;// 总条数 private Long totalPage;// 总页数 private List&lt;T&gt; items;// 当前页数据 public PageResult() &#123; &#125; public PageResult(Long total, List&lt;T&gt; items) &#123; this.total = total; this.items = items; &#125; public PageResult(Long total, Long totalPage, List&lt;T&gt; items) &#123; this.total = total; this.totalPage = totalPage; this.items = items; &#125;&#125; 另外，这个PageResult以后可能在其它项目中也有需求，因此我们将其抽取到ly-common中，提高复用性： 接下来，我们编写Controller 12345678910111213141516171819202122232425262728@RestController@RequestMapping("brand")public class BrandController &#123; @Autowired private BrandService brandService; /** * * @param page 当前页 * @param rows 每页显示多少数据 * @param sortBy 是否排序 * @param desc 是否降序 * @param key 搜索条件 * @return */ @GetMapping("page") public ResponseEntity&lt;PageResult&lt;Brand&gt;&gt; queryBrandByPage( @RequestParam(value = "page", defaultValue = "1") Integer page, @RequestParam(value = "rows", defaultValue = "5") Integer rows, @RequestParam(value = "sortBy", required = false) String sortBy, @RequestParam(value = "desc", defaultValue = "false") Boolean desc, @RequestParam(value = "key", required = false) String key )&#123; PageResult&lt;Brand&gt; brandPageResult = brandService.queryBrandByPage(page, rows, sortBy, desc, key); return ResponseEntity.ok(brandPageResult); &#125;&#125; 3.7.5.Service123456789101112131415161718192021222324252627282930313233public class BrandService &#123; @Autowired private BrandMapper brandMapper; public PageResult&lt;Brand&gt; queryBrandByPage(Integer page, Integer rows, String sortBy, boolean desc, String key) &#123; //分页 PageHelper.startPage(page,rows); //过滤(搜索) /** * SQL语句 * where name like %x% or letter==x * order by desc */ Example example = new Example(Brand.class); if(StringUtils.isNotBlank(key))&#123; example.createCriteria().orLike("name","%"+key+"%").orEqualTo("letter",key.toUpperCase());//key.toUpperCase()变成大写 &#125; //排序 if(StringUtils.isNotBlank(sortBy))&#123; String orderByClause=sortBy+(desc ? " DESC":" ASC"); example.setOrderByClause(orderByClause); &#125; //查询 List&lt;Brand&gt; list = brandMapper.selectByExample(example); if (CollectionUtils.isEmpty(list))&#123; throw new LyException(ExceptionEnums.BRAND_NOT_FOUND); &#125; //解析分页结果 PageInfo&lt;Brand&gt; info = new PageInfo&lt;&gt;(list); return new PageResult&lt;&gt;(info.getTotal(),list); &#125;&#125; 3.7.6.测试通过浏览器访问试试：http://api.leyou.com/api/item/brand/page 接下来，去页面请求数据并渲染]]></content>
      <categories>
        <category>项目实战-微服务商城</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[微服务商城（七）——商城项目搭建]]></title>
    <url>%2Fday05-%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA.html</url>
    <content type="text"><![CDATA[0.学习目标 了解电商行业 了解乐优商城项目结构 能独立搭建项目基本框架 能参考使用ES6的新语法 1.了解电商行业学习电商项目，自然要先了解这个行业，所以我们首先来聊聊电商行业 1.1.项目分类主要从需求方、盈利模式、技术侧重点这三个方面来看它们的不同 1.1.1.传统项目各种企业里面用的管理系统（ERP、HR、OA、CRM、物流管理系统。。。。。。。） 需求方：公司、企业内部 盈利模式：项目本身卖钱 技术侧重点：业务功能 1.1.2.互联网项目门户网站、电商网站：baidu.com、qq.com、taobao.com、jd.com …… 需求方：广大用户群体 盈利模式：虚拟币、增值服务、广告收益…… 技术侧重点：网站性能、业务功能 而我们今天要聊的就是互联网项目中的重要角色：电商 1.2.电商行业的发展1.2.1.钱景近年来，中国的电子商务快速发展，交易额连创新高，电子商务在各领域的应用不断拓展和深化、相关服务业蓬勃发展、支撑体系不断健全完善、创新的动力和能力不断增强。电子商务正在与实体经济深度融合，进入规模性发展阶段，对经济社会生活的影响不断增大，正成为我国经济发展的新引擎。 中国电子商务研究中心数据显示，截止到 2012 年底，中国电子商务市场交易规模达 7.85万亿人民币，同比增长 30.83%。其中，B2B 电子商务交易额达 6.25 万亿，同比增长 27%。而 2011 年全年，中国电子商务市场交易额达 6 万亿人民币，同比增长 33%，占 GDP 比重上升到 13%；2012 年，电子商务占 GDP 的比重已经高达 15%。 ![1525686041466](assets/1525686041466.png) 1.2.2.数据来看看双十一的成交数据： 2016双11开场30分钟，创造每秒交易峰值17.5万笔，每秒支付峰值12万笔的新纪录。菜鸟单日物流订单量超过4.67亿，创历史新高。 1.2.3.技术特点从上面的数据我们不仅要看到钱，更要看到背后的技术实力。正是得益于电商行业的高强度并发压力，促使了BAT等巨头们的技术进步。电商行业有些什么特点呢？ 技术范围广 技术新 高并发（分布式、静态化技术、缓存技术、异步并发、池化、队列） 高可用（集群、负载均衡、限流、降级、熔断） 数据量大 业务复杂 数据安全 1.3.常见电商模式电商行业的一些常见模式： B2C：商家对个人，如：亚马逊、当当等 C2C平台：个人对个人，如：咸鱼、拍拍网、ebay B2B平台：商家对商家，如：阿里巴巴、八方资源网等 O2O：线上和线下结合，如：饿了么、电影票、团购等 P2P：在线金融，贷款，如：网贷之家、人人聚财等。 B2C平台：天猫、京东、一号店等 1.4.一些专业术语 SaaS：软件即服务 SOA：面向服务 RPC：远程过程调用 RMI：远程方法调用 PV：(page view)，即页面浏览量； 用户每1次对网站中的每个网页访问均被记录1次。用户对同一页面的多次访问，访问量累计 UV：(unique visitor)，独立访客 指访问某个站点或点击某条新闻的不同IP地址的人数。在同一天内，uv只记录第一次进入网站的具有独立IP的访问者，在同一天内再次访问该网站则不计数。 PV与带宽： 计算带宽大小需要关注两个指标：峰值流量和页面的平均大小。 计算公式是：网站带宽= ( PV 平均页面大小（单位MB） 8 )/统计时间（换算到秒） 为什么要乘以8？ 网站大小为单位是字节(Byte)，而计算带宽的单位是bit，1Byte=8bit 这个计算的是平均带宽，高峰期还需要扩大一定倍数 PV、QPS、并发 QPS：每秒处理的请求数量。8000/s 比如你的程序处理一个请求平均需要0.1S，那么1秒就可以处理10个请求。QPS自然就是10，多线程情况下，这个数字可能就会有所增加。 由PV和QPS如何需要部署的服务器数量？ 根据二八原则，80%的请求集中在20%的时间来计算峰值压力： （每日PV 80%） / （3600s 24 20%） 每个页面的请求数 = 每个页面每秒的请求数量 然后除以服务器的QPS值，即可计算得出需要部署的服务器数量 1.5.项目开发流程项目经理：管人 产品经理：设计需求原型 测试： 前端：大前端。node 后端： 移动端： 项目开发流程图： ​ 公司现状： ​ 2.乐优商城介绍2.1.项目介绍 乐优商城是一个全品类的电商购物网站（B2C）。 用户可以在线购买商品、加入购物车、下单、秒杀商品 可以品论已购买商品 管理员可以在后台管理商品的上下架、促销活动 管理员可以监控商品销售状况 客服可以在后台处理退款操作 希望未来3到5年可以支持千万用户的使用 2.2.系统架构2.2.1.架构图乐优商城架构缩略图，大图请参考课前资料： 2.2.2.系统架构解读整个乐优商城可以分为两部分：后台管理系统、前台门户系统。 后台管理： 后台系统主要包含以下功能： 商品管理，包括商品分类、品牌、商品规格等信息的管理 销售管理，包括订单统计、订单退款处理、促销活动生成等 用户管理，包括用户控制、冻结、解锁等 权限管理，整个网站的权限控制，采用JWT鉴权方案，对用户及API进行权限控制 统计，各种数据的统计分析展示 后台系统会采用前后端分离开发，而且整个后台管理系统会使用Vue.js框架搭建出单页应用（SPA）。 预览图： 前台门户 前台门户面向的是客户，包含与客户交互的一切功能。例如： 搜索商品 加入购物车 下单 评价商品等等 前台系统我们会使用Thymeleaf模板引擎技术来完成页面开发。出于SEO优化的考虑，我们将不采用单页应用。 无论是前台还是后台系统，都共享相同的微服务集群，包括： 商品微服务：商品及商品分类、品牌、库存等的服务 搜索微服务：实现搜索功能 订单微服务：实现订单相关 购物车微服务：实现购物车相关功能 用户中心：用户的登录注册等功能 短信服务：完成各种短息的发送任务 授权服务：完成对用户的授权、鉴权等功能 Eureka注册中心 Zuul网关服务 Spring Cloud Config配置中心 … 3.商城管理系统前端页面我们的后台管理系统采用前后端分离开发，而且整个后台管理系统会使用Vue.js框架搭建出单页应用SPA 3.1.什么事SPA SPA，Single Page Application，即单页应用。整个后台管理系统只会出现一个HTML页面，剩下的一切页面的内容都是通过Vue组件来实现的。 这些Vue组件其实就是许多的JS文件。不过前端除了js，还有css、image、font等，甚至前端还开发出各种不同类型的扩展语言，这么多东西在打包、构建的过程中，人工来操作非常麻烦，因此就会有一些工具来帮助搭建前端项目，如：webpack、vue-cli 3.2.webpack####3.2.1.介绍 Webpack 是一个前端资源的打包工具，它可以将js、image、css等资源当成一个模块进行打包。 中文官方网站：https://www.webpackjs.com/ 官网给出的解释： 本质上，webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。 为什么需要打包？ 将许多碎小文件打包成一个整体，减少单页面内的衍生请求次数，提高网站效率。 将ES6的高级语法进行转换编译，以兼容老版本的浏览器。 将代码打包的同时进行混淆，提高代码的安全性。 ####3.2.2.四个核心概念 学习Webpack，你需要先理解四个核心概念： 入口(entry) webpack打包的起点，可以有一个或多个，一般是js文件。webpack会从启点文件开始，寻找启点直接或间接依赖的其它所有的依赖，包括JS、CSS、图片资源等，作为将来打包的原始数据 输出(output) 出口一般包含两个属性：path和filename。用来告诉webpack打包的目标文件夹，以及文件的名称。目的地也可以有多个。 加载器（loader） webpack本身只识别Js文件，如果要加载非JS文件，必须指定一些额外的加载器（loader），例如css-loader。然后将这些文件转为webpack能处理的有效模块，最后利用webpack的打包能力去处理。 插件(plugins) 插件可以扩展webpack的功能，让webpack不仅仅是完成打包，甚至各种更复杂的功能，或者是对打包功能进行优化、压缩，提高效率。 3.3.vue-cli3.3.1.介绍和安装在开发中，需要打包的东西不止是js、css、html。还有更多的东西要处理，这些插件和加载器如果我们一一去添加就会比较麻烦。 幸好，vue官方提供了一个快速搭建vue项目的脚手架：vue-cli 使用它能快速的构建一个web工程模板。 官网：https://github.com/vuejs/vue-cli cmd安装命令：npm install -g vue-cli 3.3.2.快速上手新建一个model idea中切换Terminal 用vue-cli命令，快速搭建一个webpack的项目：vue init webpack 3.3.3项目结构安装好的项目结构： 入口文件：main.js ####3.3.4单文件组件 需要注意的是，我们看到有一类后缀名为.vue的文件，我们称为单文件组件 每一个.vue文件，就是一个独立的vue组件。类似于我们刚才写的login.js和register.js 只不过，我们在js中编写 html模板和样式非常的不友好，而且没有语法提示和高亮。 而单文件组件中包含三部分内容： template：模板，支持html语法高亮和提示 script：js脚本，这里编写的就是vue的组件对象，还可以有data(){}等 style：样式，支持CSS语法高亮和提示 每个组件都有自己独立的html、JS、CSS，互不干扰，真正做到可独立复用。 ####3.3.5.运行 看看生成的package.json： 可以看到这引入了非常多的依赖，绝大多数都是开发期依赖，比如大量的加载器。 运行时依赖只有vue和vue-router 脚本有三个： dev：使用了webpack-dev-server命令，开发时热部署使用 start：使用了npm run dev命令，与上面的dev效果完全一样，当脚本名为“start”时，可以省略“run”。 build：等同于webpack的打包功能，会打包到dist目录下。 我们执行npm run dev 或者 npm start 都可以启动项目： 页面： ###3.4.Vuetify框架 3.4.1.为什么要学习UI框架Vue虽然会帮我们进行视图的渲染，但样式还是由我们自己来完成。这显然不是我们的强项，因此后端开发人员一般都喜欢使用一些现成的UI组件，拿来即用，常见的例如： BootStrap LayUI EasyUI ZUI 然而这些UI组件的基因天生与Vue不合，因为他们更多的是利用DOM操作，借助于jQuery实现，而不是MVVM的思想。 而目前与Vue吻合的UI框架也非常的多，国内比较知名的如： element-ui：饿了么出品 i-view：某公司出品 然而我们都不用，我们今天推荐的是一款国外的框架：Vuetify 官方网站：https://vuetifyjs.com/zh-Hans/ 3.4.2.为什么是Vuetify有中国的为什么还要用外国的？原因如下： Vuetify几乎不需要任何CSS代码，而element-ui许多布局样式需要我们来编写 Vuetify从底层构建起来的语义化组件。简单易学，容易记住。 Vuetify基于Material Design（谷歌推出的多平台设计规范），更加美观，动画效果酷炫，且风格统一 这是官网的说明： 缺陷： 目前官网虽然有中文文档，但因为翻译问题，几乎不太能看。 3.4.3.怎么用？基于官方网站的文档进行学习： 我们重点关注UI components即可，里面有大量的UI组件，我们要用的时候再查看，不用现在学习，先看下有什么： 以后用到什么组件，就来查询即可。 4.搭建基础服务4.1.技术选型前端技术： 基础的HTML、CSS、JavaScript（基于ES6标准） JQuery Vue.js 2.0以及基于Vue的框架：Vuetify 前端构建工具：WebPack 前端安装包工具：NPM Vue脚手架：Vue-cli Vue路由：vue-router ajax框架：axios 基于Vue的富文本框架：quill-editor 后端技术： 基础的SpringMVC、Spring 5.0和MyBatis3 Spring Boot 2.0.4版本 Spring Cloud 最新版 Finchley.RC1 Redis-4.0 RabbitMQ-3.4 Elasticsearch-5.6.8 nginx-1.10.2： FastDFS - 5.0.8 MyCat Thymeleaf JWT 4.2.开发环境为了保证开发环境的统一，希望每个人都按照我的环境来配置： IDE：我们使用Idea 2017.3 版本 JDK：统一使用JDK1.8 项目构建：maven3.3.9以上版本即可 版本控制工具：git idea大家可以在我的课前资料中找到。另外，使用帮助大家可以参考课前资料的《idea使用指南.md》 4.3.域名我们在开发的过程中，为了保证以后的生产、测试环境统一。尽量都采用域名来访问项目。 一级域名：www.leyou.com 二级域名：manage.leyou.com , api.leyou.com 我们可以通过switchhost工具来修改自己的host对应的地址，只要把这些域名指向127.0.0.1，那么跟你用localhost的效果是完全一样的。 switchhost可以去课前资料寻找。 4.4.创建父工程创建统一的父工程：leyou，用来管理依赖及其版本，注意是创建project，而不是moudle 填写项目信息： 注意： 父工程不需要代码，只是管理依赖，因此我们不选择任何SpringCloud的依赖 跳过依赖选择。 然后将pom文件修改成我这个样子： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.parent&lt;/groupId&gt; &lt;artifactId&gt;leyou&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;name&gt;leyou&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.1.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-cloud.version&gt;Finchley.RC1&lt;/spring-cloud.version&gt; &lt;mapper.starter.version&gt;2.0.2&lt;/mapper.starter.version&gt; &lt;mysql.version&gt;5.1.32&lt;/mysql.version&gt; &lt;pageHelper.starter.version&gt;1.2.3&lt;/pageHelper.starter.version&gt; &lt;leyou.latest.version&gt;1.0.0-SNAPSHOT&lt;/leyou.latest.version&gt; &lt;fastDFS.client.version&gt;1.26.1-RELEASE&lt;/fastDFS.client.version&gt; &lt;/properties&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- springCloud --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 通用Mapper启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;mapper.starter.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 分页助手启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;pageHelper.starter.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mysql驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;$&#123;mysql.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--FastDFS客户端--&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.tobato&lt;/groupId&gt; &lt;artifactId&gt;fastdfs-client&lt;/artifactId&gt; &lt;version&gt;$&#123;fastDFS.client.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.16.22&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.apache.commons/commons-lang3 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;version&gt;3.4&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;spring-milestones&lt;/id&gt; &lt;name&gt;Spring Milestones&lt;/name&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt;&lt;/project&gt; 可以发现，我们在父工程中引入了SpringCloud等很多以后需要用到的依赖，以后创建的子工程就不需要自己引入了。 最后，删除自动生成的LeyouApplication启动类、测试类以及application.properties文件，我们不需要。 4.5.创建EurekaServer4.5.1.创建工程这个大家应该比较熟悉了。 我们的注册中心，起名为：ly-registry 这次我们就不Spring使用提供的脚手架了。直接创建maven项目，自然会继承父类的依赖： 选择新建module： ​ 选择maven安装，但是不要选择骨架： 然后填写项目坐标，我们的项目名称为ly-registry: 选择安装目录，因为是聚合项目，目录应该是在父工程leyou的下面： 4.5.2.添加依赖添加EurekaServer的依赖： 1234567891011121314151617181920212223&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;leyou&lt;/artifactId&gt; &lt;groupId&gt;com.leyou.parent&lt;/groupId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;relativePath&gt;../leyou/pom.xml&lt;/relativePath&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.common&lt;/groupId&gt; &lt;artifactId&gt;ly-registry&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 4.5.3.编写启动类1234567@SpringBootApplication@EnableEurekaServerpublic class LyRegistry &#123; public static void main(String[] args) &#123; SpringApplication.run(LyRegistry.class, args); &#125;&#125; 4.5.4.配置文件1234567891011121314server: port: 10086spring: application: name: ly-registryeureka: client: fetch-registry: false register-with-eureka: false service-url: defaultZone: http://127.0.0.1:$&#123;server.port&#125;/eureka server: enable-self-preservation: false # 关闭自我保护 eviction-interval-timer-in-ms: 5000 # 每隔5秒进行一次服务列表清理 4.5.5.项目的结构：目前，整个项目的结构如图： 4.6.创建Zuul网关4.6.1.创建工程与上面类似，选择maven方式创建Module，然后填写项目名称，我们命名为：ly-api-gateway 填写保存的目录： 4.6.2.添加依赖这里我们需要添加Zuul和EurekaClient的依赖： 12345678910111213141516171819202122232425&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;leyou&lt;/artifactId&gt; &lt;groupId&gt;com.leyou.parent&lt;/groupId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.common&lt;/groupId&gt; &lt;artifactId&gt;ly-gateway&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-zuul&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 4.6.3.编写启动类12345678@SpringBootApplication@EnableDiscoveryClient@EnableZuulProxypublic class LyApiGateway &#123; public static void main(String[] args) &#123; SpringApplication.run(LyApiGateway.class, args); &#125;&#125; 4.6.4.配置文件123456789101112131415161718192021222324server: port: 10010spring: application: name: api-gatewayeureka: client: service-url: defaultZone: http://127.0.0.1:10086/eureka zuul: prefix: /api # 添加路由前缀ribbon: ConnectTimeout: 1000 # 连接超时时间(ms) ReadTimeout: 3500 # 通信超时时间(ms) MaxAutoRetriesNextServer: 0 # 同一服务不同实例的重试次数 MaxAutoRetries: 0 # 同一实例的重试次数hystrix: command: default: execution: isolation: thread: timeoutInMillisecond: 5000 # 熔断超时时长：5000ms 4.6.5.项目结构目前，leyou下有两个子模块： ly-registry：服务的注册中心（EurekaServer） ly-gateway：服务网关（Zuul） 目前，服务的结构如图所示： ![1525709241440](assets/1525709241440.png) 截止到这里，我们已经把基础服务搭建完毕，为了便于开发，统一配置中心（ConfigServer）我们留待以后添加。 4.7.创建商品微服务既然是一个全品类的电商购物平台，那么核心自然就是商品。因此我们要搭建的第一个服务，就是商品微服务。其中会包含对于商品相关的一系列内容的管理，包括： 商品分类管理 品牌管理 商品规格参数管理 商品管理 库存管理 我们先完成项目的搭建： 4.7.1.微服务的结构因为与商品的品类相关，我们的工程命名为ly-item. 需要注意的是，我们的ly-item是一个微服务，那么将来肯定会有其它系统需要来调用服务中提供的接口，因此肯定也会使用到接口中关联的实体类。 因此这里我们需要使用聚合工程，将要提供的接口及相关实体类放到独立子工程中，以后别人引用的时候，只需要知道坐标即可。 我们会在ly-item中创建两个子工程： ly-item-interface：主要是对外暴露的接口及相关实体类 ly-item-service：所有业务逻辑及内部使用接口 调用关系如图所示： 4.7.2.创建父工程ly-item依然是使用maven构建： 保存的位置： 不需要任何依赖，我们可以把项目打包方式设置为pom 1234567891011121314151617&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;leyou&lt;/artifactId&gt; &lt;groupId&gt;com.leyou.parent&lt;/groupId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.service&lt;/groupId&gt; &lt;artifactId&gt;ly-item&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;!-- 打包方式为pom --&gt; &lt;packaging&gt;pom&lt;/packaging&gt;&lt;/project&gt; 4.7.3.创建ly-item-interface在ly-item工程上点击右键，选择new &gt; module: 依然是使用maven构建，注意父工程是ly-item： 注意：接下来填写的目录结构需要自己手动完成，保存到ly-item下的ly-item-interface目录中： 点击Finish完成。 此时的项目结构： ​ 4.7.4.创建ly-item-service与ly-item-interface类似，我们选择在ly-item上右键，新建module，然后填写项目信息： 填写存储位置，是在/ly-item/ly-item-service目录 点击Finish完成。 4.7.5.整个微服务结构如图所示： ​ 我们打开ly-item的pom查看，会发现ly-item-interface和ly-item-service都已经称为module了： ​ 4.7.6.添加依赖接下来我们给ly-item-service中添加依赖： 思考一下我们需要什么？ Eureka客户端 web启动器 mybatis启动器 通用mapper启动器 分页助手启动器 连接池，我们用默认的Hykira mysql驱动 千万不能忘了，我们自己也需要ly-item-interface中的实体类 这些依赖，我们在顶级父工程：leyou中已经添加好了。所以直接引入即可： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;ly-item&lt;/artifactId&gt; &lt;groupId&gt;com.leyou.service&lt;/groupId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.service&lt;/groupId&gt; &lt;artifactId&gt;ly-item-service&lt;/artifactId&gt; &lt;dependencies&gt; &lt;!--web启动器--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--Eureka客户端--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--分页助手--&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--mysql驱动--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--通用mapper--&gt; &lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.leyou.service&lt;/groupId&gt; &lt;artifactId&gt;ly-item-interface&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 整个结构： 4.7.7.编写启动和配置在整个ly-item工程中，只有ly-item-service是需要启动的。因此在其中编写启动类即可： 1234567@SpringBootApplication@EnableDiscoveryClientpublic class LyItemApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(LyItemApplication.class, args); &#125;&#125; 然后是全局属性文件： 12345678910111213141516171819server: port: 8081spring: application: name: item-service datasource: url: jdbc:mysql://localhost:3306/heima username: root password: cxg200888 hikari: maximum-pool-size: 30 minimum-idle: 10eureka: client: service-url: defaultZone: http://127.0.0.1:10086/eureka instance: prefer-ip-address: true ip-address: 127.0.0.1 4.8.添加商品微服务的路由规则既然商品微服务已经创建，接下来肯定要添加路由规则到Zuul中，我们不使用默认的路由规则。 在ly-gateway中修改配置文件： 12345zuul: prefix: /api # 添加路由前缀 retryable: true routes: item-service: /item/** # 将商品微服务映射到/item/** 4.9.启动测试我们分别启动：ly-registry，ly-api-gateway，ly-item-service 查看Eureka面板： 4.10.测试路由规则为了测试路由规则是否畅通，我们是不是需要在item-service中编写一个controller接口呢？ 其实不需要，Spring提供了一个依赖：actuator 只要我们添加了actuator的依赖，它就会为我们生成一系列的访问接口： /info /health /refresh … 添加依赖： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt; 重启后访问Eureka控制台： 鼠标悬停在item-service上，会显示一个地址： 这就是actuator提供的接口，我们点击访问： 因为我们没有添加信息，所以是一个空的json，但是可以肯定的是：我们能够访问到item-service了。 接下来我们通过路由访问试试，根据路由规则，我们需要访问的地址是： http://127.0.0.1:10010/api/item/actuator/info 4.11.通用工具模块有些工具或通用的约定内容，我们希望各个服务共享，因此需要创建一个工具模块：ly-common 使用maven来构建module： 位置信息： 结构： 目前还不需要编码。 4.11.1导入工具类 JsonUtils.java 包括四个方法： toString：把一个对象序列化为string类型，包含一个参数 Object obj：原始java对象 toList：把一个json反序列化为List类型，需要指定一个集合中的元素，包含两个参数 String json：要反序列化的json字符串 Class eClass：集合中元素类型 toMap：把一个json反序列化为Map类型，需要指定集合中key和value类型，包含三个参数： String json：要反序列化的json字符串 Class kClass：集合中key的类型 Class vClass：集合中value的类型 nativeRead：把json字符串反序列化，当反序列化的结果比较复杂时。通过这个方法转换，参数： String json：要反序列化的json字符串 TypeReference type：在传递时，需要传递TypeReference的匿名内部类，把要返回的类型写在TypeReference中的泛型，则返回的就是泛型中类型 例如： 123List&lt;User&gt; users=JsonUtils.nativeRead(json, new TypeReference&lt;List&lt;User&gt;&gt;()&#123; &#125;); 4.11.2添加依赖12345678910111213141516171819202122232425262728293031&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;leyou&lt;/artifactId&gt; &lt;groupId&gt;com.leyou.parent&lt;/groupId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.common&lt;/groupId&gt; &lt;artifactId&gt;ly-common&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-core&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--日志--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--引入json--&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.7&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 5.通用异常处理5.1.场景预设###5.1.1场景 我们预设这样一个场景，加入我们做新增商品，需要接受下面的参数: 12price:价格name:名称 然后对数据做简单的校验： 价格不能为空 新增时，自动形成id，然后随商品对象一起返回 5.1.2代码在ly-item-interface pojo： 123456@Datapublic class Item &#123; private Integer id; private String name; private Long price;&#125; 在ly-item-service中 service： 123456789@Servicepublic class ItemService &#123; public Item saveItem(Item item)&#123; //随机生成id int id=new Random().nextInt(100); item.setId(id); return item; &#125;&#125; 在ly-item-service中 controller： 123456789101112131415@Controller@RequestMapping("item")public class ItemController &#123; @Autowired private ItemService itemService; @PostMapping @ResponseBody public ResponseEntity&lt;Item&gt; saveItem(Item item) &#123; if (item.getPrice()==null)&#123; throw new RuntimeException("价格不能为空"); &#125; return ResponseEntity.status(HttpStatus.CREATED).body(itemService.saveItem(item)); &#125;&#125; 在ly-common中定义异常处理工具类 123456789//扫描启动类@ControllerAdvicepublic class CommonExceptionHander &#123; //拦截ly-item-service的ItemController的RuntimeException()方法 @ExceptionHandler(RuntimeException.class) public ResponseEntity&lt;String&gt; handleException(RuntimeException e)&#123; return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(e.getMessage()); &#125;&#125; ###5.1.3测试如下 5.1.4自定义异常将上述代码优化 在ly-common中定义通用异常拦截 CommonExceptionHander 12345678910@ControllerAdvicepublic class CommonExceptionHander &#123; //拦截ly-item-service的ItemController的RuntimeException()方法 @ExceptionHandler(RuntimeException.class) public ResponseEntity&lt;ExceptionResult&gt; handleException(LyException e)&#123; return ResponseEntity.status(e.getExceptionEnums().getCode()) .body(new ExceptionResult(e.getExceptionEnums())); &#125;&#125; 异常对象：ExceptionEnums 123456789@Getter@NoArgsConstructor@AllArgsConstructorpublic enum ExceptionEnums &#123; PRICE_CANNOT_BE_NULL(400,"价格不能为空"); ; private int code; private String msg;&#125; 自定义异常方法 1234567@NoArgsConstructor@AllArgsConstructor@Getterpublic class LyException extends RuntimeException &#123; private ExceptionEnums exceptionEnums;&#125; 通用异常结果： 1234567891011@Datapublic class ExceptionResult &#123; private int status; private String message; private Long timestamp; public ExceptionResult(ExceptionEnums em)&#123; this.status=em.getCode(); this.message=em.getMsg(); this.timestamp=System.currentTimeMillis(); &#125;&#125; 修改ly-item-service 1234567891011121314151617&gt; @Controller&gt; @RequestMapping("item")&gt; public class ItemController &#123;&gt; @Autowired&gt; private ItemService itemService;&gt; @PostMapping&gt; @ResponseBody&gt; public ResponseEntity&lt;Item&gt; saveItem(Item item) &#123;&gt; if (item.getPrice()==null)&#123;&gt; //修改地方：调用ExceptionEnums.PRICE_CANNOT_BE_NULL&gt; throw new LyException(ExceptionEnums.PRICE_CANNOT_BE_NULL);&gt; &#125;&gt; return ResponseEntity.status(HttpStatus.CREATED).body(itemService.saveItem(item));&gt; &#125;&gt; &gt; &#125;&gt;]]></content>
      <categories>
        <category>项目实战-微服务商城</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[微服务商城（六）——商城前台搭建]]></title>
    <url>%2F%E5%89%8D%E5%8F%B0%E6%90%AD%E5%BB%BA.html</url>
    <content type="text"><![CDATA[0.学习目标 使用资料搭建后台系统 会使用nginx进行反向代理 实现商品分类查询功能 掌握cors解决跨域 实现品牌查询功能 1.搭建后台管理前端1.1.导入已有资源后台项目相对复杂，为了有利于教学，我们不再从0搭建项目，而是直接使用课前资料中给大家准备好的源码： 我们解压缩，放到工作目录中： 然后在Intellij idea中导入新的工程： 选中我们的工程： 这正是一个用vue-cli构建的webpack工程，是不是与昨天的一样： 1.2.安装依赖你应该注意到，这里并没有node_modules文件夹，方便给大家下发，已经把依赖都删除了。不过package.json中依然定义了我们所需的一切依赖： 我们只需要打开终端，进入项目目录，输入：npm install命令，即可安装这些依赖。 大概需要几分钟。 如果安装过程出现以下问题： 建议删除node_modules目录，重新安装。 1.3.运行一下看看输入命令：npm run dev 发现默认的端口是9001。访问：http://localhost:9001 会自动进行跳转：]]></content>
      <categories>
        <category>项目实战-微服务商城</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[微服务商城（五）——Vue入门学习二]]></title>
    <url>%2Fday04-vue%E5%85%A5%E9%97%A82%EF%BC%88vue-router%EF%BC%8Cwebpck%EF%BC%8Cvue-cli%EF%BC%8Cvue-router%EF%BC%89.html</url>
    <content type="text"><![CDATA[7.路由vue-router7.1.场景模拟现在我们来实现这样一个功能： 一个页面，包含登录和注册，点击不同按钮，实现登录和注册页切换： 7.1.1.编写父组件为了让接下来的功能比较清晰，我们先新建一个文件夹：src 然后新建一个HTML文件，作为入口：index.html 然后编写页面的基本结构： 1234567891011121314&lt;div id="app"&gt; &lt;span&gt;登录&lt;/span&gt; &lt;span&gt;注册&lt;/span&gt; &lt;hr/&gt; &lt;div&gt; 登录页/注册页 &lt;/div&gt;&lt;/div&gt;&lt;script src="node_modules/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; var vm = new Vue(&#123; el:"#app" &#125;)&lt;/script&gt; 样式： 7.1.2.编写登录及注册组件接下来我们来实现登录组件，以前我们都是写在一个文件中，但是为了复用性，开发中都会把组件放入独立的JS文件中，我们新建一个user目录以及login.js及register.js： 编写组件，这里我们只写模板，不写功能。 login.js内容如下： 123456789const loginForm = &#123; template:'\ &lt;div&gt;\ &lt;h2&gt;登录页&lt;/h2&gt; \ 用户名：&lt;input type="text"&gt;&lt;br/&gt;\ 密码：&lt;input type="password"&gt;&lt;br/&gt;\ &lt;/div&gt;\ '&#125; register.js内容： 12345678910const registerForm = &#123; template:'\ &lt;div&gt;\ &lt;h2&gt;注册页&lt;/h2&gt; \ 用&amp;ensp;户&amp;ensp;名：&lt;input type="text"&gt;&lt;br/&gt;\ 密&amp;emsp;&amp;emsp;码：&lt;input type="password"&gt;&lt;br/&gt;\ 确认密码：&lt;input type="password"&gt;&lt;br/&gt;\ &lt;/div&gt;\ '&#125; 7.1.3.在父组件中引用123456789101112131415161718192021222324252627&lt;div id="app"&gt; &lt;span&gt;登录&lt;/span&gt; &lt;span&gt;注册&lt;/span&gt; &lt;hr/&gt; &lt;div&gt; &lt;!--&lt;loginForm&gt;&lt;/loginForm&gt;--&gt; &lt;!-- 疑问：为什么不采用上面的写法？ 由于html是大小写不敏感的，如果采用上面的写法，则被认为是&lt;loginform&gt;&lt;/loginform&gt; 所以，如果是驼峰形式的组件，需要把驼峰转化为“-”的形式 --&gt; &lt;login-form&gt;&lt;/login-form&gt; &lt;register-form&gt;&lt;/register-form&gt; &lt;/div&gt;&lt;/div&gt;&lt;script src="../node_modules/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;script src="user/login.js"&gt;&lt;/script&gt;&lt;script src="user/register.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; var vm = new Vue(&#123; el: "#app", components: &#123; loginForm, registerForm &#125; &#125;)&lt;/script&gt; 效果： 7.1.5.问题我们期待的是，当点击登录或注册按钮，分别显示登录页或注册页，而不是一起显示。 但是，如何才能动态加载组件，实现组件切换呢？ 虽然使用原生的Html5和JS也能实现，但是官方推荐我们使用vue-router模块。 7.2.vue-router简介和安装使用vue-router和vue可以非常方便的实现 复杂单页应用的动态路由功能。 官网：https://router.vuejs.org/zh-cn/ 使用npm安装：npm install vue-router --save 在index.html中引入依赖： 1&lt;script src="../node_modules/vue-router/dist/vue-router.js"&gt;&lt;/script&gt; 7.3.快速入门新建vue-router对象，并且指定路由规则： 12345678910// 创建VueRouter对象const router = new VueRouter(&#123; routes:[ // 编写路由规则 &#123; path:"/login", // 请求路径 component:loginForm // 组件名称 &#125;, &#123;path:"/register",component:registerForm&#125;, ]&#125;) 创建VueRouter对象，并指定路由参数 routes：路由规则的数组，可以指定多个对象，每个对象是一条路由规则，包含以下属性： path：路由的路径 component：组件名称 在父组件中引入router对象： 12345678var vm = new Vue(&#123; el:"#app", components:&#123;// 引用登录和注册组件 loginForm, registerForm &#125;, router // 引用上面定义的router对象&#125;) 页面跳转控制： 12345678910&lt;div id="app"&gt; &lt;!--router-link来指定跳转的路径--&gt; &lt;span&gt;&lt;router-link to="/login"&gt;登录&lt;/router-link&gt;&lt;/span&gt; &lt;span&gt;&lt;router-link to="/register"&gt;注册&lt;/router-link&gt;&lt;/span&gt; &lt;hr/&gt; &lt;div&gt; &lt;!--vue-router的锚点--&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/div&gt; 通过&lt;router-view&gt;来指定一个锚点，当路由的路径匹配时，vue-router会自动把对应组件放到锚点位置进行渲染 通过&lt;router-link&gt;指定一个跳转链接，当点击时，会触发vue-router的路由功能，路径中的hash值会随之改变 效果： 注意：单页应用中，页面的切换并不是页面的跳转。仅仅是地址最后的hash值变化。 事实上，我们总共就一个HTML：index.html 8.webpackWebpack 是一个前端资源的打包工具，它可以将js、image、css等资源当成一个模块进行打包。 中文官方网站：https://www.webpackjs.com/ 官网给出的解释： 本质上，webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。 为什么需要打包？ 将许多碎小文件打包成一个整体，减少单页面内的衍生请求次数，提高网站效率。 将ES6的高级语法进行转换编译，以兼容老版本的浏览器。 将代码打包的同时进行混淆，提高代码的安全性。 8.1.安装webpack支持全局安装和本地安装，官方推荐是本地安装，我们按照官方的来。 安装最新版本webpack，输入命令：npm install --save-dev webpack webpack 4+ 版本，你还需要安装 CLI ，输入命令：npm install webpack webpack-cli --save-dev 此时，我们注意下项目中文件夹下，会有一个package.json文件。（其实早就有了） 打开文件，可以看到我们之前用npm安装过的文件都会出现在这里： 8.2.核心概念学习Webpack，你需要先理解四个核心概念： 入口(entry) webpack打包的起点，可以有一个或多个，一般是js文件。webpack会从启点文件开始，寻找启点直接或间接依赖的其它所有的依赖，包括JS、CSS、图片资源等，作为将来打包的原始数据 输出(output) 出口一般包含两个属性：path和filename。用来告诉webpack打包的目标文件夹，以及文件的名称。目的地也可以有多个。 加载器（loader） webpack本身只识别Js文件，如果要加载非JS文件，必须指定一些额外的加载器（loader），例如css-loader。然后将这些文件转为webpack能处理的有效模块，最后利用webpack的打包能力去处理。 插件(plugins) 插件可以扩展webpack的功能，让webpack不仅仅是完成打包，甚至各种更复杂的功能，或者是对打包功能进行优化、压缩，提高效率。 8.3.编写webpack配置接下来，我们编写一个webpack的配置，来指定一些打包的配置项。配置文件的名称，默认就是webpack.config.js，我们放到hello-vue的根目录： 配置文件中就是要指定上面说的四个核心概念，入口、出口、加载器、插件。 不过，加载器和插件是可选的。我们先编写入口和出口 8.3.1.入口entrywebpack打包的启点，可以有一个或多个，一般是js文件。现在思考一下我们有没有一个入口？貌似没有，我们所有的东西都集中在index.html，不是一个js，那怎么办？ 我们新建一个js，把index.html中的部分内容进行集中，然后在index.html中引用这个js不就OK了！ 然后把原来index.html中的js代码全部移动到index.js中 123456789101112131415161718192021222324// 使用es6的语法导入js模块import Vue from '../node_modules/vue/dist/vue';import VueRouter from '../node_modules/vue-router/dist/vue-router';import loginForm from './user/login';import registerForm from './user/register';Vue.use(VueRouter);// 创建vue对象const router = new VueRouter(&#123; routes: [ // 编写路由规则 // path: 路由请求路径；component：组件名称 &#123;path: "/login", component: loginForm&#125;, &#123;path: "/register", component: registerForm&#125; ]&#125;);var vm = new Vue(&#123; el: "#app", components: &#123; loginForm, registerForm &#125;, router&#125;); 原来的index.html中引入了很多其它js，在这里我们使用es6的import语法进行导入。 注意，要使用import，就需要在login.js和register.js中添加export导出语句： 123456789const loginForm=&#123; template: '\ &lt;div&gt;\ &lt;h2&gt;登陆页&lt;/h2&gt;\ 用户名：&lt;input type="text"&gt;&lt;br&gt;\ 密&amp;emsp;码：&lt;input type="password"&gt;\ &lt;/div&gt;',&#125;export default loginForm; register.js: 1234567891011const registerForm = &#123; template:'\ &lt;div&gt;\ &lt;h2&gt;注册页&lt;/h2&gt; \ 用&amp;ensp;户&amp;ensp;名：&lt;input type="text"&gt;&lt;br/&gt;\ 密&amp;emsp;&amp;emsp;码：&lt;input type="password"&gt;&lt;br/&gt;\ 确认密码：&lt;input type="password"&gt;&lt;br/&gt;\ &lt;/div&gt;\ '&#125;export default registerForm; vue-router使用模块化加载后，必须增加一句：Vue.use(VueRouter) 这样，index.js就成了我们整个配置的入口了。 我们在webpack.config.js中添加以下内容： 123module.exports=&#123; entry:'./src/index.js', //指定打包的入口文件&#125; 8.3.2.出口output出口，就是输出的目的地。一般我们会用一个dist目录，作为打包输出的文件夹： 然后，编写webpack.config.js，添加出口配置： 12345678module.exports=&#123; entry:'./src/main.js', //指定打包的入口文件 output:&#123; // path: 输出的目录，__dirname是相对于webpack.config.js配置文件的绝对路径 path : __dirname+'/dist', filename:'build.js' //输出的js文件名 &#125;&#125; 8.4.执行打包在控制台输入以下命令： 1npx webpack --config webpack.config.js 随后，查看dist目录： 尝试打开build.js，你根本看不懂： 所有的js合并为1个，并且对变量名进行了随机打乱，这样就起到了 压缩、混淆的作用。 8.5.测试运行在index.html中引入刚刚生成的build.js文件， 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;!--router-link来指定跳转的路径--&gt; &lt;span&gt;&lt;router-link to="/login"&gt;登录&lt;/router-link&gt;&lt;/span&gt; &lt;span&gt;&lt;router-link to="/register"&gt;注册&lt;/router-link&gt;&lt;/span&gt; &lt;hr/&gt; &lt;div&gt; &lt;!--vue-router的锚点--&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src="../dist/build.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 然后运行： 8.6.打包CSS我们来编写一段CSS代码，对index的样式做一些美化： 内容： 123456789101112131415161718192021#app a&#123; display: inline-block; width: 150px; line-height: 30px; background-color: dodgerblue; color: white; font-size: 16px; text-decoration: none;&#125;#app a:hover&#123; background-color: whitesmoke; color: dodgerblue;&#125;#app div&#123; width: 300px; height: 150px;&#125;#app&#123; width: 305px; border: 1px solid dodgerblue;&#125; 8.6.1.安装加载器前面说过，webpack默认只支持js加载。要加载CSS文件，必须安装加载器： 命令：npm install style-loader css-loader --save-dev 此时，在package.json中能看到新安装的： 8.6.3.index.js引入css文件因为入口在index.js，因此css文件也要在这里引入。依然使用ES6 的模块语法： 1import './css/main.css' 8.6.4.配置加载器在webpack.config.js配置文件中配置css的加载器 123456789101112131415161718module.exports = &#123; entry: './src/main.js', //指定打包的入口文件 output: &#123; path: __dirname + '/dist', // 注意：__dirname表示webpack.config.js所在目录的绝对路径 filename: 'build.js' //输出文件 &#125;, module: &#123; rules: [ &#123; test: /\.css$/, // 通过正则表达式匹配所有以.css后缀的文件 use: [ // 要使用的加载器，这两个顺序一定不要乱 'style-loader', 'css-loader' ] &#125; ] &#125;&#125; 8.6.5.重新打包再次输入打包指令：npx webpack --config webpack.config.js 效果： 8.7.script脚本我们每次使用npm安装，都会在package.json中留下痕迹，事实上，package.json中不仅可以记录安装的内容，还可编写脚本，让我们运行命令更加快捷。 我们可以把webpack的命令编入其中： 以后，如果要打包，就可以直接输入：npm run build即可。 npm run ：执行npm脚本，后面跟的是配置脚本的名称build 8.8.打包HTML之前的打包过程中，除了HTML文件外的其它文件都被打包了，当在线上部署时，我们还得自己复制HTML到dist，然后手动添加生成的js到HTML中，这非常不友好。 webpack中的一个插件：html-webpack-plugin，可以解决这个问题。 1）安装插件：npm install --save-dev html-webpack-plugin 需要在webpack.config.js中添加插件： 123456789101112131415161718192021222324252627const HtmlWebpackPlugin = require('html-webpack-plugin');module.exports = &#123; entry: './src/main.js', //指定打包的入口文件 output: &#123; path: __dirname + '/dist', // 注意：__dirname表示webpack.config.js所在目录的绝对路径 filename: 'build.js' //输出文件 &#125;, module: &#123; rules: [ &#123; test: /\.css$/, // 通过正则表达式匹配所有以.css后缀的文件 use: [ // 要使用的加载器，这两个顺序一定不要乱 'style-loader', 'css-loader' ] &#125; ] &#125;, plugins:[ new HtmlWebpackPlugin(&#123; title: '首页', //生成的页面标题&lt;head&gt;&lt;title&gt;首页&lt;/title&gt;&lt;/head&gt; filename: 'index.html', // dist目录下生成的文件名 template: './src/index.html' // 我们原来的index.html，作为模板 &#125;) ]&#125; 2）将原来HTML中的引入js代码删除： 3）再次打包：npm run build 4）查看dist目录： 打开index.html，发现已经自动添加了当前目录下的build.js 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;!--router-link来指定跳转的路径--&gt; &lt;span&gt;&lt;router-link to="/login"&gt;登录&lt;/router-link&gt;&lt;/span&gt; &lt;span&gt;&lt;router-link to="/register"&gt;注册&lt;/router-link&gt;&lt;/span&gt; &lt;div&gt; &lt;!--vue-router的锚点--&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/div&gt;&lt;script type="text/javascript" src="build.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 8.9.热更新的web服务刚才的案例中，每次修改任何js或css内容，都必须重新打包，非常麻烦。 webpack给我们提供了一个插件，可以帮我们运行一个web服务，加载页面内容，并且修改js后不需要重新加载就能看到最新结果： 1）安装插件：npm install webpack-dev-server --save-dev 2）添加启动脚本 在package.json中配置script 123"scripts": &#123; "dev": "webpack-dev-server --inline --hot --open --port 8080 --host 127.0.0.1"&#125;, –inline：自动刷新 –hot：热加载 –port：指定端口 –open：自动在默认浏览器打开 –host：可以指定服务器的 ip，不指定则为127.0.0.1 3）运行脚本：npm run dev 4）效果： 9.vue-cli9.1.介绍和安装在开发中，需要打包的东西不止是js、css、html。还有更多的东西要处理，这些插件和加载器如果我们一一去添加就会比较麻烦。 幸好，vue官方提供了一个快速搭建vue项目的脚手架：vue-cli 使用它能快速的构建一个web工程模板。 官网：https://github.com/vuejs/vue-cli 安装命令：npm install -g vue-cli 9.2.快速上手我们新建一个module： 切换到该目录： 用vue-cli命令，快速搭建一个webpack的项目：vue init webpack 前面几项都走默认或yes 下面这些我们选no 最后，再选yes，使用 npm安装 开始初始化项目，并安装依赖，可能需要 安装成功！ 可以使用npm run dev命令启动。 9.3.项目结构安装好的项目结构： 入口文件：main.js 9.4.单文件组件需要注意的是，我们看到有一类后缀名为.vue的文件，我们称为单文件组件 每一个.vue文件，就是一个独立的vue组件。类似于我们刚才写的login.js和register.js 只不过，我们在js中编写 html模板和样式非常的不友好，而且没有语法提示和高亮。 而单文件组件中包含三部分内容： template：模板，支持html语法高亮和提示 script：js脚本，这里编写的就是vue的组件对象，还可以有data(){}等 style：样式，支持CSS语法高亮和提示 每个组件都有自己独立的html、JS、CSS，互不干扰，真正做到可独立复用。 9.5.运行看看生成的package.json： 可以看到这引入了非常多的依赖，绝大多数都是开发期依赖，比如大量的加载器。 运行时依赖只有vue和vue-router 脚本有三个： dev：使用了webpack-dev-server命令，开发时热部署使用 start：使用了npm run dev命令，与上面的dev效果完全一样，当脚本名为“start”时，可以省略“run”。 build：等同于webpack的打包功能，会打包到dist目录下。 我们执行npm run dev 或者 npm start 都可以启动项目： 页面：]]></content>
      <categories>
        <category>项目实战-微服务商城</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务商城（五）——Vue入门学习一]]></title>
    <url>%2Fday04-vue%E5%85%A5%E9%97%A81.html</url>
    <content type="text"><![CDATA[学习目标 会创建Vue实例，知道Vue的常见属性 会使用Vue的生命周期的钩子函数 会使用vue常见指令 会使用vue计算属性和watch监控 会编写Vue组件 掌握组件间通信 了解vue-router使用 了解webpack使用 会使用vue-cli搭建项目 0.前言前几天我们已经对后端的技术栈有了初步的了解、并且已经搭建了整个后端微服务的平台。接下来要做的事情就是功能开发了。但是没有前端页面，我们肯定无从下手，因此今天我们就要来了解一下前端的一些技术，完成前端页面搭建。 先聊一下前端开发模式的发展。 静态页面 最初的网页以HTML为主，是纯静态的网页。网页是只读的，信息流只能从服务端到客户端单向流通。开发人员也只关心页面的样式和内容即可。 异步刷新，操作DOM 1995年，网景工程师Brendan Eich 花了10天时间设计了JavaScript语言. 随着JavaScript的诞生，我们可以操作页面的DOM元素及样式，页面有了一些动态的效果，但是依然是以静态为主。 ajax盛行： 2005年开始，ajax逐渐被前端开发人员所重视，因为不用刷新页面就可以更新页面的数据和渲染效果。 此时的开发人员不仅仅要编写HTML样式，还要懂ajax与后端交互，然后通过JS操作Dom元素来实现页面动态效果。比较流行的框架如Jquery就是典型代表。 MVVM，关注模型和视图 2008年，google的Chrome发布，随后就以极快的速度占领市场，超过IE成为浏览器市场的主导者。 2009年，Ryan Dahl在谷歌的Chrome V8引擎基础上，打造了基于事件循环的异步IO框架：Node.js。 基于事件循环的异步IO 单线程运行，避免多线程的变量同步问题 JS可以编写后台代码，前后台统一编程语言 node.js的伟大之处不在于让JS迈向了后端开发，而是构建了一个庞大的生态系统。 2010年，NPM作为node.js的包管理系统首次发布，开发人员可以遵循Common.js规范来编写Node.js模块，然后发布到NPM上供其他开发人员使用。目前已经是世界最大的包模块管理系统。 随后，在node的基础上，涌现出了一大批的前端框架： MVVM模式 M：即Model，模型，包括数据和一些基本操作 V：即View，视图，页面渲染结果 VM：即View-Model，模型与视图间的双向操作（无需开发人员干涉） 在MVVM之前，开发人员从后端获取需要的数据模型，然后要通过DOM操作Model渲染到View中。而后当用户操作视图，我们还需要通过DOM获取View中的数据，然后同步到Model中。 而MVVM中的VM要做的事情就是把DOM操作完全封装起来，开发人员不用再关心Model和View之间是如何互相影响的： 只要我们Model发生了改变，View上自然就会表现出来。 当用户修改了View，Model中的数据也会跟着改变。 把开发人员从繁琐的DOM操作中解放出来，把关注点放在如何操作Model上。 而我们今天要学习的，就是一款MVVM模式的框架：Vue 1.认识VueVue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。 ​ 前端框架三巨头：Vue.js、React.js、AngularJS，vue.js以其轻量易用著称，vue.js和React.js发展速度最快，AngularJS还是老大。 官网：https://cn.vuejs.org/ 参考：https://cn.vuejs.org/v2/guide/ Git地址：https://github.com/vuejs 尤雨溪，Vue.js 创作者，Vue Technology创始人，致力于Vue的研究开发。 2.Node和NPM前面说过，NPM是Node提供的模块管理工具，可以非常方便的下载安装很多前端框架，包括Jquery、AngularJS、VueJs都有。为了后面学习方便，我们先安装node及NPM工具。 2.1.下载Node.js下载地址：https://nodejs.org/en/ 推荐下载LTS版本。 课程中采用的是8.11.3版本。也是目前最新的。大家自行下载或者使用课前资料中提供的安装包。然后下一步安装即可。 完成以后，在控制台输入： 1node -v 看到版本信息： 2.2.NPMNode自带了NPM了，在控制台输入npm -v查看： npm默认的仓库地址是在国外网站，速度较慢，建议大家设置到淘宝镜像。但是切换镜像是比较麻烦的。推荐一款切换镜像的工具：nrm 我们首先安装nrm，这里-g代表全局安装。可能需要一点儿时间 1npm install nrm -g 然后通过nrm ls命令查看npm的仓库列表,带*的就是当前选中的镜像仓库： 通过nrm use taobao来指定要使用的镜像源： 然后通过nrm test npm来测试速度： 注意： 有教程推荐大家使用cnpm命令，但是使用发现cnpm有时会有bug，不推荐。 安装完成请一定要重启下电脑！！！ 安装完成请一定要重启下电脑！！！ 安装完成请一定要重启下电脑！！！ 3.快速入门接下来，我们快速领略下vue的魅力 3.1.创建工程创建一个新的空工程： 然后新建一个module： 选中static web，静态web项目： 位置信息： 3.2.安装vue3.2.1.下载安装下载地址：https://github.com/vuejs/vue 可以下载2.5.16版本https://github.com/vuejs/vue/archive/v2.5.16.zip 下载解压，得到vue.js文件。 3.2.2.使用CDN或者也可以直接使用公共的CDN服务： 12&lt;!-- 开发环境版本，包含了用帮助的命令行警告 --&gt;&lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt; 或者： 12&lt;!-- 生产环境版本，优化了尺寸和速度 --&gt;&lt;script src="https://cdn.jsdelivr.net/npm/vue"&gt;&lt;/script&gt; 3.2.3.推荐npm安装在idea的左下角，有个Terminal按钮，点击打开控制台： 进入hello-vue目录，先输入：npm init -y 进行初始化 安装Vue，输入命令：npm install vue --save 然后就会在hello-vue目录发现一个node_modules目录，并且在下面有一个vue目录。 node_modules是通过npm安装的所有模块的默认位置。 3.3.vue入门案例3.3.1.HTML模板 在hello-vue目录新建一个HTML 在hello.html中，我们编写一段简单的代码： h2中要输出一句话：xx 非常帅。前面的xx是要渲染的数据。 3.3.2.vue声明式渲染然后我们通过Vue进行渲染： 12345678910111213141516&lt;body&gt; &lt;div id="app"&gt; &lt;h2&gt;&#123;&#123;name&#125;&#125;，非常帅！！！&lt;/h2&gt; &lt;/div&gt;&lt;/body&gt;&lt;script src="node_modules/vue/dist/vue.js" &gt;&lt;/script&gt;&lt;script&gt; // 创建vue实例 var app = new Vue(&#123; el:"#app", // el即element，该vue实例要渲染的页面元素 data:&#123; // 渲染页面需要的数据 name: "峰哥" &#125; &#125;);&lt;/script&gt; 首先通过 new Vue()来创建Vue实例 然后构造函数接收一个对象，对象中有一些属性： el：是element的缩写，通过id选中要渲染的页面元素，本例中是一个div data：数据，数据是一个对象，里面有很多属性，都可以渲染到视图中 name：这里我们指定了一个name属性 页面中的h2元素中，我们通过的方式，来渲染刚刚定义的name属性。 打开页面查看效果： 更神奇的在于，当你修改name属性时，页面会跟着变化： 3.3.3.双向绑定我们对刚才的案例进行简单修改： 1234567891011121314151617181920&lt;body&gt; &lt;div id="app"&gt; &lt;input type="text" v-model="num"&gt; &lt;h2&gt; &#123;&#123;name&#125;&#125;，非常帅！！！有&#123;&#123;num&#125;&#125;位女神为他着迷。 &lt;/h2&gt; &lt;/div&gt;&lt;/body&gt;&lt;script src="node_modules/vue/dist/vue.js" &gt;&lt;/script&gt;&lt;script&gt; // 创建vue实例 var app = new Vue(&#123; el: "#app", // el即element，该vue实例要渲染的页面元素 data: &#123; // 渲染页面需要的数据 name: "峰哥", num: 5 &#125; &#125;);&lt;/script&gt; 我们在data添加了新的属性：num 在页面中有一个input元素，通过v-model与num进行绑定。 同时通过在页面输出 效果： 我们可以观察到，输入框的变化引起了data中的num的变化，同时页面输出也跟着变化。 input与num绑定，input的value值变化，影响到了data中的num值 页面与数据num绑定，因此num值变化，引起了页面效果变化。 没有任何dom操作，这就是双向绑定的魅力。 3.3.4.事件处理我们在页面添加一个按钮： 1&lt;button v-on:click="num++"&gt;点我&lt;/button&gt; 这里用v-on指令绑定点击事件，而不是普通的onclick，然后直接操作num 普通click是无法直接操作num的。 效果： 4.Vue实例4.1.创建Vue实例每个 Vue 应用都是通过用 Vue 函数创建一个新的 Vue 实例开始的： 123var vm = new Vue(&#123; // 选项&#125;) 在构造函数中传入一个对象，并且在对象中声明各种Vue需要的数据和方法，包括： el data methods 等等 接下来我们一 一介绍。 4.2.模板或元素每个Vue实例都需要关联一段Html模板，Vue会基于此模板进行视图渲染。 我们可以通过el属性来指定。 例如一段html模板： 123&lt;div id="app"&gt; &lt;/div&gt; 然后创建Vue实例，关联这个div 123var vm = new Vue(&#123; el:"#app"&#125;) 这样，Vue就可以基于id为app的div元素作为模板进行渲染了。在这个div范围以外的部分是无法使用vue特性的。 4.3.数据当Vue实例被创建时，它会尝试获取在data中定义的所有属性，用于视图的渲染，并且监视data中的属性变化，当data发生改变，所有相关的视图都将重新渲染，这就是“响应式“系统。 html： 123&lt;div id="app"&gt; &lt;input type="text" v-model="name"/&gt;&lt;/div&gt; js: 123456var vm = new Vue(&#123; el:"#app", data:&#123; name:"刘德华" &#125;&#125;) name的变化会影响到input的值 input中输入的值，也会导致vm中的name发生改变 4.4.方法Vue实例中除了可以定义data属性，也可以定义方法，并且在Vue实例的作用范围内使用。 html: 1234&lt;div id="app"&gt; &#123;&#123;num&#125;&#125; &lt;button v-on:click="add"&gt;加&lt;/button&gt;&lt;/div&gt; js: 123456789101112var vm = new Vue(&#123; el:"#app", data:&#123; num: 0 &#125;, methods:&#123; add:function()&#123; // this代表的当前vue实例 this.num++; &#125; &#125;&#125;) 4.5.生命周期钩子4.5.1.生命周期每个 Vue 实例在被创建时都要经过一系列的初始化过程 ：创建实例，装载模板，渲染模板等等。Vue为生命周期中的每个状态都设置了钩子函数（监听函数）。每当Vue实例处于不同的生命周期时，对应的函数就会被触发调用。 生命周期： 4.5.2.钩子函数beforeCreated：我们在用Vue时都要进行实例化，因此，该函数就是在Vue实例化是调用，也可以将他理解为初始化函数比较方便一点，在Vue1.0时，这个函数的名字就是init。 created：在创建实例之后进行调用。 beforeMount：页面加载完成，没有渲染。如：此时页面还是 mounted：我们可以将他理解为原生js中的1234567891011121314151617181920212223242526272829303132beforeDestroy：该函数将在销毁实例前进行调用 。destroyed：改函数将在销毁实例时进行调用。beforeUpdate：组件更新之前。updated：组件更新之后。例如：created代表在vue实例创建后；我们可以在Vue中定义一个created函数，代表这个时期的钩子函数：```js // 创建vue实例 var app = new Vue(&#123; el: &quot;#app&quot;, // el即element，该vue实例要渲染的页面元素 data: &#123; // 渲染页面需要的数据 name: &quot;峰哥&quot;, num: 5 &#125;, methods: &#123; add: function()&#123; this.num--; &#125; &#125;, created: function () &#123; this.num = 100; &#125; &#125;); 结果： 4.5.3.this我们可以看下在vue内部的this变量是谁，我们在created的时候，打印this 123456methods: &#123; add: function()&#123; this.num--; console.log(this); &#125;&#125;, 控制台的输出： 5.指令什么是指令？ 指令 (Directives) 是带有 v- 前缀的特殊特性。指令特性的预期值是：单个 JavaScript 表达式。指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM。 例如我们在入门案例中的v-on，代表绑定事件。 5.1.插值表达式5.1.1.花括号格式： 1&#123;&#123;表达式&#125;&#125; 说明： 该表达式支持JS语法，可以调用js内置函数（必须有返回值） 表达式必须有返回结果。例如 1 + 1，没有结果的表达式不允许使用，如：var a = 1 + 1; 可以直接获取Vue实例中定义的数据或函数 示例： HTML： 1&lt;div id="app"&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt; JS: 123456var app = new Vue(&#123; el:"#app", data:&#123; name:"Jack" &#125;&#125;) 5.1.2.插值闪烁使用1234567891011121314151617181920212223242526272829我们将网速调慢一些，然后试试看刚才的案例：![1529836021593](assets/1529836021593.png)刷新页面：![](assets/54.gif)### 5.1.3.v-text和v-html使用v-text和v-html指令来替代`&#123;&#123;&#125;&#125;`说明：- v-text：将数据输出到元素内部，如果输出的数据有HTML代码，会作为普通文本输出- v-html：将数据输出到元素内部，如果输出的数据有HTML代码，会被渲染示例：HTML:```html&lt;div id=&quot;app&quot;&gt; v-text:&lt;span v-text=&quot;hello&quot;&gt;&lt;/span&gt; &lt;br/&gt; v-html:&lt;span v-html=&quot;hello&quot;&gt;&lt;/span&gt;&lt;/div&gt; JS: 123456var vm = new Vue(&#123; el:"#app", data:&#123; hello: "&lt;h1&gt;大家好，我是峰哥&lt;/h1&gt;" &#125;&#125;) 效果： 并且不会出现插值闪烁，当没有数据时，会显示空白。 5.2.v-model刚才的v-text和v-html可以看做是单向绑定，数据影响了视图渲染，但是反过来就不行。接下来学习的v-model是双向绑定，视图（View）和模型（Model）之间会互相影响。 既然是双向绑定，一定是在视图中可以修改数据，这样就限定了视图的元素类型。目前v-model的可使用元素有： input select textarea checkbox radio components（Vue中的自定义组件） 基本上除了最后一项，其它都是表单的输入项。 举例： html： 1234567891011121314151617&lt;div id="app"&gt; &lt;input type="checkbox" v-model="language" value="Java" /&gt;Java&lt;br/&gt; &lt;input type="checkbox" v-model="language" value="PHP" /&gt;PHP&lt;br/&gt; &lt;input type="checkbox" v-model="language" value="Swift" /&gt;Swift&lt;br/&gt; &lt;h1&gt; 你选择了：&#123;&#123;language.join(',')&#125;&#125; &lt;/h1&gt;&lt;/div&gt;&lt;script src="./node_modules/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; var vm = new Vue(&#123; el:"#app", data:&#123; language: [] &#125; &#125;)&lt;/script&gt; 多个CheckBox对应一个model时，model的类型是一个数组，单个checkbox值默认是boolean类型 radio对应的值是input的value值 input 和textarea 默认对应的model是字符串 select单选对应字符串，多选对应也是数组 效果： 5.3.v-on5.3.1.基本用法v-on指令用于给页面元素绑定事件。 语法： 1v-on:事件名=&quot;js片段或函数名&quot; 示例： 123456789101112131415161718192021&lt;div id="app"&gt; &lt;!--事件中直接写js片段--&gt; &lt;button v-on:click="num++"&gt;增加一个&lt;/button&gt;&lt;br/&gt; &lt;!--事件指定一个回调函数，必须是Vue实例中定义的函数--&gt; &lt;button v-on:click="decrement"&gt;减少一个&lt;/button&gt;&lt;br/&gt; &lt;h1&gt;有&#123;&#123;num&#125;&#125;个女神迷恋峰哥&lt;/h1&gt;&lt;/div&gt;&lt;script src="./node_modules/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; var app = new Vue(&#123; el:"#app", data:&#123; num:100 &#125;, methods:&#123; decrement()&#123; this.num--; &#125; &#125; &#125;)&lt;/script&gt; 效果： 另外，事件绑定可以简写，例如v-on:click=&#39;add&#39;可以简写为@click=&#39;add&#39; 5.3.2.事件修饰符在事件处理程序中调用 event.preventDefault() 或 event.stopPropagation() 是非常常见的需求。尽管我们可以在方法中轻松实现这点，但更好的方式是：方法只有纯粹的数据逻辑，而不是去处理 DOM 事件细节。 为了解决这个问题，Vue.js 为 v-on 提供了事件修饰符。修饰符是由点开头的指令后缀来表示的。 .stop ：阻止事件冒泡到父元素 .prevent：阻止默认事件发生 .capture：使用事件捕获模式 .self：只有元素自身触发事件才执行。（冒泡或捕获的都不执行） .once：只执 阻止默认事件 123456789101112131415161718192021222324&lt;div id="app"&gt; &lt;!--右击事件，并阻止默认事件发生--&gt; &lt;button v-on:contextmenu.prevent="num++"&gt;增加一个&lt;/button&gt; &lt;br/&gt; &lt;!--右击事件，不阻止默认事件发生--&gt; &lt;button v-on:contextmenu="decrement($event)"&gt;减少一个&lt;/button&gt; &lt;br/&gt; &lt;h1&gt;有&#123;&#123;num&#125;&#125;个女神迷恋峰哥&lt;/h1&gt;&lt;/div&gt;&lt;script src="./node_modules/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; var app = new Vue(&#123; el: "#app", data: &#123; num: 100 &#125;, methods: &#123; decrement(ev) &#123; // ev.preventDefault(); this.num--; &#125; &#125; &#125;)&lt;/script&gt; 效果：（右键“增加一个”，不会触发默认的浏览器右击事件；右键“减少一个”，会触发默认的浏览器右击事件） 5.3.3.按键修添记住所有的 keyCode 比较困难，所以 Vue 为最常用的按键提供了别名： 12345&lt;!-- 同上 --&gt;&lt;input v-on:keyup.enter="submit"&gt;&lt;!-- 缩写语法 --&gt;&lt;input @keyup.enter="submit"&gt; 全部的按键别名： .enter .tab .delete (捕获“删除”和“退格”键) .esc .space .up .down .left .right 5.3.4.组合按钮可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器。 .ctrl .alt .shift 例如： 12345&lt;!-- Alt + C --&gt;&lt;input @keyup.alt.67="clear"&gt;&lt;!-- Ctrl + Click --&gt;&lt;div @click.ctrl="doSomething"&gt;Do something&lt;/div&gt; 5.4.v-for遍历数据渲染页面是非常常用的需求，Vue中通过v-for指令来实现。 5.4.1.遍历数组 语法： 1v-for=&quot;item in items&quot; items：要遍历的数组，需要在vue的data中定义好。 item：迭代得到的数组元素的别名 示例 12345678910111213141516171819202122&lt;div id="app"&gt; &lt;ul&gt; &lt;li v-for="user in users"&gt; &#123;&#123;user.name&#125;&#125; - &#123;&#123;user.gender&#125;&#125; - &#123;&#123;user.age&#125;&#125; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script src="./node_modules/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; var app = new Vue(&#123; el: "#app", data: &#123; users:[ &#123;name:'柳岩', gender:'女', age: 21&#125;, &#123;name:'峰哥', gender:'男', age: 18&#125;, &#123;name:'范冰冰', gender:'女', age: 24&#125;, &#123;name:'刘亦菲', gender:'女', age: 18&#125;, &#123;name:'古力娜扎', gender:'女', age: 25&#125; ] &#125;, &#125;)&lt;/script&gt; 效果： 5.4.2.数组角标在遍历的过程中，如果我们需要知道数组角标，可以指定第二个参数： 语法 1v-for=&quot;(item,index) in items&quot; items：要迭代的数组 item：迭代得到的数组元素别名 index：迭代到的当前元素索引，从0开始。 示例 12345&lt;ul&gt; &lt;li v-for="(user, index) in users"&gt; &#123;&#123;index + 1&#125;&#125;. &#123;&#123;user.name&#125;&#125; - &#123;&#123;user.gender&#125;&#125; - &#123;&#123;user.age&#125;&#125; &lt;/li&gt;&lt;/ul&gt; 效果： 5.4.3.遍历对象v-for除了可以迭代数组，也可以迭代对象。语法基本类似 语法： 123v-for="value in object"v-for="(value,key) in object"v-for="(value,key,index) in object" 1个参数时，得到的是对象的属性 2个参数时，第一个是属性，第二个是键 3个参数时，第三个是索引，从0开始 示例： 12345678910111213141516&lt;div id="app"&gt; &lt;ul&gt; &lt;li v-for="(value, key, index) in user"&gt; &#123;&#123;index + 1&#125;&#125;. &#123;&#123;key&#125;&#125; - &#123;&#123;value&#125;&#125; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script src="./node_modules/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; var vm = new Vue(&#123; el:"#app", data:&#123; user:&#123;name:'峰哥', gender:'男', age: 18&#125; &#125; &#125;)&lt;/script&gt; 效果： 5.4.4.key当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。 这个功能可以有效的提高渲染的效率。 但是要实现这个功能，你需要给Vue一些提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key 属性。理想的 key 值是每项都有的且唯一的 id。 示例： 123&lt;ul&gt; &lt;li v-for="(item,index) in items" :key=index&gt;&lt;/li&gt;&lt;/ul&gt; 这里使用了一个特殊语法：:key=&quot;&quot; 我们后面会讲到，它可以让你读取vue中的属性，并赋值给key属性 这里我们绑定的key是数组的索引，应该是唯一的 5.5.v-if和v-show5.5.1.基本使用v-if，顾名思义，条件判断。当得到结果为true时，所在的元素才会被渲染。 语法： 1v-if=&quot;布尔表达式&quot; 示例： 12345678910111213141516171819&lt;div id="app"&gt; &lt;button v-on:click="show = !show"&gt;点我呀&lt;/button&gt; &lt;br&gt; &lt;h1 v-if="show"&gt; 看到我啦？！ &lt;/h1&gt; &lt;h1 v-show="show"&gt; 看到我啦？！show &lt;/h1&gt;&lt;/div&gt;&lt;script src="./node_modules/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; var app = new Vue(&#123; el: "#app", data: &#123; show: true &#125; &#125;)&lt;/script&gt; 效果： 5.5.2.与v-for结合当v-if和v-for出现在一起时，v-for优先级更高。也就是说，会先遍历，再判断条件。 修改v-for中的案例，添加v-if： 12345&lt;ul&gt; &lt;li v-for="(user, index) in users" v-if="user.gender == '女'"&gt; &#123;&#123;index + 1&#125;&#125;. &#123;&#123;user.name&#125;&#125; - &#123;&#123;user.gender&#125;&#125; - &#123;&#123;user.age&#125;&#125; &lt;/li&gt;&lt;/ul&gt; 效果： 只显示女性用户信息 5.5.3.v-else你可以使用 v-else 指令来表示 v-if 的“else 块”： 12345678&lt;div id="app"&gt; &lt;h1 v-if="Math.random() &gt; 0.5"&gt; 看到我啦？！if &lt;/h1&gt; &lt;h1 v-else&gt; 看到我啦？！else &lt;/h1&gt;&lt;/div&gt; v-else 元素必须紧跟在带 v-if 或者 v-else-if 的元素的后面，否则它将不会被识别。 v-else-if，顾名思义，充当 v-if 的“else-if 块”，可以连续使用： 123456789101112131415161718192021222324&lt;div id="app"&gt; &lt;button v-on:click="random=Math.random()"&gt;点我呀&lt;/button&gt;&lt;span&gt;&#123;&#123;random&#125;&#125;&lt;/span&gt; &lt;h1 v-if="random &gt;= 0.75"&gt; 看到我啦？！if &lt;/h1&gt; &lt;h1 v-else-if="random &gt; 0.5"&gt; 看到我啦？！if 0.5 &lt;/h1&gt; &lt;h1 v-else-if="random &gt; 0.25"&gt; 看到我啦？！if 0.25 &lt;/h1&gt; &lt;h1 v-else&gt; 看到我啦？！else &lt;/h1&gt;&lt;/div&gt;&lt;script src="./node_modules/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; var app = new Vue(&#123; el: "#app", data: &#123; random: 1 &#125; &#125;)&lt;/script&gt; 类似于 v-else，v-else-if 也必须紧跟在带 v-if 或者 v-else-if 的元素之后。 演示： 5.5.4.v-show另一个用于根据条件展示元素的选项是 v-show 指令。用法大致一样： 1&lt;h1 v-show=&quot;ok&quot;&gt;Hello!&lt;/h1&gt; 不同的是带有 v-show 的元素始终会被渲染并保留在 DOM 中。v-show 只是简单地切换元素的 CSS 属性 display。 示例： 12345678910111213141516&lt;div id="app"&gt; &lt;!--事件中直接写js片段--&gt; &lt;button v-on:click="show = !show"&gt;点击切换&lt;/button&gt;&lt;br/&gt; &lt;h1 v-if="show"&gt; 你好 &lt;/h1&gt;&lt;/div&gt;&lt;script src="./node_modules/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; var app = new Vue(&#123; el:"#app", data:&#123; show:true &#125; &#125;)&lt;/script&gt; 代码： 5.6.v-bindhtml属性不能使用双大括号形式绑定，只能使用v-bind指令。 在将 v-bind 用于 class 和 style 时，Vue.js 做了专门的增强。表达式结果的类型除了字符串之外，还可以是对象或数组。 12345678910111213&lt;div id="app"&gt; &lt;!--可以是数据模型，可以是具有返回值的js代码块或者函数--&gt; &lt;div v-bind:title="title" style="border: 1px solid red; width: 50px; height: 50px;"&gt;&lt;/div&gt;&lt;/div&gt;&lt;script src="./node_modules/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; var app = new Vue(&#123; el: "#app", data: &#123; title: "title", &#125; &#125;)&lt;/script&gt; 效果： 在将 v-bind 用于 class 和 style 时，Vue.js 做了专门的增强。表达式结果的类型除了字符串之外，还可以是对象或数组。 5.6.1.绑定class样式 数组语法 我们可以借助于v-bind指令来实现： HTML： 123456789101112131415&lt;div id="app"&gt; &lt;div v-bind:class="activeClass"&gt;&lt;/div&gt; &lt;div v-bind:class="errorClass"&gt;&lt;/div&gt; &lt;div v-bind:class="[activeClass, errorClass]"&gt;&lt;/div&gt;&lt;/div&gt;&lt;script src="./node_modules/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; var app = new Vue(&#123; el: "#app", data: &#123; activeClass: 'active', errorClass: ['text-danger', 'text-error'] &#125; &#125;)&lt;/script&gt; 渲染后的效果：（具有active和hasError的样式） 对象语法 我们可以传给 v-bind:class 一个对象，以动态地切换 class： 1&lt;div v-bind:class="&#123; active: isActive &#125;"&gt;&lt;/div&gt; 上面的语法表示 active 这个 class 存在与否将取决于数据属性 isActive 的 truthiness（所有的值都是真实的，除了false,0,“”,null,undefined和NaN）。 你可以在对象中传入更多属性来动态切换多个 class。此外，v-bind:class 指令也可以与普通的 class 属性共存。如下模板: 123&lt;div class="static" v-bind:class="&#123; active: isActive, 'text-danger': hasError &#125;"&gt;&lt;/div&gt; 和如下 data： 1234data: &#123; isActive: true, hasError: false&#125; 结果渲染为： 1&lt;div class="static active"&gt;&lt;/div&gt; active样式和text-danger样式的存在与否，取决于isActive和hasError的值。本例中isActive为true，hasError为false，所以active样式存在，text-danger不存在。 通常情况下，绑定的数据对象不必内联定义在模板里： 1&lt;div class="static" v-bind:class="classObject"&gt;&lt;/div&gt; 数据： 123456data: &#123; classObject: &#123; active: true, 'text-danger': false &#125;&#125; 效果和之前一样： 1&lt;div class="static active"&gt;&lt;/div&gt; 5.6.2.绑定style样式 数组语法 数组语法可以将多个样式对象应用到同一个元素上： 1&lt;div v-bind:style="[baseStyles, overridingStyles]"&gt;&lt;/div&gt; 数据： 1234data: &#123; baseStyles: &#123;backgroundColor: 'red'&#125;, overridingStyles: &#123;border: '1px solid black'&#125;&#125; 渲染后的结果： 1&lt;div style="background-color:red; border: 1px solid black;"&gt;&lt;/div&gt; 对象语法 v-bind:style 的对象语法十分直观——看着非常像 CSS，但其实是一个 JavaScript 对象。CSS 属性名可以用驼峰式 (camelCase) 或短横线分隔 (kebab-case，记得用单引号括起来) 来命名： 1&lt;div v-bind:style="&#123;color: activeColor, fontSize: fontSize + 'px' &#125;"&gt;&lt;/div&gt; 数据： 1234data: &#123; activeColor: 'red', fontSize: 30&#125; 效果： 1&lt;div style="color: red; font-size: 30px;"&gt;&lt;/div&gt; 直接绑定到一个样式对象通常更好，这会让模板更清晰： 1&lt;div v-bind:style="styleObject"&gt;&lt;/div&gt; 123456data: &#123; styleObject: &#123; color: 'red', fontSize: '13px' &#125;&#125; 效果同上。 5.6.3.简写v-bind:class可以简写为:class 5.6.4另一个例子123456789101112131415161718192021222324252627282930313233343536&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style type="text/css"&gt; div#box&#123; width: 100px; height: 100px; color: darkgray; &#125; .red&#123; background-color: red; &#125; .blue&#123; background-color: blue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="app" &gt; &lt;button @click="color='red'"&gt;红色&lt;/button&gt; &lt;button @click="color='blue'"&gt;蓝色&lt;/button&gt; &lt;div v-bind:class="color"&gt; woemn &lt;/div&gt;&lt;/div&gt;&lt;script src="node_modules/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;script&gt; const app=new Vue(&#123; el:"#app", data:&#123; color:"red" &#125; &#125;);&lt;/script&gt;&lt;/body&gt; 改进上面的： 12345678910111213141516171819202122232425262728293031323334&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style type="text/css"&gt; div#box&#123; width: 100px; height: 100px; color: darkgray; &#125; .red&#123; background-color: red; &#125; .blue&#123; background-color: blue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="app" &gt; &lt;button @click="IsColor=!IsColor"&gt;切换&lt;/button&gt; &lt;div id="box" v-bind:class="&#123;red:IsColor,blue:!IsColor&#125;"&gt; woemn &lt;/div&gt;&lt;/div&gt;&lt;script src="node_modules/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;script&gt; const app=new Vue(&#123; el:"#app", data:&#123; IsColor:true &#125; &#125;);&lt;/script&gt;&lt;/body&gt; 5.7.计算属性在插值表达式中使用js表达式是非常方便的，而且也经常被用到。 但是如果表达式的内容很长，就会显得不够优雅，而且后期维护起来也不方便，例如下面的场景，我们有一个日期的数据，但是是毫秒值： 123data:&#123; birthday:1529032123201 // 毫秒值&#125; 我们在页面渲染，希望得到yyyy-MM-dd的样式： 1234&lt;h1&gt;您的生日是：&#123;&#123; new Date(birthday).getFullYear() + '-'+ new Date(birthday).getMonth()+ '-' + new Date(birthday).getDay() &#125;&#125;&lt;/h1&gt; 虽然能得到结果，但是非常麻烦。 Vue中提供了计算属性，来替代复杂的表达式： 123456789101112var vm = new Vue(&#123; el:"#app", data:&#123; birthday:1429032123201 // 毫秒值 &#125;, computed:&#123; birth()&#123;// 计算属性本质是一个方法，但是必须返回结果 const d = new Date(this.birthday); return d.getFullYear() + "-" + d.getMonth() + "-" + d.getDay(); &#125; &#125;&#125;) 计算属性本质就是方法，但是一定要返回数据。然后页面渲染时，可以把这个方法当成一个变量来使用。 页面使用： 123&lt;div id="app"&gt; &lt;h1&gt;您的生日是：&#123;&#123;birth&#125;&#125; &lt;/h1&gt;&lt;/div&gt; 效果： 我们可以将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的。然而，不同的是计算属性是基于它们的依赖进行缓存的。计算属性只有在它的相关依赖发生改变时才会重新求值。这就意味着只要birthday还没有发生改变，多次访问 birthday 计算属性会立即返回之前的计算结果，而不必再次执行函数。 5.8.watch###5.8.1浅监控 watch可以让我们监控一个值的变化。从而做出相应的反应。 示例： 1234567891011121314151617&lt;div id="app"&gt; &lt;input type="text" v-model="message"&gt;&lt;/div&gt;&lt;script src="./node_modules/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; var vm = new Vue(&#123; el:"#app", data:&#123; message:"" &#125;, watch:&#123; message(newVal, oldVal)&#123; console.log(newVal, oldVal); &#125; &#125; &#125;)&lt;/script&gt; 效果： 5.8.2深监控如果监控的是一个对象，需要进行深度监控到对象中的属性的变化 123456789101112131415161718192021222324&lt;body&gt;&lt;div id="app" &gt; &lt;h1&gt;&#123;&#123;person.name&#125;&#125;今年&#123;&#123;person.age&#125;&#125;岁了&lt;/h1&gt;&lt;/div&gt;&lt;script src="node_modules/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;script&gt; const app=new Vue(&#123; el:"#app", data:&#123; person:&#123; name:"jack", age:21 &#125; &#125;, watch:&#123; person:&#123; deep:true,//开启深度监控，可以监控到对象中属性的变化 handler(val)&#123;//定义监控到以后处理的方法 console.log(val.age) &#125; &#125; &#125; &#125;);&lt;/script&gt; 以前定义的时候，person是一个函数，现在改成对象，并且要指定两个属性： deep：代表深度监控，不仅监控person的变化，也监控person中属性变化 handler：就是以前的监控函数 6.组件化在大型应用开发的时候，页面可以划分成很多部分。往往不同的页面，也会有相同的部分。例如可能会有相同的头部导航。 但是如果每个页面都独自开发，这无疑增加了我们开发的成本。所以我们会把页面的不同部分拆分成独立的组件，然后在不同页面就可以共享这些组件，避免重复开发。 6.1.全局组件我们通过Vue的component方法来定义一个全局组件。 1234567891011121314151617181920&lt;div id="app"&gt; &lt;!--使用定义好的全局组件--&gt; &lt;counter&gt;&lt;/counter&gt;&lt;/div&gt;&lt;script src="./node_modules/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; // 定义全局组件，两个参数：1，组件名称。2，组件参数 //template:是模板 Vue.component("counter",&#123; template:'&lt;button v-on:click="count++"&gt;你点了我 &#123;&#123; count &#125;&#125; 次，我记住了.&lt;/button&gt;', data()&#123; return &#123; count:0 &#125; &#125; &#125;) var app = new Vue(&#123; el:"#app" &#125;)&lt;/script&gt; 组件其实也是一个Vue实例，因此它在定义时也会接收：data、methods、生命周期函数等 不同的是组件不会与页面的元素绑定，否则就无法复用了，因此没有el属性。 但是组件渲染需要html模板，所以增加了template属性，值就是HTML模板 全局组件定义完毕，任何vue实例都可以直接在HTML中通过组件名称来使用组件了。 data必须是一个函数，不再是一个对象。 效果： 6.2.组件的复用定义好的组件，可以任意复用多次： 123456&lt;div id="app"&gt; &lt;!--使用定义好的全局组件--&gt; &lt;counter&gt;&lt;/counter&gt; &lt;counter&gt;&lt;/counter&gt; &lt;counter&gt;&lt;/counter&gt;&lt;/div&gt; 效果： 你会发现每个组件互不干扰，都有自己的count值。怎么实现的？ 组件的data属性必须是函数！ 当我们定义这个 &lt;counter&gt; 组件时，它的data 并不是像这样直接提供一个对象： 123data: &#123; count: 0&#125; 取而代之的是，一个组件的 data 选项必须是一个函数，因此每个实例可以维护一份被返回对象的独立的拷贝： 12345data: function () &#123; return &#123; count: 0 &#125;&#125; 如果 Vue 没有这条规则，点击一个按钮就会影响到其它所有实例！ 6.3.局部注册一旦全局注册，就意味着即便以后你不再使用这个组件，它依然会随着Vue的加载而加载。 因此，对于一些并不频繁使用的组件，我们会采用局部注册。 我们先在外部定义一个对象，结构与创建组件时传递的第二个参数一致： 12345678const counter = &#123; template:'&lt;button v-on:click="count++"&gt;你点了我 &#123;&#123; count &#125;&#125; 次，我记住了.&lt;/button&gt;', data()&#123; return &#123; count:0 &#125; &#125;&#125;; 然后在Vue中使用它： 123456var app = new Vue(&#123; el:"#app", components:&#123; counter:counter // 将定义的对象注册为组件 &#125;&#125;) components就是当前vue对象子组件集合。 其key就是子组件名称 其值就是组件对象的属性 效果与刚才的全局注册是类似的，不同的是，这个counter组件只能在当前的Vue实例中使用 6.4.组件通信通常一个单页应用会以一棵嵌套的组件树的形式来组织： 页面首先分成了顶部导航、左侧内容区、右侧边栏三部分 左侧内容区又分为上下两个组件 右侧边栏中又包含了3个子组件 各个组件之间以嵌套的关系组合在一起，那么这个时候不可避免的会有组件间通信的需求。 6.4.1.props（父向子传递） 父组件使用子组件时，自定义属性（属性名任意，属性值为要传递的数据） 子组件通过props接收父组件属性 父组件使用子组件，并自定义了title属性： 12345678910111213141516171819202122232425262728&lt;div id="app"&gt; &lt;h1&gt;打个招呼：&lt;/h1&gt; &lt;!--使用子组件，同时传递title属性--&gt; &lt;introduce :title="msg"&gt;&lt;/introduce&gt; &lt;lessons :items="lessons"&gt;&lt;/lessons&gt;&lt;/div&gt;&lt;script src="./node_modules/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; //子 Vue.component("introduce",&#123; // 直接使用props接收到的属性来渲染页面 template:'&lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt;', props:['title'] // 通过props来接收一个父组件传递的属性 &#125;) //子 Vue.component("lessons",&#123; template:"&lt;ul&gt;&lt;li v-for='item in items'&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt;&lt;/ul&gt;", props:['items'] &#125;) //父 var app = new Vue(&#123; el:"#app", data:&#123; msg:"大家好，我是父传子", lessons:['java','php','python'] &#125; &#125;)&lt;/script&gt; 效果： 6.4.2.props验证我们定义一个子组件，并接受复杂数据： 12345678910Vue.component("lessons",&#123; template:"&lt;ul&gt;&lt;li v-for='item in items'&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt;&lt;/ul&gt;", props: &#123; items: &#123; type: Array, default: [], required: true &#125; &#125;&#125;) 这个子组件可以对 items 进行迭代，并输出到页面。 props：定义需要从父组件中接收的属性 items：是要接收的属性名称 type：限定父组件传递来的必须是数组 default：默认值 required：是否必须 当 prop 验证失败的时候，(开发环境构建版本的) Vue 将会产生一个控制台的警告。 我们在父组件中使用它： 12345&lt;div id="app"&gt; &lt;h2&gt;传智播客已开设如下课程：&lt;/h2&gt; &lt;!-- 使用子组件的同时，传递属性，这里使用了v-bind，指向了父组件自己的属性lessons --&gt; &lt;my-list :items="lessons"/&gt;&lt;/div&gt; 12345678910111213var app = new Vue(&#123; el:"#app", components:&#123; myList // 当key和value一样时，可以只写一个 &#125;, data:&#123; lessons:[ &#123;id:1, name: 'java'&#125;, &#123;id:2, name: 'php'&#125;, &#123;id:3, name: 'ios'&#125;, ] &#125;&#125;) 效果： type类型，可以有： 6.4.3.动态静态传递给 prop 传入一个静态的值： 1&lt;introduce title="大家好，我是锋哥"/&gt; 给 prop 传入一个动态的值： （通过v-bind从数据模型中，获取title的值） 1&lt;introduce :title="title"/&gt; 静态传递时，我们传入的值都是字符串类型的，但实际上任何类型的值都可以传给一个 props。 123456&lt;!-- 即便 `42` 是静态的，我们仍然需要 `v-bind` 来告诉 Vue --&gt;&lt;!-- 这是一个JavaScript表达式而不是一个字符串。--&gt;&lt;blog-post v-bind:likes="42"&gt;&lt;/blog-post&gt;&lt;!-- 用一个变量进行动态赋值。--&gt;&lt;blog-post v-bind:likes="post.likes"&gt;&lt;/blog-post&gt; 6.4.4.子向父的通信来看这样的一个案例： 12345678910111213141516171819202122&lt;div id="app"&gt; &lt;h2&gt;num: &#123;&#123;num&#125;&#125;&lt;/h2&gt; &lt;!--使用子组件的时候，传递num到子组件中--&gt; &lt;counter :num="num"&gt;&lt;/counter&gt;&lt;/div&gt;&lt;script src="node_modules/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; Vue.component("counter", &#123;// 子组件，定义了两个按钮，点击数字num会加或减 template:` &lt;div&gt; &lt;button @click="num++"&gt;加&lt;/button&gt; &lt;button @click="num--"&gt;减&lt;/button&gt; &lt;/div&gt;`, props:['num']// count是从父组件获取的。 &#125;) var app = new Vue(&#123; el:"#app", data:&#123; num:0 &#125; &#125;)&lt;/script&gt; 子组件接收父组件的num属性 子组件定义点击按钮，点击后对num进行加或减操作 我们尝试运行，好像没问题，点击按钮试试： 子组件接收到父组件属性后，默认是不允许修改的。怎么办？ 既然只有父组件能修改，那么加和减的操作一定是放在父组件： 1234567891011121314var app = new Vue(&#123; el:"#app", data:&#123; num:0 &#125;, methods:&#123; // 父组件中定义操作num的方法 increment()&#123; this.num++; &#125;, decrement()&#123; this.num--; &#125; &#125;&#125;) 但是，点击按钮是在子组件中，那就是说需要子组件来调用父组件的函数，怎么做？ 我们可以通过v-on指令将父组件的函数绑定到子组件上： 1234&lt;div id="app"&gt; &lt;h2&gt;num: &#123;&#123;num&#125;&#125;&lt;/h2&gt; &lt;counter :count="num" @inc="increment" @dec="decrement"&gt;&lt;/counter&gt;&lt;/div&gt; 在子组件中定义函数，函数的具体实现调用父组件的实现，并在子组件中调用这些函数。当子组件中按钮被点击时，调用绑定的函数： 1234567891011121314151617 // 子Vue.component("counter", &#123; template:` &lt;div&gt; &lt;button @click="plus"&gt;加&lt;/button&gt; &lt;button @click="reduce"&gt;减&lt;/button&gt; &lt;/div&gt;`, props:['count'], methods:&#123; plus()&#123; this.$emit("inc"); &#125;, reduce()&#123; this.$emit("dec"); &#125; &#125; &#125;) vue提供了一个内置的this.$emit()函数，用来调用父组件绑定的函数 完整的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839&lt;div id="app"&gt; &lt;counter :num="num" @inc="increment" @dec="decrement"&gt;&lt;/counter&gt; &lt;p &gt;&#123;&#123;num&#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script src="./node_modules/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; // 子 Vue.component("counter", &#123; template:` &lt;div&gt; &lt;button @click="plus"&gt;加&lt;/button&gt; &lt;button @click="reduce"&gt;减&lt;/button&gt; &lt;/div&gt;`, props:['count'], methods:&#123; plus()&#123; this.$emit("inc"); &#125;, reduce()&#123; this.$emit("dec"); &#125; &#125; &#125;); var app = new Vue(&#123; el:"#app", data:&#123; num:0 &#125;, methods:&#123; // 父组件中定义操作num的方法 increment()&#123; this.num++; &#125;, decrement()&#123; this.num--; &#125; &#125; &#125;);&lt;/script&gt;&lt;/body&gt; 效果：]]></content>
      <categories>
        <category>项目实战-微服务商城</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务商城（四）——ES6标准介绍]]></title>
    <url>%2Fday4-ES6%E6%A0%87%E5%87%86.html</url>
    <content type="text"><![CDATA[1、ES6 语法指后端项目搭建完毕，接下来就是前端页面了。不过在这之前需要一些准备工作。我们需要学习ES6的语法标准。 什么是ES6？就是ECMAScript第6版标准。 1.1.什么是ECMAScript？来看下前端的发展历程： web1.0时代： 最初的网页以HTML为主，是纯静态的网页。网页是只读的，信息流只能从服务的到客户端单向流通。开发人员也只关心页面的样式和内容即可。 web2.0时代： 1995年，网景工程师Brendan Eich 花了10天时间设计了JavaScript语言。 1996年，微软发布了JScript，其实是JavaScript的逆向工程实现。 1997年，为了统一各种不同script脚本语言，ECMA（欧洲计算机制造商协会）以JavaScript为基础，制定了ECMAscript标准规范。JavaScript和JScript都是ECMAScript的标准实现者，随后各大浏览器厂商纷纷实现了ECMAScript标准。 所以，ECMAScript是浏览器脚本语言的规范，而各种我们熟知的js语言，如JavaScript则是规范的具体实现。 1.2.ECMAScript的快速发展而后，ECMAScript就进入了快速发展期。 1998年6月，ECMAScript 2.0 发布。 1999年12月，ECMAScript 3.0 发布。这时，ECMAScript 规范本身也相对比较完善和稳定了，但是接下来的事情，就比较悲剧了。 2007年10月。。。。ECMAScript 4.0 草案发布。 这次的新规范，历时颇久，规范的新内容也有了很多争议。在制定ES4的时候，是分成了两个工作组同时工作的。 一边是以 Adobe, Mozilla, Opera 和 Google为主的 ECMAScript 4 工作组。 一边是以 Microsoft 和 Yahoo 为主的 ECMAScript 3.1 工作组。 ECMAScript 4 的很多主张比较激进，改动较大。而 ECMAScript 3.1 则主张小幅更新。最终经过 TC39 的会议，决定将一部分不那么激进的改动保留发布为 ECMAScript 3.1，而ES4的内容，则延续到了后来的ECMAScript5和6版本中 2009年12月，ECMAScript 5 发布。 2011年6月，ECMAScript 5.1 发布。 2015年6月，ECMAScript 6，也就是 ECMAScript 2015 发布了。 并且从 ECMAScript 6 开始，开始采用年号来做版本。即 ECMAScript 2015，就是ECMAScript6。 1.3.ES5和6的一些新特性我们这里只把一些常用的进行学习，更详细的大家参考：阮一峰的ES6教程 1.3.1.let 和 const 命令 var 之前，js定义变量只有一个关键字：var var有一个问题，就是定义的变量有时会莫名奇妙的成为全局变量。 例如这样的一段代码： 1234for(var i = 0; i &lt; 5; i++)&#123; console.log(i);&#125;console.log("循环外：" + i) 你猜下打印的结果是什么？ let let所声明的变量，只在let命令所在的代码块内有效。 我们把刚才的var改成let试试： 1234for(let i = 0; i &lt; 5; i++)&#123; console.log(i);&#125;console.log("循环外：" + i) 结果： const const声明的变量是常量，不能被修改 1.3.2.字符串扩展 新的API ES6为字符串扩展了几个新的API： includes()：返回布尔值，表示是否找到了参数字符串。 startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。 endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。 实验一下： 字符串模板 ES6中提供了`来作为字符串模板标记。我们可以这么玩： 在两个`之间的部分都会被作为字符串的值，不管你任意换行，甚至加入js脚本 键盘是的1的左侧，tab的上侧，esc的正下方 1.3.3.解构表达式 数组解构 比如有一个数组： 1let arr = [1,2,3] 我想获取其中的值，只能通过角标。ES6可以这样： 123const [x,y,z] = arr;// x，y，z将与arr中的每个位置对应来取值// 然后打印console.log(x,y,z); 结果： 对象解构 例如有个person对象： 12345const person = &#123; name:"jack", age:21, language: ['java','js','css']&#125; 我们可以这么做： 123456// 解构表达式获取值const &#123;name,age,language&#125; = person;// 打印console.log(name);console.log(age);console.log(language); 结果： 如过想要用其它变量接收，需要额外指定别名： {name:n}：name是person中的属性名，冒号后面的n是解构后要赋值给的变量。 1.3.4.函数优化 函数参数默认值 在ES6以前，我们无法给一个函数参数设置默认值，只能采用变通写法： 1234567function add(a , b) &#123; // 判断b是否为空，为空就给默认值1 b = b || 1; return a + b;&#125;// 传一个参数console.log(add(10)); 现在可以这么写： 12345function add(a , b = 1) &#123; return a + b;&#125;// 传一个参数console.log(add(10)); 箭头函数 ES6中定义函数的简写方式： 一个参数时： 12345var print = function (obj) &#123; console.log(obj);&#125;// 简写为：var print2 = obj =&gt; console.log(obj); 多个参数： 123456// 两个参数的情况：var sum = function (a , b) &#123; return a + b;&#125;// 简写为：var sum2 = (a,b) =&gt; a+b; 代码不止一行，可以用{}括起来 123var sum3 = (a,b) =&gt; &#123; return a + b;&#125; 对象的函数属性简写 比如一个Person对象，里面有eat方法： 12345678910111213let person = &#123; name: "jack", // 以前： eat: function (food) &#123; console.log(this.name + "在吃" + food); &#125;, // 箭头函数版： eat2: food =&gt; console.log(person.name + "在吃" + food),// 这里拿不到this // 简写版： eat3(food)&#123; console.log(this.name + "在吃" + food); &#125;&#125; 箭头函数结合解构表达式 比如有一个函数： 123456789const person = &#123; name:"jack", age:21, language: ['java','js','css']&#125;function hello(person) &#123; console.log("hello," + person.name)&#125; 如果用箭头函数和解构表达式 1var hi = (&#123;name&#125;) =&gt; console.log("hello," + name); 1.3.5.map和reduce数组中新增了map和reduce方法。 map map()：接收一个函数，将原数组中的所有元素用这个函数处理后放入新数组返回。 举例：有一个字符串数组，我们希望转为int数组 123456let arr = ['1','20','-5','3'];console.log(arr)arr = arr.map(s =&gt; parseInt(s));console.log(arr) reduce reduce()：接收一个函数（必须）和一个初始值（可选），该函数接收两个参数： 第一个参数是上一次reduce处理的结果 第二个参数是数组中要处理的下一个元素 reduce()会从左到右依次把数组中的元素用reduce处理，并把处理的结果作为下次reduce的第一个参数。如果是第一次，会把前两个元素作为计算参数，或者把用户指定的初始值作为起始参数 举例： 1const arr = [1,20,-5,3] 没有初始值： 指定初始值： 1.3.6.promise所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。 感觉跟java的Future类很像啊，有木有！ 我们可以通过Promise的构造函数来创建Promise对象，并在内部封装一个异步执行的结果。 语法： 123456789const promise = new Promise(function(resolve, reject) &#123; // ... 执行异步操作 if (/* 异步操作成功 */)&#123; resolve(value);// 调用resolve，代表Promise将返回成功的结果 &#125; else &#123; reject(error);// 调用reject，代表Promise会返回失败结果 &#125;&#125;); 这样，在promise中就封装了一段异步执行的结果。 如果我们想要等待异步执行完成，做一些事情，我们可以通过promise的then方法来实现,语法： 123promise.then(function(value)&#123; // 异步执行成功后的回调&#125;); 如果想要处理promise异步执行失败的事件，还可以跟上catch： 12345promise.then(function(value)&#123; // 异步执行成功后的回调&#125;).catch(function(error)&#123; // 异步执行失败后的回调&#125;) 示例： 12345678910111213141516171819const p = new Promise(function (resolve, reject) &#123; // 这里我们用定时任务模拟异步 setTimeout(() =&gt; &#123; const num = Math.random(); // 随机返回成功或失败 if (num &lt; 0.5) &#123; resolve(&quot;成功！num:&quot; + num) &#125; else &#123; reject(&quot;出错了！num:&quot; + num) &#125; &#125;, 300)&#125;)// 调用promisep.then(function (msg) &#123; console.log(msg);&#125;).catch(function (msg) &#123; console.log(msg);&#125;) 结果： 1.3.7.set和map（了解）ES6提供了Set和Map的数据结构。 Set，本质与数组类似。不同在于Set中只能保存不同元素，如果元素相同会被忽略。跟java很像吧。 构造函数： 12345// Set构造函数可以接收一个数组或空let set = new Set();set.add(1);// [1]// 接收数组let set2 = new Set([2,3,4,5,5]);// 得到[2,3,4,5] 普通方法： 123456789set.add(1);// 添加set.clear();// 清空set.delete(2);// 删除指定元素set.has(2); // 判断是否存在set.keys();// 返回所有keyset.values();// 返回所有值set.entries();// 返回键值对集合// 因为set没有键值对，所有其keys、values、entries方法返回值一样的。set.size; // 元素个数。是属性，不是方法。 map，本质是与Object类似的结构。不同在于，Object强制规定key只能是字符串。而Map结构的key可以是任意对象。即： object是 &lt;string,object&gt;集合 map是&lt;object,object&gt;集合 构造函数： 12345678910111213// map接收一个数组，数组中的元素是键值对数组const map = new Map([ ['key1','value1'], ['key2','value2'],])// 或者接收一个setconst set = new Set([ ['key1','value1'], ['key2','value2'],])const map2 = new Map(set)// 或者其它mapconst map3 = new Map(map); 方法： 1.3.8.模块化1.3.8.1.什么是模块化模块化就是把代码进行拆分，方便重复利用。类似java中的导包：要使用一个包，必须先导包。 而JS中没有包的概念，换来的是 模块。 模块功能主要由两个命令构成：export和import。 export命令用于规定模块的对外接口， import命令用于导入其他模块提供的功能。 1.3.8.2.export比如我定义一个js文件:hello.js，里面有一个对象： 12345const util = &#123; sum(a,b)&#123; return a + b; &#125;&#125; 我可以使用export将这个对象导出： 123456const util = &#123; sum(a,b)&#123; return a + b; &#125;&#125;export util; 当然，也可以简写为： 12345export const util = &#123; sum(a,b)&#123; return a + b; &#125;&#125; export不仅可以导出对象，一切JS变量都可以导出。比如：基本类型变量、函数、数组、对象。 当要导出多个值时，还可以简写。比如我有一个文件：user.js： 123var name = "jack"var age = 21export &#123;name,age&#125; 省略名称 上面的导出代码中，都明确指定了导出的变量名，这样其它人在导入使用时就必须准确写出变量名，否则就会出错。 因此js提供了default关键字，可以对导出的变量名进行省略 例如： 123456// 无需声明对象的名字export default &#123; sum(a,b)&#123; return a + b; &#125;&#125; 这样，当使用者导入时，可以任意起名字 1.3.8.3.import使用export命令定义了模块的对外接口以后，其他 JS 文件就可以通过import命令加载这个模块。 例如我要使用上面导出的util： 1234// 导入utilimport util from 'hello.js'// 调用util中的属性util.sum(1,2) 要批量导入前面导出的name和age： 123import &#123;name, age&#125; from 'user.js'console.log(name + " , 今年"+ age +"岁了") 但是上面的代码暂时无法测试，因为浏览器目前还不支持ES6 的导入和导出功能。除非借助于工具，把ES6 的语法进行编译降级到ES5，比如Babel-cli工具 我们暂时不做测试，大家了解即可。 1.3.9.对象扩展ES6给Object拓展了许多新的方法，如： keys(obj)：获取对象的所有key形成的数组 values(obj)：获取对象的所有value形成的数组 entries(obj)：获取对象的所有key和value形成的二维数组。格式：[[k1,v1],[k2,v2],...] assian(dest, …src) ：将多个src对象的值 拷贝到 dest中（浅拷贝）。 1.3.10.数组扩展ES6给数组新增了许多方法： find(callback)：把数组中的元素逐个传递给函数callback执行，如果返回true，则返回该元素 findIndex(callback)：与find类似，不过返回的是品牌到的元素的索引 includes（callback）：与find类似，如果匹配到元素，则返回true，代表找到了。]]></content>
      <categories>
        <category>项目实战-微服务商城</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务商城（三）——SpringCloud学习笔记二]]></title>
    <url>%2Fday03-%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A12.html</url>
    <content type="text"><![CDATA[0.学习目标 会配置Hystix熔断 会使用Feign进行远程调用 能独立搭建Zuul网关 能编写Zuul的拦截器 1.Hystix1.1.简介Hystix，即熔断器。 主页：https://github.com/Netflix/Hystrix/ Hystix是Netflix开源的一个延迟和容错库，用于隔离访问远程服务、第三方库，防止出现级联失败。 1.2.熔断器的工作机制： 正常工作的情况下，客户端请求调用服务cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccbbbsAPI接口： 当有服务出现异常时，直接进行失败回滚，服务降级处理： 当服务繁忙时，如果服务出现异常，不是粗暴的直接报错，而是返回一个友好的提示，虽然拒绝了用户的访问，但是会返回一个结果。 这就好比去买鱼，平常超市买鱼会额外赠送杀鱼的服务。等到逢年过节，超时繁忙时，可能就不提供杀鱼服务了，这就是服务的降级。 系统特别繁忙时，一些次要服务暂时中断，优先保证主要服务的畅通，一切资源优先让给主要服务来使用，在双十一、618时，京东天猫都会采用这样的策略。 1.3.动手实践1.3.1.引入依赖首先在consumer-demo中引入Hystix依赖： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;&lt;/dependency&gt; 1.3.2.开启熔断引入标签@EnableHystrix 1234@EnableHystrix //开启熔断@SpringBootApplication@EnableDiscoveryClient public class ConsumerDemoApplication &#123; 1.3.3.改造消费者我们改造consumer-demo，添加一个用来访问的user服务的DAO，并且声明一个失败时的回滚处理函数： 123456789101112131415161718192021222324252627282930@Componentpublic class UserDao &#123; @Autowired private RestTemplate restTemplate; private static final Logger logger = LoggerFactory.getLogger(UserDao.class); @HystrixCommand(fallbackMethod = "queryUserByIdFallback") public User queryUserById(Long id)&#123; long begin = System.currentTimeMillis(); String url = "http://user-service/user/" + id; User user = this.restTemplate.getForObject(url, User.class); long end = System.currentTimeMillis(); // 记录访问用时： logger.info("访问用时：&#123;&#125;", end - begin); return user; &#125; /** * 当上面queryById()方法执行不了就进行熔断执行queryUserByIdFallback()方法进行报错信息 * @param id * @return */ public User queryUserByIdFallback(Long id)&#123; User user = new User(); user.setId(id); user.setName("用户信息查询出现异常！"); return user; &#125;&#125; @HystrixCommand(fallbackMethod=&quot;queryUserByIdFallback&quot;)：声明一个失败回滚处理函数queryUserByIdFallback，当queryUserById执行超时（默认是1000毫秒），就会执行fallback函数，返回错误提示。 为了方便查看熔断的触发时机，我们记录请求访问时间。 在消费服务者consumer-demo原来的业务逻辑中调用这个DAO： 123456789101112131415@Servicepublic class UserService &#123; @Autowired private UserDao userDao; public List&lt;User&gt; queryUserByIds(List&lt;Long&gt; ids) &#123; List&lt;User&gt; users = new ArrayList&lt;&gt;(); ids.forEach(id -&gt; &#123; // 我们测试多次查询， users.add(this.userDao.queryUserById(id)); &#125;); return users; &#125;&#125; 1.3.4.改造服务提供者改造服务提供者，随机休眠一段时间，以触发熔断： 123456789101112@Servicepublic class UserService &#123; @Autowired private UserMapper userMapper; public User queryById(Long id) throws InterruptedException &#123; // 为了演示超时现象，我们在这里然线程休眠,时间随机 0~2000毫秒 Thread.sleep(new Random().nextInt(2000)); return this.userMapper.selectByPrimaryKey(id); &#125;&#125; 1.3.5.启动测试然后运行并查看日志： id为9、10、11的访问时间分别是： id为12的访问时间： 因此，只有12是正常访问，其它都会触发熔断，我们来查看结果： 1.3.5.优化虽然熔断实现了，但是我们的重试机制似乎没有生效，是这样吗？ 其实这里是因为我们的Ribbon超时时间设置的是1000ms: ​ 而Hystix的超时时间默认也是1000ms，因此重试机制没有被触发，而是先触发了熔断。 所以，Ribbon的超时时间一定要小于Hystix的超时时间。 我们可以通过hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds来设置Hystrix超时时间。 在消费者中（） 123456hystrix: command: execution: isolation: thread: timeoutInMillisecond: 6000 # 设置hystrix的超时时间为6000ms 2.Feign（包括了Hystix、ribbon）在前面的学习中，我们使用了Ribbon的负载均衡功能，大大简化了远程调用时的代码： 12String baseUrl = "http://user-service/user/";User user = this.restTemplate.getForObject(baseUrl + id, User.class) 如果就学到这里，你可能以后需要编写类似的大量重复代码，格式基本相同，无非参数不一样。有没有更优雅的方式，来对这些代码再次优化呢？ 这就是我们接下来要学的Feign的功能了。 2.1.简介有道词典的英文解释： ​ 为什么叫伪装？ Feign可以把Rest的请求进行隐藏，伪装成类似SpringMVC的Controller一样。你不用再自己拼接url，拼接参数等等操作，一切都交给Feign去做。 项目主页：https://github.com/OpenFeign/feign 声明式远程调用 2.2.快速入门2.2.1.导入依赖在consumer-demo中： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt; 开启Feign客户端 1234567@EnableHystrix@SpringBootApplication@EnableDiscoveryClient // 开启Eureka客户端@EnableFeignClients //开启feign客户端public class ConsumerDemoApplication &#123; &#125; 2.2.2.Feign的客户端consumer-demo中的dao中创建： 123456@FeignClient("user-service")public interface UserFeignClient &#123; @GetMapping("/user/&#123;id&#125;") User queryUserById(@PathVariable("id") Long id);&#125; 首先这是一个接口，Feign会通过动态代理，帮我们生成实现类。这点跟mybatis的mapper很像 @FeignClient，声明这是一个Feign客户端，类似@Mapper注解。同时通过value属性指定服务名称 接口中的定义方法，完全采用SpringMVC的注解，Feign会根据注解帮我们生成URL，并访问获取结果 改造原来的调用逻辑，不再调用UserDao： 123456789101112131415@Servicepublic class UserService &#123; @Autowired private UserFeignClient userFeignClient; public List&lt;User&gt; queryUserByIds(List&lt;Long&gt; ids) &#123; List&lt;User&gt; users = new ArrayList&lt;&gt;(); ids.forEach(id -&gt; &#123; // 我们测试多次查询， users.add(this.userFeignClient.queryUserById(id)); &#125;); return users; &#125;&#125; 2.2.3.开启Feign功能我们在启动类上，添加注解，开启Feign功能 123456789@SpringBootApplication@EnableDiscoveryClient@EnableHystrix@EnableFeignClients // 开启Feign功能public class UserConsumerDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(UserConsumerDemoApplication.class, args); &#125;&#125; 你会发现RestTemplate的注册被我删除了。Feign中已经自动集成了Ribbon负载均衡，因此我们不需要自己定义RestTemplate了 2.2.4.启动测试：访问接口： 正常获取到了结果。 2.3.负载均衡Feign中本身已经集成了Ribbon依赖和自动配置： ​ 因此我们不需要额外引入依赖，也不需要再注册RestTemplate对象。 另外，我们可以像上节课中讲的那样去配置Ribbon，可以通过ribbon.xx来进行全局配置。也可以通过服务名.ribbon.xx来对指定服务配置： 1234567user-service: ribbon: ConnectTimeout: 250 # 连接超时时间(ms) ReadTimeout: 1000 # 通信超时时间(ms) OkToRetryOnAllOperations: true # 是否对所有操作重试 MaxAutoRetriesNextServer: 1 # 同一服务不同实例的重试次数 MaxAutoRetries: 1 # 同一实例的重试次数 2.4.Hystix支持Feign默认也有对Hystix的集成： ​ 只不过，默认情况下是关闭的。我们需要通过下面的参数来开启： 123feign: hystrix: enabled: true # 开启Feign的熔断功能 但是，Feign中的Fallback配置不像Ribbon中那样简单了。 1）首先，我们要定义一个类，实现刚才编写的UserFeignClient，作为fallback的处理类 12345678910@Componentpublic class UserFeignClientFallback implements UserFeignClient &#123; @Override public User queryUserById(Long id) &#123; User user = new User(); user.setId(id); user.setName("用户查询出现异常！"); return user; &#125;&#125; 2）然后在UserFeignClient中，指定刚才编写的实现类 123456@FeignClient(value = "user-service", fallback = UserFeignClientFallback.class)public interface UserFeignClient &#123; @GetMapping("/user/&#123;id&#125;") User queryUserById(@PathVariable("id") Long id);&#125; 3）重启测试： 我们关闭user-service服务，然后在页面访问： 2.5.请求压缩(了解)Spring Cloud Feign 支持对请求和响应进行GZIP压缩，以减少通信过程中的性能损耗。通过下面的参数即可开启请求与响应的压缩功能： 123456feign: compression: request: enabled: true # 开启请求压缩 response: enabled: true # 开启响应压缩 同时，我们也可以对请求的数据类型，以及触发压缩的大小下限进行设置： 123456feign: compression: request: enabled: true # 开启请求压缩 mime-types: text/html,application/xml,application/json # 设置压缩的数据类型 min-request-size: 2048 # 设置触发压缩的大小下限 注：上面的数据类型、压缩大小下限均为默认值。 2.6.日志级别(了解)前面讲过，通过logging.level.xx=debug来设置日志级别。然而这个对Fegin客户端而言不会产生效果。因为@FeignClient注解修改的客户端在被代理时，都会创建一个新的Fegin.Logger实例。我们需要额外指定这个日志的级别才可以。 1）设置com.leyou包下的日志级别都为debug 123logging: level: com.leyou: debug 2）编写配置类，定义日志级别 Logger是导入：import feign.Logger; 1234567@Configurationpublic class FeignConfig &#123; @Bean Logger.Level feignLoggerLevel()&#123; return Logger.Level.FULL; &#125;&#125; 这里指定的Level级别是FULL，Feign支持4种级别： ​ NONE：不记录任何日志信息，这是默认值。 BASIC：仅记录请求的方法，URL以及响应状态码和执行时间 HEADERS：在BASIC的基础上，额外记录了请求和响应的头信息 FULL：记录所有请求和响应的明细，包括头信息、请求体、元数据。 3）在FeignClient中指定配置类： 12345@FeignClient(value = "user-service", fallback = UserFeignClientFallback.class, configuration = FeignConfig.class)public interface UserFeignClient &#123; @GetMapping("/user/&#123;id&#125;") User queryUserById(@PathVariable("id") Long id);&#125; 4）重启项目，即可看到每次访问的日志： 3.Zuul网关通过前面的学习，使用Spring Cloud实现微服务的架构基本成型，大致是这样的： 我们使用Spring Cloud Netflix中的Eureka实现了服务注册中心以及服务注册与发现；而服务间通过Ribbon或Feign实现服务的消费以及均衡负载；通过Spring Cloud Config实现了应用多环境的外部化配置以及版本管理。为了使得服务集群更为健壮，使用Hystrix的融断机制来避免在微服务架构中个别服务出现异常时引起的故障蔓延。 在该架构中，我们的服务集群包含：内部服务Service A和Service B，他们都会注册与订阅服务至Eureka Server，而Open Service是一个对外的服务，通过均衡负载公开至服务调用方。我们把焦点聚集在对外服务这块，直接暴露我们的服务地址，这样的实现是否合理，或者是否有更好的实现方式呢？ 先来说说这样架构需要做的一些事儿以及存在的不足： 首先，破坏了服务无状态特点。 为了保证对外服务的安全性，我们需要实现对服务访问的权限控制，而开放服务的权限控制机制将会贯穿并污染整个开放服务的业务逻辑，这会带来的最直接问题是，破坏了服务集群中REST API无状态的特点。 从具体开发和测试的角度来说，在工作中除了要考虑实际的业务逻辑之外，还需要额外考虑对接口访问的控制处理。 其次，无法直接复用既有接口。 当我们需要对一个即有的集群内访问接口，实现外部服务访问时，我们不得不通过在原有接口上增加校验逻辑，或增加一个代理调用来实现权限控制，无法直接复用原有的接口。 面对类似上面的问题，我们要如何解决呢？答案是：服务网关！ 为了解决上面这些问题，我们需要将权限控制这样的东西从我们的服务单元中抽离出去，而最适合这些逻辑的地方就是处于对外访问最前端的地方，我们需要一个更强大一些的均衡负载器的 服务网关。 服务网关是微服务架构中一个不可或缺的部分。通过服务网关统一向外系统提供REST API的过程中，除了具备服务路由、均衡负载功能之外，它还具备了权限控制等功能。Spring Cloud Netflix中的Zuul就担任了这样的一个角色，为微服务架构提供了前门保护的作用，同时将权限控制这些较重的非业务逻辑内容迁移到服务路由层面，使得服务集群主体能够具备更高的可复用性和可测试性。 3.1.简介官网：https://github.com/Netflix/zuul ​ Zuul：维基百科： 电影《捉鬼敢死队》中的怪兽，Zuul，在纽约引发了巨大骚乱。 事实上，在微服务架构中，Zuul就是守门的大Boss！一夫当关，万夫莫开！ 3.2.Zuul加入后的架构 不管是来自于客户端（PC或移动端）的请求，还是服务内部调用。一切对服务的请求都会经过Zuul这个网关，然后再由网关来实现 鉴权、动态路由等等操作。Zuul就是我们服务的统一入口。 3.3.快速入门3.3.1.新建工程填写基本信息： 添加Zuul依赖： 3.3.2.编写启动类通过@EnableZuulProxy注解开启Zuul的功能： 12345678@SpringBootApplication@EnableZuulProxy // 开启Zuul的网关功能public class ZuulDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ZuulDemoApplication.class, args); &#125;&#125; 3.3.3.编写配置12345server: port: 10010 #服务端口spring: application: name: api-gateway #指定服务名 3.3.4.编写路由规则我们需要用Zuul来代理user-service服务，先看一下控制面板中的服务状态： ip为：127.0.0.1 端口为：8081 映射规则： 12345zuul: routes: user-service: # 这里是路由id，随意写 path: /user-service/** # 这里是映射路径 url: http://127.0.0.1:8082 # 映射路径服务提供者的实际url地址 我们将符合path 规则的一切请求，都代理到 url参数指定的地址 本例中，我们将 /user-service/**开头的请求，代理到http://127.0.0.1:8082 3.3.5.启动测试：访问的路径中需要加上配置规则的映射路径， 以前访问方式为：http://127.0.0.1:8080/hello/list?ids=17 现在访问方式为：http://127.0.0.1:10010/user-service/user/16 ​ 3.4.面向服务的路由在刚才的路由规则中，我们把路径对应的服务地址写死了！如果同一服务有多个实例的话，这样做显然就不合理了。 我们应该根据服务的名称，去Eureka注册中心查找 服务对应的所有实例列表，然后进行动态路由才对！ 3.4.1.添加Eureka客户端依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt; 3.4.2.开启Eureka客户端发现功能123456789@SpringBootApplication@EnableZuulProxy // 开启Zuul的网关功能@EnableDiscoveryClientpublic class ZuulDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ZuulDemoApplication.class, args); &#125;&#125; 3.4.3.添加Eureka配置，获取服务信息12345678eureka: client: registry-fetch-interval-seconds: 5 # 获取服务列表的周期：5s service-url: defaultZone: http://127.0.0.1:10086/eureka instance: prefer-ip-address: true ip-address: 127.0.0.1 3.4.4.修改映射配置，通过服务名称获取因为已经有了Eureka客户端，我们可以从Eureka获取服务的地址信息，因此映射时无需指定IP地址，而是通过服务名称来访问，而且Zuul已经集成了Ribbon的负载均衡功能。 12345zuul: routes: user-service: # 这里是路由id，随意写 path: /user-service/** # 这里是映射路径 serviceId: user-service # 指定服务名称 3.4.5.启动测试再次启动，这次Zuul进行代理时，会利用Ribbon进行负载均衡访问： ​ 日志中可以看到使用了负载均衡器： 3.5.简化的路由配置在刚才的配置中，我们的规则是这样的： zuul.routes.&lt;route&gt;.path=/xxx/**： 来指定映射路径。&lt;route&gt;是自定义的路由名 zuul.routes.&lt;route&gt;.serviceId=/user-service：来指定服务名。 而大多数情况下，我们的&lt;route&gt;路由名称往往和 服务名会写成一样的。因此Zuul就提供了一种简化的配置语法：zuul.routes.&lt;serviceId&gt;=&lt;path&gt; 比方说上面我们关于user-service的配置可以简化为一条： 1234zuul: routes: user-service: /user-service/** # 这里是映射路径 &#123;服务名&#125;：&#123;服务路径&#125; 省去了对服务名称的配置。 3.6.默认的路由规则在使用Zuul的过程中，上面讲述的规则已经大大的简化了配置项。但是当服务较多时，配置也是比较繁琐的。因此Zuul就指定了默认的路由规则： 默认情况下，一切服务的映射路径就是服务名本身。 例如服务名为：user-service，则默认的映射路径就是：/user-service/** 也就是说，刚才的映射规则我们完全不配置也是OK的，不信就试试看。 3.7.路由前缀配置示例： 1234zuul: prefix: /api # 添加路由前缀 routes: user-service: /user-service/** # 服务路径 我们通过zuul.prefix=/api来指定了路由的前缀，这样在发起请求时，路径就要以/api开头。 路径/api/user-service/user/1将会被代理到/user-service/user/1 http://localhost:10010/api/user-service/user/17 3.8.过滤器Zuul作为网关的其中一个重要功能，就是实现请求的鉴权。而这个动作我们往往是通过Zuul提供的过滤器来实现的。 3.8.1.ZuulFilterZuulFilter是过滤器的顶级父类。在这里我们看一下其中定义的4个最重要的方法： 源码： 12345678910public abstract ZuulFilter implements IZuulFilter&#123; abstract public String filterType(); abstract public int filterOrder(); boolean shouldFilter();// 来自IZuulFilter Object run() throws ZuulException;// IZuulFilter&#125; shouldFilter：返回一个Boolean值，判断该过滤器是否需要执行。返回true执行，返回false不执行。 run：过滤器的具体业务逻辑。 filterType：返回字符串，代表过滤器的类型。包含以下4种： pre：请求在被路由之前执行 routing：在路由请求时调用 post：在routing和errror过滤器之后调用 error：处理请求时发生错误调用 filterOrder：通过返回的int值来定义过滤器的执行顺序，数字越小优先级越高。 3.8.2.过滤器执行生命周期：这张是Zuul官网提供的请求生命周期图，清晰的表现了一个请求在各个过滤器的执行顺序。 ​ 正常流程： 请求到达首先会经过pre类型过滤器，而后到达routing类型，进行路由，请求就到达真正的服务提供者，执行请求，返回结果后，会到达post过滤器。而后返回响应。 异常流程： 整个过程中，pre或者routing过滤器出现异常，都会直接进入error过滤器，再error处理完毕后，会将请求交给POST过滤器，最后返回给用户。 如果是error过滤器自己出现异常，最终也会进入POST过滤器，而后返回。 如果是POST过滤器出现异常，会跳转到error过滤器，但是与pre和routing不同的时，请求不会再到达POST过滤器了。 所有内置过滤器列表： ​ 3.8.3.使用场景场景非常多： 请求鉴权：一般放在pre类型，如果发现没有访问权限，直接就拦截了 异常处理：一般会在error类型和post类型过滤器中结合来处理。 服务调用时长统计：pre和post结合使用。 3.9.自定义过滤器接下来我们来自定义一个过滤器，模拟一个登录的校验。基本逻辑：如果请求中有access-token参数，则认为请求有效，放行。 3.9.1.定义过滤器类12345678910111213141516171819202122232425262728293031323334353637383940@Componentpublic class LoginFilter extends ZuulFilter&#123; @Override public String filterType() &#123; // 登录校验，肯定是在前置拦截 return "pre"; &#125; @Override public int filterOrder() &#123; // 顺序设置为1 return 1; &#125; @Override public boolean shouldFilter() &#123; // 返回true，代表过滤器生效。 return true; &#125; @Override public Object run() throws ZuulException &#123; // 登录校验逻辑。 // 1）获取Zuul提供的请求上下文对象 RequestContext ctx = RequestContext.getCurrentContext(); // 2) 从上下文中获取request对象 HttpServletRequest req = ctx.getRequest(); // 3) 从请求中获取token String token = req.getParameter("access-token"); // 4) 判断 if(token == null || "".equals(token.trim()))&#123; // 没有token，登录校验失败，拦截 ctx.setSendZuulResponse(false); // 返回401状态码。也可以考虑重定向到登录页。 ctx.setResponseStatusCode(HttpStatus.UNAUTHORIZED.value()); &#125; // 校验通过，可以考虑把用户信息放入上下文，继续向后执行 return null; &#125;&#125; 3.9.2.测试没有token参数时，访问失败： ​ 添加token参数后： 3.10.负载均衡和熔断Zuul中默认就已经集成了Ribbon负载均衡和Hystix熔断机制。但是所有的超时策略都是走的默认值，比如熔断超时时间只有1S，很容易就触发了。因此建议我们手动进行配置： 1234567891011121314zuul: retryable: trueribbon: ConnectTimeout: 250 # 连接超时时间(ms) ReadTimeout: 2000 # 通信超时时间(ms) OkToRetryOnAllOperations: true # 是否对所有操作重试 MaxAutoRetriesNextServer: 2 # 同一服务不同实例的重试次数 MaxAutoRetries: 1 # 同一实例的重试次数hystrix: command: execution: isolation: thread: timeoutInMillisecond: 6000 # 熔断超时时长：6000ms 3.11.Zuul的高可用]]></content>
      <categories>
        <category>项目实战-微服务商城</category>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>Feign远程调用</tag>
        <tag>SpringCloud</tag>
        <tag>Hystix</tag>
        <tag>Zuul</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务商城（二）——SpringCloud学习笔记一]]></title>
    <url>%2Fday02-%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A1.html</url>
    <content type="text"><![CDATA[0.学习目标 了解系统架构的演变 了解RPC与Http的区别 掌握HttpClient的简单使用 知道什么是SpringCloud 独立搭建Eureka注册中心 独立配置Robbin负载均衡 1.系统架构演变随着互联网的发展，网站应用的规模不断扩大。需求的激增，带来的是技术上的压力。系统架构也因此也不断的演进、升级、迭代。从单一应用，到垂直拆分，到分布式服务，到SOA，以及现在火热的微服务架构，还有在Google带领下来势汹涌的Service Mesh。我们到底是该乘坐微服务的船只驶向远方，还是偏安一隅得过且过？ 其实生活不止眼前的苟且，还有诗和远方。所以我们今天就回顾历史，看一看系统架构演变的历程；把握现在，学习现在最火的技术架构；展望未来，争取成为一名优秀的Java工程师。 1.1. 集中式架构当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架(ORM)是影响项目开发的关键。 存在的问题： 代码耦合，开发维护困难 无法针对不同模块进行针对性优化 无法水平扩展 单点容错率低，并发能力差 1.2.垂直拆分当访问量逐渐增大，单一应用无法满足需求，此时为了应对更高的并发和业务需求，我们根据业务功能对系统进行拆分： 优点： 系统拆分实现了流量分担，解决了并发问题 可以针对不同模块进行优化 方便水平扩展，负载均衡，容错率提高 缺点： 系统间相互独立，会有很多重复开发工作，影响开发效率 1.3.分布式服务当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的分布式调用是关键。 优点： 将基础服务进行了抽取，系统间相互调用，提高了代码复用和开发效率 缺点： 系统间耦合度变高，调用关系错综复杂，难以维护 1.4.服务治理（SOA）当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心(SOA)是关键 以前出现了什么问题？ 服务越来越多，需要管理每个服务的地址 调用关系错综复杂，难以理清依赖关系 服务过多，服务状态难以管理，无法根据服务情况动态管理 服务治理要做什么？ 服务注册中心，实现服务自动注册和发现，无需人为记录服务地址 服务自动订阅，服务列表自动推送，服务调用透明化，无需关心依赖关系 动态监控服务状态监控报告，人为控制服务状态 缺点： 服务间会有依赖关系，一旦某个环节出错会影响较大 服务关系复杂，运维、测试部署困难，不符合DevOps思想 1.5.微服务前面说的SOA，英文翻译过来是面向服务。微服务，似乎也是服务，都是对系统进行拆分。因此两者非常容易混淆，但其实缺有一些差别： 微服务的特点： 单一职责：微服务中每一个服务都对应唯一的业务能力，做到单一职责 微：微服务的服务拆分粒度很小，例如一个用户管理就可以作为一个服务。每个服务虽小，但“五脏俱全”。 面向服务：面向服务是说每个服务都要对外暴露服务接口API。并不关心服务的技术实现，做到与平台和语言无关，也不限定用什么技术实现，只要提供Rest的接口即可。 自治：自治是说服务间互相独立，互不干扰 团队独立：每个服务都是一个独立的开发团队，人数不能过多。 技术独立：因为是面向服务，提供Rest接口，使用什么技术没有别人干涉 前后端分离：采用前后端分离开发，提供统一Rest接口，后端不用再为PC、移动段开发不同接口 数据库分离：每个服务都使用自己的数据源 部署独立，服务间虽然有调用，但要做到服务重启不影响其它服务。有利于持续集成和持续交付。每个服务都是独立的组件，可复用，可替换，降低耦合，易维护 微服务结构图： 2.远程调用方式无论是微服务还是SOA，都面临着服务间的远程调用。那么服务间的远程调用方式有哪些呢？ 常见的远程调用方式有以下几种： RPC：Remote Produce Call远程过程调用，类似的还有RMI。自定义数据格式，基于原生TCP通信，速度快，效率高。早期的webservice，现在热门的dubbo，都是RPC的典型 Http：http其实是一种网络传输协议，基于TCP，规定了数据传输的格式。现在客户端浏览器与服务端通信基本都是采用Http协议。也可以用来进行远程服务调用。缺点是消息封装臃肿。 现在热门的Rest风格，就可以通过http协议来实现。 如果你们公司全部采用java技术栈，name使用Dubbo作为微服务架构师一个不错的选择 相反，如果公司采用技术栈多样，而且你更青睐spring家族，那么SpringCloud搭建微服务是不二之选，在我们项目中，我们就会选择采用SpringCloud套件，因此我们会使用http方式来实现服务间调用 2.1.认识RPCRPC，即 Remote Procedure Call（远程过程调用），是一个计算机通信协议。 该协议允许运行于一台计算机的程序调用另一台计算机的子程序，而程序员无需额外地为这个交互作用编程。说得通俗一点就是：A计算机提供一个服务，B计算机可以像调用本地服务那样调用A计算机的服务。 通过上面的概念，我们可以知道，实现RPC主要是做到两点： 实现远程调用其他计算机的服务 要实现远程调用，肯定是通过网络传输数据。A程序提供服务，B程序通过网络将请求参数传递给A，A本地执行后得到结果，再将结果返回给B程序。这里需要关注的有两点： 1）采用何种网络通讯协议？ 现在比较流行的RPC框架，都会采用TCP作为底层传输协议 2）数据传输的格式怎样？ 两个程序进行通讯，必须约定好数据传输格式。就好比两个人聊天，要用同一种语言，否则无法沟通。所以，我们必须定义好请求和响应的格式。另外，数据在网路中传输需要进行序列化，所以还需要约定统一的序列化的方式。 像调用本地服务一样调用远程服务 如果仅仅是远程调用，还不算是RPC，因为RPC强调的是过程调用，调用的过程对用户而言是应该是透明的，用户不应该关心调用的细节，可以像调用本地服务一样调用远程服务。所以RPC一定要对调用的过程进行封装 RPC调用流程图： 想要了解详细的RPC实现，给大家推荐一篇文章：自己动手实现RPC 2.2.认识HttpHttp协议：超文本传输协议，是一种应用层协议。规定了网络传输的请求格式、响应格式、资源定位和操作的方式等。但是底层采用什么网络传输协议，并没有规定，不过现在都是采用TCP协议作为底层传输协议。说到这里，大家可能觉得，Http与RPC的远程调用非常像，都是按照某种规定好的数据格式进行网络通信，有请求，有响应。没错，在这点来看，两者非常相似，但是还是有一些细微差别。 RPC并没有规定数据传输格式，这个格式可以任意指定，不同的RPC协议，数据格式不一定相同。 Http中还定义了资源定位的路径，RPC中并不需要 最重要的一点：RPC需要满足像调用本地服务一样调用远程服务，也就是对调用过程在API层面进行封装。Http协议没有这样的要求，因此请求、响应等细节需要我们自己去实现。 优点：RPC方式更加透明，对用户更方便。Http方式更灵活，没有规定API和语言，跨语言、跨平台 缺点：RPC方式需要在API层面进行封装，限制了开发的语言环境。 例如我们通过浏览器访问网站，就是通过Http协议。只不过浏览器把请求封装，发起请求以及接收响应，解析响应的事情都帮我们做了。如果是不通过浏览器，那么这些事情都需要自己去完成。 2.3.如何选择？既然两种方式都可以实现远程调用，我们该如何选择呢？ 速度来看，RPC要比http更快，虽然底层都是TCP，但是http协议的信息往往比较臃肿，不过可以采用gzip压缩。 难度来看，RPC实现较为复杂，http相对比较简单 灵活性来看，http更胜一筹，因为它不关心实现细节，跨平台、跨语言。 因此，两者都有不同的使用场景： 如果对效率要求更高，并且开发过程使用统一的技术栈，那么用RPC还是不错的。 如果需要更加灵活，跨语言、跨平台，显然http更合适 那么我们该怎么选择呢？ 微服务，更加强调的是独立、自治、灵活。而RPC方式的限制较多，因此微服务框架中，一般都会采用基于Http的Rest风格服务。 3.Http客户端工具既然微服务选择了Http，那么我们就需要考虑自己来实现对请求和响应的处理。不过开源世界已经有很多的http客户端工具，能够帮助我们做这些事情，例如： HttpClient OKHttp URLConnection 接下来，我们就一起了解一款比较流行的客户端工具：HttpClient 3.1.HttpClient3.1.1.介绍HttpClient是Apache公司的产品，是Http Components下的一个组件。 官网地址：http://hc.apache.org/index.html 特点： 基于标准、纯净的Java语言。实现了Http1.0和Http1.1 以可扩展的面向对象的结构实现了Http全部的方法（GET, POST, PUT, DELETE, HEAD, OPTIONS, and TRACE） 支持HTTPS协议。 通过Http代理建立透明的连接。 自动处理Set-Cookie中的Cookie。 3.1.2.使用我们导入课前资料提供的demo工程：《http-demo》 发起get请求： 123456@Testpublic void testGet() throws IOException &#123; HttpGet request = new HttpGet("http://www.baidu.com"); String response = this.httpClient.execute(request, new BasicResponseHandler()); System.out.println(response);&#125; 发起Post请求： 12345678@Testpublic void testPost() throws IOException &#123; HttpPost request = new HttpPost("http://www.oschina.net/"); request.setHeader("User-Agent", "Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36"); String response = this.httpClient.execute(request, new BasicResponseHandler()); System.out.println(response);&#125; 尝试访问昨天编写的接口：http://localhost/hello 这个接口返回一个User对象 123456@Testpublic void testGetPojo() throws IOException &#123; HttpGet request = new HttpGet("http://localhost/hello"); String response = this.httpClient.execute(request, new BasicResponseHandler()); System.out.println(response);&#125; 我们实际得到的是一个json字符串： 123456789101112&#123; "id": 8, "userName": "liuyan", "password": "123456", "name": "柳岩", "age": 21, "sex": 2, "birthday": "1995-08-07T16:00:00.000+0000", "created": "2014-09-20T03:41:15.000+0000", "updated": "2014-09-20T03:41:15.000+0000", "note": "柳岩同学在传智播客学表演"&#125; 如果想要得到对象，我们还需要手动进行Json反序列化，这一点比较麻烦。 3.1.3.Json转换工具HttpClient请求数据后是json字符串，需要我们自己把Json字符串反序列化为对象，我们会使用JacksonJson工具来实现。 JacksonJson是SpringMVC内置的json处理工具，其中有一个ObjectMapper类，可以方便的实现对json的处理： 对象转json12345678910111213// json处理工具 private ObjectMapper mapper = new ObjectMapper(); @Test public void testJson() throws JsonProcessingException &#123; User user = new User(); user.setId(8L); user.setAge(21); user.setName("柳岩"); user.setUserName("liuyan"); // 序列化 String json = mapper.writeValueAsString(user); System.out.println("json = " + json); &#125; 结果： json转普通对象12345678910111213141516// json处理工具private ObjectMapper mapper = new ObjectMapper();@Testpublic void testJson() throws IOException &#123; User user = new User(); user.setId(8L); user.setAge(21); user.setName("柳岩"); user.setUserName("liuyan"); // 序列化 String json = mapper.writeValueAsString(user); // 反序列化，接收两个参数：json数据，反序列化的目标类字节码 User result = mapper.readValue(json, User.class); System.out.println("result = " + result);&#125; 结果： json转集合json转集合比较麻烦，因为你无法同时把集合的class和元素的class同时传递到一个参数。 因此Jackson做了一个类型工厂，用来解决这个问题： 12345678910111213141516171819// json处理工具private ObjectMapper mapper = new ObjectMapper();@Testpublic void testJson() throws IOException &#123; User user = new User(); user.setId(8L); user.setAge(21); user.setName("柳岩"); user.setUserName("liuyan"); // 序列化,得到对象集合的json字符串 String json = mapper.writeValueAsString(Arrays.asList(user, user)); // 反序列化，接收两个参数：json数据，反序列化的目标类字节码 List&lt;User&gt; users = mapper.readValue(json, mapper.getTypeFactory().constructCollectionType(List.class, User.class)); for (User u : users) &#123; System.out.println("u = " + u); &#125;&#125; 结果： json转任意复杂类型当对象泛型关系复杂时，类型工厂也不好使了。这个时候Jackson提供了TypeReference来接收类型泛型，然后底层通过反射来获取泛型上的具体类型。实现数据转换。 12345678910111213141516171819// json处理工具private ObjectMapper mapper = new ObjectMapper();@Testpublic void testJson() throws IOException &#123; User user = new User(); user.setId(8L); user.setAge(21); user.setName("柳岩"); user.setUserName("liuyan"); // 序列化,得到对象集合的json字符串 String json = mapper.writeValueAsString(Arrays.asList(user, user)); // 反序列化，接收两个参数：json数据，反序列化的目标类字节码 List&lt;User&gt; users = mapper.readValue(json, new TypeReference&lt;List&lt;User&gt;&gt;()&#123;&#125;); for (User u : users) &#123; System.out.println("u = " + u); &#125;&#125; 结果： 3.3.Spring的RestTemplateSpring提供了一个RestTemplate模板工具类，对基于Http的客户端进行了封装，并且实现了对象与json的序列化和反序列化，非常方便。RestTemplate并没有限定Http的客户端类型，而是进行了抽象，目前常用的3种都有支持： HttpClient OkHttp JDK原生的URLConnection（默认的） 例子工程http-demo去调用工程springboot-demo的服务 注：首先要有相同的User http-demo工程如下： 首先在项目中注册一个RestTemplate对象，可以在启动类位置注册： 12345678910111213@SpringBootApplicationpublic class HttpDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(HttpDemoApplication.class, args); &#125; @Bean public RestTemplate restTemplate() &#123; // 默认的RestTemplate，底层是走JDK的URLConnection方式。 return new RestTemplate(); &#125;&#125; 在测试类中直接@Autowired注入： 12345678910111213@RunWith(SpringRunner.class)@SpringBootTest(classes = HttpDemoApplication.class)public class HttpDemoApplicationTests &#123; @Autowired private RestTemplate restTemplate; @Test public void httpGet() &#123; User user = this.restTemplate.getForObject("http://localhost:8080/user/19", User.class); System.out.println(user); &#125;&#125; 通过RestTemplate的getForObject()方法，传递url地址及实体类的字节码，RestTemplate会自动发起请求，接收响应，并且帮我们对响应结果进行反序列化。 学习完了Http客户端工具，接下来就可以正式学习微服务了。 4.初始SpringCloud微服务是一种架构方式，最终肯定需要技术架构去实施。 微服务的实现方式很多，但是最火的莫过于Spring Cloud了。为什么？ 后台硬：作为Spring家族的一员，有整个Spring全家桶靠山，背景十分强大。 技术强：Spring作为Java领域的前辈，可以说是功力深厚。有强力的技术团队支撑，一般人还真比不了 群众基础好：可以说大多数程序员的成长都伴随着Spring框架，试问：现在有几家公司开发不用Spring？SpringCloud与Spring的各个框架无缝整合，对大家来说一切都是熟悉的配方，熟悉的味道。 使用方便：相信大家都体会到了SpringBoot给我们开发带来的便利，而SpringCloud完全支持SpringBoot的开发，用很少的配置就能完成微服务框架的搭建 4.1.简介SpringCloud是Spring旗下的项目之一，官网地址：http://projects.spring.io/spring-cloud/ Spring最擅长的就是集成，把世界上最好的框架拿过来，集成到自己的项目中。 SpringCloud也是一样，它将现在非常流行的一些技术整合到一起，实现了诸如：配置管理，服务发现，智能路由，负载均衡，熔断器，控制总线，集群状态等等功能。其主要涉及的组件包括： netflix（一个公司） Eureka：注册中心 Zuul：服务网关 Ribbon：负载均衡 Feign：服务调用 Hystix：熔断器 以上只是其中一部分，架构图： 4.2.版本SpringCloud的版本命名比较特殊，因为它不是一个组件，而是许多组件的集合，它的命名是以A到Z的为首字母的一些单词组成： 我们在项目中，会是以Finchley的版本。 其中包含的组件，也都有各自的版本，如下表： Component Edgware.SR3 Finchley.RC1 Finchley.BUILD-SNAPSHOT spring-cloud-aws 1.2.2.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-cloud-bus 1.3.2.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-cloud-cli 1.4.1.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-cloud-commons 1.3.3.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-cloud-contract 1.2.4.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-cloud-config 1.4.3.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-cloud-netflix 1.4.4.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-cloud-security 1.2.2.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-cloud-cloudfoundry 1.1.1.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-cloud-consul 1.3.3.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-cloud-sleuth 1.3.3.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-cloud-stream Ditmars.SR3 Elmhurst.RELEASE Elmhurst.BUILD-SNAPSHOT spring-cloud-zookeeper 1.2.1.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-boot 1.5.10.RELEASE 2.0.1.RELEASE 2.0.0.BUILD-SNAPSHOT spring-cloud-task 1.2.2.RELEASE 2.0.0.RC1 2.0.0.RELEASE spring-cloud-vault 1.1.0.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-cloud-gateway 1.0.1.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-cloud-openfeign 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT 接下来，我们就一一学习SpringCloud中的重要组件。 5.微服务场景模拟首先，我们需要模拟一个服务调用的场景。方便后面学习微服务架构 5.1.服务提供者我们新建一个项目，对外提供查询用户的服务。 5.1.1.Spring脚手架创建工程借助于Spring提供的快速搭建工具： 创建项目：user-service 填写项目信息： 添加web依赖： 添加mybatis依赖： 填写项目位置： 生成的项目结构： 依赖也已经全部自动引入： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.demo&lt;/groupId&gt; &lt;artifactId&gt;user-service-demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;user-service-demo&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.1.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.0.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 12 非常快捷啊！ 5.1.2.编写代码添加一个对外查询的接口： 123456789101112@RestController@RequestMapping("user")public class UserController &#123; @Autowired private UserService userService; @GetMapping("/&#123;id&#125;") public User queryById(@PathVariable("id") Long id) &#123; return this.userService.queryById(id); &#125;&#125; Service： 12345678910@Servicepublic class UserService &#123; @Autowired private UserMapper userMapper; public User queryById(Long id) &#123; return this.userMapper.selectByPrimaryKey(id); &#125;&#125; mapper: 123@Mapperpublic interface UserMapper extends tk.mybatis.mapper.common.Mapper&lt;User&gt;&#123;&#125; 实体类： 123456789101112131415161718192021222324252627282930313233343536373839@Data@Table(name = "tb_user")public class User implements Serializable &#123; private static final long serialVersionUID = 1L; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; // 用户名 private String username; // 密码 private String password; // 姓名 private String name; // 年龄 private Integer age; // 性别，1男性，2女性 private Integer sex; // 出生日期 private Date birthday; // 创建时间 private Date created; // 更新时间 private Date updated; // 备注 private String note; // 。。。省略getters和setters&#125; 属性文件,这里我们采用了yaml语法，而不是properties： 12345678910server: port: 8081mybatis: type-aliases-package: com.itcast.cn.userservice.pojospring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/leyou-test?serverTimezone=Asia/Shanghai&amp;characterEncoding=utf8 username: root password: cxg200888 5.1.3.启动并测试：启动项目，访问接口：http://localhost:8081/user/7 5.2.服务调用者5.2.1.创建工程工程：consumer-demo 与上面类似，这里不再赘述，需要注意的是，我们调用user-service的功能，因此不需要mybatis相关依赖了。 pom： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.demo&lt;/groupId&gt; &lt;artifactId&gt;user-consumer-demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;user-consumer-demo&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.1.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 添加OkHttp支持 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.squareup.okhttp3&lt;/groupId&gt; &lt;artifactId&gt;okhttp&lt;/artifactId&gt; &lt;version&gt;3.9.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 5.2.2.编写代码首先在启动类中注册RestTemplate： 12345678910111213@SpringBootApplicationpublic class UserConsumerDemoApplication &#123; @Bean public RestTemplate restTemplate() &#123; // 这次我们使用了OkHttp客户端,只需要注入工厂即可 return new RestTemplate(new OkHttp3ClientHttpRequestFactory()); &#125; public static void main(String[] args) &#123; SpringApplication.run(UserConsumerDemoApplication.class, args); &#125;&#125; 然后编写UserDao，注意，这里不是调用mapper查数据库，而是通过RestTemplate远程查询user-service-demo中的接口： 1234567891011@Componentpublic class UserDao &#123; @Autowired private RestTemplate restTemplate; public User queryUserById(Long id)&#123; String url = "http://localhost:8081/user/" + id; return this.restTemplate.getForObject(url, User.class); &#125;&#125; 然后编写consumer-demo，循环查询UserDAO信息： 123456789101112131415@Servicepublic class UserService &#123; @Autowired private UserDao userDao; public List&lt;User&gt; querUserByIds(List&lt;Long&gt; ids)&#123; List&lt;User&gt; users = new ArrayList&lt;&gt;(); for (Long id : ids) &#123; User user = this.userDao.queryUserById(id); users.add(user); &#125; return users; &#125;&#125; 编写controller： 123456789101112@RestController@RequestMapping("consume")public class ConsumerController &#123; @Autowired private UserService userService; @GetMapping public List&lt;User&gt; consume(@RequestParam("ids") List&lt;Long&gt; ids) &#123; return this.userService.queryUserByIds(ids); &#125;&#125; 5.2.3.启动测试：因为我们没有配置端口，那么默认就是8080，我们访问：http://localhost:8080/hello/list?ids=16,17,18 一个简单的远程服务调用案例就实现了。 5.3.有没有问题？简单回顾一下，刚才我们写了什么： use-service：一个提供根据id查询用户的微服务 consumer-demo：一个服务调用者，通过RestTemplate远程调用user-service-demo 流程如下： 存在什么问题？ 在consumer中，我们把url地址硬编码到了代码中，不方便后期维护 consumer需要记忆user-service的地址，如果出现变更，可能得不到通知，地址将失效 consumer不清楚user-service的状态，服务宕机也不知道 user-service只有1台服务，不具备高可用性 即便user-service形成集群，consumer还需自己实现负载均衡 其实上面说的问题，概括一下就是分布式服务必然要面临的问题： 服务管理 如何自动注册和发现 如何实现状态监管 如何实现动态路由 服务如何实现负载均衡 服务如何解决容灾问题 服务如何实现统一配置 以上的问题，我们都将在SpringCloud中得到答案。 6.Eureka注册中心6.1.认识Eureka首先我们来解决第一问题，服务的管理。 问题分析 在刚才的案例中，user-service对外提供服务，需要对外暴露自己的地址。而consumer（调用者）需要记录服务提供者的地址。将来地址出现变更，还需要及时更新。这在服务较少的时候并不觉得有什么，但是在现在日益复杂的互联网环境，一个项目肯定会拆分出十几，甚至数十个微服务。此时如果还人为管理地址，不仅开发困难，将来测试、发布上线都会非常麻烦，这与DevOps的思想是背道而驰的。 网约车 这就好比是 网约车出现以前，人们出门叫车只能叫出租车。一些私家车想做出租却没有资格，被称为黑车。而很多人想要约车，但是无奈出租车太少，不方便。私家车很多却不敢拦，而且满大街的车，谁知道哪个才是愿意载人的。一个想要，一个愿意给，就是缺少引子，缺乏管理啊。 此时滴滴这样的网约车平台出现了，所有想载客的私家车全部到滴滴注册，记录你的车型（服务类型），身份信息（联系方式）。这样提供服务的私家车，在滴滴那里都能找到，一目了然。 此时要叫车的人，只需要打开APP，输入你的目的地，选择车型（服务类型），滴滴自动安排一个符合需求的车到你面前，为你服务，完美！ Eureka做什么？ Eureka就好比是滴滴，负责管理、记录服务提供者的信息。服务调用者无需自己寻找服务，而是把自己的需求告诉Eureka，然后Eureka会把符合你需求的服务告诉你。 同时，服务提供方与Eureka之间通过“心跳”机制进行监控，当某个服务提供方出现问题，Eureka自然会把它从服务列表中剔除。 这就实现了服务的自动注册、发现、状态监控。 6.2.原理图 基本架构： Eureka：就是服务注册中心（可以是一个集群），对外暴露自己的地址 提供者：启动后向Eureka注册自己信息（地址，提供什么服务） 消费者：向Eureka订阅服务，Eureka会将对应服务的所有提供者地址列表发送给消费者，并且定期更新 心跳(续约)：提供者定期通过http方式向Eureka刷新自己的状态 6.3.入门案例6.3.1.编写注册中心EurekaServer接下来我们创建一个项目，启动一个EurekaServer： 依然使用spring提供的快速搭建工具： 选择依赖： 完整的Pom文件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.demo&lt;/groupId&gt; &lt;artifactId&gt;eureka-demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;eureka-demo&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.1.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;!-- SpringCloud版本，是最新的F系列 --&gt; &lt;spring-cloud.version&gt;Finchley.RC1&lt;/spring-cloud.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- Eureka服务端 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- SpringCloud依赖，一定要放到dependencyManagement中，起到管理版本的作用即可 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;spring-milestones&lt;/id&gt; &lt;name&gt;Spring Milestones&lt;/name&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt;&lt;/project&gt; 编写启动类： 12345678@SpringBootApplication@EnableEurekaServer // 声明这个应用是一个EurekaServerpublic class EurekaDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaDemoApplication.class, args); &#125;&#125; 编写配置： 1234567891011server: port: 10086 # 端口spring: application: name: eureka-server # 应用名称，会在Eureka中显示eureka: client: register-with-eureka: false # 是否注册自己的信息到EurekaServer，默认是true fetch-registry: false # 是否拉取其它服务的信息，默认是true service-url: # EurekaServer的地址，现在是自己的地址，如果是集群，需要加上其它Server的地址。 defaultZone: http://127.0.0.1:$&#123;server.port&#125;/eureka 启动服务，并访问：http://127.0.0.1:10086/eureka 6.3.2.将服务提供者（user-service）注册到Eureka注册服务，就是在服务上添加Eureka的客户端依赖，客户端代码会自动把服务注册到EurekaServer中。 我们在user-service中添加Eureka客户端依赖： 先添加SpringCloud依赖： 1234567891011121314151617181920212223&lt;!-- SpringCloud的依赖 --&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Finchley.RC1&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt;&lt;!-- Spring的仓库地址 --&gt;&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;spring-milestones&lt;/id&gt; &lt;name&gt;Spring Milestones&lt;/name&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt;&lt;/repositories&gt; 然后是Eureka客户端： 12345&lt;!-- Eureka客户端 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt; 在启动类上开启Eureka客户端功能 通过添加@EnableDiscoveryClient来开启Eureka客户端功能 1234567@SpringBootApplication@EnableDiscoveryClient // 开启EurekaClient功能public class UserServiceDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(UserServiceDemoApplication.class, args); &#125;&#125; 编写配置 12345678910111213141516171819202122server: port: 8081spring: datasource: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://localhost:3306/leyou-test?serverTimezone=Asia/Shanghai&amp;characterEncoding=utf8 username: root password: cxg200888 hikari: maximum-pool-size: 20 minimum-idle: 10 application: name: user-service # 应用名称mybatis: type-aliases-package: com.itcast.cn.userservice.pojoeureka: client: service-url: # EurekaServer地址 defaultZone: http://127.0.0.1:10086/eureka instance: prefer-ip-address: true # 当调用getHostname获取实例的hostname时，返回ip而不是host名称 ip-address: 127.0.0.1 # 指定自己的ip信息，不指定的话会自己寻找 注意： 这里我们添加了spring.application.name属性来指定应用名称，将来会作为应用的id使用。 不用指定register-with-eureka和fetch-registry，因为默认是true 重启项目，访问Eureka监控页面查看 我们发现user-service服务已经注册成功了 6.3.3.消费者（consumer-demo）从Eureka获取服务接下来我们修改consumer-demo，尝试从EurekaServer获取服务。 方法与消费者类似，只需要在项目中添加EurekaClient依赖，就可以通过服务名称来获取信息了！ 1）添加依赖： 先添加SpringCloud依赖： 1234567891011121314151617181920212223&lt;!-- SpringCloud的依赖 --&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Finchley.RC1&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt;&lt;!-- Spring的仓库地址 --&gt;&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;spring-milestones&lt;/id&gt; &lt;name&gt;Spring Milestones&lt;/name&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt;&lt;/repositories&gt; 然后是Eureka客户端： 12345&lt;!-- Eureka客户端 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt; 2）在启动类开启Eureka客户端 1234567891011@SpringBootApplication@EnableDiscoveryClient // 开启Eureka客户端public class UserConsumerDemoApplication &#123; @Bean public RestTemplate restTemplate() &#123; return new RestTemplate(new OkHttp3ClientHttpRequestFactory()); &#125; public static void main(String[] args) &#123; SpringApplication.run(UserConsumerDemoApplication.class, args); &#125;&#125; 3）修改配置： 123456789101112server: port: 8080spring: application: name: consumer # 应用名称eureka: client: service-url: # EurekaServer地址 defaultZone: http://127.0.0.1:10086/eureka instance: prefer-ip-address: true # 当其它服务获取地址时提供ip而不是hostname ip-address: 127.0.0.1 # 指定自己的ip信息，不指定的话会自己寻找 4）修改代码，用DiscoveryClient类的方法，根据服务名称，获取服务实例： 12345678910111213141516171819202122232425262728293031@Servicepublic class UserService &#123; @Autowired private RestTemplate restTemplate; @Autowired private DiscoveryClient discoveryClient;// Eureka客户端，可以获取到服务实例信息 public List&lt;User&gt; queryUserByIds(List&lt;Long&gt; ids) &#123; List&lt;User&gt; users = new ArrayList&lt;&gt;(); // String baseUrl = "http://localhost:8081/user/"; // 根据服务名称，获取服务实例 List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances("user-service"); // 因为只有一个UserService,因此我们直接get(0)获取 ServiceInstance instance = instances.get(0); // 获取ip和端口信息 String baseUrl = "http://"+instance.getHost() + ":" + instance.getPort()+"/user/"; ids.forEach(id -&gt; &#123; // 我们测试多次查询， users.add(this.restTemplate.getForObject(baseUrl + id, User.class)); // 每次间隔500毫秒 try &#123; Thread.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;); return users; &#125;&#125; 5）Debug跟踪运行： 生成的URL： 访问结果： 6.4.Eureka详解接下来我们详细讲解Eureka的原理及配置。 6.4.1.基础架构Eureka架构中的三个核心角色： 服务注册中心 Eureka的服务端应用，提供服务注册和发现功能，就是刚刚我们建立的eureka-demo 服务提供者 提供服务的应用，可以是SpringBoot应用，也可以是其它任意技术实现，只要对外提供的是Rest风格服务即可。本例中就是我们实现的user-service-demo 服务消费者 消费应用从注册中心获取服务列表，从而得知每个服务方的信息，知道去哪里调用服务方。本例中就是我们实现的consumer-demo 6.4.2.高可用的Eureka ServerEureka Server即服务的注册中心，在刚才的案例中，我们只有一个EurekaServer，事实上EurekaServer也可以是一个集群，形成高可用的Eureka中心。 服务同步 多个Eureka Server之间也会互相注册为服务，当服务提供者注册到Eureka Server集群中的某个节点时，该节点会把服务的信息同步给集群中的每个节点，从而实现数据同步。因此，无论客户端访问到Eureka Server集群中的任意一个节点，都可以获取到完整的服务列表信息。 动手搭建高可用的EurekaServer 我们假设要搭建两条EurekaServer的集群，端口分别为：10086和10087 1）我们修改原来的EurekaServer配置： 123456789server: port: 10086 # 端口spring: application: name: eureka-server # 应用名称，会在Eureka中显示eureka: client: service-url: # 配置其他Eureka服务的地址，而不是自己，比如10087 defaultZone: http://127.0.0.1:10087/eureka 所谓的高可用注册中心，其实就是把EurekaServer自己也作为一个服务进行注册，这样多个EurekaServer之间就能互相发现对方，从而形成集群。因此我们做了以下修改： 删除了register-with-eureka=false和fetch-registry=false两个配置。因为默认值是true，这样就会吧自己注册到注册中心了。 把service-url的值改成了另外一台EurekaServer的地址，而不是自己 2）另外一台配置恰好相反： 123456789server: port: 10087 # 端口spring: application: name: eureka-server # 应用名称，会在Eureka中显示eureka: client: service-url: # 配置其他Eureka服务的地址，而不是自己，比如10087 defaultZone: http://127.0.0.1:10086/eureka 注意：idea中一个应用不能启动两次，我们需要重新配置一个启动器： 然后启动即可。 3）启动测试： 4）客户端注册服务到集群 因为EurekaServer不止一个，因此注册服务的时候，service-url参数需要变化： 1234eureka: client: service-url: # EurekaServer地址,多个地址以','隔开 defaultZone: http://127.0.0.1:10086/eureka, 6.4.3.服务提供者服务提供者要向EurekaServer注册服务，并且完成服务续约等工作。 服务注册 服务提供者在启动时，会检测配置属性中的：eureka.client.register-with-erueka=true参数是否正确，事实上默认就是true。如果值确实为true，则会向EurekaServer发起一个Rest请求，并携带自己的元数据信息，Eureka Server会把这些信息保存到一个双层Map结构中。第一层Map的Key就是服务名称，第二层Map的key是服务的实例id。 服务续约 在注册服务完成以后，服务提供者会维持一个心跳（定时向EurekaServer发起Rest请求），告诉EurekaServer：“我还活着”。这个我们称为服务的续约（renew）； 有两个重要参数可以修改服务续约的行为： 1234eureka: instance: lease-expiration-duration-in-seconds: 90 lease-renewal-interval-in-seconds: 30 lease-renewal-interval-in-seconds：服务续约(renew)的间隔，默认为30秒 lease-expiration-duration-in-seconds：服务失效时间，默认值90秒 也就是说，默认情况下每个30秒服务会向注册中心发送一次心跳，证明自己还活着。如果超过90秒没有发送心跳，EurekaServer就会认为该服务宕机，会从服务列表中移除，这两个值在生产环境不要修改，默认即可。 但是在开发时，这个值有点太长了，经常我们关掉一个服务，会发现Eureka依然认为服务在活着。所以我们在开发阶段可以适当调小。 1234eureka: instance: lease-expiration-duration-in-seconds: 10 # 10秒即过期 lease-renewal-interval-in-seconds: 5 # 5秒一次心跳 实例id 先来看一下服务状态信息： 在Eureka监控页面，查看服务注册信息： 在status一列中，显示以下信息： UP(1)：代表现在是启动了1个示例，没有集群 DESKTOP-2MVEC12:user-service:8081：是示例的名称（instance-id）， 默认格式是：${hostname} + ${spring.application.name} + ${server.port} instance-id是区分同一服务的不同实例的唯一标准，因此不能重复。 我们可以通过instance-id属性来修改它的构成： 123eureka: instance: instance-id: $&#123;spring.application.name&#125;:$&#123;server.port&#125; 重启服务再试试看： 6.4.4.服务消费者 获取服务列表 当服务消费者启动是，会检测eureka.client.fetch-registry=true参数的值，如果为true，则会从Eureka Server服务的列表只读备份，然后缓存在本地。并且每隔30秒会重新获取并更新数据。我们可以通过下面的参数来修改： 123eureka: client: registry-fetch-interval-seconds: 5 生产环境中，我们不需要修改这个值。 但是为了开发环境下，能够快速得到服务的最新状态，我们可以将其设置小一点。 6.4.5.失效剔除和自我保护修改eureka-demo配置文件 失效剔除 有些时候，我们的服务提供方并不一定会正常下线，可能因为内存溢出、网络故障等原因导致服务无法正常工作。Eureka Server需要将这样的服务剔除出服务列表。因此它会开启一个定时任务，每隔60秒对所有失效的服务（超过90秒未响应）进行剔除。 可以通过eureka.server.eviction-interval-timer-in-ms参数对其进行修改，单位是毫秒，生成环境不要修改。 这个会对我们开发带来极大的不变，你对服务重启，隔了60秒Eureka才反应过来。开发阶段可以适当调整，比如10S 自我保护 我们关停一个服务，就会在Eureka面板看到一条警告： 这是触发了Eureka的自我保护机制。当一个服务未按时进行心跳续约时，Eureka会统计最近15分钟心跳失败的服务实例的比例是否超过了85%。在生产环境下，因为网络延迟等原因，心跳失败实例的比例很有可能超标，但是此时就把服务剔除列表并不妥当，因为服务可能没有宕机。Eureka就会把当前实例的注册信息保护起来，不予剔除。生产环境下这很有效，保证了大多数服务依然可用。 但是这给我们的开发带来了麻烦， 因此开发阶段我们都会关闭自我保护模式： 1234eureka: server: enable-self-preservation: false # 关闭自我保护模式（缺省为打开） eviction-interval-timer-in-ms: 1000 # 扫描失效服务的间隔时间（缺省为60*1000ms） 7.负载均衡Ribbon在刚才的案例中，我们启动了一个user-service，然后通过DiscoveryClient来获取服务实例信息，然后获取ip和端口来访问。 但是实际环境中，我们往往会开启很多个user-service的集群。此时我们获取的服务列表中就会有多个，到底该访问哪一个呢？ 一般这种情况下我们就需要编写负载均衡算法，在多个实例列表中进行选择。 不过Eureka中已经帮我们集成了负载均衡组件：Ribbon，简单修改代码即可使用。 什么是Ribbon： 接下来，我们就来使用Ribbon实现负载均衡。 7.1.启动两个服务实例首先我们启动两个user-service实例，一个8081，一个8082。 Eureka监控面板： 7.2.开启负载均衡修改项目：consumer-demo 因为Eureka中已经集成了Ribbon，所以我们无需引入新的依赖。直接修改代码： 在RestTemplate的配置方法上添加@LoadBalanced注解： 12345@Bean@LoadBalancedpublic RestTemplate restTemplate() &#123; return new RestTemplate(new OkHttp3ClientHttpRequestFactory());&#125; 修改调用方式，不再手动获取ip和端口，而是直接通过服务名称调用： 1234567891011121314151617181920212223242526@Servicepublic class UserService &#123; @Autowired private RestTemplate restTemplate; @Autowired private DiscoveryClient discoveryClient; public List&lt;User&gt; queryUserByIds(List&lt;Long&gt; ids) &#123; List&lt;User&gt; users = new ArrayList&lt;&gt;(); // 地址直接写服务名称即可 String baseUrl = "http://user-service/user/"; ids.forEach(id -&gt; &#123; // 我们测试多次查询， users.add(this.restTemplate.getForObject(baseUrl + id, User.class)); // 每次间隔500毫秒 try &#123; Thread.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;); return users; &#125;&#125; 访问页面，查看结果： 完美！ 7.3.源码跟踪为什么我们只输入了service名称就可以访问了呢？之前还要获取ip和端口。 显然有人帮我们根据service名称，获取到了服务实例的ip和端口。它就是LoadBalancerInterceptor 我们进行源码跟踪： 继续跟入execute方法：发现获取了8082端口的服务 再跟下一次，发现获取的是8081： 7.4.负载均衡策略Ribbon默认的负载均衡策略是简单的轮询，我们可以测试一下： 编写测试类，在刚才的源码中我们看到拦截中是使用RibbonLoadBalanceClient来进行负载均衡的，其中有一个choose方法，是这样介绍的： 现在这个就是负载均衡获取实例的方法。 我们对注入这个类的对象，然后对其测试： 123456789101112131415@RunWith(SpringRunner.class)@SpringBootTest(classes = UserConsumerDemoApplication.class)public class LoadBalanceTest &#123; @Autowired RibbonLoadBalancerClient client; @Test public void test()&#123; for (int i = 0; i &lt; 100; i++) &#123; ServiceInstance instance = this.client.choose("user-service"); System.out.println(instance.getHost() + ":" + instance.getPort()); &#125; &#125;&#125; 结果： 符合了我们的预期推测，确实是轮询方式。 我们是否可以修改负载均衡的策略呢？ 继续跟踪源码，发现这么一段代码： 我们看看这个rule是谁： 这里的rule默认值是一个RoundRobinRule，看类的介绍： 这不就是轮询的意思嘛。 我们注意到，这个类其实是实现了接口IRule的，查看一下： 定义负载均衡的规则接口。 它有以下实现： SpringBoot也帮我们提供了修改负载均衡规则的配置入口： 在服务消费者中添加如下： 123user-service: ribbon: NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule 格式是：{服务名称}.ribbon.NFLoadBalancerRuleClassName，值就是IRule的实现类。 再次测试，发现结果变成了随机： 7.5.重试机制Eureka的服务治理强调了CAP原则中的AP，即可用性和可靠性。它与Zookeeper这一类强调CP（一致性，可靠性）的服务治理框架最大的区别在于：Eureka为了实现更高的服务可用性，牺牲了一定的一致性，极端情况下它宁愿接收故障实例也不愿丢掉健康实例，正如我们上面所说的自我保护机制。 但是，此时如果我们调用了这些不正常的服务，调用就会失败，从而导致其它服务不能正常工作！这显然不是我们愿意看到的。 我们现在关闭一个user-service实例： 因为服务剔除的延迟，consumer并不会立即得到最新的服务列表，此时再次访问你会得到错误提示： 但是此时，8081服务其实是正常的。 因此Spring Cloud 整合了Spring Retry 来增强RestTemplate的重试能力，当一次服务调用失败后，不会立即抛出一次，而是再次重试另一个服务。 只需要简单配置即可实现Ribbon的重试： 消费者的配置文件： 123456789101112spring: cloud: loadbalancer: retry: enabled: true # 开启Spring Cloud的重试功能user-service: ribbon: ConnectTimeout: 250 # Ribbon的连接超时时间 单位ms ReadTimeout: 1000 # Ribbon的数据读取超时时间 OkToRetryOnAllOperations: true # 是否对所有操作都进行重试 MaxAutoRetriesNextServer: 1 # 切换实例的重试次数 MaxAutoRetries: 1 # 对当前实例的重试次数 根据如上配置，当访问到某个服务超时后，它会再次尝试访问下一个服务实例，如果不行就再换一个实例，如果不行，则返回失败。切换次数取决于MaxAutoRetriesNextServer参数的值 引入spring-retry依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.retry&lt;/groupId&gt; &lt;artifactId&gt;spring-retry&lt;/artifactId&gt;&lt;/dependency&gt; 我们重启user-consumer-demo，测试，发现即使user-service2宕机，也能通过另一台服务实例获取到结果！]]></content>
      <categories>
        <category>项目实战-微服务商城</category>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
        <tag>Eureka</tag>
        <tag>Ribbon负载均衡</tag>
        <tag>系统架构演变</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务商城（一）——SpringBoot学习笔记]]></title>
    <url>%2Fday01-springboot.html</url>
    <content type="text"><![CDATA[0.学习目标 了解SpringBoot的作用 掌握java配置的方式 了解SpringBoot自动配置原理 掌握SpringBoot的基本使用 了解Thymeleaf的基本使用 1. 了解SpringBoot在这一部分，我们主要了解以下3个问题： 什么是SpringBoot 为什么要学习SpringBoot SpringBoot的特点 1.1.什么是SpringBootSpringBoot是Spring项目中的一个子工程，与我们所熟知的Spring-framework 同属于spring的产品: 我们可以看到下面的一段介绍： Takes an opinionated view of building production-ready Spring applications. Spring Boot favors convention over configuration and is designed to get you up and running as quickly as possible. 翻译一下： 用一些固定的方式来构建生产级别的spring应用。Spring Boot 推崇约定大于配置的方式以便于你能够尽可能快速的启动并运行程序。 其实人们把Spring Boot 称为搭建程序的脚手架。其最主要作用就是帮我们快速的构建庞大的spring项目，并且尽可能的减少一切xml配置，做到开箱即用，迅速上手，让我们关注与业务而非配置。 1.2.为什么要学习SpringBootjava一直被人诟病的一点就是臃肿、麻烦。当我们还在辛苦的搭建项目时，可能Python程序员已经把功能写好了，究其原因注意是两点： 复杂的配置， 项目各种配置其实是开发时的损耗， 因为在思考 Spring 特性配置和解决业务问题之间需要进行思维切换，所以写配置挤占了写应用程序逻辑的时间。 一个是混乱的依赖管理。 项目的依赖管理也是件吃力不讨好的事情。决定项目里要用哪些库就已经够让人头痛的了，你还要知道这些库的哪个版本和其他库不会有冲突，这难题实在太棘手。并且，依赖管理也是一种损耗，添加依赖不是写应用程序代码。一旦选错了依赖的版本，随之而来的不兼容问题毫无疑问会是生产力杀手。 而SpringBoot让这一切成为过去！ Spring Boot 简化了基于Spring的应用开发，只需要“run”就能创建一个独立的、生产级别的Spring应用。Spring Boot为Spring平台及第三方库提供开箱即用的设置（提供默认设置，存放默认配置的包就是启动器），这样我们就可以简单的开始。多数Spring Boot应用只需要很少的Spring配置。 我们可以使用SpringBoot创建java应用，并使用java –jar 启动它，就能得到一个生产级别的web工程。 1.3.SpringBoot的特点Spring Boot 主要目标是： 为所有 Spring 的开发者提供一个非常快速的、广泛接受的入门体验 开箱即用（启动器starter-其实就是SpringBoot提供的一个jar包），但通过自己设置参数（.properties），即可快速摆脱这种方式。 提供了一些大型项目中常见的非功能性特性，如内嵌服务器、安全、指标，健康检测、外部化配置等 绝对没有代码生成，也无需 XML 配置。 更多细节，大家可以到官网查看。 2.快速入门接下来，我们就来利用SpringBoot搭建一个web工程，体会一下SpringBoot的魅力所在！ 2.1.创建工程我们先新建一个空的工程： 工程名为demo： 新建一个model： 使用maven来构建： 然后填写项目坐标： 目录结构： 项目结构： 2.2.添加依赖看到这里很多同学会有疑惑，前面说传统开发的问题之一就是依赖管理混乱，怎么这里我们还需要管理依赖呢？难道SpringBoot不帮我们管理吗？ 别着急，现在我们的项目与SpringBoot还没有什么关联。SpringBoot提供了一个名为spring-boot-starter-parent的工程，里面已经对各种常用依赖（并非全部）的版本进行了管理，我们的项目需要以这个项目为父工程，这样我们就不用操心依赖的版本问题了，需要什么依赖，直接引入坐标即可！ 2.2.1.添加父工程坐标12345&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.0.RELEASE&lt;/version&gt;&lt;/parent&gt; 2.2.2.添加web启动器为了让SpringBoot帮我们完成各种自动配置，我们必须引入SpringBoot提供的自动配置依赖，我们称为启动器。因为我们是web项目，这里我们引入web启动器： 123456&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 需要注意的是，我们并没有在这里指定版本信息。因为SpringBoot的父工程已经对版本进行了管理了。 这个时候，我们会发现项目中多出了大量的依赖： 这些都是SpringBoot根据spring-boot-starter-web这个依赖自动引入的，而且所有的版本都已经管理好，不会出现冲突。 2.2.3.管理jdk版本默认情况下，maven工程的jdk版本是1.5，而我们开发使用的是1.8，因此这里我们需要修改jdk版本，只需要简单的添加以下属性即可： 123&lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt;&lt;/properties&gt; 2.2.4.完整pom123456789101112131415161718192021222324252627&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.demo&lt;/groupId&gt; &lt;artifactId&gt;springboot-demo&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.0.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 2.3.启动类Spring Boot项目通过main函数即可启动，我们需要创建一个启动类： 然后编写main函数： 123456@SpringBootApplicationpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125;&#125; 2.4.编写controller接下来，我们就可以像以前那样开发SpringMVC的项目了！ 我们编写一个controller： 代码： 12345678@RestControllerpublic class HelloController &#123; @GetMapping("hello") public String hello()&#123; return "hello, spring boot!"; &#125;&#125; 2.5.启动测试接下来，我们运行main函数，查看控制台： 并且可以看到监听的端口信息： 1）监听的端口是8080 2）SpringMVC的映射路径是：/ 3）/hello路径已经映射到了HelloController中的hello()方法 打开页面访问：http://localhost:8080/hello 测试成功了！ 3.Java配置在入门案例中，我们没有任何的配置，就可以实现一个SpringMVC的项目了，快速、高效！ 但是有同学会有疑问，如果没有任何的xml，那么我们如果要配置一个Bean该怎么办？比如我们要配置一个数据库连接池，以前会这么玩： 1234567&lt;!-- 配置连接池 --&gt;&lt;bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource" init-method="init" destroy-method="close"&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;" /&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;" /&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;" /&gt;&lt;/bean&gt; 现在该怎么做呢？ 3.1.回顾历史事实上，在Spring3.0开始，Spring官方就已经开始推荐使用java配置来代替传统的xml配置了，我们不妨来回顾一下Spring的历史： Spring1.0时代 在此时因为jdk1.5刚刚出来，注解开发并未盛行，因此一切Spring配置都是xml格式，想象一下所有的bean都用xml配置，细思极恐啊，心疼那个时候的程序员2秒 Spring2.0时代 Spring引入了注解开发，但是因为并不完善，因此并未完全替代xml，此时的程序员往往是把xml与注解进行结合，貌似我们之前都是这种方式。 Spring3.0及以后 3.0以后Spring的注解已经非常完善了，因此Spring推荐大家使用完全的java配置来代替以前的xml，不过似乎在国内并未推广盛行。然后当SpringBoot来临，人们才慢慢认识到java配置的优雅。 有句古话说的好：拥抱变化，拥抱未来。所以我们也应该顺应时代潮流，做时尚的弄潮儿，一起来学习下java配置的玩法。 3.2.尝试java配置java配置主要靠java类和一些注解，比较常用的注解有： @Configuration：声明一个类作为配置类，代替xml文件 @Bean：声明在方法上，将方法的返回值加入Bean容器，代替&lt;bean&gt;标签 @value：属性注入 @PropertySource：指定外部属性文件， 我们接下来用java配置来尝试实现连接池配置： 首先引入Druid连接池依赖： 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.6&lt;/version&gt;&lt;/dependency&gt; 创建一个jdbc.properties文件，编写jdbc属性： 1234jdbc.driverClassName=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://127.0.0.1:3306/leyoujdbc.username=rootjdbc.password=123 然后编写代码： 1234567891011121314151617181920212223@Configuration@PropertySource("classpath:jdbc.properties")public class JdbcConfig &#123; @Value("$&#123;jdbc.url&#125;") String url; @Value("$&#123;jdbc.driverClassName&#125;") String driverClassName; @Value("$&#123;jdbc.username&#125;") String username; @Value("$&#123;jdbc.password&#125;") String password; @Bean public DataSource dataSource() &#123; DruidDataSource dataSource = new DruidDataSource(); dataSource.setUrl(url); dataSource.setDriverClassName(driverClassName); dataSource.setUsername(username); dataSource.setPassword(password); return dataSource; &#125;&#125; 解读： @Configuration：声明我们JdbcConfig是一个配置类 @PropertySource：指定属性文件的路径是:classpath:jdbc.properties 通过@Value为属性注入值 通过@Bean将 dataSource()方法声明为一个注册Bean的方法，Spring会自动调用该方法，将方法的返回值加入Spring容器中。 然后我们就可以在任意位置通过@Autowired注入DataSource了！ 我们在HelloController中测试： 1234567891011@RestControllerpublic class HelloController &#123; @Autowired private DataSource dataSource; @GetMapping("hello") public String hello() &#123; return "hello, spring boot!" + dataSource; &#125;&#125; 然后Debug运行并查看： 属性注入成功了！ 3.3.SpringBoot的属性注入在上面的案例中，我们实验了java配置方式。不过属性注入使用的是@Value注解。这种方式虽然可行，但是不够强大，因为它只能注入基本类型值。 在SpringBoot中，提供了一种新的属性注入方式，支持各种java基本数据类型及复杂类型的注入。 1）我们新建一个类，用来进行属性注入： 123456789@ConfigurationProperties(prefix = "jdbc")public class JdbcProperties &#123; private String url; private String driverClassName; private String username; private String password; // ... 略 // getters 和 setters&#125; 在类上通过@ConfigurationProperties注解声明当前类为属性读取类 prefix=&quot;jdbc&quot;读取属性文件中，前缀为jdbc的值。 在类上定义各个属性，名称必须与属性文件中jdbc.后面部分一致 需要注意的是，这里我们并没有指定属性文件的地址，所以我们需要把jdbc.properties名称改为application.properties，这是SpringBoot默认读取的属性文件名： 2）在JdbcConfig中使用这个属性： 1234567891011121314@Configuration@EnableConfigurationProperties(JdbcProperties.class)public class JdbcConfig &#123; @Bean public DataSource dataSource(JdbcProperties jdbc) &#123; DruidDataSource dataSource = new DruidDataSource(); dataSource.setUrl(jdbc.getUrl()); dataSource.setDriverClassName(jdbc.getDriverClassName()); dataSource.setUsername(jdbc.getUsername()); dataSource.setPassword(jdbc.getPassword()); return dataSource; &#125;&#125; 通过@EnableConfigurationProperties(JdbcProperties.class)来声明要使用JdbcProperties这个类的对象 然后你可以通过以下方式注入JdbcProperties： @Autowired注入 12@Autowiredprivate JdbcProperties prop; 构造函数注入 1234private JdbcProperties prop;public JdbcConfig(Jdbcproperties prop)&#123; this.prop = prop;&#125; 声明有@Bean的方法参数注入 1234@Beanpublic Datasource dataSource(JdbcProperties prop)&#123; // ...&#125; 本例中，我们采用第三种方式。 3）测试结果： 大家会觉得这种方式似乎更麻烦了，事实上这种方式有更强大的功能，也是SpringBoot推荐的注入方式。两者对比关系： 优势： Relaxed binding：松散绑定 不严格要求属性文件中的属性名与成员变量名一致。支持驼峰，中划线，下划线等等转换，甚至支持对象引导。比如：user.friend.name：代表的是user对象中的friend属性中的name属性，显然friend也是对象。@value注解就难以完成这样的注入方式。 meta-data support：元数据支持，帮助IDE生成属性提示（写开源框架会用到）。 ​ 3.4、更优雅的注入事实上，如果一段属性只有一个Bean需要使用，我们无需将其注入到一个类（JdbcProperties）中。而是直接在需要的地方声明即可： 1234567891011@Configurationpublic class JdbcConfig &#123; @Bean // 声明要注入的属性前缀，SpringBoot会自动把相关属性通过set方法注入到DataSource中 @ConfigurationProperties(prefix = "jdbc") public DataSource dataSource() &#123; DruidDataSource dataSource = new DruidDataSource(); return dataSource; &#125;&#125; 我们直接把@ConfigurationProperties(prefix = &quot;jdbc&quot;)声明在需要使用的@Bean的方法上，然后SpringBoot就会自动调用这个Bean（此处是DataSource）的set方法，然后完成注入。使用的前提是：该类必须有对应属性的set方法！ 我们将jdbc的url改成：/heima，再次测试： 4.自动配置原理使用SpringBoot之后，一个整合了SpringMVC的WEB工程开发，变的无比简单，那些繁杂的配置都消失不见了，这是如何做到的？ 一切魔力的开始，都是从我们的main函数来的，所以我们再次来看下启动类： 我们发现特别的地方有两个： 注解：@SpringBootApplication run方法：SpringApplication.run() 我们分别来研究这两个部分。 4.1.了解@SpringBootApplication点击进入，查看源码： 这里重点的注解有3个： @SpringBootConfiguration @EnableAutoConfiguration @ComponentScan 4.1.1.@SpringBootConfiguration我们继续点击查看源码： 通过这段我们可以看出，在这个注解上面，又有一个@Configuration注解。通过上面的注释阅读我们知道：这个注解的作用就是声明当前类是一个配置类，然后Spring会自动扫描到添加了@Configuration的类，并且读取其中的配置信息。而@SpringBootConfiguration是来声明当前类是SpringBoot应用的配置类，项目中只能有一个。所以一般我们无需自己添加。 4.1.2.@EnableAutoConfiguration关于这个注解，官网上有一段说明： The second class-level annotation is @EnableAutoConfiguration. This annotationtells Spring Boot to “guess” how you want to configure Spring, based on the jardependencies that you have added. Since spring-boot-starter-web added Tomcatand Spring MVC, the auto-configuration assumes that you are developing a webapplication and sets up Spring accordingly. 简单翻译以下： 第二级的注解@EnableAutoConfiguration，告诉SpringBoot基于你所添加的依赖，去“猜测”你想要如何配置Spring。比如我们引入了spring-boot-starter-web，而这个启动器中帮我们添加了tomcat、SpringMVC的依赖。此时自动配置就知道你是要开发一个web应用，所以就帮你完成了web及SpringMVC的默认配置了！ 总结，SpringBoot内部对大量的第三方库或Spring内部库进行了默认配置，这些配置是否生效，取决于我们是否引入了对应库所需的依赖，如果有那么默认配置就会生效。 所以，我们使用SpringBoot构建一个项目，只需要引入所需框架的依赖，配置就可以交给SpringBoot处理了。除非你不希望使用SpringBoot的默认配置，它也提供了自定义配置的入口。 4.1.3.@ComponentScan我们跟进源码： 并没有看到什么特殊的地方。我们查看注释： 大概的意思： 配置组件扫描的指令。提供了类似与&lt;context:component-scan&gt;标签的作用 通过basePackageClasses或者basePackages属性来指定要扫描的包。如果没有指定这些属性，那么将从声明这个注解的类所在的包开始，扫描包及子包 而我们的@SpringBootApplication注解声明的类就是main函数所在的启动类，因此扫描的包是该类所在包及其子包。因此，一般启动类会放在一个比较前的包目录中。 4.2.默认配置原理4.2.1默认配置类通过刚才的学习，我们知道@EnableAutoConfiguration会开启SpringBoot的自动配置，并且根据你引入的依赖来生效对应的默认配置。那么问题来了： 这些默认配置是在哪里定义的呢？ 为何依赖引入就会触发配置呢？ 其实在我们的项目中，已经引入了一个依赖：spring-boot-autoconfigure，其中定义了大量自动配置类： 还有： 非常多，几乎涵盖了现在主流的开源框架，例如： redis jms amqp jdbc jackson mongodb jpa solr elasticsearch … 等等 我们来看一个我们熟悉的，例如SpringMVC，查看mvc 的自动配置类： 打开WebMvcAutoConfiguration： 我们看到这个类上的4个注解： @Configuration：声明这个类是一个配置类 @ConditionalOnWebApplication(type = Type.SERVLET) ConditionalOn，翻译就是在某个条件下，此处就是满足项目的类是是Type.SERVLET类型，也就是一个普通web工程，显然我们就是 @ConditionalOnClass({ Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class }) 这里的条件是OnClass，也就是满足以下类存在：Servlet、DispatcherServlet、WebMvcConfigurer，其中Servlet只要引入了tomcat依赖自然会有，后两个需要引入SpringMVC才会有。这里就是判断你是否引入了相关依赖，引入依赖后该条件成立，当前类的配置才会生效！ @ConditionalOnMissingBean(WebMvcConfigurationSupport.class) 这个条件与上面不同，OnMissingBean，是说环境中没有指定的Bean这个才生效。其实这就是自定义配置的入口，也就是说，如果我们自己配置了一个WebMVCConfigurationSupport的类，那么这个默认配置就会失效！ 接着，我们查看该类中定义了什么： 视图解析器： 处理器适配器（HandlerAdapter）： 还有很多，这里就不一一截图了。 4.2.2.默认配置属性另外，这些默认配置的属性来自哪里呢？ 我们看到，这里通过@EnableAutoConfiguration注解引入了两个属性：WebMvcProperties和ResourceProperties。这不正是SpringBoot的属性注入玩法嘛。 我们查看这两个属性类： 找到了内部资源视图解析器的prefix和suffix属性。 ResourceProperties中主要定义了静态资源（.js,.html,.css等)的路径： 如果我们要覆盖这些默认属性，只需要在application.properties中定义与其前缀prefix和字段名一致的属性即可。 4.3.总结SpringBoot为我们提供了默认配置，而默认配置生效的条件一般有两个： 你引入了相关依赖 你自己没有配置 1）启动器 所以，我们如果不想配置，只需要引入依赖即可，而依赖版本我们也不用操心，因为只要引入了SpringBoot提供的stater（启动器），就会自动管理依赖及版本了。 因此，玩SpringBoot的第一件事情，就是找启动器，SpringBoot提供了大量的默认启动器，参考课前资料中提供的《SpringBoot启动器.txt》 2）全局配置 另外，SpringBoot的默认配置，都会读取默认属性，而这些属性可以通过自定义application.properties文件来进行覆盖。这样虽然使用的还是默认配置，但是配置中的值改成了我们自定义的。 因此，玩SpringBoot的第二件事情，就是通过application.properties来覆盖默认属性值，形成自定义配置。我们需要知道SpringBoot的默认属性key，非常多，参考课前资料提供的：《SpringBoot全局属性.md》 属性配置文件通过application.properties和application.yml 12345678spring: datasource:# 数据源基本配置 username: root password: 123456 driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://192.168.1.103:3306/jdbc type: com.alibaba.druid.pool.DruidDataSource 5.SpringBoot实践接下来，我们来看看如何用SpringBoot来玩转以前的SSM,我们沿用之前讲解SSM用到的数据库tb_user和实体类User 安装插件lombok 要使用lombok必须每个工程都导入架包 123456&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.4&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; lombok使代码更简洁 @Data：在pojo中使用可以省略get和set方法 @Log(这是一个泛型注解，具体有很多种形式) @Slf4j：提供日志注解 5.1.整合SpringMVC虽然默认配置已经可以使用SpringMVC了，不过我们有时候需要进行自定义配置。 日志级别控制 123456logging: level: # org.springframework:spring本身 org.springframework: debug # 我们的包:com.cxg.demo com.cxg.demo: debug 5.1.1.修改端口查看SpringBoot的全局属性可知，端口通过以下方式配置： 12# 映射端口server.port=80 重启服务后测试： 5.1.2.访问静态资源现在，我们的项目是一个jar工程，那么就没有webapp，我们的静态资源该放哪里呢？ 回顾我们上面看的源码，有一个叫做ResourceProperties的类，里面就定义了静态资源的默认查找路径： 默认的静态资源路径为： classpath:/META-INF/resources/ classpath:/resources/ classpath:/static/ classpath:/public 只要静态资源放在这些目录中任何一个，SpringMVC都会帮我们处理。 我们习惯会把静态资源放在classpath:/static/目录下。我们创建目录，并且添加一些静态资源： 重启项目后测试： 5.1.3.添加拦截器拦截器也是我们经常需要使用的，在SpringBoot中该如何配置呢？ 拦截器不是一个普通属性，而是一个类，所以就要用到java配置方式了。在SpringBoot官方文档中有这么一段说明： If you want to keep Spring Boot MVC features and you want to add additional MVC configuration (interceptors, formatters, view controllers, and other features), you can add your own @Configuration class of type WebMvcConfigurer but without @EnableWebMvc. If you wish to provide custom instances of RequestMappingHandlerMapping, RequestMappingHandlerAdapter, or ExceptionHandlerExceptionResolver, you can declare a WebMvcRegistrationsAdapter instance to provide such components. If you want to take complete control of Spring MVC, you can add your own @Configuration annotated with @EnableWebMvc. 翻译： 如果你想要保持Spring Boot 的一些默认MVC特征，同时又想自定义一些MVC配置（包括：拦截器，格式化器, 视图控制器、消息转换器 等等），你应该让一个类实现WebMvcConfigurer，并且添加@Configuration注解，但是千万不要加@EnableWebMvc注解。如果你想要自定义HandlerMapping、HandlerAdapter、ExceptionResolver等组件，你可以创建一个WebMvcRegistrationsAdapter实例 来提供以上组件。 如果你想要完全自定义SpringMVC，不保留SpringBoot提供的一切特征，你可以自己定义类并且添加@Configuration注解和@EnableWebMvc注解 总结：通过实现WebMvcConfigurer并添加@Configuration注解来实现自定义部分SpringMvc配置。 首先我们定义一个拦截器： 12345678910111213141516171819public class LoginInterceptor implements HandlerInterceptor &#123; private Logger logger = LoggerFactory.getLogger(LoginInterceptor.class); @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) &#123; logger.debug("preHandle method is now running!"); return true; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) &#123; logger.debug("postHandle method is now running!"); &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) &#123; logger.debug("afterCompletion method is now running!"); &#125;&#125; 然后，我们定义配置类，注册拦截器： 123456789101112131415161718192021@Configurationpublic class MvcConfig implements WebMvcConfigurer&#123; /** * 通过@Bean注解，将我们定义的拦截器注册到Spring容器 * @return */ @Bean public LoginInterceptor loginInterceptor()&#123; return new LoginInterceptor(); &#125; /** * 重写接口中的addInterceptors方法，添加自定义拦截器 * @param registry */ @Override public void addInterceptors(InterceptorRegistry registry) &#123; // 通过registry来注册拦截器，通过addPathPatterns来添加拦截路径 registry.addInterceptor(this.loginInterceptor()).addPathPatterns("/**"); &#125;&#125; 结构如下： 接下来运行并查看日志： 你会发现日志中什么都没有，因为我们记录的log级别是debug，默认是显示info以上，我们需要进行配置。 SpringBoot通过logging.level.*=debug来配置日志级别，*填写包名 12# 设置com.leyou包的日志级别为debuglogging.level.com.leyou=debug 再次运行查看： 1232018-05-05 17:50:01.811 DEBUG 4548 --- [p-nio-80-exec-1] com.leyou.interceptor.LoginInterceptor : preHandle method is now running!2018-05-05 17:50:01.854 DEBUG 4548 --- [p-nio-80-exec-1] com.leyou.interceptor.LoginInterceptor : postHandle method is now running!2018-05-05 17:50:01.854 DEBUG 4548 --- [p-nio-80-exec-1] com.leyou.interceptor.LoginInterceptor : afterCompletion method is now running! 5.2.整合jdbc和事务spring中的jdbc连接和事务是配置中的重要一环，在SpringBoot中该如何处理呢？ 答案是不需要处理，我们只要找到SpringBoot提供的启动器即可： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt; 当然，不要忘了数据库驱动，SpringBoot并不知道我们用的什么数据库，这里我们选择MySQL： 1234&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt; 至于事务，SpringBoot中通过注解来控制。就是我们熟知的@Transactional 123456789101112131415@Servicepublic class UserService &#123; @Autowired private UserMapper userMapper; public User queryById(Long id)&#123; return this.userMapper.selectByPrimaryKey(id); &#125; @Transactional public void deleteById(Long id)&#123; this.userMapper.deleteByPrimaryKey(id); &#125;&#125; 5.3.整合连接池其实，在刚才引入jdbc启动器的时候，SpringBoot已经自动帮我们引入了一个连接池： HikariCP应该是目前速度最快的连接池了，我们看看它与c3p0的对比： 因此，我们只需要指定连接池参数即可： 12345678910# 连接四大参数spring.datasource.url=jdbc:mysql://localhost:3306/heimaspring.datasource.username=rootspring.datasource.password=123# 可省略，SpringBoot自动推断spring.datasource.driverClassName=com.mysql.jdbc.Driverspring.datasource.hikari.idle-timeout=60000spring.datasource.hikari.maximum-pool-size=30spring.datasource.hikari.minimum-idle=10 当然，如果你更喜欢Druid连接池，也可以使用Druid官方提供的启动器： 123456&lt;!-- Druid连接池 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.6&lt;/version&gt;&lt;/dependency&gt; 而连接信息的配置与上面是类似的，只不过在连接池特有属性上，方式略有不同： 12345678910#初始化连接数spring.datasource.druid.initial-size=1#最小空闲连接spring.datasource.druid.min-idle=1#最大活动连接spring.datasource.druid.max-active=20#获取连接时测试是否可用spring.datasource.druid.test-on-borrow=true#监控页面启动spring.datasource.druid.stat-view-servlet.allow=true 5.4.整合mybatis5.4.1.mybatisSpringBoot官方并没有提供Mybatis的启动器，不过Mybatis官网自己实现了： 123456&lt;!--mybatis --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt; 配置，基本没有需要配置的： 1234# mybatis 别名扫描mybatis.type-aliases-package=com.heima.pojo# mapper.xml文件位置,如果没有映射文件，请注释掉mybatis.mapper-locations=classpath:mappers/*.xml 需要注意，这里没有配置mapper接口扫描包，因此我们需要给每一个Mapper接口添加@Mapper注解，才能被识别。 123@Mapperpublic interface UserMapper &#123;&#125; 5.4.2.通用mapper通用Mapper的作者也为自己的插件编写了启动器，我们直接引入即可： 123456&lt;!-- 通用mapper --&gt;&lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.0.2&lt;/version&gt;&lt;/dependency&gt; 注意：一旦引入通用Mapper的启动器，会覆盖Mybatis官方启动器功能，因此需要移除对官方mybatis启动器依赖 不需要做任何配置就可以使用了。 无需任何配置就可以使用，如果有需要，可以看官方文档：https://github.com/abel533/Mapper/wiki/1.integration 我们要把启动类上的@MapperScan注解修改为通用mapper自带的 123@Mapperpublic interface UserMapper extends tk.mybatis.mapper.common.Mapper&lt;User&gt;&#123;&#125; 5.5.启动测试将controller进行简单改造： 123456789101112@RestControllerpublic class HelloController &#123; @Autowired private UserService userService; @GetMapping("/hello") public User hello() &#123; User user = this.userService.queryById(8L); return user; &#125;&#125; 我们启动项目，查看： 6.Thymeleaf快速入门SpringBoot并不推荐使用jsp，但是支持一些模板引擎技术： 以前大家用的比较多的是Freemarker，但是我们今天的主角是Thymeleaf！ 6.1.为什么是Thymeleaf？简单说， Thymeleaf 是一个跟 Velocity、FreeMarker 类似的模板引擎，它可以完全替代 JSP 。相较与其他的模板引擎，它有如下三个极吸引人的特点： 动静结合：Thymeleaf 在有网络和无网络的环境下皆可运行，即它可以让美工在浏览器查看页面的静态效果，也可以让程序员在服务器查看带数据的动态页面效果。这是由于它支持 html 原型，然后在 html 标签里增加额外的属性来达到模板+数据的展示方式。浏览器解释 html 时会忽略未定义的标签属性，所以 thymeleaf 的模板可以静态地运行；当有数据返回到页面时，Thymeleaf 标签会动态地替换掉静态内容，使页面动态显示。 开箱即用：它提供标准和spring标准两种方言，可以直接套用模板实现JSTL、 OGNL表达式效果，避免每天套模板、该jstl、改标签的困扰。同时开发人员也可以扩展和创建自定义的方言。 多方言支持：Thymeleaf 提供spring标准方言和一个与 SpringMVC 完美集成的可选模块，可以快速的实现表单绑定、属性编辑器、国际化等功能。 与SpringBoot完美整合，SpringBoot提供了Thymeleaf的默认配置，并且为Thymeleaf设置了视图解析器，我们可以像以前操作jsp一样来操作Thymeleaf。代码几乎没有任何区别，就是在模板语法上有区别。 接下来，我们就通过入门案例来体会Thymeleaf的魅力： 6.2.编写接口编写一个controller，返回一些用户数据，放入模型中，等会在页面渲染 123456789@GetMapping("/all")public String all(ModelMap model) &#123; // 查询用户 List&lt;User&gt; users = this.userService.queryAll(); // 放入模型 model.addAttribute("users", users); // 返回模板名称（就是classpath:/templates/目录下的html文件名） return "users";&#125; 6.3.引入启动器直接引入启动器： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; SpringBoot会自动为Thymeleaf注册一个视图解析器： 与解析JSP的InternalViewResolver类似，Thymeleaf也会根据前缀和后缀来确定模板文件的位置： 默认前缀：classpath:/templates/ 默认后缀：.html 所以如果我们返回视图：users，会指向到 classpath:/templates/users.html 一般我们无需进行修改，默认即可。 6.4.静态页面根据上面的文档介绍，模板默认放在classpath下的templates文件夹，我们新建一个html文件放入其中： 编写html模板，渲染模型中的数据： 注意，把html 的名称空间，改成：xmlns:th=&quot;http://www.thymeleaf.org&quot; 会有语法提示 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html xmlns:th="http://www.thymeleaf.org"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;首页&lt;/title&gt; &lt;style type="text/css"&gt; table &#123;border-collapse: collapse; font-size: 14px; width: 80%; margin: auto&#125; table, th, td &#123;border: 1px solid darkslategray;padding: 10px&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div style="text-align: center"&gt; &lt;span style="color: darkslategray; font-size: 30px"&gt;欢迎光临！&lt;/span&gt; &lt;hr/&gt; &lt;table class="list"&gt; &lt;tr&gt; &lt;th&gt;id&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;用户名&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;th&gt;生日&lt;/th&gt; &lt;th&gt;备注&lt;/th&gt; &lt;/tr&gt; &lt;tr th:each="user : $&#123;users&#125;"&gt; &lt;td th:text="$&#123;user.id&#125;"&gt;1&lt;/td&gt; &lt;td th:text="$&#123;user.name&#125;"&gt;张三&lt;/td&gt; &lt;td th:text="$&#123;user.userName&#125;"&gt;zhangsan&lt;/td&gt; &lt;td th:text="$&#123;user.age&#125;"&gt;20&lt;/td&gt; &lt;td th:text="$&#123;user.sex&#125; == 1 ? '男': '女'"&gt;男&lt;/td&gt; &lt;td th:text="$&#123;#dates.format(user.birthday, 'yyyy-MM-dd')&#125;"&gt;1980-02-30&lt;/td&gt; &lt;td th:text="$&#123;user.note&#125;"&gt;1&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 我们看到这里使用了以下语法： ${} ：这个类似与el表达式，但其实是ognl的语法，比el表达式更加强大 th-指令：th-是利用了Html5中的自定义属性来实现的。如果不支持H5，可以用data-th-来代替 th:each：类似于c:foreach 遍历集合，但是语法更加简洁 th:text：声明标签中的文本 例如&lt;td th-text=&#39;${user.id}&#39;&gt;1&lt;/td&gt;，如果user.id有值，会覆盖默认的1 如果没有值，则会显示td中默认的1。这正是thymeleaf能够动静结合的原因，模板解析失败不影响页面的显示效果，因为会显示默认值！ 6.5.测试接下来，我们打开页面测试一下： 6.6.模板缓存Thymeleaf会在第一次对模板解析之后进行缓存，极大的提高了并发处理能力。但是这给我们开发带来了不便，修改页面后并不会立刻看到效果，我们开发阶段可以关掉缓存使用： 12# 开发阶段关闭thymeleaf的模板缓存spring.thymeleaf.cache=false 注意： ​ 在Idea中，我们需要在修改页面后按快捷键：Ctrl + Shift + F9 对项目进行rebuild才可以。 ​ eclipse中没有测试过。 我们可以修改页面，测试一下。]]></content>
      <categories>
        <category>项目实战-微服务商城</category>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>Thymeleaf</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RabbitMQ安装]]></title>
    <url>%2FCentos6%E5%AE%89%E8%A3%85rabbitmq.html</url>
    <content type="text"><![CDATA[0.安装文件准备看linux虚拟机是64位还是32位 然后去这个网站下载Erlang安装包：https://packages.erlang-solutions.com/rpm/centos/6/ 首先将课前资料提供的安装包上传到 /home/leyou/MQ目录： 这个是RabbitMQ的安装包： 通过filezilla将文件上传到虚拟机中 1.安装Erlang我们并没有提供Erlang安装包，直接采用yum仓库安装： 12yum install esl-erlang-18.3.4.5-1_centos632.i686.rpmyum install esl-erlang-compat-R14B-1.el6.noarch.rpm 2.安装RabbitMQ2.1.安装进入文件所在目录: 1cd /home/leyou/MQ 然后输入命令： 1rpm -ivh rabbitmq-server-3.4.1-1.noarch.rpm 2.2.修改配置文件将配置文件模板复制到etc目录： 1cp /usr/share/doc/rabbitmq-server-3.4.1/rabbitmq.config.example /etc/rabbitmq/rabbitmq.config 通过vim命令编辑： 1vim /etc/rabbitmq/rabbitmq.config 修改下面内容： 注意要去掉后面的逗号 2.3.设置开机启动输入下面命令 1chkconfig rabbitmq-server on 2.4.启动命令通过下面命令来控制RabbitMQ： 123service rabbitmq-server startservice rabbitmq-server stopservice rabbitmq-server restart 2.5.开启web管理界面RabbitMQ提供了用来管理的控制界面，十分方便，不过默认是关闭的。 我们通过命令开启web管理插件： 1rabbitmq-plugins enable rabbitmq_management 然后重启RabbitMQ： 1service rabbitmq-server restart 2.6.开放端口RabbitMQ默认使用15672端口进行web访问，我们开启防火墙端口： 12/sbin/iptables -I INPUT -p tcp --dport 15672 -j ACCEPT/etc/rc.d/init.d/iptables save 然后在主机中通过地址：http://192.168.25.128:15672即可访问到管理界面 3.管理界面介绍第一次访问需要登录，默认的账号密码为：guest/guest 3.1.主页 connections：无论生产者还是消费者，都需要与RabbitMQ建立连接后才可以完成消息的生产和消费，在这里可以查看连接情况 channels：通道，建立连接后，会形成通道，消息的投递获取依赖通道。 Exchanges：交换机，用来实现消息的路由 Queues：队列，即消息队列，消息存放在队列中，等待消费，消费后被移除队列。 端口： ​ 3.2.添加用户 上面的Tags选项，其实是指定用户的角色，可选的有以下几个： 超级管理员(administrator) 可登陆管理控制台，可查看所有的信息，并且可以对用户，策略(policy)进行操作。 监控者(monitoring) 可登陆管理控制台，同时可以查看rabbitmq节点的相关信息(进程数，内存使用情况，磁盘使用情况等) 策略制定者(policymaker) 可登陆管理控制台, 同时可以对policy进行管理。但无法查看节点的相关信息(上图红框标识的部分)。 普通管理者(management) 仅可登陆管理控制台，无法看到节点信息，也无法对策略进行管理。 其他 无法登陆管理控制台，通常就是普通的生产者和消费者。 3.3.创建虚拟主机（Virtual Hosts）为了让各个用户可以互不干扰的工作，RabbitMQ添加了虚拟主机（Virtual Hosts）的概念。其实就是一个独立的访问路径，不同用户使用不同路径，各自有自己的队列、交换机，互相不会影响。 创建好虚拟主机，我们还要给用户添加访问权限： 点击添加好的虚拟主机： 进入虚拟主机设置界面： 自己创建一个账号 遇到问题[root@promote ~]# cat /var/log/rabbitmq/startup_logERROR: epmd error for host promote: address (cannot connect to host/port) 查看主机名 12[root@promote ~]# hostnamepromote.cache-dns.local 查看network 123[root@promote ~]# cat /etc/sysconfig/networkNETWORKING=yesHOSTNAME=promote.cache-dns.local 查看hosts 1234[root@promote ~]# cat /etc/hosts127.0.0.1 promote127.0.0.1 localhost localhost.localdomain localhost4 localhost4.localdomain4 promote.cache-dns.local::1 localhost localhost.localdomain localhost6 localhost6.localdomain6]]></content>
      <categories>
        <category>RabbitMQ</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在线学习视频（二十）—— 分布式事务]]></title>
    <url>%2Fday19%20%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1.html</url>
    <content type="text"><![CDATA[分布式事务1 订单与选课需求分析1.1 订单支付流程学成在线的课程分为免费和收费两种。对于收费课程，用户需提交订单并完成支付方可在线学习。 提交订单及支付流程如下： 1、用户提交订单需要先登录系统 2、提交订单，订单信息保存到订单数据库 3、订单支付，调用微信支付接口完成支付 4、完成支付，微信支付系统通知学成在线支付结果 5、学成在线接收到支付结果通知，更新支付结果 提交订单流程： 1、用户进入课程详情页面 2、点击“立即购买”，打开订单确认信息 3、点击“确认无误，提交订单” 订单提交成功，向订单数据库的xc_orders订单表保存一条记录，向xc_orders_detail订单明细表保存一条或多条记录，向订单支付表插入一条记录。 4、订单提交成功自动进入订单支付页面 5、点击“微信支付”打开二维码 6、用手机扫码支付，支付完成，点击“完成支付” 支付完成，收到微信支付系统的支付完成通知或请求微信查询支付已完成，更新学成在线订单支付表中的支付状态字段。 1.2 自动选课需求支付成功即完成订单，订单完成之后系统需自动添加选课。 下图是微信支付、学成在线订单服务、学成在线学习服务交互图： 1、用户支付完成，微信支付系统会主动通知学成在线支付结果，学成在线也可主动请求微信支付查询订单的支付结果。 最终得到支付结果后将订单支付结果保存到订单数据库中。 2、订单支付完成系统自动向选课表添加学生选课记录。 3、选课记录添加完成学习即可在线开始学习。 2 分布式事务2.1 问题描述​ 根据上边的自动选课的需求，分析如下： ​ 用户支付完成会将支付状态及订单状态保存在订单数据库中，由订单服务去维护订单数据库。而学生选课信息在学习中心数据库，由学习服务去维护学习中心数据库的信息。下图是系统结构图： ​ 如何实现两个分布式服务（订单服务、学习服务）共同完成一件事即订单支付成功自动添加学生选课的需求，这里的关键是如何保证两个分布式服务的事务的一致性。 ​ 尝试解决上边的需求，在订单服务中远程调用选课接口，伪代码如下： 12345订单支付结果通知方法｛ 更新支付表中支付状态为“成功”。 远程调用选课接口添加选课记录。｝ 上边的逻辑说明： 1、更新支付表状态为本地数据库操作。 2、远程调用选课接口为网络远程调用请求。 3、为保存事务上边两步操作由spring控制事务，当遇到Exception异常则回滚本地数据库操作。 问题如下： 1、如果更新支付表失败则抛出异常，不再执行远程调用，此设想没有问题。 2、如果更新支付表成功，网络远程调用超时会拉长本地数据库事务时间，影响数据库性能。 3、如果更新支付表成功，远程调用添加选课成功（选课数据库commit成功），最后更新支付表commit失败，此时出现操作不一致。 上边的问题涉及到分布式事务控制。 2.2 什么是分布式事务1、什么是分布式系统？ 部署在不同结点上的系统通过网络交互来完成协同工作的系统。 比如：充值加积分的业务，用户在充值系统向自己的账户充钱，在积分系统中自己积分相应的增加。充值系统和积分系统是两个不同的系统，一次充值加积分的业务就需要这两个系统协同工作来完成。 2、什么是事务？ 事务是指由一组操作组成的一个工作单元，这个工作单元具有原子性（atomicity）、一致性（consistency）、隔离性（isolation）和持久性（durability）。 原子性：执行单元中的操作要么全部执行成功，要么全部失败。如果有一部分成功一部分失败那么成功的操作要全部回滚到执行前的状态。 一致性：执行一次事务会使用数据从一个正确的状态转换到另一个正确的状态，执行前后数据都是完整的。 隔离性：在该事务执行的过程中，任何数据的改变只存在于该事务之中，对外界没有影响，事务与事务之间是完全的隔离的。只有事务提交后其它事务才可以查询到最新的数据。 持久性：事务完成后对数据的改变会永久性的存储起来，即使发生断电宕机数据依然在。 3、什么是本地事务？ 本地事务就是用关系数据库来控制事务，关系数据库通常都具有ACID特性，传统的单体应用通常会将数据全部存储在一个数据库中，会借助关系数据库来完成事务控制。 4、什么是分布式事务？ ​ 在分布式系统中一次操作由多个系统协同完成，这种一次事务操作涉及多个系统通过网络协同完成的过程称为分布式事务。这里强调的是多个系统通过网络协同完成一个事务的过程，并不强调多个系统访问了不同的数据库，即使多个系统访问的是同一个数据库也是分布式事务，如下图： ​ 另外一种分布式事务的表现是，一个应用程序使用了多个数据源连接了不同的数据库，当一次事务需要操作多个数据源，此时也属于分布式事务，当系统作了数据库拆分后会出现此种情况。 ​ 上面两种分布式事务表现形式以第一种据多。 5、分布式事务有哪些场景？ 1) 电商系统中的下单扣库存 电商系统中，订单系统和库存系统是两个系统，一次下单的操作由两个系统协同完成 2）金融系统中的银行卡充值 在金融系统中通过银行卡向平台充值需要通过银行系统和金融系统协同完成。 3）教育系统中下单选课业务 在线教育系统中，用户购买课程，下单支付成功后学生选课成功，此事务由订单系统和选课系统协同完成。 4） SNS系统的消息发送 在社交系统中发送站内消息同时发送手机短信，一次消息发送由站内消息系统和手机通信系统协同完成。 2.3 CAP理论如何进行分布式事务控制？CAP理论是分布式事务处理的理论基础，了解了CAP理论有助于我们研究分布式事务的处理方案。 CAP理论是：分布式系统在设计时只能在一致性(Consistency)、可用性(Availability)、分区容忍性(Partition Tolerance)中满足两种，无法兼顾三种。 通过下图理解CAP理论： 一致性(Consistency)：服务A、B、C三个结点都存储了用户数据， 三个结点的数据需要保持同一时刻数据一致性。 可用性(Availability)：服务A、B、C三个结点，其中一个结点宕机不影响整个集群对外提供服务，如果只有服务A结点，当服务A宕机整个系统将无法提供服务，增加服务B、C是为了保证系统的可用性。 分区容忍性(Partition Tolerance)：分区容忍性就是允许系统通过网络协同工作，分区容忍性要解决由于网络分区导致数据的不完整及无法访问等问题。 分布式系统不可避免的出现了多个系统通过网络协同工作的场景，结点之间难免会出现网络中断、网延延迟等现象，这种现象一旦出现就导致数据被分散在不同的结点上，这就是网络分区。 分布式系统能否兼顾C、A、P？ 在保证分区容忍性的前提下一致性和可用性无法兼顾，如果要提高系统的可用性就要增加多个结点，如果要保证数据的一致性就要实现每个结点的数据一致，结点越多可用性越好，但是数据一致性越差。 所以，在进行分布式系统设计时，同时满足“一致性”、“可用性”和“分区容忍性”三者是几乎不可能的。 CAP有哪些组合方式？ 1、CA：放弃分区容忍性，加强一致性和可用性，关系数据库按照CA进行设计。 2、AP：放弃一致性，加强可用性和分区容忍性，追求最终一致性，很多NoSQL数据库按照AP进行设计。 ​ 说明：这里放弃一致性是指放弃强一致性，强一致性就是写入成功立刻要查询出最新数据。追求最终一致性是指允许暂时的数据不一致，只要最终在用户接受的时间内数据 一致即可。 3、CP：放弃可用性，加强一致性和分区容忍性，一些强一致性要求的系统按CP进行设计，比如跨行转账，一次转账请求要等待双方银行系统都完成整个事务才算完成。 ​ 说明：由于网络问题的存在CP系统可能会出现待等待超时，如果没有处理超时问题则整理系统会出现阻塞。 总结： ​ 在分布式系统设计中AP的应用较多，即保证分区容忍性和可用性，牺牲数据的强一致性（写操作后立刻读取到最新数据），保证数据最终一致性。比如：订单退款，今日退款成功，明日账户到账，只要在预定的用户可以接受的时间内退款事务走完即可。 2.4 解决方案2.4.1 两阶段提交协议(2PC)​ 为解决分布式系统的数据一致性问题出现了两阶段提交协议（2 Phase Commitment Protocol），两阶段提交由协调者和参与者组成，共经过两个阶段和三个操作，部分关系数据库如Oracle、MySQL支持两阶段提交协议，本节讲解关系数据库两阶段提交协议。 参考： 2PC：https://en.wikipedia.org/wiki/Two-phase_commit_protocol 2PC协议流程图： 1）第一阶段：准备阶段（prepare） 协调者通知参与者准备提交订单，参与者开始投票。 协调者完成准备工作向协调者回应Yes。 2）第二阶段：提交(commit)/回滚(rollback)阶段 协调者根据参与者的投票结果发起最终的提交指令。 如果有参与者没有准备好则发起回滚指令。 一个下单减库存的例子： 1、应用程序连接两个数据源。 2、应用程序通过事务协调器向两个库发起prepare，两个数据库收到消息分别执行本地事务（记录日志），但不提交，如果执行成功则回复yes，否则回复no。 3、事务协调器收到回复，只要有一方回复no则分别向参与者发起回滚事务，参与者开始回滚事务。 4、事务协调器收到回复，全部回复yes，此时向参与者发起提交事务。如果参与者有一方提交事务失败则由事务协调器发起回滚事务。 2PC的优点：实现强一致性，部分关系数据库支持（Oracle、MySQL等）。 缺点：整个事务的执行需要由协调者在多个节点之间去协调，增加了事务的执行时间，性能低下。 解决方案有：springboot+Atomikos or Bitronix 3PC主要是解决协调者与参与者通信阻塞问题而产生的，它比2PC传递的消息还要多，性能不高。详细参考3PC：https://en.wikipedia.org/wiki/Three-phase_commit_protocol 2.4.2 事务补偿（TCC）TCC事务补偿是基于2PC实现的业务层事务控制方案，它是Try、Confirm和Cancel三个单词的首字母，含义如下： 1、Try 检查及预留业务资源 ​ 完成提交事务前的检查，并预留好资源。 2、Confirm 确定执行业务操作 ​ 对try阶段预留的资源正式执行。 3、Cancel 取消执行业务操作 ​ 对try阶段预留的资源释放。 下边用一个下单减库存的业务为例来说明： 1、Try 下单业务由订单服务和库存服务协同完成，在try阶段订单服务和库存服务完成检查和预留资源。 订单服务检查当前是否满足提交订单的条件（比如：当前存在未完成订单的不允许提交新订单）。 库存服务检查当前是否有充足的库存，并锁定资源。 2、Confirm 订单服务和库存服务成功完成Try后开始正式执行资源操作。 订单服务向订单写一条订单信息。 库存服务减去库存。 3、Cancel 如果订单服务和库存服务有一方出现失败则全部取消操作。 订单服务需要删除新增的订单信息。 库存服务将减去的库存再还原。 优点：最终保证数据的一致性，在业务层实现事务控制，灵活性好。 缺点：开发成本高，每个事务操作每个参与者都需要实现try/confirm/cancel三个接口。 注意：TCC的try/confirm/cancel接口都要实现幂等性，在为在try、confirm、cancel失败后要不断重试。 什么是幂等性？ ​ 幂等性是指同一个操作无论请求多少次，其结果都相同。 幂等操作实现方式有： 1、操作之前在业务方法进行判断如果执行过了就不再执行。 2、缓存所有请求和处理的结果，已经处理的请求则直接返回结果。 3、在数据库表中加一个状态字段（未处理，已处理），数据操作时判断未处理时再处理。 2.4.3 消息队列实现最终一致本方案是将分布式事务拆分成多个本地事务来完成，并且由消息队列异步协调完成，如下图： 下边以下单减少库存为例来说明： 1、订单服务和库存服务完成检查和预留资源。 2、订单服务在本地事务中完成添加订单表记录和添加“减少库存任务消息”。 3、由定时任务根据消息表的记录发送给MQ通知库存服务执行减库存操作。 4、库存服务执行减少库存，并且记录执行消息状态（为避免重复执行消息，在执行减库存之前查询是否执行过此消息）。 5、库存服务向MQ发送完成减少库存的消息。 6、订单服务接收到完成库存减少的消息后删除原来添加的“减少库存任务消息”。 实现最终事务一致要求：预留资源成功理论上要求正式执行成功，如果执行失败会进行重试，要求业务执行方法实现幂等。 优点 ： 由MQ按异步的方式协调完成事务，性能较高。 不用实现try/confirm/cancel接口，开发成本比TCC低。 缺点： 此方式基于关系数据库本地事务来实现，会出现频繁读写数据库记录，浪费数据库资源，另外对于高并发操作不是最佳方案。 2.5 自动添加选课方案2.5.1 搭建环境根据自动选课需求，为了更好的分析解决方案，这里搭建订单工程及数据库。 2.5.2.1 创建订单工程导入资料下的xc-service-manage-order工程。 2.5.2.2 创建订单数据库1、创建订单数据库xc_order（MySQL） 导入xc_order.sql 1）xc_orders：订单主表 记录订单的主要信息 2）xc_orders_details：订单明细表 记录订单的明细信息 3）xc_orders_pay：订单支付表 记录订单的支付状态 2、向xc_order数据库导入xc_order_task.sql 待处理任务表： 在任务表中包括了交换机的名称、路由key等信息为了是将任务的处理做成一个通用的功能。 考虑分布式系统并发读取任务处理任务的情况发生项目使用乐观锁的方式解决并发问题。 已完成任务表： 2.5.2.3 创建选课数据库创建xc_learning数据库，导入xc_learning.sql，xc_learning_course为学生选课表。 导入xc_task_his.sql，xc_task_his为历史任务表。 2.5.2 解决方案本项目综合考虑选择基于消息的分布式事务解决方案，解决方案如下图： 1、支付成功后，订单服务向本地数据库更新订单状态并向消息表写入“添加选课消息”，通过本地数据库保证订单状态和添加选课消息的事务。。 2、定时任务扫描消息表，取出“添加选课任务“并发向MQ。 3、学习服务接收到添加选课的消息，先查询本地数据库的历史消息表是否存在消息，存在则说明已经添加选课，否则向本地数据库添加选课，并向历史消息表添加选课消息。这里选课表和历史消息表在同一个数据库，通过本地事务保证。 4、学习服务接收到添加选课的消息，通过查询消息表判断如果已经添加选课也向MQ发送“完成添加选课任务的消息”，否则则添加选课，完成后向MQ发送“完成添加选课任务的消息”， 5、订单服务接收到完成选课的消息后删除订单数据库中消息表的“添加选课消息”，为保证后期对账将消息表的消息先添加到历史消息表再删除消息，表示此消息已经完成。 3 Spring Task定时任务3.1需求分析根据分布式事务的研究结果，订单服务需要定时扫描任务表向MQ发送任务。本节研究定时任务处理的方案，并实现定时任务扫描任务表并向MQ发送消息。 实现定时任务的方案如下： 1、使用jdk的Timer和TimerTask实现 可以实现简单的间隔执行任务，无法实现按日历去调度执行任务。 2、使用Quartz实现 Quartz 是一个异步任务调度框架，功能丰富，可以实现按日历调度。 3、使用Spring Task实现 Spring 3.0后提供Spring Task实现任务调度，支持按日历调度，相比Quartz功能稍简单，但是在开发基本够用，支持注解编程方式。 本项目使用Spring Task实现任务调度。 3.2 Spring Task串行任务3.2.1 编写任务类在Spring boot启动类上添加注解：@EnableScheduling 新建任务测试类TestTask，编写测试方法如下： 1234567891011121314151617@Componentpublic class ChooseCourseTask &#123; private static final Logger LOGGER = LoggerFactory.getLogger(ChooseCourseTask.class); // @Scheduled(fixedRate = 5000) //上次执行开始时间后5秒执行// @Scheduled(fixedDelay = 5000) //上次执行完毕后5秒执行// @Scheduled(initialDelay=3000, fixedRate=5000) //第一次延迟3秒，以后每隔5秒执行一次 @Scheduled(cron=&quot;0/3 * * * * *&quot;)//每隔3秒执行一次 public void task1()&#123; LOGGER.info(&quot;===============测试定时任务1开始===============&quot;); try &#123; Thread.sleep(5000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; LOGGER.info(&quot;===============测试定时任务1结束===============&quot;); &#125; 测试： 1、测试fixedRate和fixedDelay的区别 2、测试串行执行的特点 3.2.2 cron表达式cron表达式包括6部分： 秒（0~59） 分钟（0~59） 小时（0~23） 月中的天（1~31） 月（1~12） 周中的天（填写MON，TUE，WED，THU，FRI，SAT,SUN，或数字1~7 1表示MON，依次类推） 特殊字符介绍： “/”字符表示指定数值的增量 “*”字符表示所有可能的值 “-”字符表示区间范围 “,” 字符表示列举 “？”字符仅被用于月中的天和周中的天两个子表达式，表示不指定值 例子： 0/3 * 每隔3秒执行 0 0/5 每隔5分钟执行 0 0 0 * 表示每天0点执行 0 0 12 ? * WEN 每周三12点执行 0 15 10 ? * MON-FRI 每月的周一到周五10点 15分执行 0 15 10 ? * MON,FRI 每月的周一和周五10点 15分执行 3.2.3 串行任务测试参考 task1方法的的定义方法，再定义task2方法，此时共用两个任务方法。 12345678910@Scheduled(fixedRate = 3000) //上次执行开始时间后5秒执行public void task2()&#123; LOGGER.info(&quot;===============测试定时任务2开始===============&quot;); try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; LOGGER.info(&quot;===============测试定时任务2结束===============&quot;);&#125; 通过测试发现，两个任务方法由一个线程串行执行，task1方法执行完成task2再执行。 3.3 Spring Task并行任务3.3.1 需求分析在项目通常是需要多个不同的任务并行去执行。 本节实现Spring Task并行执行任务的方法。 3.3.2 配置异步任务创建异步任务配置类，需要配置线程池实现多线程调度任务。 12345678910111213141516171819202122232425262728293031@Configuration@EnableSchedulingpublic class AsyncTaskConfig implements SchedulingConfigurer, AsyncConfigurer &#123; //线程池线程数量 private int corePoolSize = 5; @Bean public ThreadPoolTaskScheduler taskScheduler() &#123; ThreadPoolTaskScheduler scheduler = new ThreadPoolTaskScheduler(); scheduler.initialize();//初始化线程池 scheduler.setPoolSize(corePoolSize);//线程池容量 return scheduler; &#125; @Override public Executor getAsyncExecutor() &#123; Executor executor = taskScheduler(); return executor; &#125; @Override public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler() &#123; return null; &#125; @Override public void configureTasks(ScheduledTaskRegistrar scheduledTaskRegistrar) &#123; scheduledTaskRegistrar.setTaskScheduler(taskScheduler()); &#125;&#125; 将@EnableScheduling添加到此配置类上，SpringBoot启动类上不用再添加@EnableScheduling 3.3.3 测试通过测试发现两个任务由不同的线程在并行执行，互不影响。 4 订单服务定时发送消息4.1 需求分析定时任务发送消息流程如下： 1、每隔1分钟扫描一次任务表。 1、定时任务扫描task表，一次取出多个任务，取出超过1分钟未处理的任务 2、考虑订单服务可能集群部署，为避免重复发送任务使用乐观锁的方式每次从任务列表取出要处理的任务 3、任务发送完毕更新任务发送时间 关于任务表的添加： 正常的流程是订单支付成功向更新订单支付状态并向任务表写入“添加选课任务”。 目前订单支付功能没有开发，采用手动向任务表添加任务。 4.2 RabbitMQ配置向RabbitMQ声明两个队列：添加选课、完成选课，交换机使用路由模式，代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152@Configurationpublic class RabbitMQConfig &#123; //添加选课任务交换机 public static final String EX_LEARNING_ADDCHOOSECOURSE = &quot;ex_learning_addchoosecourse&quot;; //添加选课消息队列 public static final String XC_LEARNING_ADDCHOOSECOURSE = &quot;xc_learning_addchoosecourse&quot;; //完成添加选课消息队列 public static final String XC_LEARNING_FINISHADDCHOOSECOURSE = &quot;xc_learning_finishaddchoosecourse&quot;; //添加选课路由key public static final String XC_LEARNING_ADDCHOOSECOURSE_KEY = &quot;addchoosecourse&quot;; //完成添加选课路由key public static final String XC_LEARNING_FINISHADDCHOOSECOURSE_KEY = &quot;finishaddchoosecourse&quot;; /** * 交换机配置 * @return the exchange */ @Bean(EX_LEARNING_ADDCHOOSECOURSE) public Exchange EX_DECLARE() &#123; return ExchangeBuilder.directExchange(EX_LEARNING_ADDCHOOSECOURSE).durable(true).build(); &#125; //声明队列 @Bean(XC_LEARNING_FINISHADDCHOOSECOURSE) public Queue QUEUE_XC_LEARNING_FINISHADDCHOOSECOURSE() &#123; Queue queue = new Queue(XC_LEARNING_FINISHADDCHOOSECOURSE); return queue; &#125; //声明队列 @Bean(XC_LEARNING_ADDCHOOSECOURSE) public Queue QUEUE_XC_LEARNING_ADDCHOOSECOURSE() &#123; Queue queue = new Queue(XC_LEARNING_ADDCHOOSECOURSE); return queue; &#125; /** * 绑定队列到交换机 . * @param queue the queue * @param exchange the exchange * @return the binding */ @Bean public Binding BINDING_QUEUE_FINISHADDCHOOSECOURSE(@Qualifier(XC_LEARNING_FINISHADDCHOOSECOURSE) Queue queue, @Qualifier(EX_LEARNING_ADDCHOOSECOURSE) Exchange exchange) &#123; return BindingBuilder.bind(queue).to(exchange).with(XC_LEARNING_FINISHADDCHOOSECOURSE_KEY).noargs(); &#125; @Bean public Binding BINDING_QUEUE_ADDCHOOSECOURSE(@Qualifier(XC_LEARNING_ADDCHOOSECOURSE) Queue queue, @Qualifier(EX_LEARNING_ADDCHOOSECOURSE) Exchange exchange) &#123; return BindingBuilder.bind(queue).to(exchange).with(XC_LEARNING_ADDCHOOSECOURSE_KEY).noargs(); &#125;&#125; 4.3 查询前N条任务4.3.1 Dao在XcTaskRepository中自定义方法如下： 12345public interface XcTaskRepository extends JpaRepository&lt;XcTask, String&gt; &#123; //取出指定时间之前的记录 Page&lt;XcTask&gt; findByUpdateTimeBefore(Pageable pageable,Date updateTime);&#125; 4.3.2 Service1234567891011121314151617@Servicepublic class TaskService &#123; @Autowired XcTaskRepository xcTaskRepository; @Autowired RabbitTemplate rabbitTemplate; //取出前n条任务,取出指定时间之前处理的任务 public List&lt;XcTask&gt; findTaskList(Date updateTime,int n)&#123; //设置分页参数，取出前n 条记录 Pageable pageable = new PageRequest(0, n); Page&lt;XcTask&gt; xcTasks = xcTaskRepository.findByUpdateTimeBefore(pageable,updateTime); return xcTasks.getContent(); &#125; &#125; 4.5.3 编写任务类编写任务类，每分钟执行任务，启动订单工程，观察定时发送消息日志，观察rabbitMQ队列中是否有消息，代码如下：1234567891011121314151617181920package com.xuecheng.order.mq;@Componentpublic class ChooseCourseTask &#123; private static final Logger LOGGER = LoggerFactory.getLogger(ChooseCourseTask.class); @Autowired TaskService taskService; //每隔1分钟扫描消息表，向mq发送消息 @Scheduled(fixedDelay = 60000) public void sendChoosecourseTask()&#123; //取出当前时间1分钟之前的时间 Calendar calendar =new GregorianCalendar(); calendar.setTime(new Date()); calendar.add(GregorianCalendar.MINUTE,-1); Date time = calendar.getTime(); List&lt;XcTask&gt; taskList = taskService.findTaskList(time, 1000); &#125; ｝ 启动工程，测试读取任务列表的功能。 4.5 定时发送任务4.5.1 Dao添加更新任务方法： 1234//更新任务处理时间@Modifying@Query(&quot;update XcTask t set t.updateTime = :updateTime where t.id = :id &quot;)public int updateTaskTime(@Param(value = &quot;id&quot;) String id,@Param(value = &quot;updateTime&quot;)Date updateTime); 4.5.2 Service添加发送消息方法： 123456789101112131415161718192021/** * //发送消息 * @param xcTask 任务对象 * @param ex 交换机id * @param routingKey */@Transactionalpublic void publish(XcTask xcTask,String ex,String routingKey)&#123; //查询任务 Optional&lt;XcTask&gt; taskOptional = xcTaskRepository.findById(taskId); if(taskOptional.isPresent())&#123; XcTask xcTask = taskOptional.get(); //String exchange, String routingKey, Object object rabbitTemplate.convertAndSend(ex,routingKey,xcTask); //更新任务时间为当前时间 xcTask.setUpdateTime(new Date()); xcTaskRepository.save(xcTask); &#125;&#125; 4.5.3 编写任务类编写任务类，每分钟执行任务，启动订单工程，观察定时发送消息日志，观察rabbitMQ队列中是否有消息，代码如下： 123456789101112131415161718192021222324252627package com.xuecheng.order.mq;@Componentpublic class ChooseCourseTask &#123; private static final Logger LOGGER = LoggerFactory.getLogger(ChooseCourseTask.class); @Autowired TaskService taskService; //每隔1分钟扫描消息表，向mq发送消息 @Scheduled(fixedDelay = 60000) public void sendChoosecourseTask()&#123; //取出当前时间1分钟之前的时间 Calendar calendar =new GregorianCalendar(); calendar.setTime(new Date()); calendar.add(GregorianCalendar.MINUTE,-1); Date time = calendar.getTime(); List&lt;XcTask&gt; taskList = taskService.findTaskList(time, 1000); //遍历任务列表 for(XcTask xcTask:taskList)&#123; //发送选课消息 taskService.publish(xcTask, xcTask.getMqExchange(),xcTask.getMqRoutingkey()); LOGGER.info(&quot;send choose course task id:&#123;&#125;&quot;,taskId); &#125; &#125; ｝ 4.7 乐观锁取任务考虑订单服务将来会集群部署，为了避免任务在1分钟内重复执行，这里使用乐观锁，实现思路如下： 1) 每次取任务时判断当前版本及任务id是否匹配，如果匹配则执行任务，如果不匹配则取消执行。 2) 如果当前版本和任务Id可以匹配到任务则更新当前版本加1. 1、在Dao中增加校验当前版本及任务id的匹配方法 123456public interface XcTaskRepository extends JpaRepository&lt;XcTask, String&gt; &#123; //使用乐观锁方式校验任务id和版本号是否匹配，匹配则版本号加1 @Modifying @Query(&quot;update XcTask t set t.version = :version+1 where t.id = :id and t.version = :version&quot;) public int updateTaskVersion(@Param(value = &quot;id&quot;) String id,@Param(value = &quot;version&quot;) int version); ... 2、在service中增加方法，使用乐观锁方法校验任务 12345@Transactionalpublic int getTask(String taskId,int version)&#123; int i = xcTaskRepository.updateTaskVersion(taskId, version); return i;&#125; 3、执行任务类中修改 1234567891011//任务idString taskId = xcTask.getId();//版本号Integer version = xcTask.getVersion();//调用乐观锁方法校验任务是否可以执行if(taskService.getTask(taskId, version)&gt;0)&#123; //发送选课消息 taskService.publish(xcTask, xcTask.getMqExchange(),xcTask.getMqRoutingkey()); LOGGER.info(&quot;send choose course task id:&#123;&#125;&quot;,taskId);&#125; 4 自动添加选课开发4.1 学习服务添加选课4.1.1需求分析学习服务接收MQ发送添加选课消息，执行添加 选 课操作。 添加选课成功向学生选课表插入记录、向历史任务表插入记录、并向MQ发送“完成选课”消息。 4.1.2 RabbitMQ配置学习服务监听MQ的添加选课队列，并且声明完成选课队列，配置代码同订单服务中RabbitMQ配置 4.1.3 Dao学生选课Dao： 1234public interface XcLearningCourseRepository extends JpaRepository&lt;XcLearningCourse, String&gt; &#123; //根据用户和课程查询选课记录，用于判断是否添加选课 XcLearningCourse findXcLearningCourseByUserIdAndCourseId(String userId, String courseId);&#125; 历史任务Dao： 123public interface XcTaskHisRepository extends JpaRepository&lt;XcTaskHis,String&gt; &#123;&#125; 4.1.4 Service1、添加选课方法 向xc_learning_course添加记录，为保证不重复添加选课，先查询历史任务表，如果从历史任务表查询不到任务说明此任务还没有处理，此时则添加选课并添加历史任务。 在学习服务中编码如下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445//完成选课 @Transactional public ResponseResult addcourse(String userId, String courseId,String valid,Date startTime,Date endTime,XcTask xcTask)&#123; if (StringUtils.isEmpty(courseId)) &#123; ExceptionCast.cast(LearningCode.LEARNING_GETMEDIA_ERROR); &#125; if (StringUtils.isEmpty(userId)) &#123; ExceptionCast.cast(LearningCode.CHOOSECOURSE_USERISNULL); &#125; if(xcTask == null || StringUtils.isEmpty(xcTask.getId()))&#123; ExceptionCast.cast(LearningCode.CHOOSECOURSE_TASKISNULL); &#125; //查询历史任务 Optional&lt;XcTaskHis&gt; optional = xcTaskHisRepository.findById(xcTask.getId()); if(optional.isPresent())&#123; return new ResponseResult(CommonCode.SUCCESS); &#125; XcLearningCourse xcLearningCourse = xcLearningCourseRepository.findXcLearningCourseByUserIdAndCourseId(userId, courseId); if (xcLearningCourse == null) &#123;//没有选课记录则添加 xcLearningCourse = new XcLearningCourse(); xcLearningCourse.setUserId(userId); xcLearningCourse.setCourseId(courseId); xcLearningCourse.setValid(valid); xcLearningCourse.setStartTime(startTime); xcLearningCourse.setEndTime(endTime); xcLearningCourse.setStatus(&quot;501001&quot;); xcLearningCourseRepository.save(xcLearningCourse); &#125; else &#123;//有选课记录则更新日期 xcLearningCourse.setValid(valid); xcLearningCourse.setStartTime(startTime); xcLearningCourse.setEndTime(endTime); xcLearningCourse.setStatus(&quot;501001&quot;); xcLearningCourseRepository.save(xcLearningCourse); &#125; //向历史任务表播入记录 Optional&lt;XcTaskHis&gt; optional = xcTaskHisRepository.findById(xcTask.getId()); if(!optional.isPresent())&#123; //添加历史任务 XcTaskHis xcTaskHis = new XcTaskHis(); BeanUtils.copyProperties(xcTask,xcTaskHis); xcTaskHisRepository.save(xcTaskHis); &#125; return new ResponseResult(CommonCode.SUCCESS); &#125; 4.1.5 接收添加选课消息接收到添加选课的消息调用添加选课方法完成添加选课，并发送完成选课消息。 在com.xuecheng.learning.mq包下添加ChooseCourseTask类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051@Componentpublic class ChooseCourseTask &#123; private static final Logger LOGGER = LoggerFactory.getLogger(ChooseCourseTask.class); @Autowired LearningService learningService; @Autowired RabbitTemplate rabbitTemplate; /** * 接收选课任务 */ @RabbitListener(queues = &#123;RabbitMQConfig.XC_LEARNING_ADDCHOOSECOURSE&#125;) public void receiveChoosecourseTask(XcTask xcTask,Message message,Channel channel) throws IOException &#123; LOGGER.info(&quot;receive choose course task,taskId:&#123;&#125;&quot;,xcTask.getId()); //接收到 的消息id String id = xcTask.getId(); //添加选课 try &#123; String requestBody = xcTask.getRequestBody(); Map map = JSON.parseObject(requestBody, Map.class); String userId = (String) map.get(&quot;userId&quot;); String courseId = (String) map.get(&quot;courseId&quot;); String valid = (String) map.get(&quot;valid&quot;); Date startTime = null; Date endTime = null; SimpleDateFormat dateFormat = new SimpleDateFormat(&quot;YYYY-MM-dd HH:mm:ss&quot;); if(map.get(&quot;startTime&quot;)!=null)&#123; startTime =dateFormat.parse((String) map.get(&quot;startTime&quot;)); &#125; if(map.get(&quot;endTime&quot;)!=null)&#123; endTime =dateFormat.parse((String) map.get(&quot;endTime&quot;)); &#125; //添加选课 ResponseResult addcourse = learningService.addcourse(userId, courseId, valid,startTime, endTime,xcTask); //选课成功发送响应消息 if(addcourse.isSuccess())&#123; //发送响应消息 rabbitTemplate.convertAndSend(RabbitMQConfig.EX_LEARNING_ADDCHOOSECOURSE, RabbitMQConfig.XC_LEARNING_FINISHADDCHOOSECOURSE_KEY, xcTask ); LOGGER.info(&quot;send finish choose course taskId:&#123;&#125;&quot;,id); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); LOGGER.error(&quot;send finish choose course taskId:&#123;&#125;&quot;, id); &#125; &#125;&#125; 4.2 订单服务结束任务4.2.1 需求分析订单服务接收MQ完成选课的消息，将任务从当前任务表删除，将完成的任务添加到完成任务表。 4.2.2 Dao1、删除xc_task 2、添加xc_task_his 定义过程略 4.2.3 Service在TaskService中定义删除任务方法 12345678910111213//删除任务@Transactionalpublic void finishTask(String taskId)&#123; Optional&lt;XcTask&gt; taskOptional = xcTaskRepository.findById(taskId); if(taskOptional.isPresent())&#123; XcTask xcTask = taskOptional.get(); xcTask.setDeleteTime(new Date()); XcTaskHis xcTaskHis = new XcTaskHis(); BeanUtils.copyProperties(xcTask, xcTaskHis); xcTaskHisRepository.save(xcTaskHis); xcTaskRepository.delete(xcTask); &#125;&#125; 4.2.4 接收完成选课消息在com.xuecheng.manage_order.mq包下ChooseCourseTask类中添加receiveChoosecourseTask，接收完成选课任务消息并进行处理。 1234567891011/** * 接收选课响应结果 */@RabbitListener(queues = &#123;RabbitMQConfig.xc_learning_finishaddchoosecourse&#125;)public void receiveFinishChoosecourseTask(XcTask task,Message message, Channel channel) throws IOException &#123; LOGGER.info(&quot;receiveChoosecourseTask...&#123;&#125;&quot;,task.getId()); //接收到 的消息id String id = task.getId(); //删除任务，添加历史任务 taskService.finishTask(id);&#125; 4.3 集成测试测试流程如下： 1、手动向任务表添加一条任务。 2、启动rabbitMQ. 3、启动订单服务、选课服务。 4、观察日志是否添加选课成功 完成任务后将xc_task任务移动到xc_task_his表中 完成任务后在选课表中多了一条学生选课记录 测试消息重复消费： 1、手动向任务表添加一条任务。 2、启动rabbitMQ. 3、先启动订单表，等待消息队列是否积累了多个消息。 4、再启动选课服务，观察是否重复添加选课]]></content>
      <categories>
        <category>项目实战-在线学习视频网站</category>
        <category>分布式事务</category>
      </categories>
      <tags>
        <tag>分布式事务</tag>
        <tag>Spring Task</tag>
        <tag>乐观锁</tag>
        <tag>消息队列解决分布式事务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在线学习视频（十九）—— 用户授权]]></title>
    <url>%2Fday18%20%E7%94%A8%E6%88%B7%E6%8E%88%E6%9D%83.html</url>
    <content type="text"><![CDATA[用户授权1 用户授权业务流程​ 用户授权的业务流程如下： 业务流程说明如下： 1、用户认证通过，认证服务向浏览器cookie写入token（ 身份令牌） 2、前端携带token请求用户中心服务获取jwt令牌 ​ 前端获取到jwt令牌解析，并存储在sessionStorage 3、前端携带cookie中的身份令牌及jwt令牌访问资源服务 ​ 前端请求资源服务需要携带两个token，一个是cookie中的身份令牌，一个是http header中的jwt ​ 前端请求资源服务前在http header上添加jwt请求资源 4、网关校验token的合法性 ​ 用户请求必须携带身份令牌和jwt令牌 ​ 网关校验redis中user_token的有效期，已过期则要求用户重新登录 5、资源服务校验jwt的合法性并进行授权 资源服务校验jwt令牌，完成授权，拥有权限的方法正常执行，没有权限的方法将拒绝访问。 2 方法授权2.1需求分析方法授权要完成的是资源服务根据jwt令牌完成对方法的授权，具体流程如下： 1、生成Jwt令牌时在令牌中写入用户所拥有的权限 我们给每个权限起个名字，例如某个用户拥有如下权限： course_find_list：课程查询 course_pic_list：课程图片查询 2、在资源服务方法上添加注解PreAuthorize，并指定此方法所需要的权限 例如下边是课程管理接口方法的授权配置，它就表示要执行这个方法需要拥有course_find_list权限。 12345@PreAuthorize(&quot;hasAuthority(&apos;course_find_list&apos;)&quot;)@Overridepublic QueryResult&lt;CourseInfo&gt; findCourseList(@PathVariable(&quot;page&quot;) int page, @PathVariable(&quot;size&quot;) int size, CourseListRequest courseListRequest) 3、当请求有权限的方法时正常访问 4、当请求没有权限的方法时则拒绝访问 2.2 jwt令牌包含权限修改认证服务的UserDetailServiceImpl类，下边的代码中 permissionList列表中存放了用户的权限， 并且将权限标识按照中间使用逗号分隔的语法组成一个字符串，最终提供给Spring security。 12345678910111213141516......//指定用户的权限，这里暂时硬编码 List&lt;String&gt; permissionList = new ArrayList&lt;&gt;(); permissionList.add(&quot;course_get_baseinfo&quot;); permissionList.add(&quot;course_find_pic&quot;); //将权限串中间以逗号分隔 String permissionString = StringUtils.join(permissionList.toArray(), &quot;,&quot;); //String user_permission_string = &quot;&quot;; UserJwt userDetails = new UserJwt(username, password, AuthorityUtils.commaSeparatedStringToAuthorityList(permissionString)); //用户名称 userDetails.setName(userext.getName()); //用户头像 userDetails.setUserpic(userext.getUserpic()); ...... 重启认证服务工程，使用postman完成登录，从redis中找到jwt令牌。 使用jwt的测试程序查看 此令牌的内容。 1&#123;&quot;companyId&quot;:null,&quot;userpic&quot;:null,&quot;user_name&quot;:&quot;mrt&quot;,&quot;scope&quot;:[&quot;app&quot;],&quot;name&quot;:&quot;教学管理员&quot;,&quot;utype&quot;:&quot;101002&quot;,&quot;id&quot;:&quot;49&quot;,&quot;exp&quot;:1527202013,&quot;authorities&quot;:[&quot;course_find_pic&quot;,&quot;course_get_baseinfo&quot;],&quot;jti&quot;:&quot;9360fa85-c1b4-428a-80ec-b2e705a02827&quot;,&quot;client_id&quot;:&quot;XcWebApp&quot;&#125; 可以看到authorities属性中为用户的权限。 2.3 方法授权实现2.3.1资源服务添加授权控制1、要想在资源服务使用方法授权，首先在资源服务配置授权控制 1）添加spring-cloud-starter-oauth2依赖。 2）拷贝授权配置类ResourceServerConfig。 3）拷贝公钥。 2.3.2方法上添加注解通常情况下，程序员编写在资源服务的controller方法时会使用注解指定此方法的权限标识。 1、查询课程列表方法 指定查询课程列表方法需要拥有course_find_list权限。 12345@PreAuthorize(&quot;hasAuthority(&apos;course_find_list&apos;)&quot;)@Overridepublic QueryResult&lt;CourseInfo&gt; findCourseList(@PathVariable(&quot;page&quot;) int page, @PathVariable(&quot;size&quot;) int size, CourseListRequest courseListRequest) 2、查看课程基本信息方法 指定查询课程基本信息方法需要拥有course_get_baseinfo权限。 123@PreAuthorize(&quot;hasAuthority(&apos;course_get_baseinfo&apos;)&quot;)@Overridepublic CourseBase getCourseBaseById(@PathVariable(&quot;courseId&quot;) String courseId) 3、在资源服务（这里是课程管理）的ResourceServerConfig类上添加注解，激活方法上添加授权注解 12//激活方法上的PreAuthorize注解@EnableGlobalMethodSecurity(prePostEnabled = true, securedEnabled = true) 2.4 方法授权测试重启课程管理服务，测试上边两个方法。 使用postman测试，测试前执行登录，并且将jwt令牌添加到header。 1）Get 请求 http://www.xuecheng.com/api/course/coursebase/get/4028e581617f945f01617f9dabc40000 用户拥有course_get_baseinfo权限，可以正常访问 2) Get请求 http://www.xuecheng.com/api/course/coursebase/list/1/2 由于用户没有查询课程列表方法的权限，所以无法正常访问，其它方法可以正常访问。 控制台报错： org.springframework.security.access.AccessDeniedException: 不允许访问 说明：如果方法上没有添加授权注解spring security将不进行授权控制，只要jwt令牌合法则可以正常访问。 3）异常处理 上边当没有权限访问时资源服务应该返回下边的错误代码： 1UNAUTHORISE(false,10002,&quot;权限不足，无权操作！&quot;) 进入资源服务（这里是课程管理），添加异常类AccessDeniedException.class与错误代码 10002 的 对应关系 123456789@ControllerAdvicepublic class CustomExceptionCatch extends ExceptionCatch &#123; static &#123; //除了CustomException以外的异常类型及对应的错误代码在这里定义,，如果不定义则统一返回固定的错误信息 builder.put(AccessDeniedException.class, CommonCode.UNAUTHORISE); &#125;&#125; 再次测试，结果如下： 2.5 小结方法授权步骤： 1、ResourceServerConfig类上添加注解，如下： 12//激活方法上的PreAuthorize注解@EnableGlobalMethodSecurity(prePostEnabled = true, securedEnabled = true) 2、在方法添加授权注解 1@PreAuthorize(&quot;hasAuthority(&apos;???&apos;)&quot;) 3、如果方法上不添加授权注解表示此方法不需要权限即可访问。 3 动态查询用户权限3.1 需求分析截至目前在测试授权时使用的权限数据是静态数据，正常情况的流程是： 1、管理员给用户分配权限，权限数据写到数据库中。 2、认证服务在进行用户认证时从数据库读取用户的权限数据（动态数据） 本节实现动态权限数据。 3.2 权限数据模型3.2.1 数据模型结构打开xc_user数据库，找到下边的表： xc_user：用户表，存储了系统用户信息，用户类型包括：学生、老师、管理员等 xc_role：角色表，存储了系统的角色信息，学生、老师、教学管理员、系统管理员等。 xc_user_role：用户角色表，一个用户可拥有多个角色，一个角色可被多个用户所拥有 xc_menu:模块表，记录了菜单及菜单下的权限 xc_permission:角色权限表，一个角色可拥有多个权限，一个权限可被多个角色所拥有 3.2.2 数据模型的使用本项目教学阶段不再实现权限定义及用户权限分配的功能，但是基于权限数据模型（5张数据表）及现有数据，要求学生在数据库中操作完成给用户分配权限、查询用户权限等需求。 1、查询用户所拥有的权限 步骤： 确定用户的id 查询用户所拥有的角色 查询用户所拥有的权限 例子： 12345SELECT * FROM xc_menu WHERE id IN( SELECT menu_id FROM xc_permission WHERE role_id IN( SELECT role_id FROM xc_user_role WHERE user_id = &apos;49&apos; )) 2、给用户分配权限 1）向已拥有角色分配权限 步骤： 确定用户的id 确定权限的id 确定用户的角色 向角色权限表添加记录 2）添加角色给用户分配权限 步骤： 确定用户的id 确定权限的id 添加角色 向角色权限表添加记录 向用户角色关系表添加记录 3.3 用户中心查询用户权限3.3.1 需求分析认证服务请求用户中心查询用户信息，用户需要将用户基本信息和用户权限一同返回给认证服务。 本小节实现用户查询查询用户权限，并将用户权限信息添加到的用户信息中返回给认证服务。 以上需求需要修改如下接口： 12@GetMapping(&quot;/getuserext&quot;)public XcUserExt getUserext(@RequestParam(&quot;username&quot;) String username); 3.3.2 DAO在用户中心服务中编写dao，实现根据用户id查询权限。 1、定义XcMenuMapper.java 在com.xuecheng.ucenter.dao包下定义： 1234@Mapperpublic interface XcMenuMapper &#123; public List&lt;XcMenu&gt; selectPermissionByUserId(String userid);&#125; 2、XcMenuMapper.xml 在com.xuecheng.ucenter.dao下定义XcMenuMapper.xml 123456789101112131415161718192021222324252627282930&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;&lt;mapper namespace=&quot;com.xuecheng.ucenter.dao.XcMenuMapper&quot; &gt; &lt;select id=&quot;selectPermissionByUserId&quot; resultType=&quot;com.xuecheng.framework.domain.ucenter.XcMenu&quot; parameterType=&quot;java.lang.String&quot; &gt; SELECT id, CODE, p_id pId, menu_name menuName, url, is_menu isMenu, LEVEL, sort, STATUS, icon, create_time createTime, update_time updateTiem FROM xc_menu WHERE id IN( SELECT menu_id FROM xc_permission WHERE role_id IN( SELECT role_id FROM xc_user_role WHERE user_id = #&#123;id&#125; ) ) &lt;/select&gt;&lt;/mapper&gt; 其它Dao采用spring data 编写如下： 3.3.3 Service修改UserService的getUserExt方法，查询用户权限。 123456789101112131415//根据账号查询用户的信息，返回用户扩展信息public XcUserExt getUserExt(String username)&#123; XcUser xcUser = this.findXcUserByUsername(username); if(xcUser == null)&#123; return null; &#125; //根据用户id查询用户权限 String userId = xcUser.getId(); List&lt;XcMenu&gt; xcMenus = xcMenuMapper.selectPermissionByUserId(userId); XcUserExt xcUserExt = new XcUserExt(); BeanUtils.copyProperties(xcUser,xcUserExt); //用户的权限 xcUserExt.setPermissions(xcMenus); return xcUserExt;&#125; 3.4 认证服务查询用户权限修改认证服务的UserDetailServiceImpl，查询用户的权限，并拼接权限串，将原来硬编码权限代码删除，代码如下： 12345678910111213141516171819 ...... //请求ucenter查询用户 XcUserExt userext = userClient.getUserext(username); if(userext == null)&#123; //返回NULL表示用户不存在，Spring Security会抛出异常 return null; &#125; //从数据库查询用户正确的密码，Spring Security会去比对输入密码的正确性 String password = userext.getPassword(); //指定用户的权限，这里暂时硬编码 List&lt;String&gt; permissionList = new ArrayList&lt;&gt;();// permissionList.add(&quot;course_get_baseinfo&quot;);// permissionList.add(&quot;course_find_pic&quot;); //取出用户权限 List&lt;XcMenu&gt; permissions = userext.getPermissions(); for(XcMenu xcMenu:permissions)&#123; permissionList.add(xcMenu.getCode()); &#125; ...... 3.5 测试1、执行登录，在redis中查看jwt令牌，使用jwt测试程序解析jwt令牌中是否包括用户的权限 。 2、使用新的jwt令牌测试方法授权 3、给用户分配新权限，重新生成jwt令牌，测试授权 4 前端集成认证授权4.1 需求分析截至目前认证授权服务端的功能已基本完成，本章实现前端集成认证授权功能。 前端集成认证授权功能需要作如下工作： 1、前端页面校验用户的身份，如果用户没有登录则跳转到登录页面 2、前端请求资源服务需要在http header中添加jwt令牌，资源服务根据jwt令牌完成授权。 哪些功能需要前端请求时携带JWT？ 用户登录成功请求资源服务都需要携带jwt令牌，因为资源服务已经实现了jwt认证，如果校验头部没有jwt则会认为身份不合法。 4.2教学管理中心本节实现教学管理中心实现身份校验，其它前端参考教学管理中心实现。 4.2.1 配置虚拟主机教学管理前端访问微服务统一在访问地址前添加/api前缀并经过网关转发到微服务。 配置teacher.xuecheng.com虚拟主机。 123456789101112131415161718192021222324252627282930313233343536#前端教学管理upstream teacher_server_pool&#123; server 127.0.0.1:12000 weight=10;&#125;#文件服务upstream filesystem_server_pool&#123; server 127.0.0.1:22100 weight=10;&#125; #媒资服务upstream media_server_pool&#123; server 127.0.0.1:31400 weight=10;&#125;#学成网教学管理中心server &#123; listen 80; server_name teacher.xuecheng.com; #个人中心 location / &#123; proxy_pass http://teacher_server_pool; &#125; location /api &#123; proxy_pass http://api_server_pool; &#125; location /filesystem &#123; proxy_pass http://filesystem_server_pool; &#125; #媒资管理 location ^~ /api/media/ &#123; proxy_pass http://media_server_pool/media/; &#125; #认证 location ^~ /openapi/auth/ &#123; proxy_pass http://auth_server_pool/auth/; &#125; &#125; 4.2.2身份校验教学管理中心是单页面应用，我们在路由变化时校验用户的身份，校验失败将跳转到登录页面。 校验方法如下： 1、如果成功从sessionStorage和cookie获取当前用户则继续访问 2、如果sessionStorage中无当前用户，cookie中有当前用户则请求服务端获取jwt，如果成功则继续访问。 3、以上两种情况都不满足则跳转到登录页面。 在main.js中添加路由监控代码，如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243router.beforeEach((to, from, next) =&gt; &#123; if(openAuthenticate)&#123; // console.log(to) // console.log(from) //***********身份校验*************** let activeUser let uid try&#123; activeUser = utilApi.getActiveUser() uid = utilApi.getCookie(&quot;uid&quot;) &#125;catch(e)&#123; //alert(e) &#125; if(activeUser &amp;&amp; uid &amp;&amp; uid == activeUser.uid) &#123; next(); &#125;else if(to.path ==&apos;/login&apos; || to.path ==&apos;/logout&apos;)&#123; next(); &#125;else if(uid)&#123; //请求获取jwt systemApi.getjwt().then((res)=&gt;&#123; if(res.success)&#123; let jwt = res.jwt; let activeUser = utilApi.getUserInfoFromJwt(jwt) if(activeUser)&#123; utilApi.setUserSession(&quot;activeUser&quot;,JSON.stringify(activeUser)) &#125; next(); &#125;else&#123; //跳转到统一登陆 window.location = &quot;http://ucenter.xuecheng.com/#/login?returnUrl=&quot;+ Base64.encode(window.location) &#125; &#125;) &#125;else&#123; //跳转到统一登陆 window.location = &quot;http://ucenter.xuecheng.com/#/login?returnUrl=&quot;+ Base64.encode(window.location) &#125; &#125;else&#123; next(); &#125;&#125;); 2、在base/api/system.js中添加getjwt方法 1234/*获取jwt令牌*/export const getjwt= () =&gt; &#123; return http.requestQuickGet(&apos;/openapi/auth/userjwt&apos;)&#125; 3、在utils.js中添加 如下方法 123456789101112131415161718192021222324252627282930313233343536getActiveUser: function()&#123; let uid = this.getCookie(&quot;uid&quot;) if(uid)&#123; let activeUserStr = this.getUserSession(&quot;activeUser&quot;); return JSON.parse(activeUserStr); &#125;else&#123; this.delUserSession(&quot;activeUser&quot;) &#125; &#125;,//获取jwt令牌 getJwt : function()&#123; let activeUser = this.getActiveUser() if(activeUser)&#123; return activeUser.jwt &#125; &#125;, //解析jwt令牌，获取用户信息 getUserInfoFromJwt : function (jwt) &#123; if(!jwt)&#123; return ; &#125; var jwtDecodeVal = jwtDecode(jwt); if (!jwtDecodeVal) &#123; return ; &#125; let activeUser=&#123;&#125; //console.log(jwtDecodeVal) activeUser.utype = jwtDecodeVal.utype || &apos;&apos;; activeUser.username = jwtDecodeVal.name || &apos;&apos;; activeUser.userpic = jwtDecodeVal.userpic || &apos;&apos;; activeUser.userid = jwtDecodeVal.userid || &apos;&apos;; activeUser.authorities = jwtDecodeVal.authorities || &apos;&apos;; activeUser.uid = jwtDecodeVal.jti || &apos;&apos;; activeUser.jwt = jwt; return activeUser; &#125;, 4、测试 1）启动学习中心前端、教学管理前端、认证服务、用户中心服务、网关、Eureka a、进入首页 b、点击“教学提供方”，此时由于没有登录自动跳转到登录页面 c、输入账号和密码登录 登录成功，跳转到教学管理页面 4.2.2 携带JWT授权1、前端携带JWT请求 根据需求，在使用axios进行http请求前向header中加入jwt令牌 在main.js中添加 12345678910111213import axios from &apos;axios&apos;// 添加请求拦截器axios.interceptors.request.use(function (config) &#123; // 在发送请求向header添加jwt let jwt = utilApi.getJwt() if(jwt)&#123; config.headers[&apos;Authorization&apos;] = &apos;Bearer &apos;+jwt &#125; return config;&#125;, function (error) &#123; return Promise.reject(error);&#125;); 2、测试http请求是否携带jwt 进入教学管理中心，点击我的课程，观察request header中是否有Authorization信息 3、测试授权效果 当访问一个没有权限的方法时是否报错？ 测试方法： 在课程计划查询方法上添加授权注解，表示当前用户需要拥有course_teachplan_list权限方可正常访问。 12345@PreAuthorize(&quot;hasAuthority(&apos;course_teachplan_list&apos;)&quot;)@Overridepublic TeachplanNode findTeachplanList(@PathVariable(&quot;courseId&quot;) String courseId) &#123; return courseService.findTeachplanList(courseId);&#125; 进入我的课程，点击课程计划，观察响应结果为 10002错误。 4、提示权限不足 当权限不足首页要给出提示，实现思路是使用axios的拦截，在执行后校验响应结果，如果是10002代码的错误则提示用户“权限不足”，如果是10001代码则强制登录。 在main.js中添加 1234567891011121314// 响应拦截axios.interceptors.response.use(data =&gt; &#123; console.log(&quot;data=&quot;) console.log(data) if(data &amp;&amp; data.data)&#123; if(data.data.code &amp;&amp; data.data.code ==&apos;10001&apos;)&#123; //需要登录 window.location = &quot;http://ucenter.xuecheng.com/#/login?returnUrl=&quot;+ Base64.encode(window.location) &#125;else if(data.data.code &amp;&amp; data.data.code ==&apos;10002&apos;)&#123; Message.error(&apos;您没有此操作的权限，请与客服联系！&apos;); &#125; &#125; return data&#125;) 测试： 执行一个没有权限的操作，提示如下： 3 细粒度授权3.1 需求分析什么是细粒度授权？ 细粒度授权也叫数据范围授权，即不同的用户所拥有的操作权限相同，但是能够操作的数据范围是不一样的。一个例子：用户A和用户B都是教学机构，他们都拥有“我的课程”权限，但是两个用户所查询到的数据是不一样的。 本项目有哪些细粒度授权？ 比如： 我的课程，教学机构只允许查询本教学机构下的课程信息。 我的选课，学生只允许查询自己所选课。 如何实现细粒度授权？ 细粒度授权涉及到不同的业务逻辑，通常在service层实现，根据不同的用户进行校验，根据不同的参数查询不同的数据或操作不同的数据。 3.3 我的课程细粒度授权3.3.1 需求分析1、我的课程查询，细粒度授权过程如下： 1）获取当前登录的用户Id 2）得到用户所属教育机构的Id 3）查询该教学机构下的课程信息 最终实现了用户只允许查询自己机构的课程信息。 2、修改课程管理服务“我的课程”的功能，根据公司Id查询课程，思路如下： 1）修改Dao，支持根据公司Id 查询课程。 2）修改Service，将公司Id传入Dao。 3）修改Controller，获取当前用户的公司Id，传给Service。 3、数据模型分析如下： 1）课程表 在xc_course数据库的course_base 表中添加company_id字段，来表示此课程的归属 2）用户企业表 在xc_user数据库的xc_company_user表中记录了用户的归属公司信息 通过xc_company_user表可得到用户的所属公司Id。 如何查询某个用户的课程？ 1、确定用户的Id 2、根据用户的Id查询用户归属的公司。 3、根据公司Id查询该公司下的课程信息 一个例子： 12345/*确定用户的id：49*//*根据用户Id查找所属公司*/SELECT company_id FROM xc_user.xc_company_user WHERE user_id = &apos;49&apos;/*根据公司查询所拥有的课程*/SELECT * FROM xc_course.course_base WHERE company_id = &apos;1&apos; 3.3.2 Api定义我的课程查询接口如下： 123public QueryResponseResult&lt;CourseInfo&gt; findCourseList(int page, int size, CourseListRequest courseListRequest); 3.3.3 Dao修改 CourseMapper.xml的查询课程列表，添加companyId条件。 123456789101112&lt;select id=&quot;findCourseListPage&quot; resultType=&quot;com.xuecheng.framework.domain.course.ext.CourseInfo&quot; parameterType=&quot;com.xuecheng.framework.domain.course.request.CourseListRequest&quot;&gt; SELECT course_base.*, (SELECT pic FROM course_pic WHERE courseid = course_base.id) pic FROM course_base where 1=1 &lt;if test=&quot;companyId!=null and companyId!=&apos;&apos;&quot;&gt; and course_base.company_id = #&#123;companyId&#125; &lt;/if&gt;&lt;/select&gt; 3.3.4 Service修改CourseService的findCourseList方法，添加companyId参数，并且传给dao. 1234567891011121314151617181920212223public QueryResult&lt;CourseInfo&gt; findCourseList(String companyId,int page,int size,CourseListRequest courseListRequest) &#123; if(courseListRequest == null)&#123; courseListRequest = new CourseListRequest(); &#125; //企业id courseListRequest.setCompanyId(companyId); //将companyId传给dao courseListRequest.setCompanyId(companyId); if(page&lt;=0)&#123; page = 0; &#125; if(size&lt;=0)&#123; size = 20; &#125; PageHelper.startPage(page, size); Page&lt;CourseInfo&gt; courseListPage = courseMapper.findCourseListPage(courseListRequest); List&lt;CourseInfo&gt; list = courseListPage.getResult(); long total = courseListPage.getTotal(); QueryResult&lt;CourseInfo&gt; courseIncfoQueryResult = new QueryResult&lt;CourseInfo&gt;(); courseIncfoQueryResult.setList(list); courseIncfoQueryResult.setTotal(total); return courseIncfoQueryResult;&#125; 3.3.5 Controller修改CourseController的findCourseList，向service传入companyId 这里先使用静态数据测试使用。 12345678910@Override@GetMapping(&quot;/coursebase/list/&#123;page&#125;/&#123;size&#125;&quot;) public QueryResult&lt;CourseInfo&gt; findCourseList(@PathVariable(&quot;page&quot;) int page, @PathVariable(&quot;size&quot;) int size, CourseListRequest courseListRequest) &#123; //先使用静态数据测试 String companyId = &quot;1&quot;; return courseService.findCourseList(companyId,page,size,courseListRequest); &#125; 3.3.5 测试1、用户登录 由于使用了静态数据companyId为1，所以要使用企业编号为1的下边的用户去登录。 2、进入我的课程，查看数据是否正确。 观察所查询到的课程是该企业下的课程。 3.4 获取当前用户信息3.4.1需求分析要想实现只查询自己的课程信息则需要获取当前用户所属的企业id。 1、认证服务在用户认证通过将用户所属公司id等信息存储到jwt令牌中。 2、用户请求到达资源服务后，资源服务需要取出header中的jwt令牌，并解析出用户信息。 3.4.2 jwt令牌包括企业Id资源服务在授权时需要用到用户所属企业ID，需要实现认证服务生成的JWT令牌中包括用户所属公司id信息。 查看认证服务UserDetailServiceImpl代码如下： 123456789101112//用户iduserDetails.setId(userext.getId());//用户名称userDetails.setName(userext.getName());//用户头像userDetails.setUserpic(userext.getUserpic());//用户类型userDetails.setUtype(userext.getUtype());//用户所属企业iduserDetails.setCompanyId(userext.getCompanyId()); return userDetails; 通过上边代码的分析得知，认证服务调用XcUserExt userext = userClient.getUserext(username);获取用户信息，将userext 中的信息存储到jwt令牌中，在userext 对象中已经包括了companyId公司ID等信息。 3.4.3获取当前用户3.4.3.1 JWT解析工具类1、在Oauth2Util工具类中，从header中取出JWT令牌，并解析JWT令牌的内容。 123456789101112131415161718192021222324252627public class Oauth2Util &#123; public static Map&lt;String,String&gt; getJwtClaimsFromHeader(HttpServletRequest request) &#123; if (request == null) &#123; return null; &#125; //取出头信息 String authorization = request.getHeader(&quot;Authorization&quot;); if (StringUtils.isEmpty(authorization) || authorization.indexOf(&quot;Bearer&quot;) &lt; 0) &#123; return null; &#125; //从Bearer 后边开始取出token String token = authorization.substring(7); Map&lt;String,String&gt; map = null; try &#123; //解析jwt Jwt decode = JwtHelper.decode(token); //得到 jwt中的用户信息 String claims = decode.getClaims(); //将jwt转为Map map = JSON.parseObject(claims, Map.class); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return map; &#125;&#125; 2、在XcOauth2Util工具类中，将解析的JWT内容封装成UserJwt对象返回。 1234567891011121314151617181920212223242526public class XcOauth2Util &#123; public UserJwt getUserJwtFromHeader(HttpServletRequest request)&#123; Map&lt;String, String&gt; jwtClaims = Oauth2Util.getJwtClaimsFromHeader(request); if(jwtClaims == null || StringUtils.isEmpty(jwtClaims.get(&quot;id&quot;)))&#123; return null; &#125; UserJwt userJwt = new UserJwt(); userJwt.setId(jwtClaims.get(&quot;id&quot;)); userJwt.setName(jwtClaims.get(&quot;name&quot;)); userJwt.setCompanyId(jwtClaims.get(&quot;companyId&quot;)); userJwt.setUtype(jwtClaims.get(&quot;utype&quot;)); userJwt.setUserpic(jwtClaims.get(&quot;userpic&quot;)); return userJwt; &#125; @Data public class UserJwt&#123; private String id; private String name; private String userpic; private String utype; private String companyId; &#125;&#125; 3.4.3.2 获取当前用户修改课程管理的CourseController类，将companyId的静态数据改为动态获取： 1234567891011121314@Overridepublic QueryResult&lt;CourseInfo&gt; findCourseList(@PathVariable(&quot;page&quot;) int page, @PathVariable(&quot;size&quot;) int size, CourseListRequest courseListRequest) &#123; //调用工具类取出用户信息 XcOauth2Util xcOauth2Util = new XcOauth2Util(); XcOauth2Util.UserJwt userJwt = xcOauth2Util.getUserJwtFromHeader(request); if(userJwt == null)&#123; ExceptionCast.cast(CommonCode.UNAUTHENTICATED); &#125; String companyId = userJwt.getCompanyId(); return courseService.findCourseList(companyId,page,size,courseListRequest);&#125; 3.4.4 测试使用不同的用户登录系统，测试细粒度权限控制效果。 预期结果：每个用户只查询自己所拥有的课程。 4 微服务之间认证4.1 需求分析前边章节已经实现了用户携带身份令牌和JWT令牌访问微服务，微服务获取jwt并完成授权。 当微服务访问微服务，此时如果没有携带JWT则微服务会在授权时报错。 测试课程预览： 1、将课程管理服务和CMS全部添加授权配置 2、用户登录教学管理前端，进入课程发布界面，点击课程发布，观察课程管理服务端报错如下： 123feign.FeignException: status 401 reading CmsPageClient#save(CmsPage); content:&#123;&quot;error&quot;:&quot;unauthorized&quot;,&quot;error_description&quot;:&quot;Full authentication is required to access this resource&quot;&#125; 分析原因： ​ 由于课程管理访问CMS时没有携带JWT令牌导致。 解决方案： ​ 微服务之间进行调用时需携带JWT。 4.2 Feign 拦截器4.2.1 定义Feign拦截器​ 微服务之间使用feign进行远程调用，采用feign拦截器实现远程调用携带JWT。 在common工程添加依赖： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt; 在Common工程定义拦截器如下： 12345678910111213141516171819202122232425262728293031package com.xuecheng.framework.interceptor;public class FeignClientInterceptor implements RequestInterceptor &#123; @Override public void apply(RequestTemplate requestTemplate) &#123; try &#123; //使用RequestContextHolder工具获取request相关变量 ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes(); if(attributes!=null)&#123; //取出request HttpServletRequest request = attributes.getRequest(); Enumeration&lt;String&gt; headerNames = request.getHeaderNames(); if (headerNames != null) &#123; while (headerNames.hasMoreElements()) &#123; String name = headerNames.nextElement(); String values = request.getHeader(name); if(name.equals(&quot;authorization&quot;))&#123; //System.out.println(&quot;name=&quot;+name+&quot;values=&quot;+values); requestTemplate.header(name, values); &#125; &#125; &#125; &#125; &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 4.2.2 使用Feign拦截器本例子中课程管理调用cms需要携带jwt，所以需要在课程管理中定义Feign拦截器bean，在启动类中定义bean如下： 1234@Beanpublic FeignClientInterceptor feignClientInterceptor()&#123; return new FeignClientInterceptor();&#125; 4.2.3 测试执行课程发布，提示发布成功。]]></content>
      <categories>
        <category>项目实战-在线学习视频网站</category>
      </categories>
      <tags>
        <tag>方法授权</tag>
        <tag>权限数据模型</tag>
        <tag>细粒度授权</tag>
        <tag>服务间的认证</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在线学习视频（十五）—— 媒资管理]]></title>
    <url>%2Fday14%20%E5%AA%92%E8%B5%84%E7%AE%A1%E7%90%86.html</url>
    <content type="text"><![CDATA[媒资管理1 视频处理1.1需求分析​ 原始视频通常需要经过编码处理，生成m3u8和ts文件方可基于HLS协议播放视频。通常用户上传原始视频，系统自动处理成标准格式，系统对用户上传的视频自动编码、转换，最终生成m3u8文件和ts文件，处理流程如下： 1、用户上传视频成功 2、系统对上传成功的视频自动开始编码处理 3、用户查看视频处理结果，没有处理成功的视频用户可在管理界面再次触发处理 4、视频处理完成将视频地址及处理结果保存到数据库 视频处理流程如下： 视频处理进程的任务是接收视频处理消息进行视频处理，业务流程如下： 1、监听MQ，接收视频处理消息。 2、进行视频处理。 3、向数据库写入视频处理结果。 视频处理进程属于媒资管理系统的一部分，考虑提高系统的扩展性，将视频处理单独定义视频处理工程。 1.2 视频处理开发1.2.1 视频处理工程创建1、导入“资料”下的视频处理工程：xc-service-manage-media-processor 2、RabbitMQ配置 使用rabbitMQ的routing交换机模式，视频处理程序监听视频处理队列，如下图： RabbitMQ配置如下： 123456789101112131415161718192021222324252627282930313233343536373839@Configurationpublic class RabbitMQConfig &#123; public static final String EX_MEDIA_PROCESSTASK = &quot;ex_media_processor&quot;; //视频处理队列 @Value(&quot;$&#123;xc-service-manage-media.mq.queue-media-video-processor&#125;&quot;) public String queue_media_video_processtask; //视频处理路由 @Value(&quot;$&#123;xc-service-manage-media.mq.routingkey-media-video&#125;&quot;) public String routingkey_media_video; /** * 交换机配置 * @return the exchange */ @Bean(EX_MEDIA_PROCESSTASK) public Exchange EX_MEDIA_VIDEOTASK() &#123; return ExchangeBuilder.directExchange(EX_MEDIA_PROCESSTASK).durable(true).build(); &#125; //声明队列 @Bean(&quot;queue_media_video_processtask&quot;) public Queue QUEUE_PROCESSTASK() &#123; Queue queue = new Queue(queue_media_video_processtask,true,false,true); return queue; &#125; /** * 绑定队列到交换机 . * @param queue the queue * @param exchange the exchange * @return the binding */ @Bean public Binding binding_queue_media_processtask(@Qualifier(&quot;queue_media_video_processtask&quot;) Queue queue, @Qualifier(EX_MEDIA_PROCESSTASK) Exchange exchange) &#123; return BindingBuilder.bind(queue).to(exchange).with(routingkey_media_video).noargs(); &#125;&#125; 在application.yml中配置队列名称及routingkey 1234xc-service-manage-media: mq: queue-media-video-processor: queue_media_video_processor routingkey-media-video: routingkey_media_video 1.2.2 视频处理技术方案如何通过程序进行视频处理？ ffmpeg是一个可行的视频处理程序，可以通过Java调用ffmpeg.exe完成视频处理。 在java中可以使用Runtime类和Process Builder类两种方式来执行外部程序，工作中至少掌握一种。 本项目使用Process Builder的方式来调用ffmpeg完成视频处理。 关于Process Builder的测试如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475 @Test public void testProcessBuilder()&#123; ProcessBuilder processBuilder = new ProcessBuilder();// processBuilder.command(&quot;ping&quot;,&quot;127.0.0.1&quot;); processBuilder.command(&quot;ipconfig&quot;); //将标准输入流和错误输入流合并，通过标准输入流读取信息 processBuilder.redirectErrorStream(true); try &#123; //启动进程 Process start = processBuilder.start(); //获取输入流 InputStream inputStream = start.getInputStream(); //转成字符输入流 InputStreamReader inputStreamReader = new InputStreamReader(inputStream,&quot;gbk&quot;); int len = -1; char[] c = new char[1024]; StringBuffer outputString = new StringBuffer(); //读取进程输入流中的内容 while ((len= inputStreamReader.read(c))!=-1) &#123; String s = new String(c,0,len); outputString.append(s); System.out.print(s); &#125; inputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; @Test public void testFFmpeg()&#123; ProcessBuilder processBuilder = new ProcessBuilder(); //定义命令内容 List&lt;String&gt; command = new ArrayList&lt;&gt;(); command.add(&quot;D:\\Program Files\\ffmpeg-20180227-fa0c9d6-win64-static\\bin\\ffmpeg.exe&quot;); command.add(&quot;-i&quot;); command.add(&quot;E:\\ffmpeg_test\\1.avi&quot;); command.add(&quot;-y&quot;);//覆盖输出文件 command.add(&quot;-c:v&quot;); command.add(&quot;libx264&quot;); command.add(&quot;-s&quot;); command.add(&quot;1280x720&quot;); command.add(&quot;-pix_fmt&quot;); command.add(&quot;yuv420p&quot;); command.add(&quot;-b:a&quot;); command.add(&quot;63k&quot;); command.add(&quot;-b:v&quot;); command.add(&quot;753k&quot;); command.add(&quot;-r&quot;); command.add(&quot;18&quot;); command.add(&quot;E:\\ffmpeg_test\\1.mp4&quot;); processBuilder.command(command); //将标准输入流和错误输入流合并，通过标准输入流读取信息 processBuilder.redirectErrorStream(true); try &#123; //启动进程 Process start = processBuilder.start(); //获取输入流 InputStream inputStream = start.getInputStream(); //转成字符输入流 InputStreamReader inputStreamReader = new InputStreamReader(inputStream,&quot;gbk&quot;); int len = -1; char[] c = new char[1024]; StringBuffer outputString = new StringBuffer(); //读取进程输入流中的内容 while ((len= inputStreamReader.read(c))!=-1) &#123; String s = new String(c,0,len); outputString.append(s); System.out.print(s); &#125; inputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; 上边的代码已经封装成工具类，参见： 上边的工具类中： Mp4VideoUtil.java完成avi转mp4 HlsVideoUtil.java完成mp4转hls 分别测试每个工具类的使用方法。 123456789101112131415public static void main(String[] args) throws IOException &#123; //ffmpeg的路径 String ffmpeg_path = &quot;D:\\Program Files\\ffmpeg-20180227-fa0c9d6-win64-static\\bin\\ffmpeg.exe&quot;;//ffmpeg的安装位置 //源avi视频的路径 String video_path = &quot;E:\\ffmpeg_test\\1.avi&quot;; //转换后mp4文件的名称 String mp4_name = &quot;1.mp4&quot;; //转换后mp4文件的路径 String mp4_path = &quot;E:\\ffmpeg_test\\&quot;; //创建工具类对象 Mp4VideoUtil videoUtil = new Mp4VideoUtil(ffmpeg_path,video_path,mp4_name,mp4_path); //开始视频转换，成功将返回success String s = videoUtil.generateMp4(); System.out.println(s);&#125; 1.2.3 视频处理实现1.2.3.1确定消息格式MQ消息统一采用json格式，视频处理生产方会向MQ发送如下消息，视频处理消费方接收此消息后进行视频处理： ｛“mediaId”:XXX｝ 1.2.3.2处理流程1）接收视频处理消息 2）判断媒体文件是否需要处理（本视频处理程序目前只接收avi视频的处理） 当前只有avi文件需要处理，其它文件需要更新处理状态为“无需处理”。 3）处理前初始化处理状态为“未处理” 4）处理失败需要在数据库记录处理日志，及处理状态为“处理失败” 5）处理成功记录处理状态为“处理成功” 1.2.3.3数据模型在MediaFile类中添加mediaFileProcess_m3u8属性记录ts文件列表，代码如下： 1234//处理状态private String processStatus;//hls处理private MediaFileProcess_m3u8 mediaFileProcess_m3u8; 123456@Data@ToStringpublic class MediaFileProcess_m3u8 extends MediaFileProcess &#123; //ts列表 private List&lt;String&gt; tslist;&#125; 1.2.3.4 视频处理生成Mp41、创建Dao 视频处理结果需要保存到媒资数据库，创建dao如下：123public interface MediaFileRepository extends MongoRepository&lt;MediaFile,String&gt; &#123;&#125; 2、在application.yml中配置ffmpeg的位置及视频目录的根目录： 123xc-service-manage-media: video-location: F:/develop/video/ ffmpeg-path: D:/Program Files/ffmpeg-20180227-fa0c9d6-win64-static/bin/ffmpeg.exe 3、处理任务类 在mq包下创建MediaProcessTask类，此类负责监听视频处理队列，并进行视频处理。 整个视频处理内容较多，这里分两部分实现：生成Mp4和生成m3u8，下边代码实现了生成mp4。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859@Componentpublic class MediaProcessTask &#123; private static final Logger LOGGER = LoggerFactory.getLogger(MediaProcessTask.class); //ffmpeg绝对路径 @Value(&quot;$&#123;xc-service-manage-media.ffmpeg-path&#125;&quot;) String ffmpeg_path; //上传文件根目录 @Value(&quot;$&#123;xc-service-manage-media.upload-location&#125;&quot;) String serverPath; @Autowired MediaFileRepository mediaFileRepository; @RabbitListener(queues = &quot;$&#123;xc-service-manage-media.mq.queue-media-processtask&#125;&quot;) public void receiveMediaProcessTask(String msg) throws IOException &#123; Map msgMap = JSON.parseObject(msg, Map.class); LOGGER.info(&quot;receive media process task msg :&#123;&#125; &quot;,msgMap); //解析消息 //媒资文件id String mediaId = (String) msgMap.get(&quot;mediaId&quot;); //获取媒资文件信息 Optional&lt;MediaFile&gt; optional = mediaFileRepository.findById(fileMd5); if(！optional.isPresent())&#123; return ; &#125; MediaFile mediaFile = optional.get(); //媒资文件类型 String fileType = mediaFile.getFileType(); if(fileType == null || !fileType.equals(&quot;avi&quot;))&#123;//目前只处理avi文件 mediaFile.setProcessStatus(&quot;303004&quot;);//处理状态为无需处理 mediaFileRepository.save(mediaFile); return ; &#125;else&#123; mediaFile.setProcessStatus(&quot;303001&quot;);//处理状态为未处理 mediaFileRepository.save(mediaFile); &#125; //生成mp4 String video_path = serverPath + mediaFile.getFilePath()+mediaFile.getFileName(); String mp4_name = mediaFile.getFileId()+&quot;.mp4&quot;; String mp4folder_path = serverPath + mediaFile.getFilePath(); Mp4VideoUtil videoUtil = new Mp4VideoUtil(ffmpeg_path,video_path,mp4_name,mp4folder_path); String result = videoUtil.generateMp4(); if(result == null || !result.equals(&quot;success&quot;))&#123; //操作失败写入处理日志 mediaFile.setProcessStatus(&quot;303003&quot;);//处理状态为处理失败 MediaFileProcess_m3u8 mediaFileProcess_m3u8 = new MediaFileProcess_m3u8(); mediaFileProcess_m3u8.setErrormsg(result); mediaFile.setMediaFileProcess_m3u8(mediaFileProcess_m3u8); mediaFileRepository.save(mediaFile); return ; &#125; //生成m3u8... &#125;&#125; 说明： 1、原始视频转成mp4如何判断转换成功？ 根据视频时长来判断，取原视频和转换成功视频的时长（时分秒），如果相等则相同。 1.2.3.5 视频处理生成m3u8下边是完整的视频处理任务类代码，包括了生成m3u8及生成mp4的代码。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283@Componentpublic class MediaProcessTask &#123; private static final Logger LOGGER = LoggerFactory.getLogger(MediaProcessTask.class); //ffmpeg绝对路径 @Value(&quot;$&#123;xc-service-manage-media.ffmpeg-path&#125;&quot;) String ffmpeg_path; //上传文件根目录 @Value(&quot;$&#123;xc-service-manage-media.upload-location&#125;&quot;) String serverPath; @Autowired MediaFileRepository mediaFileRepository; @RabbitListener(queues = &quot;$&#123;xc-service-manage-media.mq.queue-media-processtask&#125;&quot;) public void receiveMediaProcessTask(String msg) throws IOException &#123; Map msgMap = JSON.parseObject(msg, Map.class); LOGGER.info(&quot;receive media process task msg :&#123;&#125; &quot;,msgMap); //解析消息 //媒资文件id String mediaId = (String) msgMap.get(&quot;mediaId&quot;); //获取媒资文件信息 Optional&lt;MediaFile&gt; optional = mediaFileRepository.findById(fileMd5); if(！optional.isPresent())&#123; return ; &#125; MediaFile mediaFile = optional.get(); //媒资文件类型 String fileType = mediaFile.getFileType(); if(fileType == null || !fileType.equals(&quot;avi&quot;))&#123;//目前只处理avi文件 mediaFile.setProcessStatus(&quot;303004&quot;);//处理状态为无需处理 mediaFileRepository.save(mediaFile); return ; &#125;else&#123; mediaFile.setProcessStatus(&quot;303001&quot;);//处理状态为未处理 mediaFileRepository.save(mediaFile); &#125; //生成mp4 String video_path = serverPath + mediaFile.getFilePath()+mediaFile.getFileName(); String mp4_name = mediaFile.getFileId()+&quot;.mp4&quot;; String mp4folder_path = serverPath + mediaFile.getFilePath(); Mp4VideoUtil videoUtil = new Mp4VideoUtil(ffmpeg_path,video_path,mp4_name,mp4folder_path); String result = videoUtil.generateMp4(); if(result == null || !result.equals(&quot;success&quot;))&#123; //操作失败写入处理日志 mediaFile.setProcessStatus(&quot;303003&quot;);//处理状态为处理失败 MediaFileProcess_m3u8 mediaFileProcess_m3u8 = new MediaFileProcess_m3u8(); mediaFileProcess_m3u8.setErrormsg(result); mediaFile.setMediaFileProcess_m3u8(mediaFileProcess_m3u8); mediaFileRepository.save(mediaFile); return ; &#125; //生成m3u8 video_path = serverPath + mediaFile.getFilePath()+mp4_name;//此地址为mp4的地址 String m3u8_name = mediaFile.getFileId()+&quot;.m3u8&quot;; String m3u8folder_path = serverPath + mediaFile.getFilePath()+&quot;hls/&quot;; HlsVideoUtil hlsVideoUtil = new HlsVideoUtil(ffmpeg_path,video_path,m3u8_name,m3u8folder_path); result = hlsVideoUtil.generateM3u8(); if(result == null || !result.equals(&quot;success&quot;))&#123; //操作失败写入处理日志 mediaFile.setProcessStatus(&quot;303003&quot;);//处理状态为处理失败 MediaFileProcess_m3u8 mediaFileProcess_m3u8 = new MediaFileProcess_m3u8(); mediaFileProcess_m3u8.setErrormsg(result); mediaFile.setMediaFileProcess_m3u8(mediaFileProcess_m3u8); mediaFileRepository.save(mediaFile); return ; &#125; //获取m3u8列表 List&lt;String&gt; ts_list = hlsVideoUtil.get_ts_list(); //更新处理状态为成功 mediaFile.setProcessStatus(&quot;303002&quot;);//处理状态为处理成功 MediaFileProcess_m3u8 mediaFileProcess_m3u8 = new MediaFileProcess_m3u8(); mediaFileProcess_m3u8.setTslist(ts_list); mediaFile.setMediaFileProcess_m3u8(mediaFileProcess_m3u8); //m3u8文件url mediaFile.setFileUrl(mediaFile.getFilePath()+&quot;hls/&quot;+m3u8_name); mediaFileRepository.save(mediaFile); &#125;&#125; 说明： mp4转成m3u8如何判断转换成功？ 第一、根据视频时长来判断，同mp4转换成功的判断方法。 第二、最后还要判断m3u8文件内容是否完整。 1.3 发送视频处理消息当视频上传成功后向MQ 发送视频 处理消息。 修改媒资管理服务的文件上传代码，当文件上传成功向MQ发送视频处理消息。 1.3.1 RabbitMQ配置1、将media-processor工程下的RabbitmqConfig配置类拷贝到media工程下。 2、在media工程下配置mq队列等信息 修改application.yml 1234xc-service-manage-media: mq: queue-media-video-processor: queue_media_video_processor routingkey-media-video: routingkey_media_video 1.3.2 修改Service在文件合并方法中添加向mq发送视频处理消息的代码： 1234567891011121314151617181920212223//向MQ发送视频处理消息public ResponseResult sendProcessVideoMsg(String mediaId)&#123; Optional&lt;MediaFile&gt; optional = mediaFileRepository.findById(fileMd5); if(！optional.isPresent())&#123; return new ResponseResult(CommonCode.FAIL); &#125; MediaFile mediaFile = optional.get(); //发送视频处理消息 Map&lt;String,String&gt; msgMap = new HashMap&lt;&gt;(); msgMap.put(&quot;mediaId&quot;,mediaId); //发送的消息 String msg = JSON.toJSONString(msgMap); try &#123; this.rabbitTemplate.convertAndSend(RabbitMQConfig.EX_MEDIA_PROCESSTASK,routingkey_media_video, msg); LOGGER.info(&quot;send media process task msg:&#123;&#125;&quot;,msg); &#125;catch (Exception e)&#123; e.printStackTrace(); LOGGER.info(&quot;send media process task error,msg is:&#123;&#125;,error:&#123;&#125;&quot;,msg,e.getMessage()); return new ResponseResult(CommonCode.FAIL); &#125; return new ResponseResult(CommonCode.SUCCESS);&#125; 在mergechunks方法最后调用sendProcessVideo方法。 1234567//状态为上传成功mediaFile.setFileStatus(&quot;301002&quot;);mediaFileRepository.save(mediaFile);String mediaId = mediaFile.getFileId();//向MQ发送视频处理消息sendProcessVideoMsg(mediaId); 1.4 视频处理测试测试流程： 1、上传avi文件 2、观察日志是否发送消息 3、观察视频处理进程是否接收到消息进行处理 4、观察mp4文件是否生成 5、观察m3u8及 ts文件是否生成 1.5 视频处理并发设置代码中使用@RabbitListener注解指定消费方法，默认情况是单线程监听队列，可以观察当队列有多个任务时消费端每次只消费一个消息，单线程处理消息容易引起消息处理缓慢，消息堆积，不能最大利用硬件资源。 可以配置mq的容器工厂参数，增加并发处理数量即可实现多线程处理监听队列，实现多线程处理消息。 1、在RabbitmqConfig.java中添加容器工厂配置： 1234567891011//消费者并发数量public static final int DEFAULT_CONCURRENT = 10;@Bean(&quot;customContainerFactory&quot;)public SimpleRabbitListenerContainerFactory containerFactory(SimpleRabbitListenerContainerFactoryConfigurer configurer, ConnectionFactory connectionFactory) &#123; SimpleRabbitListenerContainerFactory factory = new SimpleRabbitListenerContainerFactory(); factory.setConcurrentConsumers(DEFAULT_CONCURRENT); factory.setMaxConcurrentConsumers(DEFAULT_CONCURRENT); configurer.configure(factory, connectionFactory); return factory;&#125; 2、在@RabbitListener注解中指定容器工厂 123//视频处理方法@RabbitListener(queues = &#123;&quot;$&#123;xc-service-manage-media.mq.queue-media-video-processor&#125;&quot;&#125;, containerFactory=&quot;customContainerFactory&quot;) 再次测试当队列有多个任务时消费端的并发处理能力。 2 我的媒资2.1 需求分析通过我的媒资可以查询本教育机构拥有的媒资文件，进行文件处理、删除文件、修改文件信息等操作，具体需求如下： 1、分页查询我的媒资文件 2、删除媒资文件 3、处理媒资文件 4、修改媒资文件信息 2.2 API本节讲解我的媒资文件分页查询、处理媒资文件，其它功能请学员自行实现。 12345678@Api(value = &quot;媒体文件管理&quot;,description = &quot;媒体文件管理接口&quot;,tags = &#123;&quot;媒体文件管理接口&quot;&#125;)public interface MediaFileControllerApi &#123; @ApiOperation(&quot;查询文件列表&quot;) public QueryResponseResult findList(int page, int size, QueryMediaFileRequest queryMediaFileRequest) ;&#125; 2.3 服务端开发2.3.1 Dao1234@Repositorypublic interface MediaFileDao extends MongoRepository&lt;MediaFile,String&gt; &#123;&#125; 2.3.2 Service定义findList方法实现媒资文件查询列表。 123456789101112131415161718192021222324252627282930313233343536373839404142434445@Servicepublic class MediaFileService &#123; private static Logger logger = LoggerFactory.getLogger(MediaFileService.class); @Autowired MediaFileRepository mediaFileRepository; //文件列表分页查询 public QueryResponseResult findList(int page,int size,QueryMediaFileRequest queryMediaFileRequest)&#123; //查询条件 MediaFile mediaFile = new MediaFile(); if(queryMediaFileRequest == null)&#123; queryMediaFileRequest = new QueryMediaFileRequest(); &#125; //查询条件匹配器 ExampleMatcher matcher = ExampleMatcher.matching() .withMatcher(&quot;tag&quot;, ExampleMatcher.GenericPropertyMatchers.contains())//tag字段模糊匹配 .withMatcher(&quot;fileOriginalName&quot;, ExampleMatcher.GenericPropertyMatchers.contains())//文件原始名称模糊匹配 .withMatcher(&quot;processStatus&quot;, ExampleMatcher.GenericPropertyMatchers.exact());//处理状态精确匹配（默认） //查询条件对象 if(StringUtils.isNotEmpty(queryMediaFileRequest.getTag()))&#123; mediaFile.setTag(queryMediaFileRequest.getTag()); &#125; if(StringUtils.isNotEmpty(queryMediaFileRequest.getFileOriginalName()))&#123; mediaFile.setFileOriginalName(queryMediaFileRequest.getFileOriginalName()); &#125; if(StringUtils.isNotEmpty(queryMediaFileRequest.getProcessStatus()))&#123; mediaFile.setProcessStatus(queryMediaFileRequest.getProcessStatus()); &#125; //定义example实例 Example&lt;MediaFile&gt; ex = Example.of(mediaFile, matcher); page = page-1; //分页参数 Pageable pageable = new PageRequest(page, size); //分页查询 Page&lt;MediaFile&gt; all = mediaFileRepository.findAll(ex,pageable); QueryResult&lt;MediaFile&gt; mediaFileQueryResult = new QueryResult&lt;MediaFile&gt;(); mediaFileQueryResult.setList(all.getContent()); mediaFileQueryResult.setTotal(all.getTotalElements()); return new QueryResponseResult(CommonCode.SUCCESS,mediaFileQueryResult); &#125;&#125; 2.3.3 Controller123456789101112131415161718@RestController@RequestMapping(&quot;/media/file&quot;)public class MediaFileController implements MediaFileControllerApi &#123; @Autowired MediaFileService mediaFileService; @Autowired MediaUploadService mediaUploadService; @Override @GetMapping(&quot;/list/&#123;page&#125;/&#123;size&#125;&quot;) public QueryResponseResult findList(@PathVariable(&quot;page&quot;) int page, @PathVariable(&quot;size&quot;) int size, QueryMediaFileRequest queryMediaFileRequest) &#123; //媒资文件查询 return mediaFileService.findList(page,size,queryMediaFileRequest); &#125;&#125; 2.4 前端开发2.4.1 API方法在media模块定义api方法如下：123456789101112131415import http from &apos;./../../../base/api/public&apos;import querystring from &apos;querystring&apos;let sysConfig = require(&apos;@/../config/sysConfig&apos;)let apiUrl = sysConfig.xcApiUrlPre;/*页面列表*/export const media_list = (page,size,params) =&gt; &#123; //params为json格式 //使用querystring将json对象转成key/value串 let querys = querystring.stringify(params) return http.requestQuickGet(apiUrl+&apos;/media/file/list/&apos;+page+&apos;/&apos;+size+&apos;/?&apos;+querys)&#125;/*发送处理消息*/export const media_process = (id) =&gt; &#123; return http.requestPost(apiUrl+&apos;/media/file/process/&apos;+id)&#125; 2.4.2 页面在media模块创建media_list.vue，可参考cms系统的page_list.vue来编写此页面。 1、视图 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;template&gt; &lt;div&gt; &lt;!--查询表单--&gt; &lt;el-form :model=&quot;params&quot;&gt; 标签： &lt;el-input v-model=&quot;params.tag&quot; style=&quot;width:160px&quot;&gt;&lt;/el-input&gt; 原始名称： &lt;el-input v-model=&quot;params.fileOriginalName&quot; style=&quot;width:160px&quot;&gt;&lt;/el-input&gt; 处理状态： &lt;el-select v-model=&quot;params.processStatus&quot; placeholder=&quot;请选择处理状态&quot;&gt; &lt;el-option v-for=&quot;item in processStatusList&quot; :key=&quot;item.id&quot; :label=&quot;item.name&quot; :value=&quot;item.id&quot;&gt; &lt;/el-option&gt; &lt;/el-select&gt; &lt;br/&gt; &lt;el-button type=&quot;primary&quot; v-on:click=&quot;query&quot; size=&quot;small&quot;&gt;查询&lt;/el-button&gt; &lt;router-link class=&quot;mui-tab-item&quot; :to=&quot;&#123;path:&apos;/media/upload&apos;&#125;&quot;&gt; &lt;el-button type=&quot;primary&quot; size=&quot;small&quot; &gt;上传文件&lt;/el-button&gt; &lt;/router-link&gt; &lt;/el-form&gt; &lt;!--列表--&gt; &lt;el-table :data=&quot;list&quot; highlight-current-row v-loading=&quot;listLoading&quot; style=&quot;width: 100%;&quot;&gt; &lt;el-table-column type=&quot;index&quot; width=&quot;30&quot;&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;fileOriginalName&quot; label=&quot;原始文件名称&quot; width=&quot;220&quot;&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;fileName&quot; label=&quot;文件名称&quot; width=&quot;220&quot;&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;fileUrl&quot; label=&quot;访问url&quot; width=&quot;260&quot;&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;tag&quot; label=&quot;标签&quot; width=&quot;100&quot;&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;fileSize&quot; label=&quot;文件大小&quot; width=&quot;120&quot;&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;processStatus&quot; label=&quot;处理状态&quot; width=&quot;100&quot; :formatter=&quot;formatProcessStatus&quot;&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;uploadTime&quot; label=&quot;创建时间&quot; width=&quot;110&quot; :formatter=&quot;formatCreatetime&quot;&gt; &lt;/el-table-column&gt; &lt;el-table-column label=&quot;开始处理&quot; width=&quot;100&quot; &gt; &lt;template slot-scope=&quot;scope&quot;&gt; &lt;el-button size=&quot;small&quot; type=&quot;primary&quot; plain @click=&quot;process(scope.row.fileId)&quot;&gt;开始处理 &lt;/el-button&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; &lt;!--分页--&gt; &lt;el-col :span=&quot;24&quot; class=&quot;toolbar&quot;&gt; &lt;el-pagination background layout=&quot;prev, pager, next&quot; @current-change=&quot;changePage&quot; :page-size=&quot;this.params.size&quot; :total=&quot;total&quot; :current-page=&quot;this.params.page&quot; style=&quot;float:right;&quot;&gt; &lt;/el-pagination&gt; &lt;/el-col&gt; &lt;/div&gt;&lt;/template&gt; 2、数据对象 12345678910111213141516171819import * as mediaApi from &apos;../api/media&apos;import utilApi from &apos;@/common/utils&apos;;export default&#123; data()&#123; return &#123; params:&#123; page:1,//页码 size:2,//每页显示个数 tag:&apos;&apos;,//标签 fileName:&apos;&apos;,//文件名称 processStatus:&apos;&apos;//处理状态 &#125;, listLoading:false, list:[], total:0, processStatusList:[] &#125; &#125; 。。。 3、方法123456789101112131415161718192021222324252627282930313233343536373839404142434445methods:&#123; formatCreatetime(row, column)&#123; var createTime = new Date(row.uploadTime); if (createTime) &#123; return utilApi.formatDate(createTime, &apos;yyyy-MM-dd hh:mm:ss&apos;); &#125; &#125;, formatProcessStatus(row,column)&#123; var processStatus = row.processStatus; if (processStatus) &#123; if(processStatus == &apos;303001&apos;)&#123; return &quot;处理中&quot;; &#125;else if(processStatus == &apos;303002&apos;)&#123; return &quot;处理成功&quot;; &#125;else if(processStatus == &apos;303003&apos;)&#123; return &quot;处理失败&quot;; &#125;else if(processStatus == &apos;303004&apos;)&#123; return &quot;无需处理&quot;; &#125; &#125; &#125;, changePage(page)&#123; this.params.page = page; this.query() &#125;, process (id) &#123;// console.log(id) mediaApi.media_process(id).then((res)=&gt;&#123; console.log(res) if(res.success)&#123; this.$message.success(&apos;开始处理，请稍后查看处理结果&apos;); &#125;else&#123; this.$message.error(&apos;操作失败，请刷新页面重试&apos;); &#125; &#125;) &#125;, query()&#123; mediaApi.media_list(this.params.page,this.params.size,this.params).then((res)=&gt;&#123; console.log(res) this.total = res.queryResult.total this.list = res.queryResult.list &#125;) &#125; &#125; 4、钩子方法1234567891011121314151617181920212223242526272829303132created()&#123; //默认第一页 this.params.page = Number.parseInt(this.$route.query.page||1); &#125;, mounted() &#123; //默认查询页面 this.query() //初始化处理状态 this.processStatusList = [ &#123; id:&apos;&apos;, name:&apos;全部&apos; &#125;, &#123; id:&apos;303001&apos;, name:&apos;处理中&apos; &#125;, &#123; id:&apos;303002&apos;, name:&apos;处理成功&apos; &#125;, &#123; id:&apos;303003&apos;, name:&apos;处理失败&apos; &#125;, &#123; id:&apos;303004&apos;, name:&apos;无需处理&apos; &#125; ] &#125;&#125; 3 媒资与课程计划关联3.1需求分析到目前为止，媒资管理已完成文件上传、视频处理、我的媒资功能等基本功能。其它模块已可以使用媒资管理功能，本节要讲解课程计划在编辑时如何选择媒资文件。 操作的业务流程如下： 1、进入课程计划修改页面 2、选择视频 打开媒资文件查询窗口，找到该课程章节的视频，选择此视频。 点击“选择媒资文件”打开媒资文件列表 3、 选择成功后，将在课程管理数据库保存课程计划对应在的课程视频地址。 在课程管理数据库创建表 teachplan_media 存储课程计划与媒资关联信息，如下： 3.2 选择视频3.2.1 Vue父子组件通信上一章已实现了我的媒资页面，所以媒资查询窗口页面不需要再开发，将“我的媒资页面”作为一个组件在修改课程计划页面中引用，如下图： 修改课程计划页面为父组件，我的媒资查询页面为子组件。 问题1： 我的媒资页面在选择媒资文件时不允许显示，比如“视频处理”按钮，该如何控制？ 这时就需要父组件（修改课程计划页面）向子组件（我的媒资页面）传入一个变量，使用此变量来控制当前是否进入选择媒资文件业务，从而控制哪些元素不显示，如下图： 问题2： 在我的媒资页面选择了媒资文件，如何将选择的媒资文件信息传到父组件？ 这时就需要子组件调用父组件的方法来解决此问题，如下图： 3.2.2 父组件（修改课程计划）本节实现功能：在课程计划页面打开我的媒资页面。 1、引入子组件 1234567import mediaList from &apos;@/module/media/page/media_list.vue&apos;; export default &#123; components:&#123; mediaList &#125;, data() &#123; .... 2、使用子组件 在父组件的视图中使用子组件，同时传入变量ischoose，并指定父组件的方法名为choosemedia 这里使用el-dialog 实现弹出窗口。 123&lt;el-dialog title=&quot;选择媒资文件&quot; :visible.sync=&quot;mediaFormVisible&quot;&gt; &lt;media-list v-bind:ischoose=&quot;true&quot; @choosemedia=&quot;choosemedia&quot;&gt;&lt;/media-list&gt;&lt;/el-dialog&gt; 3、choosemedia方法 在父组件中定义choosemedia方法，接收子组件调用，参数包括：媒资文件id、媒资文件的原始名称、媒资文件url123choosemedia(mediaId,fileOriginalName,mediaUrl)&#123; &#125; 4、打开子组件窗口 1）打开子组件窗口按钮定义 12添加“选择视频”按钮：&lt;el-button style=&quot;font-size: 12px;&quot; type=&quot;text&quot; on-click=&#123; () =&gt; this.querymedia(data.id) &#125;&gt;选择视频&lt;/el-button&gt; 效果如下： 2、打开子组件窗口方法 定义querymedia方法： 123456methods: &#123; //打开查询媒资文件窗口，传入课程计划id querymedia(teachplanId)&#123; this.activeTeachplanId = teachplanId; this.mediaFormVisible = true; &#125;, 3.2.3 子组件（我的媒资查询）1、定义ischoose变量，接收父组件传入的ischoose123export default&#123; props: [&apos;ischoose&apos;], data()&#123; 2、父组件传的ischoose变量为 true时表示当前是选择媒资文件业务，需要控制页面元素是否显示 1）ischoose=true，选择按钮显示 123456&lt;el-table-column label=&quot;选择&quot; width=&quot;80&quot; v-if=&quot;ischoose == true&quot;&gt; &lt;template slot-scope=&quot;scope&quot;&gt; &lt;el-button size=&quot;small&quot; type=&quot;primary&quot; plain @click=&quot;choose(scope.row)&quot;&gt;选择&lt;/el-button&gt; &lt;/template&gt;&lt;/el-table-column&gt; 2）ischoose=false，视频处理按钮显示 1234567&lt;el-table-column label=&quot;开始处理&quot; width=&quot;100&quot; v-if=&quot;ischoose != true&quot;&gt; &lt;template slot-scope=&quot;scope&quot;&gt; &lt;el-button size=&quot;small&quot; type=&quot;primary&quot; plain @click=&quot;process(scope.row.fileId)&quot;&gt;开始处理 &lt;/el-button&gt; &lt;/template&gt;&lt;/el-table-column&gt; 3、选择媒资文件方法 用户点击“选择”按钮将向父组件传递媒资文件信息 123456789101112choose(mediaFile)&#123; if(mediaFile.processStatus !=&apos;303002&apos; &amp;&amp; mediaFile.processStatus !=&apos;303004&apos;)&#123; this.$message.error(&apos;该文件未处理，不允许选择&apos;); return ; &#125; if(!mediaFile.fileUrl)&#123; this.$message.error(&apos;该文件的访问url为空，不允许选择&apos;); return ; &#125; //调用父组件的choosemedia方法 this.$emit(&apos;choosemedia&apos;,mediaFile.fileId,mediaFile.fileOriginalName);&#125; 3.3 保存视频信息3.3.1 需求分析​ 用户进入课程计划页面，选择视频，将课程计划与视频信息保存在课程管理数据库中。 用户操作流程： 1、进入课程计划，点击”选择视频“，打开我的媒资查询页面 2、为课程计划选择对应的视频，选择“选择” 3、前端请求课程管理服务保存课程计划与视频信息。 3.3.2 数据模型在课程管理数据库创建表 teachplan_media 存储课程计划与媒资关联信息，如下： 创建teachplanMedia 模型类： 1234567891011121314151617181920212223242526@Data@ToString@Entity@Table(name=&quot;teachplan_media&quot;)@GenericGenerator(name = &quot;jpa-assigned&quot;, strategy = &quot;assigned&quot;)public class TeachplanMedia implements Serializable &#123; private static final long serialVersionUID = -916357110051689485L; @Id @GeneratedValue(generator = &quot;jpa-assigned&quot;) @Column(name=&quot;teachplan_id&quot;) private String teachplanId; @Column(name=&quot;media_id&quot;) private String mediaId; @Column(name=&quot;media_fileoriginalname&quot;) private String mediaFileOriginalName; @Column(name=&quot;media_url&quot;) private String mediaUrl; @Column(name=&quot;courseid&quot;) private String courseId;&#125; 3.3.3 API接口此接口作为前端请求课程管理服务保存课程计划与视频信息的接口： 在课程管理服务增加接口： 12@ApiOperation(&quot;保存媒资信息&quot;)public ResponseResult savemedia(TeachplanMedia teachplanMedia); 3.3.4 服务端开发3.3.3.1 DAO创建TeachplanMediaRepository用于对TeachplanMedia的操作。 12public interface TeachplanMediaRepository extends JpaRepository&lt;TeachplanMedia, String&gt; &#123;&#125; 3.3.3.2 Service123456789101112131415161718192021222324252627282930313233343536//保存媒资信息public ResponseResult savemedia(TeachplanMedia teachplanMedia) &#123; if(teachplanMedia == null)&#123; ExceptionCast.cast(CommonCode.INVALIDPARAM); &#125; //课程计划 String teachplanId = teachplanMedia.getTeachplanId(); //查询课程计划 Optional&lt;Teachplan&gt; optional = teachplanRepository.findById(teachplanId); if(!optional.isPresent())&#123; ExceptionCast.cast(CourseCode.COURSE_MEDIA_TEACHPLAN_ISNULL); &#125; Teachplan teachplan = optional.get(); //只允许为叶子结点课程计划选择视频 String grade = teachplan.getGrade(); if(StringUtils.isEmpty(grade) || !grade.equals(&quot;3&quot;))&#123; ExceptionCast.cast(CourseCode.COURSE_MEDIA_TEACHPLAN_GRADEERROR); &#125; TeachplanMedia one = null; Optional&lt;TeachplanMedia&gt; teachplanMediaOptional = teachplanMediaRepository.findById(teachplanId); if(!teachplanMediaOptional.isPresent())&#123; one = new TeachplanMedia(); &#125;else&#123; one = teachplanMediaOptional.get(); &#125; //保存媒资信息与课程计划信息 one.setTeachplanId(teachplanId); one.setCourseId(teachplanMedia.getCourseId()); one.setMediaFileOriginalName(teachplanMedia.getMediaFileOriginalName()); one.setMediaId(teachplanMedia.getMediaId()); one.setMediaUrl(teachplanMedia.getMediaUrl()); teachplanMediaRepository.save(one); return new ResponseResult(CommonCode.SUCCESS);&#125; 3.3.3.3 Controller12345@Override@PostMapping(&quot;/savemedia&quot;)public ResponseResult savemedia(@RequestBody TeachplanMedia teachplanMedia) &#123; return courseService.savemedia(teachplanMedia);&#125; 3.3.4 前端开发3.3.4.1 API方法定义api方法，调用课程管理服务保存媒资信息接口 1234/*保存媒资信息*/export const savemedia = teachplanMedia =&gt; &#123; return http.requestPost(apiUrl+&apos;/course/savemedia&apos;,teachplanMedia);&#125; 3.3.4.2 API调用在课程视频方法中调用api： 12345678910111213141516171819choosemedia(mediaId,fileOriginalName,mediaUrl)&#123; this.mediaFormVisible = false; //保存课程计划与视频对应关系 let teachplanMedia = &#123;&#125;; teachplanMedia.teachplanId = this.activeTeachplanId; teachplanMedia.mediaId = mediaId; teachplanMedia.mediaFileOriginalName = fileOriginalName; teachplanMedia.mediaUrl = mediaUrl; teachplanMedia.courseId = this.courseid; //保存媒资信息到课程数据库 courseApi.savemedia(teachplanMedia).then(res=&gt;&#123; if(res.success)&#123; this.$message.success(&quot;选择视频成功&quot;) &#125;else&#123; this.$message.error(res.message) &#125; &#125;)&#125;, 3.3.4测试1、向叶子结点课程计划保存媒资信息 操作结果：保存成功 2、向非叶子结点课程计划保存媒资信息 操作结果：保存失败 3.4 查询视频信息3.4.1 需求分析课程计划的视频信息保存后在页面无法查看，本节解决课程计划页面显示相关联的媒资信息。 解决方案： 在获取课程计划树结点信息时将关联的媒资信息一并查询，并在前端显示，下图说明了课程计划显示的区域。 3.4.2 Dao修改课程计划查询的Dao: 1、修改模型 在课程计划结果信息中添加媒资信息 12345678910@Data@ToStringpublic class TeachplanNode extends Teachplan &#123; List&lt;TeachplanNode&gt; children; //媒资信息 private String mediaId; private String mediaFileOriginalName;&#125; 2、修改sql语句，添加关联查询媒资信息 添加mediaId、mediaFileOriginalName 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;resultMap type=&quot;com.xuecheng.framework.domain.course.ext.TeachplanNode&quot; id=&quot;teachplanMap&quot; &gt; &lt;id property=&quot;id&quot; column=&quot;one_id&quot;/&gt; &lt;result property=&quot;pname&quot; column=&quot;one_name&quot;/&gt; &lt;result property=&quot;grade&quot; column=&quot;one_grade&quot;/&gt; &lt;collection property=&quot;children&quot; ofType=&quot;com.xuecheng.framework.domain.course.ext.TeachplanNode&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;two_id&quot;/&gt; &lt;result property=&quot;pname&quot; column=&quot;two_name&quot;/&gt; &lt;result property=&quot;grade&quot; column=&quot;two_grade&quot;/&gt; &lt;collection property=&quot;children&quot; ofType=&quot;com.xuecheng.framework.domain.course.ext.TeachplanNode&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;three_id&quot;/&gt; &lt;result property=&quot;pname&quot; column=&quot;three_name&quot;/&gt; &lt;result property=&quot;grade&quot; column=&quot;three_grade&quot;/&gt; &lt;result property=&quot;mediaId&quot; column=&quot;mediaId&quot;/&gt; &lt;result property=&quot;mediaFileOriginalName&quot; column=&quot;mediaFileOriginalName&quot;/&gt; &lt;/collection&gt; &lt;/collection&gt;&lt;/resultMap&gt;&lt;select id=&quot;selectList&quot; resultMap=&quot;teachplanMap&quot; parameterType=&quot;java.lang.String&quot; &gt; SELECT a.id one_id, a.pname one_name, a.grade one_grade, a.orderby one_orderby, b.id two_id, b.pname two_name, b.grade two_grade, b.orderby two_orderby, c.id three_id, c.pname three_name, c.grade three_grade, c.orderby three_orderby, media.media_id mediaId, media.media_fileoriginalname mediaFileOriginalName FROM teachplan a LEFT JOIN teachplan b ON a.id = b.parentid LEFT JOIN teachplan c ON b.id = c.parentid LEFT JOIN teachplan_media media ON c.id = media.teachplan_id WHERE a.parentid = &apos;0&apos; &lt;if test=&quot;_parameter!=null and _parameter!=&apos;&apos;&quot;&gt; and a.courseid=#&#123;courseId&#125; &lt;/if&gt; ORDER BY a.orderby, b.orderby, c.orderby&lt;/select&gt; 3.4.3 页面查询视频课程计划结点信息已包括媒资信息，可在页面获取信息后显示： 1&lt;el-button style=&quot;font-size: 12px;&quot; type=&quot;text&quot; on-click=&#123; () =&gt; this.querymedia(data.id) &#125;&gt;&#123;data.mediaFileOriginalName&#125;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;选择视频&lt;/el-button&gt; 效果如下： 选择视频后立即刷新课程计划树，在提交成功后，添加查询课程计划代码：this.findTeachplan()，完整代码如下： 123456789101112131415161718192021choosemedia(mediaId,fileOriginalName,mediaUrl)&#123; this.mediaFormVisible = false; //保存课程计划与视频对应关系 let teachplanMedia = &#123;&#125;; teachplanMedia.teachplanId = this.activeTeachplanId; teachplanMedia.mediaId = mediaId; teachplanMedia.mediaFileOriginalName = fileOriginalName; teachplanMedia.mediaUrl = mediaUrl; teachplanMedia.courseId = this.courseid; //保存媒资信息到课程数据库 courseApi.savemedia(teachplanMedia).then(res=&gt;&#123; if(res.success)&#123; this.$message.success(&quot;选择视频成功&quot;) //查询课程计划 this.findTeachplan() &#125;else&#123; this.$message.error(res.message) &#125; &#125;)&#125;,]]></content>
      <categories>
        <category>项目实战-在线学习视频网站</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
        <tag>播放器video.js</tag>
        <tag>FFmpeg解码</tag>
        <tag>断点传输</tag>
        <tag>文件上传</tag>
        <tag>媒体处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在线学习视频（十四）—— 在线学习 HLS]]></title>
    <url>%2Fday13%20%E5%9C%A8%E7%BA%BF%E5%AD%A6%E4%B9%A0%20HLS.html</url>
    <content type="text"><![CDATA[在线学习 HLS1 在线学习需求分析1.1 需求描述​ 学成在线作为在线教育网站，提供多种学习形式，包括：录播、直播、图文、社群等，学生登录进入学习中心即可在线学习，本章节将开发录播课程的在线学习功能，需求如下： 1、学生可以在windows浏览器上在线观看视频。 2、播放器具有快进、快退、暂停等基本功能。 3、学生可以方便切换章节进行学习。 什么是录播课程？ 录播课程就是提供录制好课程视频，供用户在线点播，反复学习。 课程视频如何管理？ 媒资管理系统专门来管理课程视频，用户视频文件上传到媒资系统，并对视频进行编码处理。 1.2 视频点播解决方案1.2.1 流媒体 流媒体： 详细参考：https://baike.baidu.com/item/%E6%B5%81%E5%AA%92%E4%BD%93/98740?fr=aladdin 概括理解：流媒体就是将视频文件分成许多小块儿，将这些小块儿作为数据包通过网络发送出去，实现一边传输视频 数据 包一边观看视频。 流式传输 在网络上传输音、视频信息有两个方式：下载和流式传输。 下载：就是把音、视频文件完全下载到本机后开始播放，它的特点是必须等到视频文件下载完成方可播放，播放等待时间较长，无法去播放还未下载的部分视频。 流式传输：就是客户端通过链接视频服务器实时传输音、视频信息，实现“边下载边播放”。 流式传输包括如下两种方式： 1） 顺序流式传输 即顺序下载音、视频文件，可以实现边下载边播放，不过，用户只能观看已下载的视频内容，无法快进到未下载的视频部分，顺序流式传输可以使用Http服务器来实现，比如Nginx、Apache等。 2）实时流式传输 实时流式传输可以解决顺序流式传输无法快进的问题，它与Http流式传输不同，它必须使用流媒体服务器并且使用流媒体协议来传输视频，它比Http流式传输复杂。常见的实时流式传输协议有RTSP、RTMP、RSVP等。 流媒体系统的概要结构 通过流媒体系统的概要结构学习流媒体系统的基本业务流程。 1、将原始的视频文件通过编码器转换为适合网络传输的流格式，编码后的视频直接输送给媒体服务器。 原始的视频文件通常是事先录制好的视频，比如通过摄像机、摄像头等录像、录音设备采集到的音视频文件，体积较大，要想在网络上传输需要经过压缩处理，即通过编码器进行编码 。 2、媒体服务获取到编码好的视频文件，对外提供流媒体数据传输接口，接口协议包括 ：HTTP、RTSP、RTMP等 。 3、播放器通过流媒体协议与媒体服务器通信，获取视频数据，播放视频。 1.2.2 点播方案本项目包括点播和直播两种方式，我们先调研点播的方案，如下： 1、 播放器通过 http协议从http服务器上下载视频文件进行播放 问题：必须等到视频下载完才可以播放，不支持快进到某个时间点进行播放 2、 播放器通过rtmp协议连接媒体服务器以实时流方式播放视频 使用rtmp协议需要架设媒体服务器，造价高，对于直播多采用此方案。 3、 播放器使用HLS协议连接http服务器（Nginx、Apache等）实现近实时流方式播放视频 HLS协议规定：基于Http协议，视频封装格式为ts，视频的编码格式为H264,音频编码格式为MP3、AAC或者AC-3。 HLS是什么？ ​ HLS的工作方式是：将视频拆分成若干ts格式的小文件，通过m3u8格式的索引文件对这些ts小文件建立索引。一般10秒一个ts文件，播放器连接m3u8文件播放，当快进时通过m3u8即可找到对应的索引文件，并去下载对应的ts文件，从而实现快进、快退以近实时 的方式播放视频。 ​ IOS、Android设备、及各大浏览器都支持HLS协议。 详细参考：https://baike.baidu.com/item/HLS/8328931?fr=aladdin 采用HLS方案即可实现边下载边播放，并可不用使用rtmp等流媒体协议，不用构建专用的媒体服务器，节省成本。 本项目点播方案确定为方案3。 2 视频编码2.1 视频编码格式 详情参考 ：https://baike.baidu.com/item/%E8%A7%86%E9%A2%91%E7%BC%96%E7%A0%81/839038 首先我们要分清文件格式和编码格式： 文件格式：是指.mp4、.avi、.rmvb等 这些不同扩展名的视频文件的文件格式 ，视频文件的内容主要包括视频和音频，其文件格式是按照一 定的编码格式去编码，并且按照该文件所规定的封装格式将视频、音频、字幕等信息封装在一起，播放器会根据它们的封装格式去提取出编码，然后由播放器解码，最终播放音视频。 音视频编码格式：通过音视频的压缩技术，将视频格式转换成另一种视频格式，通过视频编码实现流媒体的传输。比如：一个.avi的视频文件原来的编码是a，通过编码后编码格式变为b，音频原来为c，通过编码后变为d。 音视频编码格式各类繁多，主要有几下几类： MPEG系列 （由ISO[国际标准组织机构]下属的MPEG[运动图象专家组]开发 ）视频编码方面主要是Mpeg1（vcd用的就是它）、Mpeg2（DVD使用）、Mpeg4（的DVDRIP使用的都是它的变种，如：divx，xvid等）、Mpeg4 AVC（正热门）；音频编码方面主要是MPEG Audio Layer 1/2、MPEG Audio Layer 3（大名鼎鼎的mp3）、MPEG-2 AAC 、MPEG-4 AAC等等。注意：DVD音频没有采用Mpeg的。 H.26X系列 （由ITU[国际电传视讯联盟]主导，侧重网络传输，注意：只是视频编码） 包括H.261、H.262、H.263、H.263+、H.263++、H.264（就是MPEG4 AVC-合作的结晶） 目前最常用的编码标准是视频H.264，音频AAC。 提问： H.264是编码格式还是文件格式？ mp4是编码格式还是文件格式？ 2.2 FFmpeg 的基本使用我们将视频录制完成后，使用视频编码软件对视频进行编码，本项目 使用FFmpeg对视频进行编码 。 ​ FFmpeg被许多开源项目采用，QQ影音、暴风影音、VLC等。 下载：FFmpeg https://www.ffmpeg.org/download.html#build-windows 下载 ：ffmpeg-20180227-fa0c9d6-win64-static.zip，并解压，本教程将ffmpeg解压到了F:\devenv\edusoft\ffmpeg-20180227-fa0c9d6-win64-static\ffmpeg-20180227-fa0c9d6-win64-static下。 将F:\devenv\edusoft\ffmpeg-20180227-fa0c9d6-win64-static\ffmpeg-20180227-fa0c9d6-win64-static\bin目录配置在path环境变量中。 检测是否安装成功： 简单的测试： 将一个.avi文件转成mp4、mp3、gif等。 比如我们将lucene.avi文件转成mp4，运行如下命令： ffmpeg -i lucene.avi lucene.mp4 转成mp3：ffmpeg -i lucene.avi lucene.mp3 转成gif：ffmpeg -i lucene.avi lucene.gif 官方文档（英文）：http://ffmpeg.org/ffmpeg.html 2.2 生成m3u8/ts文件使用ffmpeg生成 m3u8的步骤如下： 第一步：先将avi视频转成mp4 1ffmpeg.exe -i lucene.avi -c:v libx264 -s 1280x720 -pix_fmt yuv420p -b:a 63k -b:v 753k -r 18 .\lucene.mp4 下面把各参数意思大概讲讲，大概了解意思即可，不再此展开流媒体专业知识的讲解。 -c:v 视频编码为x264 ，x264编码是H264的一种开源编码格式。 -s 设置分辨率 -pix_fmt yuv420p：设置像素采样方式，主流的采样方式有三种，YUV4:4:4，YUV4:2:2，YUV4:2:0，它的作用是根据采样方式来从码流中还原每个像素点的YUV（亮度信息与色彩信息）值。 -b 设置码率，-b:a和-b:v分别表示音频的码率和视频的码率，-b表示音频加视频的总码率。码率对一个视频质量有很大的作用，后边会介绍。 -r：帧率，表示每秒更新图像画面的次数，通常大于24肉眼就没有连贯与停顿的感觉了。 第二步：将mp4生成m3u8 1ffmpeg -i lucene.mp4 -hls_time 10 -hls_list_size 0 -hls_segment_filename ./hls/lucene_%05d.ts ./hls/lucene.m3u8 -hls_time 设置每片的长度，单位为秒 -hls_list_size n: 保存的分片的数量，设置为0表示保存所有分片 -hls_segment_filename ：段文件的名称，%05d表示5位数字 生成的效果是：将lucene.mp4视频文件每10秒生成一个ts文件，最后生成一个m3u8文件，m3u8文件是ts的索引文件。 ​ 使用VLC打开m3u8文件，测试播放效果，VLC 是一款自由、开源的跨平台多媒体播放器及框架，可播放大多数多媒体文件，以及 DVD、音频 CD、VCD 及各类流媒体协议。（http://www.videolan.org/） 2.2.1 码率的设置码率又叫比特率即每秒传输的bit数，单位为bps(Bit Per Second)，码率越大传送数据的速度越快。 码率的计算公式是：文件大小（转成bit）/ 时长（秒）/1024 = kbps 即每秒传输千位数 例如一个1M的视频，它的时长是10s，它的码率等于 11*1024*1024*8/10/1024 = 819Kbps 码率设置到多少才能达到最好，通过根据个人的经验或参考一些视频网台给出的参考，下图是优酷对码率的要求： ​ 如果要将视频上传到优酷则必须按照上面的要求，如果是自己搭建视频服务器，码率设置不易过大，最终达到的视频清晰度满足业务需求即可。 3 播放器3.1 技术选型​ 视频编码后要使用播放器对其进行解码、播放视频内容。在web应用中常用的播放器有flash播放器、H5播放器或浏览器插件播放器，其中以flash和H5播放器最常见。 flash播放器：缺点是需要在客户机安装Adobe Flash Player播放器，优点是flash播放器已经很成熟了，并且浏览器对flash支持也很好。 H5播放器：基于h5自带video标签进行构建，优点是大部分浏览器支持H5，不用再安装第三方的flash播放器，并且随着前端技术的发展，h5技术会越来越成熟。 本项目采用H5播放器，使用Video.js开源播放器。 ​ Video.js是一款基于HTML5世界的网络视频播放器。它支持HTML5和Flash视频，它支持在台式机和移动设备上播放视频。这个项目于2010年中开始，目前已在40万网站使用。 官方地址：http://videojs.com/ 3.2 下载video.jsVideo.js： https://github.com/videojs/video.js videojs-contrib-hls： https://github.com/videojs/videojs-contrib-hls#installation （videojs-contrib-hls是播放hls的一个插件） 使用文档：http://docs.videojs.com/tutorial-videojs_.html 本教程使用 video.js 6.7.3 版本，videojs-contrib-hls 5.14.1版本。 下载上边两个文件，为了测试需求将其放在门户的plugins目录中。 3.3 搭建媒体服务器正常使用video.js播放视频是通过一个网页，用户通过浏览器打开网页去播放视频，网页和视频都从web服务器请求，通常视频的url地址使用单独的域名。 3.3.1 Nginx媒体服务器HLS协议基于Http协议，本项目使用Nginx作为视频服务器。下图是Nginx媒体服务器的配置流程图： 1、用户打开&lt;www.xuecheng.com&gt;上边的video.html网页 在此网页中引入视频链接，视频地址指向video.xuecheng.com 2、video.xuecheng.com进行负载均衡处理，将视频请求转发到媒体服务器 根据上边的流程，我们在媒体服务器上安装Nginx，并配置如下： 12345678910#学成网媒体服务server &#123; listen 90; server_name localhost; #视频目录 location /video/ &#123; alias F:/develop/video/; &#125;&#125; 3.3.2 媒体服务器代理媒体服务器不止一台，通过代理实现负载均衡功能，使用Nginx作为媒体服务器的代理，此代理服务器作为video.xuecheng.com域名服务器。 配置video.xuecheng.com虚拟主机： 注意：开发中代理服务器和媒体服务器在同一台服务器，使用同一个Nginx。 1234567891011121314151617181920#学成网媒体服务代理map $http_origin $origin_list&#123; default http://www.xuecheng.com; &quot;~http://www.xuecheng.com&quot; http://www.xuecheng.com; &quot;~http://ucenter.xuecheng.com&quot; http://ucenter.xuecheng.com;&#125;#学成网媒体服务代理server &#123; listen 80; server_name video.xuecheng.com; location /video &#123; proxy_pass http://video_server_pool; add_header Access-Control-Allow-Origin $origin_list; #add_header Access-Control-Allow-Origin *; add_header Access-Control-Allow-Credentials true; add_header Access-Control-Allow-Methods GET; &#125; &#125; cors跨域参数： Access-Control-Allow-Origin：允许跨域访问的外域地址 ​ 通常允许跨域访问的站点不是一个，所以这里用map定义了多个站点。 ​ 如果允许任何站点跨域访问则设置为*，通常这是不建议的。 Access-Control-Allow-Credentials： 允许客户端携带证书访问 Access-Control-Allow-Methods：允许客户端跨域访问的方法 video_server_pool的配置如下： 1234#媒体服务upstream video_server_pool&#123; server 127.0.0.1:90 weight=10;&#125; 3.4 测试video.js参考https://github.com/videojs/videojs-contrib-hls#installation http://jsbin.com/vokipos/8/edit?html,output 1、编写测试页面video.html。123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt; &lt;title&gt;视频播放&lt;/title&gt; &lt;link href=&quot;/plugins/videojs/video-js.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;video id=example-video width=800 height=600 class=&quot;video-js vjs-default-skin vjs-big-play-centered&quot; controls poster=&quot;http://127.0.0.1:90/video/add.jpg&quot;&gt; &lt;source src=&quot;http://video.xuecheng.com/video/hls/lucene.m3u8&quot; type=&quot;application/x-mpegURL&quot;&gt;&lt;/video&gt;&lt;input type=&quot;button&quot; onClick=&quot;switchvideo()&quot; value=&quot;switch&quot;/&gt;&lt;script src=&quot;/plugins/videojs/video.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;/plugins/videojs/videojs-contrib-hls.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var player = videojs(&apos;example-video&apos;); //player.play(); //切换视频 function switchvideo()&#123; player.src(&#123; src: &apos;http://video.xuecheng.com/video/hls/lucene.m3u8&apos;, type: &apos;application/x-mpegURL&apos;, withCredentials: true &#125;); player.play(); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2、测试 配置hosts文件，本教程开发环境使用Window10，修改C:\Windows\System32\drivers\etc\hosts文件1127.0.0.1 video.xuecheng.com 效果： 点击”switch”测试切换视频功能。 4 搭建学习中心前端​ 学成网学习中心提供学生在线学习的各各模块，上一章节测试的点播学习功能也属于学习中心的一部分，本章节将实现学习中心点播学习的前端部分。之所以先实现前端部分，主要是因为要将video.js+vue.js集成，一部分精力还是要放在技术研究。 4.1 界面原型先看一下界面原型，如下图，最终的目标是在此页面使用video.js播放视频。 4.2 创建学习中心工程学习中心的用户是学生，为了便于系统维护和扩展，单独创建学习中心工程： 1、从资料目录拷贝xc-ui-pc-leanring.zip 并解压到xc-ui-pc-leanring目录。 2、使用webstorm创建打开xc-ui-pc-leanring目录 3、进入xc-ui-pc-leanring目录，执行cnpm install，将根据package.json的依赖配置远程下载依赖的js包。 创建完成，xc-ui-pc-leanring工程如下： 4.2.1 配置域名学习中心的二级域名为ucenter.xuecheng.com，我们在nginx中配置ucenter虚拟主机。123456789101112131415#学成网用户中心server &#123; listen 80; server_name ucenter.xuecheng.com; #个人中心 location / &#123; proxy_pass http://ucenter_server_pool; &#125; &#125;#前端ucenterupstream ucenter_server_pool&#123; #server 127.0.0.1:7081 weight=10; server 127.0.0.1:13000 weight=10;&#125; 4.2.2 访问启动工程，看到下边的界面说明本工程创建完成： 4.3 调试视频播放页面​ 使用vue-video-player组件将video.js集成到vue.js中，本项目使用vue-video-player实现video.js播放。 组件地址：https://github.com/surmon-china/vue-video-player 上面的 xc-ui-pc-learning工程已经添加vue-video-player组件，我们在vue页面直接使用即可。 ​ 前边我们已经测试通过 video.js，下面我们直接在vue页面中使用vue-video-player完成视频播放。 导入learning_video.vue页面到course 模块下。 配置路由： 12345678import learning_video from &apos;@/module/course/page/learning_video.vue&apos;; &#123; path: &apos;/learning/:courseId/:chapter&apos;, component: learning_video, name: &apos;录播视频学习&apos;, hidden: false, iconCls: &apos;el-icon-document&apos; &#125; 预览效果： 请求：http://ucenter.xuecheng.com/#/learning/1/2 第一个参数：courseId，课程id，这里是测试页面效果随便输入一个ID即可，这里输入1 第二个参数：chapter，课程计划id，这里是测试页面效果随便输入一个ID即可，这里输入2 6 媒资管理前边章节完成在线视频播放，如何实现点击课程计划播放视频呢，课程视频如何管理呢？ 本节开始将对课程视频进行管理。 6.1需求分析​ 媒资管理系统是每个在线教育平台所必须具备的，百度百科对它的定义如下： 每个教学机构都可以在媒资系统管理自己的教学资源，包括：视频、教案等文件。 目前媒资管理的主要管理对象是课程录播视频，包括：媒资文件的查询、视频上传、视频删除、视频处理等。 媒资查询：教学机构查询自己所拥有的媒体文件。 视频上传：将用户线下录制的教学视频上传到媒资系统。 视频处理：视频上传成功，系统自动对视频进行编码处理。 视频删除 ：如果该视频已不再使用，可以从媒资系统删除。 下边是媒资系统与其它系统的交互情况： 1、上传媒资文件 前端/客户端请求媒资系统上传文件。 文件上传成功将文件存储到媒资服务器，将文件信息存储到数据库。 2、使用媒资 课程管理请求媒资系统查询媒资信息，将课程计划与媒资信息对应、存储。 3、视频播放 用户进入学习中心请求学习服务学习在线播放视频。 学习服务校验用户资格通过后请求媒资系统获取视频地址。 6.2 开发环境6.2.1 创建媒资数据库1、媒资文件信息 123456789101112131415161718192021222324252627282930@Data@ToString@Document(collection = &quot;media_file&quot;)public class MediaFile &#123; /* 文件id、名称、大小、文件类型、文件状态（未上传、上传完成、上传失败）、上传时间、视频处理方式、视频处理状态、hls_m3u8,hls_ts_list、课程视频信息（课程id、章节id） */ @Id //文件id private String fileId; //文件名称 private String fileName; //文件原始名称 private String fileOriginalName; //文件路径 private String filePath; //文件url private String fileUrl; //文件类型 private String fileType; //mimetype private String mimeType; //文件大小 private Long fileSize; //文件状态 private String fileStatus; //上传时间 private Date uploadTime;&#125; 2、创建xc_media数据库 媒资系统使用mongodb数据库存储媒资信息。 6.2.2 创建媒资服务工程媒资管理的相关功能单独在媒资服务中开发，下边创建媒资服务工程（xc-service-manage-media）。 媒资服务的配置与cms类似，导入 “资料”–》xc-service-manage-media工程，工程结构如下： 6.3上传文件6.3.1 断点续传解决方案​ 通常视频文件都比较大，所以对于媒资系统上传文件的需求要满足大文件的上传要求。http协议本身对上传文件大小没有限制，但是客户的网络环境质量、电脑硬件环境等参差不齐，如果一个大文件快上传完了网断了，电断了没有上传完成，需要客户重新上传，这是致命的，所以对于大文件上传的要求最基本的是断点续传。 什么是断点续传： ​ 引用百度百科：断点续传指的是在下载或上传时，将下载或上传任务（一个文件或一个压缩包）人为的划分为几个部分，每一个部分采用一个线程进行上传或下载，如果碰到网络故障，可以从已经上传或下载的部分开始继续上传下载未完成的部分，而没有必要从头开始上传下载，断点续传可以提高节省操作时间，提高用户体验性。 如下图： 上传流程如下： 1、上传前先把文件分成块 2、一块一块的上传，上传中断后重新上传，已上传的分块则不用再上传 3、各分块上传完成最后合并文件 文件下载则同理。 6.3.2 文件分块与合并为了更好的理解文件分块上传的原理，下边用java代码测试文件的分块与合并。 6.3.2.1文件分块文件分块的流程如下： 1、获取源文件长度 2、根据设定的分块文件的大小计算出块数 3、从源文件读数据依次向每一个块文件写数据。 12345678910111213141516171819202122232425262728293031323334353637383940414243//测试文件分块方法 @Test public void testChunk() throws IOException &#123; File sourceFile = new File(&quot;F:/develop/ffmpeg/lucene.mp4&quot;);// File sourceFile = new File(&quot;d:/logo.png&quot;); String chunkPath = &quot;F:/develop/ffmpeg/chunk/&quot;; File chunkFolder = new File(chunkPath); if(!chunkFolder.exists())&#123; chunkFolder.mkdirs(); &#125; //分块大小 long chunkSize = 1024*1024*1; //分块数量 long chunkNum = (long) Math.ceil(sourceFile.length() * 1.0 / chunkSize ); if(chunkNum&lt;=0)&#123; chunkNum = 1; &#125; //缓冲区大小 byte[] b = new byte[1024]; //使用RandomAccessFile访问文件 RandomAccessFile raf_read = new RandomAccessFile(sourceFile, &quot;r&quot;); //分块 for(int i=0;i&lt;chunkNum;i++)&#123; //创建分块文件 File file = new File(chunkPath+i); boolean newFile = file.createNewFile(); if(newFile)&#123; //向分块文件中写数据 RandomAccessFile raf_write = new RandomAccessFile(file, &quot;rw&quot;); int len = -1; while((len = raf_read.read(b))!=-1)&#123; raf_write.write(b,0,len); if(file.length()&gt;chunkSize)&#123; break; &#125; &#125; raf_write.close(); &#125; &#125; raf_read.close(); &#125; 6.3.2.2文件合并文件合并流程： 1、找到要合并的文件并按文件合并的先后进行排序。 2、创建合并文件 3、依次从合并的文件中读取数据向合并文件写入数 123456789101112131415161718192021222324252627282930313233343536373839404142434445//测试文件合并方法@Testpublic void testMerge() throws IOException &#123; //块文件目录 File chunkFolder = new File(&quot;F:/develop/ffmpeg/chunk/&quot;); //合并文件 File mergeFile = new File(&quot;F:/develop/ffmpeg/lucene1.mp4&quot;); if(mergeFile.exists())&#123; mergeFile.delete(); &#125; //创建新的合并文件 mergeFile.createNewFile(); //用于写文件 RandomAccessFile raf_write = new RandomAccessFile(mergeFile, &quot;rw&quot;); //指针指向文件顶端 raf_write.seek(0); //缓冲区 byte[] b = new byte[1024]; //分块列表 File[] fileArray = chunkFolder.listFiles(); // 转成集合，便于排序 List&lt;File&gt; fileList = new ArrayList&lt;File&gt;(Arrays.asList(fileArray)); // 从小到大排序 Collections.sort(fileList, new Comparator&lt;File&gt;() &#123; @Override public int compare(File o1, File o2) &#123; if (Integer.parseInt(o1.getName()) &lt; Integer.parseInt(o2.getName())) &#123; return -1; &#125; return 1; &#125; &#125;); //合并文件 for(File chunkFile:fileList)&#123; RandomAccessFile raf_read = new RandomAccessFile(chunkFile,&quot;rw&quot;); int len = -1; while((len=raf_read.read(b))!=-1)&#123; raf_write.write(b,0,len); &#125; raf_read.close(); &#125; raf_write.close();&#125; 6.3.3 前端页面上传文件的页面内容参考：“资料”–》upload.vue文件 6.3.3.1 WebUploader介绍如何在web页面实现断点续传？ 常见的方案有： 1、通过Flash上传，比如SWFupload、Uploadify。 2、安装浏览器插件，变相的pc客户端，用的比较少。 3、Html5 随着html5的流行，本项目采用Html5完成文件分块上传。 ​ 本项目使用WebUploader完成大文件上传功能的开发，WebUploader官网地址：http://fexteam.gz01.bdysite.com/webuploader/ 特性如下： 使用WebUploader上传流程如下： 6.3.3.1 钩子方法在webuploader中提供很多钩子方法，下边列出一些重要的： 本项目使用如下钩子方法： 1）before-send-file 在开始对文件分块儿之前调用，可以做一些上传文件前的准备工作，比如检查文件目录是否创建完成等。 2）before-send 在上传文件分块之前调用此方法，可以请求服务端检查分块是否存在，如果已存在则此分块儿不再上传。 3）after-send-file 在所有分块上传完成后触发，可以请求服务端合并分块文件。 注册钩子方法源代码： 12345WebUploader.Uploader.register(&#123; &quot;before-send-file&quot;:&quot;beforeSendFile&quot;, &quot;before-send&quot;:&quot;beforeSend&quot;, &quot;after-send-file&quot;:&quot;afterSendFile&quot; &#125; 6.3.3.2 构建WebUploader使用webUploader前需要创建webUploader对象。 指定上传分块的地址：/api/media/upload/uploadchunk 123456789101112131415// 创建uploader对象，配置参数this.uploader = WebUploader.create( &#123; swf:&quot;/static/plugins/webuploader/dist/Uploader.swf&quot;,//上传文件的flash文件，浏览器不支持h5时启动flash server:&quot;/api/media/upload/uploadchunk&quot;,//上传分块的服务端地址，注意跨域问题 fileVal:&quot;file&quot;,//文件上传域的name pick:&quot;#picker&quot;,//指定选择文件的按钮容器 auto:false,//手动触发上传 disableGlobalDnd:true,//禁掉整个页面的拖拽功能 chunked:true,// 是否分块上传 chunkSize:1*1024*1024, // 分块大小（默认5M） threads:3, // 开启多个线程（默认3个） prepareNextFile:true// 允许在文件传输时提前把下一个文件准备好 &#125;) 6.3.3.3 before-send-file文件开始上传前前端请求服务端准备上传工作。 参考源代码如下： 12345678910type:&quot;POST&quot;,url:&quot;/api/media/upload/register&quot;,data:&#123; // 文件唯一表示 fileMd5:this.fileMd5, fileName: file.name, fileSize:file.size, mimetype:file.type, fileExt:file.ext&#125; 6.3.3.4 before-send上传分块前前端请求服务端校验分块是否存在。 参考源代码如下： 12345678910type:&quot;POST&quot;,url:&quot;/api/media/upload/checkchunk&quot;,data:&#123; // 文件唯一表示 fileMd5:this.fileMd5, // 当前分块下标 chunk:block.chunk, // 当前分块大小 chunkSize:block.end-block.start&#125; 6.3.3.5 after-send-file在所有分块上传完成后触发，可以请求服务端合并分块文件 参考代码如下： 123456789type:&quot;POST&quot;,url:&quot;/api/media/upload/mergechunks&quot;,data:&#123; fileMd5:this.fileMd5, fileName: file.name, fileSize:file.size, mimetype:file.type, fileExt:file.ext&#125; 6.3.3.6 页面效果 6.3.4 Api接口定义文件上传的Api接口，此接收是前端WebUploader调用服务端的接口。 编写此接口需要参数前端WebUploader应用代码。 12345678910111213141516171819202122232425Api(value = &quot;媒资管理接口&quot;,description = &quot;媒资管理接口，提供文件上传，文件处理等接口&quot;)public interface MediaUploadControllerApi &#123; @ApiOperation(&quot;文件上传注册&quot;) public ResponseResult register(String fileMd5, String fileName, Long fileSize, String mimetype, String fileExt); @ApiOperation(&quot;分块检查&quot;) public CheckChunkResult checkchunk(String fileMd5, Integer chunk, Integer chunkSize); @ApiOperation(&quot;上传分块&quot;) public ResponseResult uploadchunk(MultipartFile file, Integer chunk, String fileMd5); @ApiOperation(&quot;合并文件&quot;) public ResponseResult mergechunks(String fileMd5, String fileName, Long fileSize, String mimetype, String fileExt); &#125; 6.3.5媒资服务端编写6.3.5.1 业务流程服务端需要实现如下功能： 1、上传前检查上传环境 检查文件是否上传，已上传则直接返回。 检查文件上传路径是否存在，不存在则创建。 2、分块检查 检查分块文件是否上传，已上传则返回true。 未上传则检查上传路径是否存在，不存在则创建。 3、分块上传 将分块文件上传到指定的路径。 4、合并分块 将所有分块文件合并为一个文件。 在数据库记录文件信息。 6.3.5.2 上传注册由于上传过程复杂，开发时按业务流程分别实现。 1、配置 application.yml配置上传文件的路径： 12xc-service-manage-media: upload-location: F:/develop/video/ 2、定义Dao 媒资文件管理Dao 123public interface MediaFileRepository extends MongoRepository&lt;MediaFile,String&gt; &#123;&#125; 3、Service 功能： 1）检查上传文件是否存在 2）创建文件目录 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576@Servicepublic class MediaUploadService &#123; private final static Logger LOGGER = LoggerFactory.getLogger(MediaUploadController.class); @Autowired MediaFileRepository mediaFileRepository; //上传文件根目录 @Value(&quot;$&#123;xc-service-manage-media.upload-location&#125;&quot;) String uploadPath; /** * 根据文件md5得到文件路径 * 规则： * 一级目录：md5的第一个字符 * 二级目录：md5的第二个字符 * 三级目录：md5 * 文件名：md5+文件扩展名 * @param fileMd5 文件md5值 * @param fileExt 文件扩展名 * @return 文件路径 */ private String getFilePath(String fileMd5,String fileExt)&#123; String filePath = uploadPath+fileMd5.substring(0, 1) + &quot;/&quot; + fileMd5.substring(1, 2) + &quot;/&quot; + fileMd5 + &quot;/&quot; + fileMd5 + &quot;.&quot; + fileExt; return filePath; &#125; //得到文件目录相对路径，路径中去掉根目录 private String getFileFolderRelativePath(String fileMd5,String fileExt)&#123; String filePath = fileMd5.substring(0, 1) + &quot;/&quot; + fileMd5.substring(1, 2) + &quot;/&quot; + fileMd5 + &quot;/&quot;; return filePath; &#125; //得到文件所在目录 private String getFileFolderPath(String fileMd5)&#123; String fileFolderPath = uploadPath+ fileMd5.substring(0, 1) + &quot;/&quot; + fileMd5.substring(1, 2) + &quot;/&quot; + fileMd5 + &quot;/&quot; ; return fileFolderPath; &#125; //创建文件目录 private boolean createFileFold(String fileMd5)&#123; //创建上传文件目录 String fileFolderPath = getFileFolderPath(fileMd5); File fileFolder = new File(fileFolderPath); if (!fileFolder.exists()) &#123; //创建文件夹 boolean mkdirs = fileFolder.mkdirs(); return mkdirs; &#125; return true; &#125; //文件上传注册 public ResponseResult register(String fileMd5, String fileName, String fileSize, String mimetype, String fileExt) &#123; //检查文件是否上传 //1、得到文件的路径 String filePath = getFilePath(fileMd5, fileExt); File file = new File(filePath); //2、查询数据库文件是否存在 Optional&lt;MediaFile&gt; optional = mediaFileRepository.findById(fileMd5); //文件存在直接返回 if(file.exists() &amp;&amp; optional.isPresent())&#123; ExceptionCast.cast(MediaCode.UPLOAD_FILE_REGISTER_EXIST); &#125; boolean fileFold = createFileFold(fileMd5); if(!fileFold)&#123; //上传文件目录创建失败 ExceptionCast.cast(MediaCode.UPLOAD_FILE_REGISTER_CREATEFOLDER_FAIL); &#125; return new ResponseResult(CommonCode.SUCCESS); &#125; &#125; 6.3.5.3 分块检查在Service 中定义分块检查方法： 1234567891011121314151617//得到块文件所在目录private String getChunkFileFolderPath(String fileMd5)&#123; String fileChunkFolderPath = getFileFolderPath(fileMd5) +&quot;/&quot; + &quot;chunks&quot; + &quot;/&quot;; return fileChunkFolderPath;&#125;//检查块文件public CheckChunkResult checkchunk(String fileMd5, String chunk, String chunkSize) &#123; //得到块文件所在路径 String chunkfileFolderPath = getChunkFileFolderPath(fileMd5); //块文件的文件名称以1,2,3..序号命名，没有扩展名 File chunkFile = new File(chunkfileFolderPath+chunk); if(chunkFile.exists())&#123; return new CheckChunkResult(MediaCode.CHUNK_FILE_EXIST_CHECK,true); &#125;else&#123; return new CheckChunkResult(MediaCode.CHUNK_FILE_EXIST_CHECK,false); &#125;&#125; 6.3.5.4 上传分块在Service 中定义分块上传分块方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//块文件上传public ResponseResult uploadchunk(MultipartFile file, String fileMd5, String chunk) &#123; if(file == null)&#123; ExceptionCast.cast(MediaCode.UPLOAD_FILE_REGISTER_ISNULL); &#125; //创建块文件目录 boolean fileFold = createChunkFileFolder(fileMd5); //块文件 File chunkfile = new File(getChunkFileFolderPath(fileMd5) + chunk); //上传的块文件 InputStream inputStream= null; FileOutputStream outputStream = null; try &#123; inputStream = file.getInputStream(); outputStream = new FileOutputStream(chunkfile); IOUtils.copy(inputStream,outputStream); &#125; catch (Exception e) &#123; e.printStackTrace(); LOGGER.error(&quot;upload chunk file fail:&#123;&#125;&quot;,e.getMessage()); ExceptionCast.cast(MediaCode.CHUNK_FILE_UPLOAD_FAIL); &#125;finally &#123; try &#123; inputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; try &#123; outputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; return new ResponseResult(CommonCode.SUCCESS);&#125; //创建块文件目录 private boolean createChunkFileFolder(String fileMd5)&#123; //创建上传文件目录 String chunkFileFolderPath = getChunkFileFolderPath(fileMd5); File chunkFileFolder = new File(chunkFileFolderPath); if (!chunkFileFolder.exists()) &#123; //创建文件夹 boolean mkdirs = chunkFileFolder.mkdirs(); return mkdirs; &#125; return true; &#125; 6.3.5.5 合并分块在Service 中定义分块合并分块方法，功能如下： 1）将块文件合并 2）校验文件md5是否正确 3）向Mongodb写入文件信息 //合并块文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129public ResponseResult mergechunks(String fileMd5, String fileName, Long fileSize, String mimetype, String fileExt) &#123; //获取块文件的路径 String chunkfileFolderPath = getChunkFileFolderPath(fileMd5); File chunkfileFolder = new File(chunkfileFolderPath); if(!chunkfileFolder.exists())&#123; chunkfileFolder.mkdirs(); &#125; //合并文件路径 File mergeFile = new File(getFilePath(fileMd5,fileExt)); //创建合并文件 //合并文件存在先删除再创建 if(mergeFile.exists())&#123; mergeFile.delete(); &#125; boolean newFile = false; try &#123; newFile = mergeFile.createNewFile(); &#125; catch (IOException e) &#123; e.printStackTrace(); LOGGER.error(&quot;mergechunks..create mergeFile fail:&#123;&#125;&quot;,e.getMessage()); &#125; if(!newFile)&#123; ExceptionCast.cast(MediaCode.MERGE_FILE_CREATEFAIL); &#125; //获取块文件，此列表是已经排好序的列表 List&lt;File&gt; chunkFiles = getChunkFiles(chunkfileFolder); //合并文件 mergeFile = mergeFile(mergeFile, chunkFiles); if(mergeFile == null)&#123; ExceptionCast.cast(MediaCode.MERGE_FILE_FAIL); &#125; //校验文件 boolean checkResult = this.checkFileMd5(mergeFile, fileMd5); if(!checkResult)&#123; ExceptionCast.cast(MediaCode.MERGE_FILE_CHECKFAIL); &#125; //将文件信息保存到数据库 MediaFile mediaFile = new MediaFile(); mediaFile.setFileId(fileMd5); mediaFile.setFileName(fileMd5+&quot;.&quot;+fileExt); mediaFile.setFileOriginalName(fileName); //文件路径保存相对路径 mediaFile.setFilePath(getFileFolderRelativePath(fileMd5,fileExt)); mediaFile.setFileSize(fileSize); mediaFile.setUploadTime(new Date()); mediaFile.setMimeType(mimetype); mediaFile.setFileType(fileExt); //状态为上传成功 mediaFile.setFileStatus(&quot;301002&quot;); MediaFile save = mediaFileDao.save(mediaFile); return new ResponseResult(CommonCode.SUCCESS);&#125; //校验文件的md5值 private boolean checkFileMd5(File mergeFile,String md5)&#123; if(mergeFile == null || StringUtils.isEmpty(md5))&#123; return false; &#125; //进行md5校验 FileInputStream mergeFileInputstream = null; try &#123; mergeFileInputstream = new FileInputStream(mergeFile); //得到文件的md5 String mergeFileMd5 = DigestUtils.md5Hex(mergeFileInputstream); //比较md5 if(md5.equalsIgnoreCase(mergeFileMd5))&#123; return true; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); LOGGER.error(&quot;checkFileMd5 error,file is:&#123;&#125;,md5 is:&#123;&#125;&quot;,mergeFile.getAbsoluteFile(),md5); &#125;finally&#123; try &#123; mergeFileInputstream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; return false; &#125;//获取所有块文件 private List&lt;File&gt; getChunkFiles(File chunkfileFolder)&#123; //获取路径下的所有块文件 File[] chunkFiles = chunkfileFolder.listFiles(); //将文件数组转成list，并排序 List&lt;File&gt; chunkFileList = new ArrayList&lt;File&gt;(); chunkFileList.addAll(Arrays.asList(chunkFiles)); //排序 Collections.sort(chunkFileList, new Comparator&lt;File&gt;() &#123; @Override public int compare(File o1, File o2) &#123; if(Integer.parseInt(o1.getName())&gt;Integer.parseInt(o2.getName()))&#123; return 1; &#125; return -1; &#125; &#125;); return chunkFileList; &#125; //合并文件 private File mergeFile(File mergeFile,List&lt;File&gt; chunkFiles)&#123; try &#123; //创建写文件对象 RandomAccessFile raf_write = new RandomAccessFile(mergeFile,&quot;rw&quot;); //遍历分块文件开始合并 //读取文件缓冲区 byte[] b = new byte[1024]; for(File chunkFile:chunkFiles)&#123; RandomAccessFile raf_read = new RandomAccessFile(chunkFile,&quot;r&quot;); int len = -1; //读取分块文件 while((len = raf_read.read(b))!=-1)&#123; //向合并文件中写数据 raf_write.write(b,0,len); &#125; raf_read.close(); &#125; raf_write.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); LOGGER.error(&quot;merge file error:&#123;&#125;&quot;,e.getMessage()); return null; &#125; return mergeFile; &#125; 6.3.5.6 Controller12345678910111213141516171819202122232425262728293031@RestController@RequestMapping(&quot;/media/upload&quot;)public class MediaUploadController implements MediaUploadControllerApi &#123; @Autowired MediaUploadService mediaUploadService; @Override @PostMapping(&quot;/register&quot;) public ResponseResult register(@RequestParam(&quot;fileMd5&quot;) String fileMd5, @RequestParam(&quot;fileName&quot;) String fileName, @RequestParam(&quot;fileSize&quot;) Long fileSize, @RequestParam(&quot;mimetype&quot;) String mimetype, @RequestParam(&quot;fileExt&quot;) String fileExt) &#123; return mediaUploadService.register(fileMd5,fileName,fileSize,mimetype,fileExt); &#125; @Override @PostMapping(&quot;/checkchunk&quot;) public CheckChunkResult checkchunk(@RequestParam(&quot;fileMd5&quot;) String fileMd5, @RequestParam(&quot;chunk&quot;) Integer chunk, @RequestParam(&quot;chunkSize&quot;) Integer chunkSize) &#123; return mediaUploadService.checkchunk(fileMd5,chunk,chunkSize); &#125; @Override @PostMapping(&quot;/uploadchunk&quot;) public ResponseResult uploadchunk(@RequestParam(&quot;file&quot;) MultipartFile file, @RequestParam(&quot;fileMd5&quot;) String fileMd5, @RequestParam(&quot;chunk&quot;) Integer chunk) &#123; return mediaUploadService.uploadchunk(file,fileMd5,chunk); &#125; @Override @PostMapping(&quot;/mergechunks&quot;) public ResponseResult mergechunks(@RequestParam(&quot;fileMd5&quot;) String fileMd5, @RequestParam(&quot;fileName&quot;) String fileName, @RequestParam(&quot;fileSize&quot;) Long fileSize, @RequestParam(&quot;mimetype&quot;) String mimetype, @RequestParam(&quot;fileExt&quot;) String fileExt) &#123; return mediaUploadService.mergechunks(fileMd5,fileName,fileSize,mimetype,fileExt); &#125;&#125;]]></content>
      <categories>
        <category>项目实战-在线学习视频网站</category>
      </categories>
      <tags>
        <tag>播放器video.js</tag>
        <tag>FFmpeg解码</tag>
        <tag>断点传输</tag>
        <tag>文件上传</tag>
        <tag>媒体处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在线学习视频（十六）—— 媒资管理系统集成]]></title>
    <url>%2Fday15%20%E5%AA%92%E8%B5%84%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E9%9B%86%E6%88%90.html</url>
    <content type="text"><![CDATA[媒资管理系统集成1 学习页面查询课程计划1.1 需求分析​ 到目前为止，我们已可以编辑课程计划信息并上传课程视频，下一步我们要实现在线学习页面动态读取章节对应的视频并进行播放。在线学习页面所需要的信息有两类：一类是课程计划信息、一类是课程学习信息（视频地址、学习进度等），如下图： 在线学习集成媒资管理的需求如下： 1、在线学习页面显示课程计划 2、点击课程计划播放该课程计划对应的视频 本章节实现学习页面动态显示课程计划，进入不同课程的学习页面右侧动态显示当前课程的课程计划。 1.2 Api接口课程计划信息从哪里获取？ 目前课程计划信息在课程管理数据库和ES索引库中存在，考虑性能要求，课程发布后对课程的查询统一从ES索引库中查询。 前端通过请求搜索服务获取课程信息，需要单独在搜索服务中定义课程信息查询接口。 本接口接收课程id，查询课程所有信息返回给前端。 12@ApiOperation(&quot;根据id查询课程信息&quot;)public Map&lt;String,CoursePub&gt; getall(String id); 返回的课程信息为json结构：key为课程id，value为课程内容。 1.3 服务端开发在搜索服务中开发查询课程信息接口。 1.3.1 Service在搜索服务中增加查询课程信息接口的service 1234567891011121314151617181920212223242526272829303132333435363738394041424344public Map&lt;String, CoursePub&gt; getall(String id) &#123; //设置索引库 SearchRequest searchRequest = new SearchRequest(es_index); //设置类型 searchRequest.types(es_type); SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder(); //查询条件，根据课程id查询 searchSourceBuilder.query(QueryBuilders.termsQuery(&quot;id&quot;, id)); //取消source源字段过虑，查询所有字段// searchSourceBuilder.fetchSource(new String[]&#123;&quot;name&quot;, &quot;grade&quot;, &quot;charge&quot;,&quot;pic&quot;&#125;, new String[]&#123;&#125;); searchRequest.source(searchSourceBuilder); SearchResponse searchResponse = null; try &#123; //执行搜索 searchResponse = restHighLevelClient.search(searchRequest); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; //获取搜索结果 SearchHits hits = searchResponse.getHits(); SearchHit[] searchHits = hits.getHits(); Map&lt;String,CoursePub&gt; map = new HashMap&lt;&gt;(); for (SearchHit hit : searchHits) &#123; String courseId = hit.getId(); Map&lt;String, Object&gt; sourceAsMap = hit.getSourceAsMap(); String courseId = (String) sourceAsMap.get(&quot;id&quot;); String name = (String) sourceAsMap.get(&quot;name&quot;); String grade = (String) sourceAsMap.get(&quot;grade&quot;); String charge = (String) sourceAsMap.get(&quot;charge&quot;); String pic = (String) sourceAsMap.get(&quot;pic&quot;); String description = (String) sourceAsMap.get(&quot;description&quot;); String teachplan = (String) sourceAsMap.get(&quot;teachplan&quot;); CoursePub coursePub = new CoursePub(); coursePub.setId(courseId); coursePub.setName(name); coursePub.setPic(pic); coursePub.setGrade(grade); coursePub.setTeachplan(teachplan); coursePub.setDescription(description); map.put(courseId,coursePub); &#125; return map; &#125; 1.3.2 Controller12345@Override@GetMapping(&quot;/getall/&#123;id&#125;&quot;)public Map&lt;String, CoursePub&gt; getall(@PathVariable(&quot;id&quot;) String id) &#123; return esCourseService.getall(id);&#125; 1.3.3 测试使用swagger-ui或postman测试查询课程信息接口。 1.4前端开发1.4.1 配置虚拟主机学习中心的二级域名为ucenter.xuecheng.com，我们在nginx中配置ucenter虚拟主机。 123456789101112131415#学成网用户中心server &#123; listen 80; server_name ucenter.xuecheng.com; #个人中心 location / &#123; proxy_pass http://ucenter_server_pool; &#125; &#125;#前端ucenterupstream ucenter_server_pool&#123; #server 127.0.0.1:7081 weight=10; server 127.0.0.1:13000 weight=10;&#125; 在学习中心要调用搜索的API，使用Nginx解决代理，如下图： 配置搜索Api代理路径： 12345678#后台搜索（公开api）upstream search_server_pool&#123; server 127.0.0.1:40100 weight=10;&#125;#后端搜索服务location /openapi/search/ &#123; proxy_pass http://search_server_pool/search/; &#125; 1.4.2 API方法在学习中心对课程信息的查询属于基础常用功能，所以我们将课程查询的api方法定义在base模块下，如下图： 在system.js中定义课程查询方法： 1234import http from &apos;./public&apos;export const course_view = id =&gt; &#123; return http.requestGet(&apos;/openapi/search/course/getall/&apos;+id);&#125; 1.4.3 API调用在learning_video.vue页面中调用课程信息查询接口，得到课程计划，将课程计划json串转成对象。 1、定义视图 a、课程计划 1234567&lt;div class=&quot;nav nav-stacked&quot; v-for=&quot;(teachplan_first, index) in teachplanList&quot;&gt; &lt;div class=&quot;tit nav-justified text-center&quot;&gt;&lt;i class=&quot;pull-left glyphicon glyphicon-th-list&quot;&gt;&lt;/i&gt;&#123;&#123;teachplan_first.pname&#125;&#125;&lt;i class=&quot;pull-right&quot;&gt;&lt;/i&gt;&lt;/div&gt; &lt;li v-if=&quot;teachplan_first.children!=null&quot; v-for=&quot;(teachplan_second, index) in teachplan_first.children&quot;&gt;&lt;i class=&quot;glyphicon glyphicon-check&quot;&gt;&lt;/i&gt; &lt;a :href=&quot;url&quot; @click=&quot;study(teachplan_second.id)&quot;&gt; &#123;&#123;teachplan_second.pname&#125;&#125; &lt;/a&gt; &lt;/li&gt; b、课程名称 123&lt;div class=&quot;top text-center&quot;&gt; &#123;&#123;coursename&#125;&#125;&lt;/div&gt; 2、定义数据对象 12345678910111213141516171819data() &#123; return &#123; url:&apos;&apos;,//当前url courseId:&apos;&apos;,//课程id chapter:&apos;&apos;,//章节Id coursename:&apos;&apos;,//课程名称 coursepic:&apos;&apos;,//课程图片 teachplanList:[],//课程计划 playerOptions: &#123;//播放参数 autoplay: false, controls: true, sources: [&#123; type: &quot;application/x-mpegURL&quot;, src: &apos;&apos; &#125;] &#125;, &#125; &#125; 3、在created钩子方法中获取课程信息 12345678910111213141516171819202122232425created()&#123; //当前请求的url this.url = window.location //课程id this.courseId = this.$route.params.courseId //章节id this.chapter = this.$route.params.chapter //查询课程信息 systemApi.course_view(this.courseId).then((view_course)=&gt;&#123; if(!view_course || !view_course[this.courseId])&#123; this.$message.error(&quot;获取课程信息失败，请重新进入此页面！&quot;) return ; &#125; let courseInfo = view_course[this.courseId] console.log(courseInfo) this.coursename = courseInfo.name if(courseInfo.teachplan)&#123; let teachplan = JSON.parse(courseInfo.teachplan); this.teachplanList = teachplan.children; &#125; &#125;) &#125;, 1.4.4 测试在浏览器请求：http://ucenter.xuecheng.com/#/learning/4028e581617f945f01617f9dabc40000/0 4028e581617f945f01617f9dabc40000：第一个参数为课程id，测试时从ES索引库找一个课程id 0：第二个参数为课程计划id，此参数用于点击课程计划播放视频。 2 学习页面获取视频播放地址2.1 需求分析用户进入在线学习页面，点击课程计划将播放该课程计划对应的教学视频。 业务流程如下： 业务流程说明： 1、用户进入在线学习页面，页面请求搜索服务获取课程信息（包括课程计划信息）并且在页面展示。 2、在线学习页面请求学习服务获取视频播放地址。 3、学习服务校验当前用户是否有权限学习，如果没有权限学习则提示用户。 4、学习服务校验通过，请求搜索服务获取课程媒资信息。 5、搜索服务请求ElasticSearch获取课程媒资信息。 为什么要请求ElasticSearch查询课程媒资信息？ 出于性能的考虑，公开查询课程信息从搜索服务查询。 什么时候将课程媒资信息存储到ElasticSearch中？ 课程媒资信息是在课程发布的时候存入ElasticSearch，因为课程发布后课程信息将基本不再修改。 2.2 课程发布存储媒资信息2.2.1 需求分析​ 课程媒资信息是在课程发布的时候存入ElasticSearch索引库，因为课程发布后课程信息将基本不再修改，具体的业务流程如下。 业务流程如下： 1、课程发布，向课程媒资信息表写入数据。 1）根据课程id删除teachplanMediaPub中的数据 2）根据课程id查询teachplanMedia数据 3）将查询到的teachplanMedia数据插入到teachplanMediaPub中 2、Logstash定时扫描课程媒资信息表，并将课程媒资信息写入索引库。 2.2.2 数据模型在xc_course数据库创建课程计划媒资发布表： 123456789CREATE TABLE `teachplan_media_pub` ( `teachplan_id` varchar(32) NOT NULL COMMENT &apos;课程计划id&apos;, `media_id` varchar(32) NOT NULL COMMENT &apos;媒资文件id&apos;, `media_fileoriginalname` varchar(128) NOT NULL COMMENT &apos;媒资文件的原始名称&apos;, `media_url` varchar(256) NOT NULL COMMENT &apos;媒资文件访问地址&apos;, `courseid` varchar(32) NOT NULL COMMENT &apos;课程Id&apos;, `timestamp` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT &apos;logstash使用&apos;, PRIMARY KEY (`teachplan_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 数据模型类如下： 12345678910111213141516171819202122232425262728@Data@ToString@Entity@Table(name=&quot;teachplan_media_pub&quot;)@GenericGenerator(name = &quot;jpa-assigned&quot;, strategy = &quot;assigned&quot;)public class TeachplanMediaPub implements Serializable &#123; private static final long serialVersionUID = -916357110051689485L; @Id @GeneratedValue(generator = &quot;jpa-assigned&quot;) @Column(name=&quot;teachplan_id&quot;) private String teachplanId; @Column(name=&quot;media_id&quot;) private String mediaId; @Column(name=&quot;media_fileoriginalname&quot;) private String mediaFileOriginalName; @Column(name=&quot;media_url&quot;) private String mediaUrl; @Column(name=&quot;courseid&quot;) private String courseId; @Column(name=&quot;timestamp&quot;) private Date timestamp;//时间戳&#125; 2.2.3 Dao创建TeachplanMediaPub表的Dao，向TeachplanMediaPub存储信息采用先删除该课程的媒资信息，再添加该课程的媒资信息，所以这里定义根据课程id删除课程计划媒资方法： 12345678public interface TeachplanMediaPubRepository extends JpaRepository&lt;TeachplanMediaPub, String&gt; &#123; //根据课程id删除课程计划媒资信息 long deleteByCourseId(String courseId);&#125;//从TeachplanMedia查询课程计划媒资信息public interface TeachplanMediaRepository extends JpaRepository&lt;TeachplanMedia, String&gt; &#123; List&lt;TeachplanMedia&gt; findByCourseId(String courseId);&#125; 2.2.4 Service编写保存课程计划媒资信息方法，并在课程发布时调用此方法。 1、保存课程计划媒资信息方法 本方法采用先删除该课程的媒资信息，再添加该课程的媒资信息。 1234567891011121314//保存课程计划媒资信息private void saveTeachplanMediaPub(String courseId)&#123; //查询课程媒资信息 List&lt;TeachplanMedia&gt; teachplanMediaList = teachplanMediaRepository.findByCourseId(courseId); //将课程计划媒资信息存储待索引表 teachplanMediaPubRepository.deleteByCourseId(courseId); List&lt;TeachplanMediaPub&gt; teachplanMediaPubList = new ArrayList&lt;&gt;(); for(TeachplanMedia teachplanMedia:teachplanMediaList)&#123; TeachplanMediaPub teachplanMediaPub =new TeachplanMediaPub(); BeanUtils.copyProperties(teachplanMedia,teachplanMediaPub); teachplanMediaPubList.add(teachplanMediaPub); &#125; teachplanMediaPubRepository.saveAll(teachplanMediaPubList);&#125; 2、课程发布时调用此方法 修改课程发布的service方法： 123456//保存课程计划媒资信息到待索引表saveTeachplanMediaPub(courseId);//页面urlString pageUrl = cmsPostPageResult.getPageUrl();return new CoursePublishResult(CommonCode.SUCCESS,pageUrl); 3.2.5 测试测试课程发布后是否成功将课程媒资信息存储到teachplan_media_pub中，测试流程如下： 1、指定一个课程 2、为课程计划添加课程媒资 3、执行课程发布 4、观察课程计划媒资信息是否存储至teachplan_media_pub中 注意：由于此测试仅用于测试发布课程计划媒资信息的功能，可暂时将cms页面发布的功能暂时屏蔽，提高测试效率。 2.3 Logstash扫描课程计划媒资Logstash定时扫描课程媒资信息表，并将课程媒资信息写入索引库。‘ 2.3.1 创建索引1、创建xc_course_media索引 2、并向此索引创建如下映射 Post http://localhost:9200/xc_course_media/doc/_mapping 123456789101112131415161718192021&#123; &quot;properties&quot; : &#123; &quot;courseid&quot; : &#123; &quot;type&quot; : &quot;keyword&quot; &#125;, &quot;teachplan_id&quot; : &#123; &quot;type&quot; : &quot;keyword&quot; &#125;, &quot;media_id&quot; : &#123; &quot;type&quot; : &quot;keyword&quot; &#125;, &quot;media_url&quot; : &#123; &quot;index&quot; : false, &quot;type&quot; : &quot;text&quot; &#125;, &quot;media_fileoriginalname&quot; : &#123; &quot;index&quot; : false, &quot;type&quot; : &quot;text&quot; &#125; &#125; &#125; 2.3.2 创建Logstash模板文件在logstach的config目录创建xc_course_media_template.json，内容如下： 本教程的xc_course_media_template.json目录是：D:/ElasticSearch/logstash-6.2.1/config/xc_course_media_template.json 12345678910111213141516171819202122232425&#123; &quot;mappings&quot; : &#123; &quot;doc&quot; : &#123; &quot;properties&quot; : &#123; &quot;courseid&quot; : &#123; &quot;type&quot; : &quot;keyword&quot; &#125;, &quot;teachplan_id&quot; : &#123; &quot;type&quot; : &quot;keyword&quot; &#125;, &quot;media_id&quot; : &#123; &quot;type&quot; : &quot;keyword&quot; &#125;, &quot;media_url&quot; : &#123; &quot;index&quot; : false, &quot;type&quot; : &quot;text&quot; &#125;, &quot;media_fileoriginalname&quot; : &#123; &quot;index&quot; : false, &quot;type&quot; : &quot;text&quot; &#125; &#125; &#125;, &quot;template&quot; : &quot;xc_course_media&quot;&#125; 2.3.3 配置mysql.conf在logstash的config目录下配置mysql_course_media.conf文件供logstash使用，logstash会根据mysql_course_media.conf文件的配置的地址从MySQL中读取数据向ES中写入索引。 参考https://www.elastic.co/guide/en/logstash/current/plugins-inputs-jdbc.html 配置输入数据源和输出数据源。 12345678910111213141516171819202122232425262728293031323334353637383940414243input &#123; stdin &#123; &#125; jdbc &#123; jdbc_connection_string =&gt; &quot;jdbc:mysql://localhost:3306/xc_course?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=true&amp;serverTimezone=UTC&quot; # the user we wish to excute our statement as jdbc_user =&gt; &quot;root&quot; jdbc_password =&gt; mysql # the path to our downloaded jdbc driver jdbc_driver_library =&gt; &quot;F:/develop/maven/repository3/mysql/mysql-connector-java/5.1.41/mysql-connector-java-5.1.41.jar&quot; # the name of the driver class for mysql jdbc_driver_class =&gt; &quot;com.mysql.jdbc.Driver&quot; jdbc_paging_enabled =&gt; &quot;true&quot; jdbc_page_size =&gt; &quot;50000&quot; #要执行的sql文件 #statement_filepath =&gt; &quot;/conf/course.sql&quot; statement =&gt; &quot;select * from teachplan_media_pub where timestamp &gt; date_add(:sql_last_value,INTERVAL 8 HOUR)&quot; #定时配置 schedule =&gt; &quot;* * * * *&quot; record_last_run =&gt; true last_run_metadata_path =&gt; &quot;D:/ElasticSearch/logstash-6.2.1/config/xc_course_media_metadata&quot; &#125;&#125;output &#123; elasticsearch &#123; #ES的ip地址和端口 hosts =&gt; &quot;localhost:9200&quot; #hosts =&gt; [&quot;localhost:9200&quot;,&quot;localhost:9202&quot;,&quot;localhost:9203&quot;] #ES索引库名称 index =&gt; &quot;xc_course_media&quot; document_id =&gt; &quot;%&#123;id&#125;&quot; document_type =&gt; &quot;doc&quot; template =&gt;&quot;D:/ElasticSearch/logstash-6.2.1/config/xc_course_media_template.json&quot; template_name =&gt;&quot;xc_course_media&quot; template_overwrite =&gt;&quot;true&quot; &#125; stdout &#123; #日志输出 codec =&gt; json_lines &#125;&#125; 2.3.4 启动logstash.bat启动logstash.bat采集teachplan_media_pub中的数据，向ES写入索引。 1logstash.bat -f ../config/mysql_course_media.conf 2.4 搜索服务查询课程媒资接口2.4.1 需求分析搜索服务提供查询课程媒资接口，此接口供学习服务调用。 2.4.2 Api在课程搜索包下定义Api 12@ApiOperation(&quot;根据课程计划查询媒资信息&quot;)public TeachplanMediaPub getmedia(String teachplanId); 2.4.3 Service1、配置课程计划媒资索引库等信息 在application.yml中配置 123456xuecheng: elasticsearch: media: index: xc_course_media type: doc source_field: courseid,media_id,media_url,teachplan_id,media_fileoriginalname 2、service方法开发 在课程搜索服务中定义课程媒资查询接口，为了适应后续需求，service参数定义为数组，可一次查询多个课程计划的媒资信息。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//根据课程计划查询媒资信息public QueryResponseResult&lt;TeachplanMediaPub&gt; getmedia(String[] teachplanIds)&#123; //设置索引 SearchRequest searchRequest = new SearchRequest(media_index); //设置类型 searchRequest.types(media_type); SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder(); //source源字段过虑 String[] source_fields = media_source_field.split(&quot;,&quot;); searchSourceBuilder.fetchSource(source_fields, new String[]&#123;&#125;); //查询条件，根据课程计划id查询(可传入多个id) searchSourceBuilder.query(QueryBuilders.termsQuery(&quot;teachplan_id&quot;, teachplanIds)); searchRequest.source(searchSourceBuilder); SearchResponse searchResponse = null; try &#123; //执行搜索 searchResponse = restHighLevelClient.search(searchRequest); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; //获取搜索结果 SearchHits hits = searchResponse.getHits(); SearchHit[] searchHits = hits.getHits(); Map&lt;String,CoursePub&gt; map = new HashMap&lt;&gt;(); //数据列表 List&lt;TeachplanMediaPub&gt; teachplanMediaPubList = new ArrayList&lt;&gt;(); for (SearchHit hit : searchHits) &#123; TeachplanMediaPub teachplanMediaPub =new TeachplanMediaPub(); Map&lt;String, Object&gt; sourceAsMap = hit.getSourceAsMap(); //取出课程计划媒资信息 String courseid = (String) sourceAsMap.get(&quot;courseid&quot;); String media_id = (String) sourceAsMap.get(&quot;media_id&quot;); String media_url = (String) sourceAsMap.get(&quot;media_url&quot;); String teachplan_id = (String) sourceAsMap.get(&quot;teachplan_id&quot;); String media_fileoriginalname = (String) sourceAsMap.get(&quot;media_fileoriginalname&quot;); teachplanMediaPub.setCourseId(courseid); teachplanMediaPub.setMediaUrl(media_url); teachplanMediaPub.setMediaFileOriginalName(media_fileoriginalname); teachplanMediaPub.setMediaId(media_id); teachplanMediaPub.setTeachplanId(teachplan_id); //将数据加入列表 teachplanMediaPubList.add(teachplanMediaPub); &#125; //构建返回课程媒资信息对象 QueryResult&lt;TeachplanMediaPub&gt; queryResult = new QueryResult&lt;&gt;(); queryResult.setList(teachplanMediaPubList); QueryResponseResult&lt;TeachplanMediaPub&gt; queryResponseResult = new QueryResponseResult&lt;TeachplanMediaPub&gt;(CommonCode.SUCCESS,queryResult); return queryResponseResult;&#125; 2.4.4 Controller12345678910111213141516@Override@GetMapping(value=&quot;/getmedia/&#123;teachplanId&#125;&quot;)public TeachplanMediaPub getmedia(@PathVariable(&quot;teachplanId&quot;) String teachplanId) &#123; //将课程计划id放在数组中，为调用service作准备 String[] teachplanIds = new String[]&#123;teachplanId&#125;; //通过service查询ES获取课程媒资信息 QueryResponseResult&lt;TeachplanMediaPub&gt; mediaPubQueryResponseResult = esCourseService.getmedia(teachplanIds); QueryResult&lt;TeachplanMediaPub&gt; queryResult = mediaPubQueryResponseResult.getQueryResult(); if(queryResult!=null &amp;&amp; queryResult.getList()!=null &amp;&amp; queryResult.getList().size()&gt;0)&#123; //返回课程计划对应课程媒资 return queryResult.getList().get(0); &#125; return new TeachplanMediaPub();&#125; 2.4.5 测试使用swagger-ui和postman测试课程媒资查询接口。 3 在线学习接口3.1 需求分析根据下边的业务流程，本章节完成前端学习页面请求学习服务获取课程视频地址，并自动播放视频。 3.2 搭建开发环境3.2.1 创建数据库创建xc_learning数据库，学习数据库将记录学生的选课信息、学习信息。 导入：资料/xc_learning.sql 3.2.2 创建学习服务工程参考课程管理服务工程结构，创建学习服务工程： pom.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495 &lt;dependencies&gt; &lt;!-- 导入Eureka服务的依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.squareup.okhttp3&lt;/groupId&gt; &lt;artifactId&gt;okhttp&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.netflix.feign&lt;/groupId&gt; &lt;artifactId&gt;feign-okhttp&lt;/artifactId&gt; &lt;version&gt;8.18.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.xuecheng&lt;/groupId&gt; &lt;artifactId&gt;xc-service-api&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.xuecheng&lt;/groupId&gt; &lt;artifactId&gt;xc-framework-model&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.xuecheng&lt;/groupId&gt; &lt;artifactId&gt;xc-framework-utils&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.xuecheng&lt;/groupId&gt; &lt;artifactId&gt;xc-framework-common&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-orm&lt;/artifactId&gt; &lt;version&gt;$&#123;springframework.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 1234567891011121314151617181920212223242526272829303132333435server: port: $&#123;PORT:40600&#125;spring: application: name: xc-service-learning datasource: druid: url: $&#123;MYSQL_URL:jdbc:mysql://localhost:3306/xc_learning?characterEncoding=utf-8&#125; username: root password: mysql driverClassName: com.mysql.jdbc.Driver initialSize: 5 #初始建立连接数量 minIdle: 5 #最小连接数量 maxActive: 20 #最大连接数量 maxWait: 10000 #获取连接最大等待时间，毫秒 testOnBorrow: true #申请连接时检测连接是否有效 testOnReturn: false #归还连接时检测连接是否有效 timeBetweenEvictionRunsMillis: 60000 #配置间隔检测连接是否有效的时间（单位是毫秒） minEvictableIdleTimeMillis: 300000 #连接在连接池的最小生存时间（毫秒）eureka: client: registerWithEureka: true #服务注册开关 fetchRegistry: true #服务发现开关 serviceUrl: #Eureka客户端与Eureka服务端进行交互的地址，多个中间用逗号分隔 defaultZone: $&#123;EUREKA_SERVER:http://localhost:50101/eureka/&#125; instance: prefer-ip-address: true #将自己的ip地址注册到Eureka服务中 ip-address: $&#123;IP_ADDRESS:127.0.0.1&#125; instance-id: $&#123;spring.application.name&#125;:$&#123;server.port&#125; #指定实例idribbon: MaxAutoRetries: 2 #最大重试次数，当Eureka中可以找到服务，但是服务连不上时将会重试，如果eureka中找不到服务则直接走断路器 MaxAutoRetriesNextServer: 3 #切换实例的重试次数 OkToRetryOnAllOperations: false #对所有操作请求都进行重试，如果是get则可以，如果是post，put等操作没有实现幂等的情况下是很危险的,所以设置为false ConnectTimeout: 5000 #请求连接的超时时间 ReadTimeout: 6000 #请求处理的超时时间 启动类： 1234567891011121314151617181920@EnableDiscoveryClient@EnableFeignClients@SpringBootApplication@EntityScan(&quot;com.xuecheng.framework.domain.learning&quot;)//扫描实体类@ComponentScan(basePackages=&#123;&quot;com.xuecheng.api&quot;&#125;)//扫描接口@ComponentScan(basePackages=&#123;&quot;com.xuecheng.learning&quot;&#125;)//扫描接口@ComponentScan(basePackages=&#123;&quot;com.xuecheng.framework&quot;&#125;)//扫描common下的所有类public class LearningApplication &#123; public static void main(String[] args) throws Exception &#123; SpringApplication.run(LearningApplication.class, args); &#125; @Bean @LoadBalanced public RestTemplate restTemplate() &#123; return new RestTemplate(new OkHttp3ClientHttpRequestFactory()); &#125;&#125; 3.3 Api接口此api接口是课程学习页面请求学习服务获取课程学习地址。 定义返回值类型：123456789101112@Data@ToString@NoArgsConstructorpublic class GetMediaResult extends ResponseResult &#123; public GetMediaResult(ResultCode resultCode, String fileUrl) &#123; super(resultCode); this.fileUrl = fileUrl; &#125; //媒资文件播放地址 private String fileUrl;&#125; 定义接口，学习服务根据传入课程ID、章节Id(课程计划ID)来取学习地址。 1234567@Api(value = &quot;录播课程学习管理&quot;,description = &quot;录播课程学习管理&quot;)public interface CourseLearningControllerApi &#123; @ApiOperation(&quot;获取课程学习地址&quot;) public GetMediaResult getmedia(String courseId,String teachplanId);&#125; 3.4 服务端开发3.4.1 需求分析学习服务根据传入课程ID、章节Id(课程计划ID)请求搜索服务获取学习地址。 3.4.2 搜索服务注册Eureka学习服务要调用搜索服务查询课程媒资信息，所以需要将搜索服务注册到eureka中。 1、查看服务名称是否为xc-service-search 1234注意修改application.xml中的服务名称：spring: application: name: xc-service-search 2、配置搜索服务的配置文件application.yml，加入Eureka配置 如下： 12345678910111213141516eureka: client: registerWithEureka: true #服务注册开关 fetchRegistry: true #服务发现开关 serviceUrl: #Eureka客户端与Eureka服务端进行交互的地址，多个中间用逗号分隔 defaultZone: $&#123;EUREKA_SERVER:http://localhost:50101/eureka/,http://localhost:50102/eureka/&#125; instance: prefer-ip-address: true #将自己的ip地址注册到Eureka服务中 ip-address: $&#123;IP_ADDRESS:127.0.0.1&#125; instance-id: $&#123;spring.application.name&#125;:$&#123;server.port&#125; #指定实例idribbon: MaxAutoRetries: 2 #最大重试次数，当Eureka中可以找到服务，但是服务连不上时将会重试，如果eureka中找不到服务则直接走断路器 MaxAutoRetriesNextServer: 3 #切换实例的重试次数 OkToRetryOnAllOperations: false #对所有操作请求都进行重试，如果是get则可以，如果是post，put等操作没有实现幂等的情况下是很危险的,所以设置为false ConnectTimeout: 5000 #请求连接的超时时间 ReadTimeout: 6000 #请求处理的超时时间 3、添加eureka依赖： 12345&lt;!-- 导入Eureka客户端的依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt; 4、修改启动类，在class上添加如下注解： 1@EnableDiscoveryClient 3.4.3 搜索服务客户端在学习服务创建搜索服务的客户端接口，此接口会生成代理对象，调用搜索服务： 123456789101112package com.xuecheng.learning.client;import com.xuecheng.api.search.EsCourseControllerApi;import com.xuecheng.framework.client.XcServiceList;import org.springframework.cloud.netflix.feign.FeignClient;@FeignClient(value = &quot;xc-service-search&quot;)public interface CourseSearchClient &#123; @GetMapping(value=&quot;/getmedia/&#123;teachplanId&#125;&quot;) public TeachplanMediaPub getmedia(@PathVariable(&quot;teachplanId&quot;) String teachplanId);&#125; 3.4.4 Service在学习服务中定义service方法，此方法远程请求课程管理服务、媒资管理服务获取课程学习地址。 1234567891011121314151617181920@Servicepublic class LearningService &#123; @Autowired CourseSearchClient courseSearchClient; //获取课程 public GetMediaResult getMedia(String courseId, String teachplanId) &#123; //校验学生的学习权限。。是否资费等 //调用搜索服务查询 TeachplanMediaPub teachplanMediaPub = courseSearchClient.getmedia(teachplanId); if(teachplanMediaPub == null || StringUtils.isEmpty(teachplanMediaPub.getMediaUrl()))&#123; //获取视频播放地址出错 ExceptionCast.cast(LearningCode.LEARNING_GETMEDIA_ERROR); &#125; return new GetMediaResult(CommonCode.SUCCESS,teachplanMediaPub.getMediaUrl()); &#125;&#125; 3.4.5 Controller调用service根据课程计划id查询视频播放地址： 123456789101112131415@RestController@RequestMapping(&quot;/learning/course&quot;)public class CourseLearningController implements CourseLearningControllerApi &#123; @Autowired LearningService learningService; @Override @GetMapping(&quot;/getmedia/&#123;courseId&#125;/&#123;teachplanId&#125;&quot;) public GetMediaResult getmedia(@PathVariable String courseId, @PathVariable String teachplanId) &#123; //获取课程学习地址 return learningService.getMedia(courseId, teachplanId); &#125;&#125; 3.4.6 测试使用swagger-ui或postman测试学习服务查询课程视频地址接口。 3.5 前端开发3.5.1需求分析需要在学习中心前端页面需要完成如下功能： 1、进入课程学习页面需要带上课程Id参数及课程计划Id的参数，其中课程Id参数必带，课程计划Id可以为空。 2、进入页面根据课程Id取出该课程的课程计划显示在右侧。 3、进入页面后判断如果请求参数中有课程计划Id则播放该章节的视频。 4、进入页面后判断如果课程计划id为0则需要取出本课程第一个课程计划的Id，并播放第一个课程计划的视频。 3.5.2 api方法123456let sysConfig = require(&apos;@/../config/sysConfig&apos;)let apiUrl = sysConfig.xcApiUrlPre;/*获取播放地址*/export const get_media = (courseId,chapter) =&gt; &#123; return http.requestGet(apiUrl+&apos;/api/learning/course/getmedia/&apos;+courseId+&apos;/&apos;+chapter);&#125; 3.3.3 配置代理在Nginx中的ucenter.xuecheng.com虚拟主机中配置/api/learning/的路径转发，此url请转发到学习服务。 12345678#学习服务upstream learning_server_pool&#123; server 127.0.0.1:40600 weight=10;&#125; #学习服务location ^~ /api/learning/ &#123; proxy_pass http://learning_server_pool/learning/; &#125; 3.5.3 视频播放页面1、如果传入的课程计划id为0则取出第一个课程计划id 在created钩子方法中完成 1234567891011121314151617181920212223242526272829303132333435created()&#123; //当前请求的url this.url = window.location //课程id this.courseId = this.$route.params.courseId //课程计划id this.chapter = this.$route.params.chapter //查询课程信息 systemApi.course_view(this.courseId).then((view_course)=&gt;&#123; if(!view_course || !view_course[this.courseId])&#123; this.$message.error(&quot;获取课程信息失败，请重新进入此页面！&quot;) return ; &#125; let courseInfo = view_course[this.courseId] console.log(courseInfo) this.coursename = courseInfo.name if(courseInfo.teachplan)&#123; //将从服务端获取的课程计划json转成对象 let teachplan = JSON.parse(courseInfo.teachplan); //将课程计划赋值给数据模型 this.teachplanList = teachplan.children; console.log(this.teachplanList) if(!this.chapter || this.chapter == &apos;0&apos;)&#123; //取出第一个教学计划 this.chapter = this.getFirstTeachplan() console.log(this.chapter) //开始学习 this.study(this.chapter) &#125; &#125; &#125;) &#125;, 取出第一个章节id： 1234567891011//取出第一个章节getFirstTeachplan()&#123; for(var i=0;i&lt;this.teachplanList.length;i++)&#123; let firstTeachplan = this.teachplanList[i]; if(firstTeachplan.children &amp;&amp; firstTeachplan.children.length&gt;0)&#123; let secondTeachplan = firstTeachplan.children[0]; return secondTeachplan.id; &#125; &#125; return ;&#125;, 开始学习： 1234567891011121314151617//开始学习 study(chapter)&#123; // 获取播放地址 courseApi.get_media(this.courseId,chapter).then((res)=&gt;&#123; if(res.success)&#123; let fileUrl = sysConfig.videoUrl + res.fileUrl //播放视频 this.playvideo(fileUrl) &#125;else if(res.message)&#123; this.$message.error(res.message) &#125;else&#123; this.$message.error(&quot;播放视频失败，请刷新页面重试&quot;) &#125; &#125;).catch(res=&gt;&#123; this.$message.error(&quot;播放视频失败，请刷新页面重试&quot;) &#125;); &#125;, 2、点击右侧课程章节切换播放 在原有代码基础上添加click事件，点击调用开始学习方法（study）。 12345&lt;li v-if=&quot;teachplan_first.children!=null&quot; v-for=&quot;(teachplan_second, index) in teachplan_first.children&quot;&gt;&lt;i class=&quot;glyphicon glyphicon-check&quot;&gt;&lt;/i&gt; &lt;a :href=&quot;url&quot; @click=&quot;study(teachplan_second.id)&quot;&gt; &#123;&#123;teachplan_second.pname&#125;&#125; &lt;/a&gt;&lt;/li&gt; 3.5.4 测试访问在线学习页面：http://ucenter.xuecheng.com/#/learning/课程id/课程计划id 通过url传入两个参数：课程id和课程计划id 如果没有课程计划则传入0 测试项目如下： 1、传入正确的课程id、课程计划id，自动播放本章节的视频 2、传入正确的课程id、课程计划id传入0，自动播放第一个视频 3、传入错误的课程id或课程计划id，提示错误信息。 4、通过右侧章节目录切换章节及播放视频。]]></content>
      <categories>
        <category>项目实战-在线学习视频网站</category>
      </categories>
      <tags>
        <tag>Logstash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在线学习视频（十三）—— 搜索前端 Nuxt.js]]></title>
    <url>%2Fday12-%E6%90%9C%E7%B4%A2%E5%89%8D%E7%AB%AF%20Nuxt.js.html</url>
    <content type="text"><![CDATA[搜索前端 Nuxt.js1 搜索前端技术需求1.1 需求描述​ 采用vue.js开发搜索界面则SEO不友好，需要解决SEO的问题。 1.2 了解SEO 总结：seo是网站为了提高自已的网站排名，获得更多的流量，对网站的结构及内容进行调整优化，以便搜索引擎（百度，google等）更好抓取到更优质的网站的内容。 下图是搜索引擎爬取网站页面的大概流程图： （搜索引擎的工作流程很复杂，下图只是简单概括） 从上图可以看到SEO是网站自己为了方便spider抓取网页而作出的网页内容优化，常见的SEO方法比如： 1）对url链接的规范化，多用restful风格的url，多用静态资源url； 2) 注意title、keywords的设置。 3）由于spider对javascript支持不好，对于网页跳转用href标签。 1.3 服务端渲染和客户端渲染采用什么技术有利于SEO？要解答这个问题需要理解服务端渲染和客户端渲染。 什么是服务端渲染? 我们用传统的servlet开发来举例：浏览器请求servlet，servlet在服务端生成html响应给浏览器，浏览器展示html 的内容，这个过程就是服务端渲染，如下图： 服务端渲染的特点： 1）在服务端生成html网页的dom元素。 2）客户端（浏览器）只负责显示dom元素内容。 当初随着web2.0的到来，AJAX技术兴起，出现了客户端渲染：客户端（浏览器） 使用AJAX向服务端发起http请求，获取到了想要的数据，客户端拿着数据开始渲染html网页，生成Dom元素，并最终将网页内容展示给用户，如下图： 客户端渲染的特点： 1）在服务端只是给客户端响应的了数据，而不是html网页 2）客户端（浏览器）负责获取服务端的数据生成Dom元素。 两种方式各有什么优缺点？ 客户端渲染： 1) 缺点 不利于网站进行SEO，因为网站大量使用javascript技术，不利于spider抓取网页。 2) 优点 客户端负责渲染，用户体验性好，服务端只提供数据不用关心用户界面的内容，有利于提高服务端的开发效率。 3）适用场景 对SEO没有要求的系统，比如后台管理类的系统，如电商后台管理，用户管理等。 服务端渲染： 1) 优点 有利于SEO，网站通过href的url将spider直接引到服务端，服务端提供优质的网页内容给spider。 2) 缺点 服务端完成一部分客户端的工作，通常完成一个需求需要修改客户端和服务端的代码，开发效率低，不利于系统的稳定性。 3）适用场景 对SEO有要求的系统，比如：门户首页、商品详情页面等。 2 Nuxt.js介绍2.1 Nuxt.js介绍​ 移动互联网的兴起促进了web前后端分离开发模式的发展，服务端只专注业务，前端只专注用户体验，前端大量运用的前端渲染技术，比如流行的vue.js、react框架都实现了功能强大的前端渲染。 ​ 但是，对于有SEO需求的网页如果使用前端渲染技术去开发就不利于SEO了，有没有一种即使用vue.js、react的前端技术也实现服务端渲染的技术呢？其实，对于服务端渲染的需求，vue.js、react这样流行的前端框架提供了服务端渲染的解决方案。 从上图可以看到： react框架提供next.js实现服务端渲染。 vue.js框架提供Nuxt.js实现服务端渲染。 2.2 Nuxt.js工作原理下图展示了从客户端请求到Nuxt.js进行服务端渲染的整体的工作流程： 1、用户打开浏览器，输入网址请求到Node.js 2、部署在Node.js的应用Nuxt.js接收浏览器请求，并请求服务端获取数据 3、Nuxt.js获取到数据后进行服务端渲染 4、Nuxt.js将html网页响应给浏览器 Nuxt.js使用了哪些技术？ Nuxt.js使用Vue.js+webpack+Babel三大技术框架/组件，如下图： Babel 是一个js的转码器，负责将ES6的代码转成浏览器识别的ES5代码。 Webpack是一个前端工程打包工具。 Vue.js是一个优秀的前端框架。 Nuxt.js的特性有哪些？ 基于 Vue.js 自动代码分层 服务端渲染 强大的路由功能，支持异步数据 静态文件服务 ES6/ES7 语法支持 打包和压缩 JS 和 CSS HTML头部标签管理 本地开发支持热加载 集成ESLint 支持各种样式预处理器： SASS、LESS、 Stylus等等 3 Nuxt.js基本使用3.1 创建Nuxt工程nuxt.js有标准的目录结构，官方提供了模板工程，可以模板工程快速创建nuxt项目。 模板工程地址：https://github.com/nuxt-community/starter-template/archive/master.zip 本项目提供基于Nuxt.js的封装工程，基于此封装工程开发搜索前端，见“资料”–》xc-ui-pc-portal.zip，解压 xc-ui-pc-portal.zip到本项目前端工程目录下。 本前端工程属于门户的一部分，将承载一部分考虑SEO的非静态化页面。 本工程基于Nuxt.js模板工程构建，Nuxt.js使用1.3版本，并加入了今后开发中所使用的依赖包，直接解压本工程即可使用。 3.2 目录结构本工程的目录结构如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253- 资源目录资源目录 assets 用于组织未编译的静态资源如 LESS、SASS 或 JavaScript。- 组件目录组件目录 components 用于组织应用的 Vue.js 组件。Nuxt.js 不会扩展增强该目录下 Vue.js 组件，即这些组件不会像页面组件那样有 asyncData 方法的特性。- 布局目录布局目录 layouts 用于组织应用的布局组件。该目录名为Nuxt.js保留的，不可更改。- 中间件目录middleware 目录用于存放应用的中间件。- 页面目录页面目录 pages 用于组织应用的路由及视图。Nuxt.js 框架读取该目录下所有的 .vue 文件并自动生成对应的路由配置。该目录名为Nuxt.js保留的，不可更改。- 插件目录插件目录 plugins 用于组织那些需要在 根vue.js应用 实例化之前需要运行的 Javascript 插件。- 静态文件目录静态文件目录 static 用于存放应用的静态文件，此类文件不会被 Nuxt.js 调用 Webpack 进行构建编译处理。 服务器启动的时候，该目录下的文件会映射至应用的根路径 / 下。举个例子: /static/logo.png 映射至 /logo.png该目录名为Nuxt.js保留的，不可更改。- Store 目录store 目录用于组织应用的 Vuex 状态树 文件。 Nuxt.js 框架集成了 Vuex 状态树 的相关功能配置，在 store 目录下创建一个 index.js 文件可激活这些配置。该目录名为Nuxt.js保留的，不可更改。- nuxt.config.js 文件nuxt.config.js 文件用于组织Nuxt.js 应用的个性化配置，以便覆盖默认配置。该文件名为Nuxt.js保留的，不可更改。- package.json 文件package.json 文件用于描述应用的依赖关系和对外暴露的脚本接口。该文件名为Nuxt.js保留的，不可更改。 nuxt.js 提供了目录的别名，方便在程序中引用： 3.3 页面布局页面布局就是页面内容的整体结构，通过在layouts目录下添加布局文件来实现。在layouts 根目录下的所有文件都属于个性化布局文件，可以在页面组件中利用 layout 属性来引用。 1234567891011121314151617181920212223242526272829303132333435363738394041一个例子：1、定义：layouts/test.vue布局文件，如下：注意：布局文件中一定要加 &lt;nuxt/&gt; 组件用于显示页面内容。&lt;template&gt; &lt;div&gt; &lt;div&gt;这里是头&lt;/div&gt; &lt;nuxt/&gt; &lt;div&gt;这里是尾&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; &#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt;2、在pages目录创建user目录，并创建index.vue页面在 pages/user/index.vue 页面里， 可以指定页面组件使用 test 布局，代码如下：&lt;template&gt; &lt;div&gt; 测试页面 &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default&#123; layout:&apos;test&apos; &#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt;3、测试，请求：http://localhost:10000/user，如果如下: 这里是头测试页面这里是尾 3.4 路由3.4.1 基础路由Nuxt.js 依据 pages 目录结构自动生成 vue-router 模块的路由配置。 Nuxt.js根据pages的目录结构及页面名称定义规范来生成路由，下边是一个基础路由的例子： 假设 pages 的目录结构如下： 1234pages/--| user/-----| index.vue-----| one.vue 那么，Nuxt.js 自动生成的路由配置如下： 1234567891011121314router: &#123; routes: [ &#123; name: &apos;user&apos;, path: &apos;/user&apos;, component: &apos;pages/user/index.vue&apos; &#125;, &#123; name: &apos;user-one&apos;, path: &apos;/user/one&apos;, component: &apos;pages/user/one.vue&apos; &#125; ]&#125; index.vue代码如下： 12345678910111213&lt;template&gt; &lt;div&gt; 用户管理首页 &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default&#123; layout:&quot;test&quot;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; one.vue代码如下：12345678910111213&lt;template&gt; &lt;div&gt; one页面 &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default&#123; layout:&quot;test&quot;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 分别访问如下链接进行测试： http://localhost:10000/user http://localhost:10000/user/one 3.4.2 嵌套路由你可以通过 vue-router 的子路由创建 Nuxt.js 应用的嵌套路由。 创建内嵌子路由，你需要添加一个 Vue 文件，同时添加一个与该文件同名的目录用来存放子视图组件。 别忘了在父级 Vue 文件内增加 用于显示子视图内容。 假设文件结构如： 12345pages/--| user/-----| _id.vue-----| index.vue--| user.vue Nuxt.js 自动生成的路由配置如下： 1234567891011121314151617181920router: &#123; routes: [ &#123; path: &apos;/user&apos;, component: &apos;pages/user.vue&apos;, children: [ &#123; path: &apos;&apos;, component: &apos;pages/user/index.vue&apos;, name: &apos;user&apos; &#125;, &#123; path: &apos;:id&apos;, component: &apos;pages/user/_id.vue&apos;, name: &apos;user-id&apos; &#125; ] &#125; ]&#125; 将user.vue文件创建到与user目录的父目录下，即和user目录保持平级。 123456789101112131415&lt;template&gt; &lt;div&gt; 用户管理导航，&lt;nuxt-link :to=&quot;&apos;/user/101&apos;&quot;&gt;修改&lt;/nuxt-link&gt; &lt;nuxt-child/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default&#123; layout:&quot;test&quot; &#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; _id.vue页面实现了向页面传入id参数，页面内容如下： 1234567891011121314151617181920212223&lt;template&gt; &lt;div&gt; 修改用户信息&#123;&#123;id&#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default&#123; layout:&quot;test&quot;, data()&#123; return &#123; id:&apos;&apos; &#125; &#125;, mounted()&#123; this.id = this.$route.params.id; console.log(this.id) &#125; &#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 测试：http://localhost:10000/user 点击修改： 3.6 获取数据3.6.1 asyncData 方法​ Nuxt.js 扩展了 Vue.js，增加了一个叫 asyncData 的方法，asyncData方法会在组件（限于页面组件）每次加载之前被调用。它可以在服务端或路由更新之前被调用。 在这个方法被调用的时候，第一个参数被设定为当前页面的上下文对象，你可以利用 asyncData方法来获取数据，Nuxt.js 会将 asyncData 返回的数据融合组件 data 方法返回的数据一并返回给当前组件。 注意：由于asyncData方法是在组件 初始化 前被调用的，所以在方法内是没有办法通过 this 来引用组件的实例对象。 例子： 在上边例子中的user/_id.vue中添加，页面代码如下： 1234567891011121314151617181920212223242526272829&lt;template&gt; &lt;div&gt; 修改用户信息&#123;&#123;id&#125;&#125;,名称：&#123;&#123;name&#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default&#123; layout:&apos;test&apos;, //根据id查询用户信息 asyncData()&#123; console.log(&quot;async方法&quot;) return &#123; name:&apos;黑马程序员&apos; &#125; &#125;, data()&#123; return &#123; id:&apos;&apos; &#125; &#125;, mounted()&#123; this.id = this.$route.params.id; &#125; &#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 此方法在服务端被执行，观察服务端控制台打印输出“async方法”。 此方法返回data模型数据，在服务端被渲染，最后响应给前端，刷新此页面查看页面源代码可以看到name模型数据已在页面源代码中显示。 3.6.2 async /await方法使用async 和 await配合promise也可以实现同步调用，nuxt.js中使用async/await实现同步调用效果。 1、先测试异步调用，增加a、b两个方法，并在mounted中调用。 12345678910111213141516171819202122232425262728methods:&#123; a()&#123; return new Promise(function(resolve,reject)&#123; setTimeout(function () &#123; resolve(1) &#125;,2000) &#125;) &#125;, b()&#123; return new Promise(function(resolve,reject)&#123; setTimeout(function () &#123; resolve(2) &#125;,1000) &#125;) &#125;&#125;, mounted()&#123; this.a().then(res=&gt;&#123; alert(res) console.log(res) &#125;) this.b().then(res=&gt;&#123; alert(res) console.log(res) &#125;) &#125; 观察客户端，并没有按照方法执行的顺序输出，使用Promise实现了异步调用。 2、使用async/await完成同步调用 1234567891011121314151617181920async asyncData(&#123; store, route &#125;) &#123; console.log(&quot;async方法&quot;) var a = await new Promise(function (resolve, reject) &#123; setTimeout(function () &#123; console.log(&quot;1&quot;) resolve(1) &#125;,2000) &#125;); var a = await new Promise(function (resolve, reject) &#123; setTimeout(function () &#123; console.log(&quot;2&quot;) resolve(2) &#125;,1000) &#125;); return &#123; name:&apos;黑马程序员&apos; &#125; &#125;, 观察服务端控制台发现是按照a、b方法的调用顺序输出1、2，实现了使用async/await完成同步调用。 3 搜索前端开发3.1 搜索页面3.1.1 需求分析 上图是课程搜索前端的界面，用户通过前端向服务端发起搜索请求，搜索功能包括： 1、界面默认查询所有课程，并分页显示 2、通过一级分类和二分类搜索课程，选择一级分类后将显示下属的二级分类 3、通过关键字搜索课程 4、通过课程等级搜索课程 3.1.2 页面布局nuxt.js将/layout/default.vue作为所有页面的默认布局，通常布局包括：页头、内容区、页尾 default.vue内容如下： 1234567891011121314151617181920&lt;template&gt; &lt;div&gt; &lt;Header /&gt; &lt;nuxt/&gt; &lt;Footer /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import Footer from &apos;../components/Footer.vue&apos; import Header from &apos;../components/Header.vue&apos; export default &#123; components: &#123; Header, Footer &#125; &#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 3.1.3 Nginx代理配置搜索页面中以/static开头的静态资源通过nginx解析，如下： /static/plugins：指向门户目录下的plugins目录。 /static/css：指向门户目录下的的css目录 修改Nginx中&lt;www.xuecheng.com&gt;虚拟主机的配置： 12345678910111213141516#静态资源，包括系统所需要的图片，js、css等静态资源 location /static/img/ &#123; alias F:/develop/xc_portal_static/img/; &#125; location /static/css/ &#123; alias F:/develop/xc_portal_static/css/; &#125; location /static/js/ &#123; alias F:/develop/xc_portal_static/js/; &#125; location /static/plugins/ &#123; alias F:/develop/xc_portal_static/plugins/; add_header Access-Control-Allow-Origin http://ucenter.xuecheng.com; add_header Access-Control-Allow-Credentials true; add_header Access-Control-Allow-Methods GET; &#125; 配置搜索Url，下图是Nginx搜索转发流程图： 用户请求/course/search时Nginx将请求转发到nuxt.js服务，nginx在转发时根据每台nuxt服务的负载情况进行转发，实现负载均衡。 本教程开发环境Nuxt.js服务和&lt;www.xuecheng.com&gt;虚拟机主在同一台计算机，使用同一个nginx，配置如下： 123456789101112#前端门户课程搜索location ^~ /course/search &#123; proxy_pass http://dynamic_portal_server_pool; &#125; #后端搜索服务location /openapi/search/ &#123; proxy_pass http://search_server_pool/search/; &#125; #分类信息location /static/category/ &#123; proxy_pass http://static_server_pool;&#125; dynamic_portal_server_pool配置如下 ： 12345678#前端动态门户upstream dynamic_portal_server_pool&#123; server 127.0.0.1:10000 weight=10;&#125; #后台搜索（公开api）upstream search_server_pool&#123; server 127.0.0.1:40100 weight=10;&#125; 其它配置： 1234#开发环境webpack定时加载此文件location ^~ /__webpack_hmr &#123; proxy_pass http://dynamic_portal_server_pool/__webpack_hmr; &#125; 1234#开发环境nuxt访问_nuxtlocation ^~ /_nuxt/ &#123; proxy_pass http://dynamic_portal_server_pool/_nuxt/; &#125; 在静态虚拟主机中添加：12345678#学成网静态资源server &#123; listen 91; server_name localhost; #分类信息 location /static/category/ &#123; alias F:/develop/xuecheng/static/category/; &#125; 3.1.4 搜索页面创建搜索页面如下： 页面文件参考：“资料”–》“search”–》index_1.vue，重要代码如下： nuxt.js支持定义header，本页面我们在header中引入css样式并定义头部信息。 1234567891011121314151617181920//配置文件let config = require(&apos;~/config/sysConfig&apos;)import querystring from &apos;querystring&apos;import * as courseApi from &apos;~/api/course&apos;export default &#123; head() &#123; return &#123; title: &apos;传智播客-一样的教育,不一样的品质&apos;, meta: [ &#123;charset: &apos;utf-8&apos;&#125;, &#123;name: &apos;description&apos;, content: &apos;传智播客专注IT培训,Java培训,Android培训,安卓培训,PHP培训,C++培训,网页设计培训,平面设计培训,UI设计培训,移动开发培训,网络营销培训,web前端培训,云计算大数据培训,全栈工程师培训,产品经理培训。&apos;&#125;, &#123;name: &apos;keywords&apos;, content: this.keywords&#125; ], link: [ &#123;rel: &apos;stylesheet&apos;, href: &apos;/static/plugins/normalize-css/normalize.css&apos;&#125;, &#123;rel: &apos;stylesheet&apos;, href: &apos;/static/plugins/bootstrap/dist/css/bootstrap.css&apos;&#125;, &#123;rel: &apos;stylesheet&apos;, href: &apos;/static/css/page-learing-list.css&apos;&#125; ] &#125; &#125;, 其它数据模型及方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;script&gt; //配置文件 let config = require(&apos;~/config/sysConfig&apos;) import querystring from &apos;querystring&apos; import * as courseApi from &apos;~/api/course&apos; export default &#123; head() &#123; return &#123; title: &apos;传智播客-一样的教育,不一样的品质&apos;, meta: [ &#123;charset: &apos;utf-8&apos;&#125;, &#123;name: &apos;description&apos;, content: &apos;传智播客专注IT培训,Java培训,Android培训,安卓培训,PHP培训,C++培训,网页设计培训,平面设计培训,UI设计培训,移动开发培训,网络营销培训,web前端培训,云计算大数据培训,全栈工程师培训,产品经理培训。&apos;&#125;, &#123;name: &apos;keywords&apos;, content: this.keywords&#125; ], link: [ &#123;rel: &apos;stylesheet&apos;, href: &apos;/static/plugins/normalize-css/normalize.css&apos;&#125;, &#123;rel: &apos;stylesheet&apos;, href: &apos;/static/plugins/bootstrap/dist/css/bootstrap.css&apos;&#125;, &#123;rel: &apos;stylesheet&apos;, href: &apos;/static/css/page-learing-list.css&apos;&#125; ] &#125; &#125;, async asyncData(&#123; store, route &#125;) &#123; return &#123; courselist: &#123;&#125;, first_category:&#123;&#125;, second_category:&#123;&#125;, mt:&apos;&apos;, st:&apos;&apos;, grade:&apos;&apos;, keyword:&apos;&apos;, total:0, imgUrl:config.imgUrl &#125; &#125;, data() &#123; return &#123; courselist: &#123;&#125;, first_category:&#123;&#125;, second_category:&#123;&#125;, mt:&apos;&apos;, st:&apos;&apos;, grade:&apos;&apos;, keyword:&apos;&apos;, imgUrl:config.imgUrl, total:0,//总记录数 page:1,//页码 page_size:12//每页显示个数 &#125; &#125;, watch:&#123;//路由发生变化立即搜索search表示search方法 &apos;$route&apos;:&apos;search&apos; &#125;, methods: &#123; //分页触发 handleCurrentChange(page) &#123; &#125;, //搜索方法 search()&#123; //刷新当前页面 window.location.reload(); &#125; &#125; &#125;&lt;/script&gt; 3.1.5 测试重启Nginx，请求：http://www.xuecheng.com/course/search，页面效果如下： 3.2 查询全部3.2.1 需求分析初次进入页面，没有输入任何查询条件，默认查询全部课程，分页显示。 3.2.2 API方法在api目录创建本工程所用的api方法类，api方法类使用了public.js等一些抽取类： /api/public.js————-抽取axios 的基础方法 /api/util.js—————–工具类 /config/sysConfig.js—-系统配置类，配置了系统参数变量 创建course.js，作为课程相关业务模块的api方法类。1234567891011121314import http from &apos;./public&apos;import qs from &apos;qs&apos;let config = require(&apos;~/config/sysConfig&apos;)let apiURL = config.apiURLlet staticURL = config.staticURLif (typeof window === &apos;undefined&apos;) &#123; apiURL = config.backApiURL staticURL = config.backStaticURL&#125;/*搜索*/export const search_course = (page,size,params) =&gt; &#123; let querys = qs.stringify(params); return http.requestQuickGet(apiURL+&quot;/search/course/list/&quot;+page+&quot;/&quot;+size+&quot;?&quot;+querys);&#125; 3.2.3搜索方法实现思路如下： 1、用户请求本页面到达node.js 2、在asyncData方法中向服务端请求查询课程 3、asyncData方法执行完成开始服务端渲染 在asyncData中执行搜索，代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859async asyncData(&#123; store, route &#125;) &#123;//服务端调用方法 //搜索课程 let page = route.query.page; if(!page)&#123; page = 1; &#125;else&#123; page = Number.parseInt(page) &#125; console.log(page); //请求搜索服务，搜索服务 let course_data = await courseApi.search_course(page,2,route.query); console.log(course_data) if (course_data &amp;&amp; course_data.queryResult ) &#123; let keywords = &apos;&apos; let mt=&apos;&apos; let st=&apos;&apos; let grade=&apos;&apos; let keyword=&apos;&apos; let total = course_data.queryResult.total if( route.query.mt)&#123; mt = route.query.mt &#125; if( route.query.st)&#123; st = route.query.st &#125; if( route.query.grade)&#123; grade = route.query.grade &#125; if( route.query.keyword)&#123; keyword = route.query.keyword &#125; return &#123; courselist: course_data.queryResult.list,//课程列表 keywords:keywords, mt:mt, st:st, grade:grade, keyword:keyword, page:page, total:total, imgUrl:config.imgUrl &#125; &#125;else&#123; return &#123; courselist: &#123;&#125;, first_category:&#123;&#125;, second_category:&#123;&#125;, mt:&apos;&apos;, st:&apos;&apos;, grade:&apos;&apos;, keyword:&apos;&apos;, page:page, total:0, imgUrl:config.imgUrl &#125; &#125; &#125; 3.2.5 页面在页面中展示课程列表。1234567891011121314151617181920&lt;div class=&quot;content-list&quot;&gt; &lt;div class=&quot;recom-item&quot; v-for=&quot;(course, index) in courselist&quot;&gt; &lt;nuxt-link :to=&quot;&apos;/course/detail/&apos;+course.id+&apos;.html&apos;&quot; target=&quot;_blank&quot;&gt; &lt;div v-if=&quot;course.pic&quot;&gt; &lt;p&gt;&lt;img :src=&quot;imgUrl+&apos;/&apos;+course.pic&quot; width=&quot;100%&quot; alt=&quot;&quot;&gt;&lt;/p&gt; &lt;/div&gt; &lt;div v-else&gt; &lt;p&gt;&lt;img src=&quot;/img/widget-demo1.png&quot; width=&quot;100%&quot; alt=&quot;&quot;&gt;&lt;/p&gt; &lt;/div&gt; &lt;ul &gt; &lt;li class=&quot;course_title&quot;&gt;&lt;span v-html=&quot;course.name&quot;&gt;&lt;/span&gt;&lt;/li&gt; &lt;li style=&quot;float: left&quot;&gt;&lt;span v-if=&quot;course.charge == &apos;203001&apos;&quot;&gt;免费&lt;/span&gt;&lt;span v-if=&quot;course.charge == &apos;203002&apos;&quot;&gt;￥&#123;&#123;course.price | money&#125;&#125;&lt;/span&gt; &lt;!-- &lt;em&gt; · &lt;/em&gt;--&gt;&amp;nbsp;&amp;nbsp;&lt;!--&lt;em&gt;1125人在学习&lt;/em&gt;--&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/nuxt-link&gt; &lt;/div&gt; &lt;li class=&quot;clearfix&quot;&gt;&lt;/li&gt; &lt;/div&gt; 3.3 分页查询3.3.1 服务端代码12345678910//分页//当前页码if(page&lt;=0)&#123; page = 1;&#125;//起始记录下标int from = (page -1) * size;searchSourceBuilder.from(from);searchSourceBuilder.size(size); 3.3.2 前端代码使用Element-UI的el-pagination分页插件：123456789101112&lt;div style=&quot;text-align: center&quot;&gt; &lt;el-pagination background layout=&quot;prev, pager, next&quot; @current-change=&quot;handleCurrentChange&quot; :total=&quot;total&quot; :page-size=&quot;page_size&quot; :current-page=&quot;page&quot; prev-text=&quot;上一页&quot; next-text=&quot;下一页&quot;&gt; &lt;/el-pagination&gt;&lt;/div&gt; 定义分页触发方法：12345678methods:&#123; //分页触发 handleCurrentChange(page) &#123; this.page = page this.$route.query.page = page let querys = querystring.stringify(this.$route.query) window.location = &apos;/course/search?&apos;+querys; &#125; 3.4 按分类搜索3.4.1 需求分析1、通过一级分类搜索 2、选择一级分类后将显示下属的二级分类 3、选择二分类进行搜索 4、选择一级分类的全部则表示没有按照分类搜索 5、选择一级分类的全部时二级分类不显示 3.4.2 API方法课程分类将通过页面静态化的方式写入静态资源下，通过/category/category.json可访问，通过&lt;www.xuecheng.com/static/category/category.json&gt;即可访问。 category.json的内容如下： 我们需要定义api方法获取所有的分类 在/api/course.js中添加：1234/*获取分类*/export const sysres_category = () =&gt; &#123; return http.requestQuickGet(staticURL+&quot;/static/category/category.json&quot;);&#125; 3.4.3 在asyncData中查询分类进入搜索页面将默认显示所有一级分类，当前如果已选择一级分类则要显示所有一级分类及该一级分类下属的二级分类。 在asyncData方法中实现上边的需求，代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576async asyncData(&#123; store, route &#125;) &#123;//服务端调用方法 //搜索课程 let page = route.query.page; if(!page)&#123; page = 1; &#125;else&#123; page = Number.parseInt(page) &#125; console.log(page); //请求搜索服务，搜索服务 let course_data = await courseApi.search_course(page,2,route.query); console.log(course_data) //查询分类 let category_data = await courseApi.sysres_category() if (course_data &amp;&amp; course_data.queryResult ) &#123; //全部分类 let category = category_data.category//分部分类 let first_category = category[0].children//一级分类 let second_category=[]//二级分类 let keywords = &apos;&apos; let mt=&apos;&apos; let st=&apos;&apos; let grade=&apos;&apos; let keyword=&apos;&apos; let total = course_data.queryResult.total if( route.query.mt)&#123; mt = route.query.mt &#125; if( route.query.st)&#123; st = route.query.st &#125; if( route.query.grade)&#123; grade = route.query.grade &#125; if( route.query.keyword)&#123; keyword = route.query.keyword &#125; //遍历一级分类 for(var i in first_category)&#123; keywords+=first_category[i].name+&apos; &apos; if(mt!=&apos;&apos;&amp;&amp; mt == first_category[i].id)&#123; //取出二级分类 second_category = first_category[i].children; // console.log(second_category) break; &#125; &#125; return &#123; courselist: course_data.queryResult.list,//课程列表 first_category: first_category, second_category: second_category, keywords:keywords, mt:mt, st:st, grade:grade, keyword:keyword, page:page, total:total, imgUrl:config.imgUrl &#125; &#125;else&#123; return &#123; courselist: &#123;&#125;, first_category:&#123;&#125;, second_category:&#123;&#125;, mt:&apos;&apos;, st:&apos;&apos;, grade:&apos;&apos;, keyword:&apos;&apos;, page:page, total:0, imgUrl:config.imgUrl &#125; &#125; &#125; 3.3.4 页面在页面显示一级分类及二级分类，需要根据当前是否选择一级分类、是否选择二分类显示页面内容。 123456789101112131415161718192021222324252627282930&lt;ul&gt; &lt;li&gt;一级分类：&lt;/li&gt; &lt;li v-if=&quot;mt!=&apos;&apos;&quot;&gt;&lt;nuxt-link class=&quot;title-link&quot; :to=&quot;&apos;/course/search?keyword=&apos;+keyword+&apos;&amp;grade=&apos;+grade&quot;&gt;全部&lt;/nuxt-link&gt;&lt;/li&gt; &lt;li class=&quot;all&quot; v-else&gt;全部&lt;/li&gt; &lt;ol&gt; &lt;li v-for=&quot;category_v in first_category&quot;&gt; &lt;nuxt-link class=&quot;title-link all&quot; :to=&quot;&apos;/course/search?keyword=&apos;+keyword+&apos;&amp;mt=&apos; + category_v.id&quot; v-if=&quot;category_v.id == mt&quot;&gt;&#123;&#123;category_v.name&#125;&#125;&lt;/nuxt-link&gt; &lt;nuxt-link class=&quot;title-link&quot; :to=&quot;&apos;/course/search?keyword=&apos;+keyword+&apos;&amp;mt=&apos; + category_v.id&quot; v-else&gt;&#123;&#123;category_v.name&#125;&#125;&lt;/nuxt-link&gt; &lt;/li&gt; &lt;/ol&gt; &lt;!--&lt;ol&gt; &lt;li&gt;数据分析&lt;/li&gt; &lt;li&gt;机器学习工程&lt;/li&gt; &lt;li&gt;前端开发工程&lt;/li&gt; &lt;/ol&gt;--&gt;&lt;/ul&gt;&lt;ul&gt; &lt;li&gt;二级分类：&lt;/li&gt; &lt;li v-if=&quot;st!=&apos;&apos;&quot;&gt;&lt;nuxt-link class=&quot;title-link&quot; :to=&quot;&apos;/course/search?keyword=&apos;+keyword+&apos;&amp;mt=&apos;+mt+&apos;&amp;grade=&apos;+grade&quot;&gt;全部&lt;/nuxt-link&gt;&lt;/li&gt; &lt;li class=&quot;all&quot; v-else&gt;全部&lt;/li&gt; &lt;ol v-if=&quot;second_category.length&gt;0&quot;&gt; &lt;li v-for=&quot;category_v in second_category&quot;&gt; &lt;nuxt-link class=&quot;title-link all&quot; :to=&quot;&apos;/course/search?keyword=&apos;+keyword+&apos;&amp;mt=&apos;+mt+&apos;&amp;st=&apos; + category_v.id&quot; v-if=&quot;category_v.id == st&quot;&gt;&#123;&#123;category_v.name&#125;&#125;&lt;/nuxt-link&gt; &lt;nuxt-link class=&quot;title-link&quot; :to=&quot;&apos;/course/search?keyword=&apos;+keyword+&apos;&amp;mt=&apos;+mt+&apos;&amp;st=&apos; + category_v.id&quot; v-else&gt;&#123;&#123;category_v.name&#125;&#125;&lt;/nuxt-link&gt; &lt;/li&gt; &lt;!-- &lt;li&gt;大数据&lt;/li&gt; &lt;li&gt;云计算&lt;/li&gt;--&gt; &lt;/ol&gt; &lt;!--&lt;a href=&quot;#&quot; class=&quot;more&quot;&gt;更多 ∨&lt;/a&gt;--&gt;&lt;/ul&gt; 3.3.5 立即搜索当用户点击分类时立即执行搜索，实现思路如下： 1）点击分类立即更改路由。 2）通过监听路由，路由更改则刷新页面。 1）创建搜索方法 1234search()&#123; //刷新当前页面 window.location.reload();&#125; 2）定义watch 通过vue.js的watch可以实现监视某个变量，当变量值出现变化时执行某个方法。 实现思路是： 1、点击分类页面路由更改 2、通过watch监视路由，路由更改触发search方法 与methods并行定义watch： 123watch:&#123;//路由发生变化立即搜索search表示search方法 &apos;$route&apos;:&apos;search&apos;&#125;, 3.5 按难度等级搜索3.5.1 需求分析用户选择不同的课程难度等级去搜索课程。 3.5.2 API方法使用 search_course方法完成搜索。 3.5.3页面按难度等级搜索思路如下： 1）点击难度等级立即更改路由。 2）通过监听路由，路由更改则立即执行search搜索方法。 按难度等级搜索页面代码如下： 12345678910111213141516&lt;ul&gt; &lt;li&gt;难度等级：&lt;/li&gt; &lt;li v-if=&quot;grade!=&apos;&apos;&quot;&gt; &lt;nuxt-link class=&quot;title-link&quot; :to=&quot;&apos;/course/search?keyword=&apos;+keyword+&apos;&amp;mt=&apos; + mt+&apos;&amp;st=&apos;+st+&apos;&amp;grade=&apos;&quot;&gt;全部 &lt;/nuxt-link&gt; &lt;/li&gt; &lt;li class=&quot;all&quot; v-else&gt;全部&lt;/li&gt; &lt;ol&gt; &lt;li v-if=&quot;grade==&apos;200001&apos;&quot; class=&quot;all&quot;&gt;初级&lt;/li&gt; &lt;li v-else&gt;&lt;nuxt-link class=&quot;title-link&quot; :to=&quot;&apos;/course/search?keyword=&apos;+keyword+&apos;&amp;mt=&apos; + mt+&apos;&amp;st=&apos;+st+&apos;&amp;grade=200001&apos;&quot;&gt;初级&lt;/nuxt-link&gt;&lt;/li&gt; &lt;li v-if=&quot;grade==&apos;200002&apos;&quot; class=&quot;all&quot;&gt;中级&lt;/li&gt; &lt;li v-else&gt;&lt;nuxt-link class=&quot;title-link&quot; :to=&quot;&apos;/course/search?keyword=&apos;+keyword+&apos;&amp;mt=&apos; + mt+&apos;&amp;st=&apos;+st+&apos;&amp;grade=200002&apos;&quot;&gt;中级&lt;/nuxt-link&gt;&lt;/li&gt; &lt;li v-if=&quot;grade==&apos;200003&apos;&quot; class=&quot;all&quot;&gt;高级&lt;/li&gt; &lt;li v-else&gt;&lt;nuxt-link class=&quot;title-link&quot; :to=&quot;&apos;/course/search?keyword=&apos;+keyword+&apos;&amp;mt=&apos; + mt+&apos;&amp;st=&apos;+st+&apos;&amp;grade=200003&apos;&quot;&gt;高级&lt;/nuxt-link&gt;&lt;/li&gt; &lt;/ol&gt;&lt;/ul&gt; 3.6 高亮显示3.6.1 服务端代码修改service的搜索方法，添加高亮设置： 1234567891011121314151617181920212223242526272829303132...//定义高亮HighlightBuilder highlightBuilder = new HighlightBuilder();highlightBuilder.preTags(&quot;&lt;font class=&apos;eslight&apos;&gt;&quot;);highlightBuilder.postTags(&quot;&lt;/font&gt;&quot;);highlightBuilder.fields().add(new HighlightBuilder.Field(&quot;name&quot;));searchSourceBuilder.highlighter(highlightBuilder);...//解析高亮字段for(SearchHit hit:searchHits)&#123; CoursePub coursePub = new CoursePub(); //源文档 Map&lt;String, Object&gt; sourceAsMap = hit.getSourceAsMap(); //课程id String id = (String) sourceAsMap.get(&quot;id&quot;); coursePub.setId(id); //取出name String name = (String) sourceAsMap.get(&quot;name&quot;); //取出高亮字段 Map&lt;String, HighlightField&gt; highlightFields = hit.getHighlightFields(); if(highlightFields.get(&quot;name&quot;)!=null)&#123; HighlightField highlightField = highlightFields.get(&quot;name&quot;); Text[] fragments = highlightField.fragments(); StringBuffer stringBuffer = new StringBuffer(); for(Text text:fragments)&#123; stringBuffer.append(text); &#125; name = stringBuffer.toString(); &#125; coursePub.setName(name); .... 3.6.2 前端代码在search/index.vue中定义eslight样式： 12345&lt;style&gt; .eslight&#123; color: red; &#125; ... 4 集成测试4.1 需求分析本次集成测试的目的如下： 1、测试课程发布与CMS接口是否正常。 2、测试课程发布与ES接口是否正常。 3、测试课程从创建到发布的整个过程。 4.2 准备环境1、启动MySQL、MongoDB 2、启动ElasticSearch、RabbitMQ 3、启动Eureka Server 4、启动CMS、课程管理服务、搜索服务。 5、启动Nginx、系统管理前端、教学管理前端、Nuxt.js。]]></content>
      <categories>
        <category>项目实战-在线学习视频网站</category>
      </categories>
      <tags>
        <tag>Elasticsearch</tag>
        <tag>Nuxt.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在线学习视频（十二）—— 搜索服务]]></title>
    <url>%2Fday11%20%E6%90%9C%E7%B4%A2%E6%9C%8D%E5%8A%A1.html</url>
    <content type="text"><![CDATA[搜索服务1 课程搜索需求分析1.1 需求分析 1、根据分类搜索课程信息。 2、根据关键字搜索课程信息，搜索方式为全文检索，关键字需要匹配课程的名称、 课程内容。 3、根据难度等级搜索课程。 4、搜索结点分页显示。 1.2 搜索流程 1、课程管理服务将数据写到MySQL数据库 2、使用Logstash将MySQL数据库中的数据写到ES的索引库。 3、用户在前端搜索课程信息，请求到搜索服务。 4、搜索服务请求ES搜索课程信息。 2 全文检索技术研究参考：elasticsearch研究 研究ElasticSearch搜索方法。 3 课程索引3.1 技术方案如何维护课程索引信息？ 1、当课程向MySQL添加后同时将课程信息添加到索引库。 采用Logstash实现，Logstash会从MySQL中将数据采集到ES索引库。 2、当课程在MySQL更新信息后同时更新该课程在索引库的信息。 采用Logstash实现。 3、当课程在MySQL删除后同时将该课程从索引库删除。 手工写程序实现，在删除课程后将索引库中该课程信息删除。 3.2 准备课程索引信息课程发布成功在MySQL数据库存储课程发布信息，此信息作为课程索引信息。 3.2.1创建课程发布表课程信息分布在course_base、course_pic等不同的表中。 课程发布成功为了方便进行索引将这几张表的数据合并在一张表中，作为课程发布信息。 创建course_pub表 3.2.2创建课程发布表模型在课程管理服务创建模型： 12345678910111213141516171819202122232425262728293031@Data@ToString@Entity@Table(name=&quot;course_pub&quot;)@GenericGenerator(name = &quot;jpa-assigned&quot;, strategy = &quot;assigned&quot;)public class CoursePub implements Serializable &#123; private static final long serialVersionUID = -916357110051689487L; @Id @GeneratedValue(generator = &quot;jpa-assigned&quot;) @Column(length = 32) private String id; private String name; private String users; private String mt; private String st; private String grade; private String studymodel; private String teachmode; private String description; private String pic;//图片 private Date timestamp;//时间戳 private String charge; private String valid; private String qq; private Float price; private Float price_old; private String expires; private String teachplan;//课程计划 @Column(name=&quot;pub_time&quot;) private String pubTime;//课程发布时间&#125; 3.2.3修改课程发布在课程管理服务定义dao： 1）创建course_pub表的dao 12public interface CoursePubRepository extends JpaRepository&lt;CoursePub, String&gt; &#123;&#125; 2) 修改课程发布service 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//保存CoursePub public CoursePub saveCoursePub(String id, CoursePub coursePub)&#123; if(StringUtils.isNotEmpty(id))&#123; ExceptionCast.cast(CourseCode.COURSE_PUBLISH_COURSEIDISNULL); &#125; CoursePub coursePubNew = null; Optional&lt;CoursePub&gt; coursePubOptional = coursePubRepository.findById(id); if(coursePubOptional.isPresent())&#123; coursePubNew = coursePubOptional.get(); &#125; if(coursePubNew == null)&#123; coursePubNew = new CoursePub(); &#125; BeanUtils.copyProperties(coursePub,coursePubNew); //设置主键 coursePubNew.setId(id); //更新时间戳为最新时间 coursePub.setTimestamp(new Date()); //发布时间 SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;YYYY-MM-dd HH:mm:ss&quot;); String date = simpleDateFormat.format(new Date()); coursePub.setPubTime(date); coursePubRepository.save(coursePub); return coursePub; &#125; //创建coursePub对象 private CoursePub createCoursePub(String id)&#123; CoursePub coursePub = new CoursePub(); coursePub.setId(id); //基础信息 Optional&lt;CourseBase&gt; courseBaseOptional = courseBaseRepository.findById(id); if(courseBaseOptional == null)&#123; CourseBase courseBase = courseBaseOptional.get(); BeanUtils.copyProperties(courseBase, coursePub); &#125; //查询课程图片 Optional&lt;CoursePic&gt; picOptional = coursePicRepository.findById(id); if(picOptional.isPresent())&#123; CoursePic coursePic = picOptional.get(); BeanUtils.copyProperties(coursePic, coursePub); &#125; //课程营销信息 Optional&lt;CourseMarket&gt; marketOptional = courseMarketRepository.findById(id); if(marketOptional.isPresent())&#123; CourseMarket courseMarket = marketOptional.get(); BeanUtils.copyProperties(courseMarket, coursePub); &#125; //课程计划 TeachplanNode teachplanNode = teachplanMapper.selectList(id); //将课程计划转成json String teachplanString = JSON.toJSONString(teachplanNode); coursePub.setTeachplan(teachplanString); return coursePub; &#125; 修改课程发布方法，添加调用saveCoursePub方法的代码，添加部分的代码如下： 123456789101112131415//课程发布 @Transactional public CoursePublishResult publish(String courseId)&#123; .... //创建课程索引 //创建课程索引信息 CoursePub coursePub = createCoursePub(courseId); //向数据库保存课程索引信息 CoursePub newCoursePub = saveCoursePub(courseId, coursePub); if(newCoursePub==null)&#123; //创建课程索引信息失败 ExceptionCast.cast(CourseCode.COURSE_PUBLISH_CREATE_INDEX_ERROR); &#125; &#125; 3.3 搭建ES环境3.3.1 ES安装开发环境使用ES单机环境，启动ES服务端。 注意：旧的ES环境，可以删除elasticsearch-6.2.1\data\nodes目录以完全清除ES环境。 安装elasticsearch-head并启动。 3.3.2 创建索引库创建索引库 创建xc_course索引库，一个分片，0个副本。 3.3.3 创建映射Post http://localhost:9200/xc_course/doc/_mapping 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&#123;&quot;properties&quot; : &#123; &quot;description&quot; : &#123; &quot;analyzer&quot; : &quot;ik_max_word&quot;, &quot;search_analyzer&quot;: &quot;ik_smart&quot;, &quot;type&quot; : &quot;text&quot; &#125;, &quot;grade&quot; : &#123; &quot;type&quot; : &quot;keyword&quot; &#125;, &quot;id&quot; : &#123; &quot;type&quot; : &quot;keyword&quot; &#125;, &quot;mt&quot; : &#123; &quot;type&quot; : &quot;keyword&quot; &#125;, &quot;name&quot; : &#123; &quot;analyzer&quot; : &quot;ik_max_word&quot;, &quot;search_analyzer&quot;: &quot;ik_smart&quot;, &quot;type&quot; : &quot;text&quot; &#125;, &quot;users&quot; : &#123; &quot;index&quot; : false, &quot;type&quot; : &quot;text&quot; &#125;, &quot;charge&quot; : &#123; &quot;type&quot; : &quot;keyword&quot; &#125;, &quot;valid&quot; : &#123; &quot;type&quot; : &quot;keyword&quot; &#125;, &quot;pic&quot; : &#123; &quot;index&quot; : false, &quot;type&quot; : &quot;keyword&quot; &#125;, &quot;qq&quot; : &#123; &quot;index&quot; : false, &quot;type&quot; : &quot;keyword&quot; &#125;, &quot;price&quot; : &#123; &quot;type&quot; : &quot;float&quot; &#125;, &quot;price_old&quot; : &#123; &quot;type&quot; : &quot;float&quot; &#125;, &quot;st&quot; : &#123; &quot;type&quot; : &quot;keyword&quot; &#125;, &quot;status&quot; : &#123; &quot;type&quot; : &quot;keyword&quot; &#125;, &quot;studymodel&quot; : &#123; &quot;type&quot; : &quot;keyword&quot; &#125;, &quot;teachmode&quot; : &#123; &quot;type&quot; : &quot;keyword&quot; &#125;, &quot;teachplan&quot; : &#123; &quot;analyzer&quot; : &quot;ik_max_word&quot;, &quot;search_analyzer&quot;: &quot;ik_smart&quot;, &quot;type&quot; : &quot;text&quot; &#125;, &quot;expires&quot; : &#123; &quot;type&quot; : &quot;date&quot;, &quot;format&quot;: &quot;yyyy-MM-dd HH:mm:ss&quot; &#125;, &quot;pub_time&quot; : &#123; &quot;type&quot; : &quot;date&quot;, &quot;format&quot;: &quot;yyyy-MM-dd HH:mm:ss&quot; &#125;, &quot;start_time&quot; : &#123; &quot;type&quot; : &quot;date&quot;, &quot;format&quot;: &quot;yyyy-MM-dd HH:mm:ss&quot; &#125;, &quot;end_time&quot; : &#123; &quot;type&quot; : &quot;date&quot;, &quot;format&quot;: &quot;yyyy-MM-dd HH:mm:ss&quot; &#125; &#125; &#125; 3.4 Logstash创建索引​ Logstash是ES下的一款开源软件，它能够同时 从多个来源采集数据、转换数据，然后将数据发送到Eleasticsearch中创建索引。 本项目使用Logstash将MySQL中的数据采用到ES索引中。 3.4.1 下载Logstash下载Logstash6.2.1版本，和本项目使用的Elasticsearch6.2.1版本一致。 解压： 3.4.2 安装logstash-input-jdbclogstash-input-jdbc 是ruby开发的，先下载ruby并安装 下载地址: https://rubyinstaller.org/downloads/ 下载2.5版本即可。 安装完成查看是否安装成功 Logstash5.x以上版本本身自带有logstash-input-jdbc，6.x版本本身不带logstash-input-jdbc插件，需要手动安装 安装成功后我们可以在logstash根目录下的以下目录查看对应的插件版本 解压老师提供的logstash-6.2.1.zip,此logstash中已集成了logstash-input-jdbc插件。 3.4.3 创建模板文件Logstash的工作是从MySQL中读取数据，向ES中创建索引，这里需要提前创建mapping的模板文件以便logstash使用。 在Logstash的config目录创建xc_course_template.json，内容如下： 本教程的xc_course_template.json目录是：D:/ElasticSearch/logstash-6.2.1/config/xc_course_template.json 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&#123; &quot;mappings&quot; : &#123; &quot;doc&quot; : &#123; &quot;properties&quot; : &#123; &quot;charge&quot; : &#123; &quot;type&quot; : &quot;keyword&quot; &#125;, &quot;description&quot; : &#123; &quot;analyzer&quot; : &quot;ik_max_word&quot;, &quot;search_analyzer&quot; : &quot;ik_smart&quot;, &quot;type&quot; : &quot;text&quot; &#125;, &quot;end_time&quot; : &#123; &quot;format&quot; : &quot;yyyy-MM-dd HH:mm:ss&quot;, &quot;type&quot; : &quot;date&quot; &#125;, &quot;expires&quot; : &#123; &quot;format&quot; : &quot;yyyy-MM-dd HH:mm:ss&quot;, &quot;type&quot; : &quot;date&quot; &#125;, &quot;grade&quot; : &#123; &quot;type&quot; : &quot;keyword&quot; &#125;, &quot;id&quot; : &#123; &quot;type&quot; : &quot;keyword&quot; &#125;, &quot;mt&quot; : &#123; &quot;type&quot; : &quot;keyword&quot; &#125;, &quot;name&quot; : &#123; &quot;analyzer&quot; : &quot;ik_max_word&quot;, &quot;search_analyzer&quot; : &quot;ik_smart&quot;, &quot;type&quot; : &quot;text&quot; &#125;, &quot;pic&quot; : &#123; &quot;index&quot; : false, &quot;type&quot; : &quot;keyword&quot; &#125;, &quot;price&quot; : &#123; &quot;type&quot; : &quot;float&quot; &#125;, &quot;price_old&quot; : &#123; &quot;type&quot; : &quot;float&quot; &#125;, &quot;pub_time&quot; : &#123; &quot;format&quot; : &quot;yyyy-MM-dd HH:mm:ss&quot;, &quot;type&quot; : &quot;date&quot; &#125;, &quot;qq&quot; : &#123; &quot;index&quot; : false, &quot;type&quot; : &quot;keyword&quot; &#125;, &quot;st&quot; : &#123; &quot;type&quot; : &quot;keyword&quot; &#125;, &quot;start_time&quot; : &#123; &quot;format&quot; : &quot;yyyy-MM-dd HH:mm:ss&quot;, &quot;type&quot; : &quot;date&quot; &#125;, &quot;status&quot; : &#123; &quot;type&quot; : &quot;keyword&quot; &#125;, &quot;studymodel&quot; : &#123; &quot;type&quot; : &quot;keyword&quot; &#125;, &quot;teachmode&quot; : &#123; &quot;type&quot; : &quot;keyword&quot; &#125;, &quot;teachplan&quot; : &#123; &quot;analyzer&quot; : &quot;ik_max_word&quot;, &quot;search_analyzer&quot; : &quot;ik_smart&quot;, &quot;type&quot; : &quot;text&quot; &#125;, &quot;users&quot; : &#123; &quot;index&quot; : false, &quot;type&quot; : &quot;text&quot; &#125;, &quot;valid&quot; : &#123; &quot;type&quot; : &quot;keyword&quot; &#125; &#125; &#125; &#125;, &quot;template&quot; : &quot;xc_course&quot;&#125; 3.4.4 配置mysql.conf在logstash的config目录下配置mysql.conf文件供logstash使用，logstash会根据mysql.conf文件的配置的地址从MySQL中读取数据向ES中写入索引。 参考https://www.elastic.co/guide/en/logstash/current/plugins-inputs-jdbc.html 配置输入数据源和输出数据源。 12345678910111213141516171819202122232425262728293031323334353637383940414243input &#123; stdin &#123; &#125; jdbc &#123; jdbc_connection_string =&gt; &quot;jdbc:mysql://localhost:3306/xc_course?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=true&amp;serverTimezone=UTC&quot; # the user we wish to excute our statement as jdbc_user =&gt; &quot;root&quot; jdbc_password =&gt; mysql # the path to our downloaded jdbc driver jdbc_driver_library =&gt; &quot;F:/develop/maven/repository3/mysql/mysql-connector-java/5.1.41/mysql-connector-java-5.1.41.jar&quot; # the name of the driver class for mysql jdbc_driver_class =&gt; &quot;com.mysql.jdbc.Driver&quot; jdbc_paging_enabled =&gt; &quot;true&quot; jdbc_page_size =&gt; &quot;50000&quot; #要执行的sql文件 #statement_filepath =&gt; &quot;/conf/course.sql&quot; statement =&gt; &quot;select * from course_pub where timestamp &gt; date_add(:sql_last_value,INTERVAL 8 HOUR)&quot; #定时配置 schedule =&gt; &quot;* * * * *&quot; record_last_run =&gt; true last_run_metadata_path =&gt; &quot;D:/ElasticSearch/logstash-6.2.1/config/logstash_metadata&quot; &#125;&#125;output &#123; elasticsearch &#123; #ES的ip地址和端口 hosts =&gt; &quot;localhost:9200&quot; #hosts =&gt; [&quot;localhost:9200&quot;,&quot;localhost:9202&quot;,&quot;localhost:9203&quot;] #ES索引库名称 index =&gt; &quot;xc_course&quot; document_id =&gt; &quot;%&#123;id&#125;&quot; document_type =&gt; &quot;doc&quot; template =&gt;&quot;D:/ElasticSearch/logstash-6.2.1/config/xc_course_template.json&quot; template_name =&gt;&quot;xc_course&quot; template_overwrite =&gt;&quot;true&quot; &#125; stdout &#123; #日志输出 codec =&gt; json_lines &#125;&#125; 说明： 1、ES采用UTC时区问题 ES采用UTC 时区，比北京时间早8小时，所以ES读取数据时让最后更新时间加8小时 where timestamp &gt; date_add(:sql_last_value,INTERVAL 8 HOUR) 2、logstash每个执行完成会在D:/ElasticSearch/logstash-6.2.1/config/logstash_metadata记录执行时间下次以此时间为基准进行增量同步数据到索引库。 3.4.5 测试启动logstash.bat： 1.\logstash.bat -f ..\config\mysql.conf 修改course_pub中的数据，并且修改timestamp为当前时间，观察Logstash日志是否读取到要索引的数据。 最后用head登录ES查看索引文档内容是否修改。 4 课程搜索4.1 需求分析 1、根据分类搜索课程信息。 2、根据关键字搜索课程信息，搜索方式为全文检索，关键字需要匹配课程的名称、 课程内容。 3、根据难度等级搜索课程。 4、搜索结点分页显示。 技术分析： 1、根据关键字搜索，采用MultiMatchQuery，搜索name、description、teachplan 2、根据分类、课程等级搜索采用过虑器实现。 3、分页查询。 4、高亮显示。 4.2 创建搜索服务工程1）创建xc-service-search工程 2）配置 1、配置appliction.yml 12345678910server: port: 40100spring: application: name: xc-search-serviceelasticsearch: hostlist: 127.0.0.1:9200 #多个结点中间用逗号分隔 course: index: xc_course type: doc 2、配置RestHighLevelClient和RestClient 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.xuecheng.search.config;import org.apache.http.HttpHost;import org.elasticsearch.client.RestClient;import org.elasticsearch.client.RestHighLevelClient;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configurationpublic class ElasticsearchConfig &#123; @Value(&quot;$&#123;xuecheng.elasticsearch.hostlist&#125;&quot;) private String hostlist; @Bean public RestHighLevelClient restHighLevelClient()&#123; //解析hostlist配置信息 String[] split = hostlist.split(&quot;,&quot;); //创建HttpHost数组，其中存放es主机和端口的配置信息 HttpHost[] httpHostArray = new HttpHost[split.length]; for(int i=0;i&lt;split.length;i++)&#123; String item = split[i]; httpHostArray[i] = new HttpHost(item.split(&quot;:&quot;)[0], Integer.parseInt(item.split(&quot;:&quot;)[1]), &quot;http&quot;); &#125; //创建RestHighLevelClient客户端 return new RestHighLevelClient(RestClient.builder(httpHostArray)); &#125; @Bean public RestClient restClient()&#123; //解析hostlist配置信息 String[] split = hostlist.split(&quot;,&quot;); //创建HttpHost数组，其中存放es主机和端口的配置信息 HttpHost[] httpHostArray = new HttpHost[split.length]; for(int i=0;i&lt;split.length;i++)&#123; String item = split[i]; httpHostArray[i] = new HttpHost(item.split(&quot;:&quot;)[0], Integer.parseInt(item.split(&quot;:&quot;)[1]), &quot;http&quot;); &#125; return RestClient.builder(httpHostArray).build(); &#125;&#125; 4.3 API123456789@Api(value = &quot;课程搜索&quot;,description = &quot;课程搜索&quot;,tags = &#123;&quot;课程搜索&quot;&#125;)public interface EsCourseControllerApi &#123; @ApiOperation(&quot;课程搜索&quot;) public QueryResponseResult&lt;CoursePub&gt; list(int page,int size, CourseSearchParam courseSearchParam) throws IOException;&#125; 4.4 ServiceService方法代码复杂，这里分三步完成。 4.4.1 按关键字搜索1）在appliction.yml中配置source_field 123456elasticsearch: hostlist: 127.0.0.1:9200 #多个结点中间用逗号分隔 course: index: xc_course type: doc source_field: id,name,grade,mt,st,charge,valid,pic,qq,price,price_old,status,studymodel,teachmode,expires,pub_time,start_time,end_time 2）service完整代码如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102@Servicepublic class EsCourseService &#123; private static final Logger LOGGER = LoggerFactory.getLogger(EsCourseService.class); @Value(&quot;$&#123;xuecheng.elasticsearch.course.index&#125;&quot;) private String es_index; @Value(&quot;$&#123;xuecheng.elasticsearch.course.type&#125;&quot;) private String es_type; @Value(&quot;$&#123;xuecheng.elasticsearch.course.source_field&#125;&quot;) private String source_field; @Autowired RestHighLevelClient restHighLevelClient; public QueryResponseResult&lt;CoursePub&gt; list(int page,int size,CourseSearchParam courseSearchParam) &#123; //设置索引 SearchRequest searchRequest = new SearchRequest(es_index); //设置类型 searchRequest.types(es_type); SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder(); BoolQueryBuilder boolQueryBuilder = QueryBuilders.boolQuery(); //source源字段过虑 String[] source_fields = source_field.split(&quot;,&quot;); searchSourceBuilder.fetchSource(source_fields, new String[]&#123;&#125;); //关键字 if(StringUtils.isNotEmpty(courseSearchParam.getKeyword()))&#123; //匹配关键字 MultiMatchQueryBuilder multiMatchQueryBuilder = QueryBuilders.multiMatchQuery(courseSearchParam.getKeyword(), &quot;name&quot;, &quot;teachplan&quot;,&quot;description&quot;); //设置匹配占比 multiMatchQueryBuilder.minimumShouldMatch(&quot;70%&quot;); //提升另个字段的Boost值 multiMatchQueryBuilder.field(&quot;name&quot;,10); boolQueryBuilder.must(multiMatchQueryBuilder); &#125; //布尔查询 searchSourceBuilder.query(boolQueryBuilder); //请求搜索 searchRequest.source(searchSourceBuilder); SearchResponse searchResponse = null; try &#123; searchResponse = restHighLevelClient.search(searchRequest); &#125; catch (IOException e) &#123; e.printStackTrace(); LOGGER.error(&quot;xuecheng search error..&#123;&#125;&quot;,e.getMessage()); return new QueryResponseResult(CommonCode.SUCCESS,new QueryResult&lt;CoursePub&gt;()); &#125; //结果集处理 SearchHits hits = searchResponse.getHits(); SearchHit[] searchHits = hits.getHits(); //记录总数 long totalHits = hits.getTotalHits(); //数据列表 List&lt;CoursePub&gt; list = new ArrayList&lt;&gt;(); for (SearchHit hit : searchHits) &#123; CoursePub coursePub = new CoursePub(); //取出source Map&lt;String, Object&gt; sourceAsMap = hit.getSourceAsMap(); //取出名称 String name = (String) sourceAsMap.get(&quot;name&quot;); coursePub.setName(name); //图片 String pic = (String) sourceAsMap.get(&quot;pic&quot;); coursePub.setPic(pic); //价格 Float price = null; try &#123; if(sourceAsMap.get(&quot;price&quot;)!=null )&#123; price = Float.parseFloat((String) sourceAsMap.get(&quot;price&quot;)); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; coursePub.setPrice(price); Float price_old = null; try &#123; if(sourceAsMap.get(&quot;price_old&quot;)!=null )&#123; price_old = Float.parseFloat((String) sourceAsMap.get(&quot;price_old&quot;)); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; coursePub.setPrice_old(price_old); list.add(coursePub); &#125; QueryResult&lt;CoursePub&gt; queryResult = new QueryResult&lt;&gt;(); queryResult.setList(list); queryResult.setTotal(totalHits); QueryResponseResult&lt;CoursePub&gt; coursePubQueryResponseResult = new QueryResponseResult&lt;CoursePub&gt;(CommonCode.SUCCESS,queryResult); return coursePubQueryResponseResult; &#125;&#125; 4.4.2 按分类和难度等级搜索按分类和难度等级搜索代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112@Servicepublic class EsCourseService &#123; private static final Logger LOGGER = LoggerFactory.getLogger(EsCourseService.class); @Value(&quot;$&#123;xuecheng.elasticsearch.course.index&#125;&quot;) private String es_index; @Value(&quot;$&#123;xuecheng.elasticsearch.course.type&#125;&quot;) private String es_type; @Value(&quot;$&#123;xuecheng.elasticsearch.course.source_field&#125;&quot;) private String source_field; @Autowired RestHighLevelClient restHighLevelClient; public QueryResponseResult&lt;CoursePub&gt; list(int page,int size,CourseSearchParam courseSearchParam) &#123; //设置索引 SearchRequest searchRequest = new SearchRequest(es_index); //设置类型 searchRequest.types(es_type); SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder(); BoolQueryBuilder boolQueryBuilder = QueryBuilders.boolQuery(); //source源字段过虑 String[] source_fields = source_field.split(&quot;,&quot;); searchSourceBuilder.fetchSource(source_fields, new String[]&#123;&#125;); //关键字 if(StringUtils.isNotEmpty(courseSearchParam.getKeyword()))&#123; //匹配关键字 MultiMatchQueryBuilder multiMatchQueryBuilder = QueryBuilders.multiMatchQuery(courseSearchParam.getKeyword(), &quot;name&quot;, &quot;teachplan&quot;,&quot;description&quot;); //设置匹配占比 multiMatchQueryBuilder.minimumShouldMatch(&quot;70%&quot;); //提升另个字段的Boost值 multiMatchQueryBuilder.field(&quot;name&quot;,10); boolQueryBuilder.must(multiMatchQueryBuilder); &#125; //过虑 if(StringUtils.isNotEmpty(courseSearchParam.getMt()))&#123; boolQueryBuilder.filter(QueryBuilders.termQuery(&quot;mt&quot;,courseSearchParam.getMt())); &#125; if(StringUtils.isNotEmpty(courseSearchParam.getSt()))&#123; boolQueryBuilder.filter(QueryBuilders.termQuery(&quot;st&quot;,courseSearchParam.getSt())); &#125; if(StringUtils.isNotEmpty(courseSearchParam.getGrade()))&#123; boolQueryBuilder.filter(QueryBuilders.termQuery(&quot;grade&quot;,courseSearchParam.getGrade())); &#125; //布尔查询 searchSourceBuilder.query(boolQueryBuilder); //请求搜索 searchRequest.source(searchSourceBuilder); SearchResponse searchResponse = null; try &#123; searchResponse = restHighLevelClient.search(searchRequest); &#125; catch (IOException e) &#123; e.printStackTrace(); LOGGER.error(&quot;xuecheng search error..&#123;&#125;&quot;,e.getMessage()); return new QueryResponseResult(CommonCode.SUCCESS,new QueryResult&lt;CoursePub&gt;()); &#125; //结果集处理 SearchHits hits = searchResponse.getHits(); SearchHit[] searchHits = hits.getHits(); //记录总数 long totalHits = hits.getTotalHits(); //数据列表 List&lt;CoursePub&gt; list = new ArrayList&lt;&gt;(); for (SearchHit hit : searchHits) &#123; CoursePub coursePub = new CoursePub(); //取出source Map&lt;String, Object&gt; sourceAsMap = hit.getSourceAsMap(); //取出名称 String name = (String) sourceAsMap.get(&quot;name&quot;); coursePub.setName(name); //图片 String pic = (String) sourceAsMap.get(&quot;pic&quot;); coursePub.setPic(pic); //价格 Float price = null; try &#123; if(sourceAsMap.get(&quot;price&quot;)!=null )&#123; price = Float.parseFloat((String) sourceAsMap.get(&quot;price&quot;)); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; coursePub.setPrice(price); Float price_old = null; try &#123; if(sourceAsMap.get(&quot;price_old&quot;)!=null )&#123; price_old = Float.parseFloat((String) sourceAsMap.get(&quot;price_old&quot;)); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; coursePub.setPrice_old(price_old); list.add(coursePub); &#125; QueryResult&lt;CoursePub&gt; queryResult = new QueryResult&lt;&gt;(); queryResult.setList(list); queryResult.setTotal(totalHits); QueryResponseResult&lt;CoursePub&gt; coursePubQueryResponseResult = new QueryResponseResult&lt;CoursePub&gt;(CommonCode.SUCCESS,queryResult); return coursePubQueryResponseResult; &#125;&#125; 4.4.3 分页与高亮123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141@Servicepublic class EsCourseService &#123; private static final Logger LOGGER = LoggerFactory.getLogger(EsCourseService.class); @Value(&quot;$&#123;xuecheng.elasticsearch.course.index&#125;&quot;) private String es_index; @Value(&quot;$&#123;xuecheng.elasticsearch.course.type&#125;&quot;) private String es_type; @Value(&quot;$&#123;xuecheng.elasticsearch.course.source_field&#125;&quot;) private String source_field; @Autowired RestHighLevelClient restHighLevelClient; public QueryResponseResult&lt;CoursePub&gt; list(int page,int size,CourseSearchParam courseSearchParam) &#123; //设置索引 SearchRequest searchRequest = new SearchRequest(es_index); //设置类型 searchRequest.types(es_type); SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder(); BoolQueryBuilder boolQueryBuilder = QueryBuilders.boolQuery(); //source源字段过虑 String[] source_fields = source_field.split(&quot;,&quot;); searchSourceBuilder.fetchSource(source_fields, new String[]&#123;&#125;); //关键字 if(StringUtils.isNotEmpty(courseSearchParam.getKeyword()))&#123; //匹配关键字 MultiMatchQueryBuilder multiMatchQueryBuilder = QueryBuilders.multiMatchQuery(courseSearchParam.getKeyword(), &quot;name&quot;, &quot;teachplan&quot;,&quot;description&quot;); //设置匹配占比 multiMatchQueryBuilder.minimumShouldMatch(&quot;70%&quot;); //提升另个字段的Boost值 multiMatchQueryBuilder.field(&quot;name&quot;,10); boolQueryBuilder.must(multiMatchQueryBuilder); &#125; //过虑 if(StringUtils.isNotEmpty(courseSearchParam.getMt()))&#123; boolQueryBuilder.filter(QueryBuilders.termQuery(&quot;mt&quot;,courseSearchParam.getMt())); &#125; if(StringUtils.isNotEmpty(courseSearchParam.getSt()))&#123; boolQueryBuilder.filter(QueryBuilders.termQuery(&quot;st&quot;,courseSearchParam.getSt())); &#125; if(StringUtils.isNotEmpty(courseSearchParam.getGrade()))&#123; boolQueryBuilder.filter(QueryBuilders.termQuery(&quot;grade&quot;,courseSearchParam.getGrade())); &#125; //分页 if(page&lt;=0)&#123; page = 1; &#125; if(size&lt;=0)&#123; size = 20; &#125; int start = (page-1)*size; searchSourceBuilder.from(start); searchSourceBuilder.size(size); //布尔查询 searchSourceBuilder.query(boolQueryBuilder); //高亮设置 HighlightBuilder highlightBuilder = new HighlightBuilder(); highlightBuilder.preTags(&quot;&lt;font class=&apos;eslight&apos;&gt;&quot;); highlightBuilder.postTags(&quot;&lt;/font&gt;&quot;); //设置高亮字段 highlightBuilder.fields().add(new HighlightBuilder.Field(&quot;name&quot;)); searchSourceBuilder.highlighter(highlightBuilder); //请求搜索 searchRequest.source(searchSourceBuilder); SearchResponse searchResponse = null; try &#123; searchResponse = restHighLevelClient.search(searchRequest); &#125; catch (IOException e) &#123; e.printStackTrace(); LOGGER.error(&quot;xuecheng search error..&#123;&#125;&quot;,e.getMessage()); return new QueryResponseResult(CommonCode.SUCCESS,new QueryResult&lt;CoursePub&gt;()); &#125; //结果集处理 SearchHits hits = searchResponse.getHits(); SearchHit[] searchHits = hits.getHits(); //记录总数 long totalHits = hits.getTotalHits(); //数据列表 List&lt;CoursePub&gt; list = new ArrayList&lt;&gt;(); for (SearchHit hit : searchHits) &#123; CoursePub coursePub = new CoursePub(); //取出source Map&lt;String, Object&gt; sourceAsMap = hit.getSourceAsMap(); //取出名称 String name = (String) sourceAsMap.get(&quot;name&quot;); //取出高亮字段内容 Map&lt;String, HighlightField&gt; highlightFields = hit.getHighlightFields(); if(highlightFields!=null)&#123; HighlightField nameField = highlightFields.get(&quot;name&quot;); if(nameField!=null)&#123; Text[] fragments = nameField.getFragments(); StringBuffer stringBuffer = new StringBuffer(); for (Text str : fragments) &#123; stringBuffer.append(str.string()); &#125; name = stringBuffer.toString(); &#125; &#125; coursePub.setName(name); //图片 String pic = (String) sourceAsMap.get(&quot;pic&quot;); coursePub.setPic(pic); //价格 Float price = null; try &#123; if(sourceAsMap.get(&quot;price&quot;)!=null )&#123; price = Float.parseFloat((String) sourceAsMap.get(&quot;price&quot;)); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; coursePub.setPrice(price); Float price_old = null; try &#123; if(sourceAsMap.get(&quot;price_old&quot;)!=null )&#123; price_old = Float.parseFloat((String) sourceAsMap.get(&quot;price_old&quot;)); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; coursePub.setPrice_old(price_old); list.add(coursePub); &#125; QueryResult&lt;CoursePub&gt; queryResult = new QueryResult&lt;&gt;(); queryResult.setList(list); queryResult.setTotal(totalHits); QueryResponseResult&lt;CoursePub&gt; coursePubQueryResponseResult = new QueryResponseResult&lt;CoursePub&gt;(CommonCode.SUCCESS,queryResult); return coursePubQueryResponseResult; &#125;&#125; 4.5 Controller123456789101112@RestController@RequestMapping(&quot;/search/course&quot;)public class EsCourseController implements EsCourseControllerApi &#123; @Autowired EsCourseService esCourseService; @Override @GetMapping(value=&quot;/list/&#123;page&#125;/&#123;size&#125;&quot;) public QueryResponseResult&lt;CoursePub&gt; list(@PathVariable(&quot;page&quot;) int page, @PathVariable(&quot;size&quot;) int size, CourseSearchParam courseSearchParam) throws IOException &#123; return esCourseService.list(page,size,courseSearchParam); &#125;&#125; 4.5 测试使用postman测试/search/course]]></content>
      <categories>
        <category>项目实战-在线学习视频网站</category>
        <category>ElasticSearch Logstash</category>
      </categories>
      <tags>
        <tag>Elasticsearch</tag>
        <tag>Logstash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在线学习视频（七）—— 课程管理实战]]></title>
    <url>%2Fday07-%E8%AF%BE%E7%A8%8B%E7%AE%A1%E7%90%86%E5%AE%9E%E6%88%98.html</url>
    <content type="text"><![CDATA[课程管理实战1 我的课程1.1需求分析课程添加完成后可通过我的课程进入课程修改页面，此页面显示我的课程列表，如下图所示，可分页查询。 ​ 上边的查询要实现分页、会存在多表关联查询，所以建议使用mybatis实现我的课程查询。 1.2 API接口输入参数： 页码、每页显示个数、查询条件 输出结果类型： QueryResponseResult&lt;自定义类型&gt;在api工程创建course包，创建CourseControllerApi接口。 12345678//查询课程列表@ApiOperation(&quot;查询我的课程列表&quot;)public QueryResponseResult&lt;CourseInfo&gt; findCourseList( int page, int size, CourseListRequest courseListRequest); 1.3 课程管理服务1.3.1 PageHelperPageHelper是mybatis的通用分页插件，通过mybatis的拦截器实现分页功能，拦截sql查询请求，添加分页语句，最终实现分页查询功能。 我的课程具有分页功能，本项目使用Pagehelper实现Mybatis分页功能开发，由于本项目使用springboot开发，在springboot上集成pagehelper（https://github.com/pagehelper/pagehelper-spring-boot） PageHelper的使用方法及原理如下： 在调用dao的service方法中设置分页参数：PageHelper.startPage(page, size)，分页参数会设置在ThreadLocal中 PageHelper在mybatis执行sql前进行拦截，从ThreadLocal取出分页参数，修改当前执行的sql语句，添加分页sql。 最后执行添加了分页sql的sql语句，实现分页查询。 1）添加依赖 12345&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.4&lt;/version&gt;&lt;/dependency&gt; 2）配置pageHelper 在application.yml中配置pageHelper操作的数据库类型： 12pagehelper: helper-dialect: mysql 2.3.2 Dao1）mapper 接口 1234567891011import com.github.pagehelper.Page;import com.xuecheng.framework.domain.course.CourseBase;import com.xuecheng.framework.domain.course.ext.CourseInfo;import com.xuecheng.framework.domain.course.request.CourseListRequest;import org.apache.ibatis.annotations.Mapper;@Mapperpublic interface CourseMapper &#123; CourseBase findCourseBaseById(String id); Page&lt;CourseInfo&gt; findCourseListPage(CourseListRequest courseListRequest);&#125; 2）mapper.xml映射文件 12345678&lt;select id=&quot;findCourseListPage&quot; resultType=&quot;com.xuecheng.framework.domain.course.ext.CourseInfo&quot; parameterType=&quot;com.xuecheng.framework.domain.course.request.CourseListRequest&quot;&gt; SELECT course_base.*, (SELECT pic FROM course_pic WHERE courseid = course_base.id) pic FROM course_base&lt;/select&gt; 3）测试Dao 123456789//测试分页@Testpublic void testPageHelper()&#123; PageHelper.startPage(2, 1); CourseListRequest courseListRequest = new CourseListRequest(); Page&lt;CourseInfo&gt; courseListPage = courseMapper.findCourseListPage(courseListRequest); List&lt;CourseInfo&gt; result = courseListPage.getResult(); System.out.println(courseListPage);&#125; 测试前修改日志级别为debug，并跟踪运行日志，发现sql语句中已经包括分页语句。 1.3.3 Service定义CourseService.java类，用于课程管理的service定义： 12345678910111213141516171819202122232425//课程列表分页查询 public QueryResponseResult&lt;CourseInfo&gt; findCourseList(int page,int size,CourseListRequest courseListRequest) &#123; if(courseListRequest == null)&#123; courseListRequest = new CourseListRequest(); &#125; if(page&lt;=0)&#123; page = 0; &#125; if(size&lt;=0)&#123; size = 20; &#125; //设置分页参数 PageHelper.startPage(page, size); //分页查询 Page&lt;CourseInfo&gt; courseListPage = courseMapper.findCourseListPage(courseListRequest); //查询列表 List&lt;CourseInfo&gt; list = courseListPage.getResult(); //总记录数 long total = courseListPage.getTotal(); //查询结果集 QueryResult&lt;CourseInfo&gt; courseIncfoQueryResult = new QueryResult&lt;CourseInfo&gt;(); courseIncfoQueryResult.setList(list); courseIncfoQueryResult.setTotal(total); return new QueryResponseResult&lt;CourseInfo&gt;(CommonCode.SUCCESS, courseIncfoQueryResult); &#125; 1.3.4 Controller123456789101112131415@RestController@RequestMapping(&quot;/course&quot;)public class CourseController implements CourseControllerApi &#123; @Autowired CourseService courseService; @Override @GetMapping(&quot;/coursebase/list/&#123;page&#125;/&#123;size&#125;&quot;) public QueryResponseResult&lt;CourseInfo&gt; findCourseList( @PathVariable(&quot;page&quot;) int page, @PathVariable(&quot;size&quot;) int size, CourseListRequest courseListRequest) &#123; return courseService.findCourseList(page,size,courseListRequest); &#125;&#125; 1.3.5 测试使用postman或swagger-ui测试课程列表接口。 1.4 前端1.4.1 页面创建course_list.vue 1）使用element 的card组件 页面布局代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115&lt;template&gt; &lt;section&gt; &lt;el-row &gt; &lt;el-col :span=&quot;8&quot; :offset=2 &gt; &lt;el-card :body-style=&quot;&#123; padding: &apos;10px&apos; &#125;&quot;&gt; &lt;img src=&quot;/static/images/add.jpg&quot; class=&quot;image&quot; height=&quot;150px&quot;&gt; &lt;div style=&quot;padding: 10px;&quot;&gt; &lt;span&gt;课程名称&lt;/span&gt; &lt;div class=&quot;bottom clearfix&quot;&gt; &lt;time class=&quot;time&quot;&gt;&lt;/time&gt; &lt;router-link class=&quot;mui-tab-item&quot; :to=&quot;&#123;path:&apos;/course/add/base&apos;&#125;&quot;&gt; &lt;el-button type=&quot;text&quot; class=&quot;button&quot; &gt;新增课程&lt;/el-button&gt; &lt;/router-link&gt; &lt;/div&gt; &lt;/div&gt; &lt;/el-card&gt; &lt;/el-col&gt; &lt;el-col :span=&quot;8&quot; v-for=&quot;(course, index) in courses&quot; :key=&quot;course.id&quot; :offset=&quot;index &gt; 0 ? 2 : 2&quot;&gt; &lt;el-card :body-style=&quot;&#123; padding: &apos;10px&apos; &#125;&quot;&gt; &lt;img :src=&quot;course.pic!=null?imgUrl+course.pic:&apos;/static/images/nonepic.jpg&apos;&quot; class=&quot;image&quot; height=&quot;150px&quot;&gt; &lt;div style=&quot;padding: 10px;&quot;&gt; &lt;span&gt;&#123;&#123;course.name&#125;&#125;&lt;/span&gt; &lt;div class=&quot;bottom clearfix&quot;&gt; &lt;time class=&quot;time&quot;&gt;&lt;/time&gt; &lt;el-button type=&quot;text&quot; class=&quot;button&quot; @click=&quot;handleManage(course.id)&quot;&gt;管理课程&lt;/el-button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/el-card&gt; &lt;/el-col&gt; &lt;!--分页--&gt; &lt;el-col :span=&quot;24&quot; class=&quot;toolbar&quot;&gt; &lt;el-pagination background layout=&quot;prev, pager, next&quot; @current-change=&quot;handleCurrentChange&quot; :page-size=&quot;size&quot; :total=&quot;total&quot; :current-page=&quot;page&quot; style=&quot;float:right;&quot;&gt; &lt;/el-pagination&gt; &lt;/el-col&gt; &lt;/el-row&gt; &lt;/section&gt;&lt;/template&gt;&lt;script&gt; import * as courseApi from &apos;../api/course&apos;; import utilApi from &apos;../../../common/utils&apos;; let sysConfig = require(&apos;@/../config/sysConfig&apos;) export default &#123; data() &#123; return &#123; page:1, size:7, total: 0, courses: [], sels: [],//列表选中列 imgUrl:sysConfig.imgUrl &#125; &#125;, methods: &#123; //分页方法 handleCurrentChange(val) &#123; this.page = val; &#125;, //获取课程列表 getCourse() &#123; &#125;, handleManage: function (id) &#123; console.log(id) this.$router.push(&#123; path: &apos;/course/manager/&apos;+id&#125;) &#125; &#125;, created()&#123; &#125;, mounted() &#123; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .el-col-8&#123; width:20% &#125; .el-col-offset-2&#123; margin-left:2% &#125; .time &#123; font-size: 13px; color: #999; &#125; .bottom &#123; margin-top: 13px; line-height: 12px; &#125; .button &#123; padding: 0; float: right; &#125; .image &#123; width: 100%; display: block; &#125; .clearfix:before, .clearfix:after &#123; display: table; content: &quot;&quot;; &#125; .clearfix:after &#123; clear: both &#125;&lt;/style&gt; 6）路由 1234567891011121314import course_list from &apos;@/module/course/page/course_list.vue&apos;;import Home from &apos;@/module/home/page/home.vue&apos;;export default [ &#123; path: &apos;/course&apos;, component: Home, name: &apos;课程管理&apos;, hidden: false, iconCls: &apos;el-icon-document&apos;, children: [ &#123; path: &apos;/course/list&apos;, name: &apos;我的课程&apos;,component: course_list,hidden: false &#125; ] &#125;] 1.4.2 Api调用1、定义Api方法 1234567//我的课程列表export const findCourseList = (page,size,params) =&gt; &#123; //对于查询条件，向服务端传入key/value串。 //使用工具类将json对象转成key/value let queries = querystring.stringify(params) return http.requestQuickGet(apiUrl+&quot;/course/coursebase/list/&quot;+page+&quot;/&quot;+size+&quot;?&quot;+queries);&#125; 2、在页面调用findCourseList方法： 12345678910//获取课程列表getCourse() &#123; courseApi.findCourseList(this.page,this.size,&#123;&#125;).then((res) =&gt; &#123; console.log(res); if(res.success)&#123; this.total = res.queryResult.total; this.courses = res.queryResult.list; &#125; &#125;);&#125; 在mounted钩子中调用getCourse方法 1234mounted() &#123; //查询我的课程 this.getCourse();&#125; 在分页方法中调用getCourse方法 12345 //分页方法handleCurrentChange(val) &#123; this.page = val; this.getCourse();&#125;, 1.4.3 测试页面效果如下： 注意：由于课程图片服务器没有搭建，这里图片暂时无法显示。 2 新增课程2.1 需求分析用户操作流程如下： 1、用户进入“我的课程”页面，点击“新增课程”，进入新增课程页面 2、填写课程信息，选择课程分类、课程等级、学习模式等。 3、信息填写完毕，点击“提交”，课程添加成功或课程添加失败并提示失败原因。 需要解决的是在新增页面上输入的信息： 1、课程分类 多级分类，需要方便用户去选择。 2、课程等级、学习模式等这些选项建议是可以配置的。 2.2 课程分类查询2.2.1介绍​ 在新增课程界面需要选择课程所属分类， 分类信息是整个项目非常重要的信息，课程即商品，分类信息设置的好坏直接影响用户访问量。 分类信息在哪里应用？ 1、首页分类导航 2、课程的归属地 添加课程时要选择课程的所属分类。 2.2.2数据结构分类表category的结构如下： 2.2.3分类查询2.2.3.1数据格式在添加课程时需要选择课程所属的分类，这里需要定义课程分类查询接口。 接口格式要根据前端需要的数据格式来定义，前端展示课程分类使用elemenet-ui的cascader（级联选择器）组件。 数据格式例子如下： 1234567891011121314151617181920212223[ &#123; value: &apos;zhinan&apos;, label: &apos;指南&apos;, children: [&#123; value: &apos;shejiyuanze&apos;, label: &apos;设计原则&apos;, children: [&#123; value: &apos;yizhi&apos;, label: &apos;一致&apos; &#125;, &#123; value: &apos;fankui&apos;, label: &apos;反馈&apos; &#125;, &#123; value: &apos;xiaolv&apos;, label: &apos;效率&apos; &#125;, &#123; value: &apos;kekong&apos;, label: &apos;可控&apos; &#125;] &#125;] &#125;] 2.2.3.2 数据模型1）定义category的模型 category模型对数据字段对应，如下： 12345678910111213141516171819@Data@ToString@Entity@Table(name=&quot;category&quot;)@GenericGenerator(name = &quot;jpa-assigned&quot;, strategy = &quot;assigned&quot;)public class Category implements Serializable &#123; private static final long serialVersionUID = -906357110051689484L; @Id @GeneratedValue(generator = &quot;jpa-assigned&quot;) @Column(length = 32) private String id; private String name; private String label; private String parentid; private String isshow; private Integer orderby; private String isleaf;&#125; 1）定义数据返回格式 1234567@Data@ToStringpublic class CategoryNode extends Category &#123; List&lt;CategoryNode&gt; children;&#125; 2.2.3.3 Api接口1234567891011121314151617package com.xuecheng.api.web.controller.api.course;import com.xuecheng.framework.domain.course.ext.CategoryNode;import io.swagger.annotations.Api;import io.swagger.annotations.ApiOperation;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;@Api(value = &quot;课程分类管理&quot;,description = &quot;课程分类管理&quot;,tags = &#123;&quot;课程分类管理&quot;&#125;)public interface CategoryControllerApi &#123; @ApiOperation(&quot;查询分类&quot;) public CategoryNode findList();&#125; 2.2.3.4 dao根据数据格式的分析，此查询需要返回树型数据格式，为了开发方便我们使用mybatis实现查询 。 1）定义mapper 12345@Mapperpublic interface CategoryMapper &#123; //查询分类 public CategoryNode selectList();&#125; 2）定义mapper映射文件 采用表的自连接方式输出树型结果集。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;&lt;mapper namespace=&quot;com.xuecheng.manage_course.dao.CategoryMapper&quot; &gt; &lt;resultMap type=&quot;com.xuecheng.framework.domain.course.ext.CategoryNode&quot; id=&quot;categoryMap&quot; &gt; &lt;id property=&quot;id&quot; column=&quot;one_id&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;one_name&quot;/&gt; &lt;result property=&quot;label&quot; column=&quot;one_label&quot;/&gt; &lt;result property=&quot;isshow&quot; column=&quot;one_isshow&quot;/&gt; &lt;result property=&quot;isleaf&quot; column=&quot;one_isleaf&quot;/&gt; &lt;result property=&quot;orderby&quot; column=&quot;one_orderby&quot;/&gt; &lt;result property=&quot;parentid&quot; column=&quot;one_parentid&quot;/&gt; &lt;collection property=&quot;children&quot; ofType=&quot;com.xuecheng.framework.domain.course.ext.CategoryNode&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;two_id&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;two_name&quot;/&gt; &lt;result property=&quot;label&quot; column=&quot;two_label&quot;/&gt; &lt;result property=&quot;isshow&quot; column=&quot;two_isshow&quot;/&gt; &lt;result property=&quot;isleaf&quot; column=&quot;two_isleaf&quot;/&gt; &lt;result property=&quot;orderby&quot; column=&quot;two_orderby&quot;/&gt; &lt;result property=&quot;parentid&quot; column=&quot;two_parentid&quot;/&gt; &lt;collection property=&quot;children&quot; ofType=&quot;com.xuecheng.framework.domain.course.ext.CategoryNode&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;three_id&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;three_name&quot;/&gt; &lt;result property=&quot;label&quot; column=&quot;three_label&quot;/&gt; &lt;result property=&quot;isshow&quot; column=&quot;three_isshow&quot;/&gt; &lt;result property=&quot;isleaf&quot; column=&quot;three_isleaf&quot;/&gt; &lt;result property=&quot;orderby&quot; column=&quot;three_orderby&quot;/&gt; &lt;result property=&quot;parentid&quot; column=&quot;three_parentid&quot;/&gt; &lt;/collection&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;select id=&quot;selectList&quot; resultMap=&quot;categoryMap&quot; &gt; SELECT a.id one_id, a.name one_name, a.label one_label, a.isshow one_isshow, a.isleaf one_isleaf, a.orderby one_orderby, a.parentid one_parentid, b.id two_id, b.name two_name, b.label two_label, b.isshow two_isshow, b.isleaf two_isleaf, b.orderby two_orderby, b.parentid two_parentid, c.id three_id, c.name three_name, c.label three_label, c.isshow three_isshow, c.isleaf three_isleaf, c.orderby three_orderby, c.parentid three_parentid FROM category a LEFT JOIN category b ON a.id = b.parentid LEFT JOIN category c ON b.id = c.parentid WHERE a.parentid = &apos;0&apos; ORDER BY a.orderby, b.orderby, c.orderby &lt;/select&gt;&lt;/mapper&gt; 2.2.3.5 Service123456789@Servicepublic class CategoryService &#123; @Autowired CategoryMapper categoryMapper; //查询分类 public CategoryNode findList()&#123; return categoryMapper.selectList(); &#125;&#125; 2.2.3.6 Controller123456789101112@RestController@RequestMapping(&quot;/category&quot;)public class CategoryController implements CategoryControllerApi &#123; @Autowired CategoryService categoryService; @Override @GetMapping(&quot;/list&quot;) public CategoryNode list() &#123; return categoryService.findList(); &#125;&#125; 2.2.3.7 接口测试接口描述如下： 使用swagger-ui或postman测试接口。 2.3 数据字典2.3.1介绍​ 在新增课程界面需要选择课程等级、课程状态等，这些信息统一采用数据字典管理的方式。 ​ 本项目对一些业务的分类配置信息，比如：课程等级、课程状态、用户类型、用户状态等进行统一管理，通过在数据库创建数据字典表来维护这些分类信息。 ​ 数据字典对系统的业务分类进行统一管理，并且也可以解决硬编码问题，比如添加课程时选择课程等级，下拉框中的课程等级信息如果在页面硬编码将造成不易修改维护的问题，所以从数据字典表中获取，如果要修改名称则在数据字典修改即可，提高系统的可维护性。 2.3.2 数据模型在mongodb中创建数据字典表sys_dictionary 一个字典信息如下： 12 12345678910111213141516171819202122&#123;&quot;_id&quot; : ObjectId(&quot;5a7e8d2dd019f15418fa2b71&quot;), &quot;d_name&quot; : &quot;课程等级&quot;, &quot;d_type&quot; : &quot;200&quot;, &quot;d_value&quot; : [ &#123; &quot;sd_name&quot; : &quot;低级&quot;, &quot;sd_id&quot; : &quot;200001&quot;, &quot;sd_status&quot; : &quot;1&quot; &#125;, &#123; &quot;sd_name&quot; : &quot;中级&quot;, &quot;sd_id&quot; : &quot;200002&quot;, &quot;sd_status&quot; : &quot;1&quot; &#125;, &#123; &quot;sd_name&quot; : &quot;高级&quot;, &quot;sd_id&quot; : &quot;200003&quot;, &quot;sd_status&quot; : &quot;1&quot; &#125;]&#125; 字段说明如下： d_name：字典名称 d_type：字典分类 d_value：字典数据 ​ sd_name：项目名称 ​ sd_id：项目id ​ sd_status：项目状态（1：可用，0不可用） 数据模型类： 123456789101112131415161718@Data@ToString@Document(collection = &quot;sys_dictionary&quot;)public class SysDictionary &#123; @Id private String id; @Field(&quot;d_name&quot;) private String dName; @Field(&quot;d_type&quot;) private String dType; @Field(&quot;d_value&quot;) private List&lt;SysDictionaryValue&gt; dValue;&#125; SysDictionaryValue类型： 1234567891011121314@Data@ToStringpublic class SysDictionaryValue &#123; @Field(&quot;sd_id&quot;) private String sdId; @Field(&quot;sd_name&quot;) private String sdName; @Field(&quot;sd_status&quot;) private String sdStatus;&#125; 2.3.3 字典查询接口2.3.3.1 API接口为了方便其它子系统使用，在cms模块下创建字典查询接口，根据字典的type查询字典信息，接口定义如下： 123456@Api(value = &quot;数据字典接口&quot;,description = &quot;提供数据字典接口的管理、查询功能&quot;)public interface SysDicthinaryControllerApi &#123; //数据字典 @ApiOperation(value=&quot;数据字典查询接口&quot;) public SysDictionary getByType(String type);&#125; 2.3.3.2 Dao在cms模块下创建数据库的dao、service等类。 12345@Repositorypublic interface SysDictionaryDao extends MongoRepository&lt;SysDictionary,String&gt; &#123; //根据字典分类查询字典信息 SysDictionary findBydType(String dType);&#125; 2.3.3.3 Service123456789@Servicepublic class SysdictionaryService &#123; @Autowired SysDictionaryDao sysDictionaryDao; //根据字典分类type查询字典信息 public SysDictionary findDictionaryByType(String type)&#123; return sysDictionaryDao.findBydType(type); &#125;&#125; 2.3.3.4Controller12345678910111213@RestController@RequestMapping(&quot;/sys/dictionary&quot;)public class SysDictionaryController implements SysDictionaryControllerApi &#123; @Autowired SysdictionaryService sysdictionaryService; //根据字典分类id查询字典信息 @Override @GetMapping(&quot;/get/&#123;type&#125;&quot;) public SysDictionary getByType(@PathVariable(&quot;type&quot;) String type) &#123; return sysdictionaryService.findDictionaryByType(type); &#125;&#125; 2.3.3.5测试 2.4 新增课程页面完善本节完成数据字典显示及课程分类显示。 2.4.1 新增课程页面1、页面效果如下： 2）创建course_add.vue页面 在teach前端工程的course模块下创建course_add.vue页面。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899&lt;template&gt; &lt;div&gt; &lt;el-form :model=&quot;courseForm&quot; label-width=&quot;80px&quot; :rules=&quot;courseRules&quot; ref=&quot;courseForm&quot;&gt; &lt;el-form-item label=&quot;课程名称&quot; prop=&quot;name&quot;&gt; &lt;el-input v-model=&quot;courseForm.name&quot; auto-complete=&quot;off&quot; &gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;适用人群&quot; prop=&quot;users&quot;&gt; &lt;el-input type=&quot;textarea&quot; v-model=&quot;courseForm.users&quot; auto-complete=&quot;off&quot; &gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;课程分类&quot; prop=&quot;categoryActive&quot;&gt; &lt;el-cascader expand-trigger=&quot;hover&quot; :options=&quot;categoryList&quot; v-model=&quot;categoryActive&quot; :props=&quot;props&quot;&gt; &lt;/el-cascader&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;课程等级&quot; prop=&quot;grade&quot;&gt; &lt;b v-for=&quot;grade in gradeList&quot;&gt; &lt;el-radio v-model=&quot;courseForm.grade&quot; :label=&quot;grade.sdId&quot; &gt;&#123;&#123;grade.sdName&#125;&#125;&lt;/el-radio&gt;&amp;nbsp;&amp;nbsp; &lt;/b&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;学习模式&quot; prop=&quot;studymodel&quot;&gt; &lt;b v-for=&quot;studymodel_v in studymodelList&quot;&gt; &lt;el-radio v-model=&quot;courseForm.studymodel&quot; :label=&quot;studymodel_v.sdId&quot; &gt;&#123;&#123;studymodel_v.sdName&#125;&#125;&lt;/el-radio&gt;&amp;nbsp;&amp;nbsp; &lt;/b&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;课程介绍&quot; prop=&quot;description&quot;&gt; &lt;el-input type=&quot;textarea&quot; v-model=&quot;courseForm.description&quot; &gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;div slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt; &lt;el-button type=&quot;primary&quot; @click.native=&quot;save&quot; &gt;提交&lt;/el-button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import * as courseApi from &apos;../api/course&apos;; import utilApi from &apos;../../../common/utils&apos;; import * as systemApi from &apos;../../../base/api/system&apos;; export default &#123; data() &#123; return &#123; studymodelList:[], gradeList:[], props: &#123; value: &apos;id&apos;, label:&apos;label&apos;, children:&apos;children&apos; &#125;, categoryList: [], categoryActive:[], courseForm: &#123; id:&apos;&apos;, name: &apos;&apos;, users: &apos;&apos;, grade:&apos;&apos;, studymodel:&apos;&apos;, mt:&apos;&apos;, st:&apos;&apos;, description: &apos;&apos; &#125;, courseRules: &#123; name: [ &#123;required: true, message: &apos;请输入课程名称&apos;, trigger: &apos;blur&apos;&#125; ], category: [ &#123;required: true, message: &apos;请选择课程分类&apos;, trigger: &apos;blur&apos;&#125; ], grade: [ &#123;required: true, message: &apos;请选择课程等级&apos;, trigger: &apos;blur&apos;&#125; ], studymodel: [ &#123;required: true, message: &apos;请选择学习模式&apos;, trigger: &apos;blur&apos;&#125; ] &#125; &#125; &#125;, methods: &#123; save () &#123; &#125; &#125;, created()&#123; &#125;, mounted()&#123; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 2）页面路由 12import course_add from &apos;@/module/course/page/course_add.vue&apos;;&#123; path: &apos;/course/add/base&apos;, name: &apos;添加课程&apos;,component: course_add,hidden: true &#125;, 3）课程添加链接 在我的课程页面添加“新增课程”链接 在course_list.vue 中添加： 123&lt;router-link class=&quot;mui-tab-item&quot; :to=&quot;&#123;path:&apos;/course/add/base&apos;&#125;&quot;&gt; &lt;el-button type=&quot;text&quot; class=&quot;button&quot; &gt;新增课程&lt;/el-button&gt;&lt;/router-link&gt; 2.4.2 查询数据字典课程添加页面中课程等级、学习模式需要从数据字典查询字典信息。 1）定义方法 数据字典查询 为公用方法，所以定义在/base/api/system.js中 123456let sysConfig = require(&apos;@/../config/sysConfig&apos;)let apiUrl = sysConfig.xcApiUrlPre;/*数据字典 */export const sys_getDictionary= dType =&gt; &#123; return http.requestQuickGet(apiUrl+&apos;/sys/dictionary/get/&apos;+dType)&#125; 2）在页面获取数据字典 在mounted钩子中定义方法如下： 1234567//查询数据字典字典systemApi.sys_getDictionary(&apos;201&apos;).then((res) =&gt; &#123;this.studymodelList = res.dvalue;&#125;);systemApi.sys_getDictionary(&apos;200&apos;).then((res) =&gt; &#123;this.gradeList = res.dvalue;&#125;); 3）效果 2.4.3 课程分类课程添加页面中课程分类采用Cascader组件完成。 Cascader级联选择器 1）页面 12345678&lt;el-form-item label=&quot;课程分类&quot; prop=&quot;categoryActive&quot;&gt; &lt;el-cascader expand-trigger=&quot;hover&quot; :options=&quot;categoryList&quot; v-model=&quot;categoryActive&quot; :props=&quot;props&quot;&gt; &lt;/el-cascader&gt;&lt;/el-form-item&gt; 2）定义方法 在本模块的course.js中定义 1234/*查询课程分类 */export const category_findlist= () =&gt; &#123; return http.requestQuickGet(apiUrl+&apos;/category/list&apos;)&#125; 3）在页面获取课程分类 在mounted钩子中定义 1234//取课程分类courseApi.category_findlist(&#123;&#125;).then((res) =&gt; &#123; this.categoryList = res.children;&#125;); 4）效果 5) 如何获取选择的分类 用户选择课程分类后，所选分类ID绑定到categoryActive（数组）中，选择了一级、二级分类，分别存储在categoryActive数组的第一个、第二个元素中。 2.5 API接口创建课程添加提交接口： 123456@Api(value = &quot;课程管理&quot;,description = &quot;课程管理&quot;,tags = &#123;&quot;课程管理&quot;&#125;)public interface CourseControllerApi &#123; @ApiOperation(&quot;添加课程基础信息&quot;) public AddCourseResult addCourseBase(CourseBase courseBase);&#125; 2.6 新增课程服务端2.6.1 Dao123public interface CourseBaseRepository extends JpaRepository&lt;CourseBase, String&gt; &#123; &#125; 2.6.2 Service12345678//添加课程提交@Transactionalpublic AddCourseResult addCourseBase(CourseBase courseBase) &#123; //课程状态默认为未发布 courseBase.setStatus(&quot;202001&quot;); courseBaseRepository.save(courseBase); return new AddCourseResult(CommonCode.SUCCESS,courseBase.getId());&#125; 2.6.3 Controller12345@Override@PostMapping(&quot;/coursebase/add&quot;)public AddCourseResult addCourseBase(@RequestBody CourseBase courseBase) &#123; return courseService.addCourseBase(courseBase);&#125; 2.7 新增课程前端2.7.1 Api方法定义在前端定义请求服务端添加课程的api的方法，在course模块中定义方法如下： 1234/*添加课程基础信息*/export const addCourseBase = params =&gt; &#123; return http.requestPost(apiUrl+&apos;/course/coursebase/add&apos;,params)&#125; 2.7.2 Api方法调用在course_add.vue 调用api提交课程信息 123456789101112131415161718192021222324252627282930313233methods: &#123; save () &#123; this.$refs.courseForm.validate((valid) =&gt; &#123; if (valid) &#123; this.$confirm(&apos;确认提交吗？&apos;, &apos;提示&apos;, &#123;&#125;).then(() =&gt; &#123; //当前选择的分类 let mt = this.categoryActive[0]; let st = this.categoryActive[1]; this.courseForm.mt = mt; this.courseForm.st = st; //请求服务接口 courseApi.addCourseBase(this.courseForm).then((res) =&gt; &#123; if(res.success)&#123; this.$message.success(&apos;提交成功&apos;); //跳转到课程图片 //this.$router.push(&#123; path: &apos;/course/add/picture/1/&apos;+this.courseid&#125;) &#125;else&#123; if(res.message)&#123; this.$message.error(res.message); &#125;else&#123; this.$message.error(&apos;提交失败&apos;); &#125; &#125; &#125;); &#125;); &#125; &#125;); &#125; &#125;, 2.7.3 测试注意：将course_base表中的company_id改为非必填，待认证功能开发完成再修改为必填 测试流程： 1、进入我的课程，点击“新增课程”打开新增课程页面 2、输入课程信息，点击提交 3 课程信息修改3.1 需求分析课程添加成功进入课程管理页面，通过课程管理页面修改课程的基本信息、编辑课程图片、编辑课程营销信息等。 本小节实现修改课程。 3.2 课程管理页面说明3.2.1 页面结构课程管理页面的结构如下： 3.2.2 课程管理导航页面1、定义course_manage.vue为课程管理导航页面。 导航效果使用Element-UI的NavMenu组件实现。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;template&gt; &lt;div&gt; &lt;el-menu :default-active=&quot;activeIndex&quot; class=&quot;el-menu-demo&quot; mode=&quot;horizontal&quot; background-color=&quot;#eee&quot; text-color=&quot;#000&quot; active-text-color=&quot;#000&quot;&gt; &lt;router-link class=&quot;mui-tab-item&quot; :to=&quot;&#123;path:&apos;/course/manage/summary/&apos;+this.courseid&#125;&quot;&gt; &lt;el-menu-item index=&quot;1&quot;&gt;课程首页&lt;/el-menu-item&gt; &lt;/router-link&gt; &lt;router-link class=&quot;mui-tab-item&quot; :to=&quot;&#123;path:&apos;/course/manage/baseinfo/&apos;+this.courseid&#125;&quot;&gt; &lt;el-menu-item index=&quot;2&quot;&gt;基本信息&lt;/el-menu-item&gt; &lt;/router-link&gt; &lt;router-link class=&quot;mui-tab-item&quot; :to=&quot;&#123;path:&apos;/course/manage/picture/&apos;+this.courseid&#125;&quot;&gt; &lt;el-menu-item index=&quot;3&quot;&gt;课程图片&lt;/el-menu-item&gt; &lt;/router-link&gt; &lt;router-link class=&quot;mui-tab-item&quot; :to=&quot;&#123;path:&apos;/course/manage/marketinfo/&apos;+this.courseid&#125;&quot;&gt; &lt;el-menu-item index=&quot;4&quot;&gt;课程营销&lt;/el-menu-item&gt; &lt;/router-link&gt; &lt;router-link class=&quot;mui-tab-item&quot; :to=&quot;&#123;path:&apos;/course/manage/plan/&apos;+this.courseid&#125;&quot;&gt; &lt;el-menu-item index=&quot;5&quot;&gt;课程计划&lt;/el-menu-item&gt; &lt;/router-link&gt; &lt;router-link class=&quot;mui-tab-item&quot; :to=&quot;&#123;path:&apos;/course/manage/teacher/&apos;+this.courseid&#125;&quot;&gt; &lt;el-menu-item index=&quot;6&quot;&gt;教师信息&lt;/el-menu-item&gt; &lt;/router-link&gt; &lt;router-link class=&quot;mui-tab-item&quot; :to=&quot;&#123;path:&apos;/course/manage/pub/&apos;+this.courseid&#125;&quot;&gt; &lt;el-menu-item index=&quot;7&quot;&gt;发布课程&lt;/el-menu-item&gt; &lt;/router-link&gt; &lt;/el-menu&gt; &lt;router-view class=&quot;main&quot;&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import * as courseApi from &apos;../api/course&apos;; import utilApi from &apos;../../../common/utils&apos;; export default &#123; data() &#123; return &#123; activeIndex:&apos;2&apos;, courseid:&apos;&apos; &#125; &#125;, methods: &#123; &#125;, mounted()&#123; //课程id this.courseid = this.$route.params.courseid console.log(&quot;courseid=&quot; + this.courseid) //跳转到页面列表 this.$router.push(&#123; path: &apos;/course/manage/baseinfo/&apos;+this.courseid&#125;) &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; &lt;/style&gt; 2、创建各各信息管理页面 通过管理页面的导航可以进入各各信息管理页面，这里先创建各各信息管理页面，页面内容暂时为空，待开发时再完善，在本模块的page目录下创建course_manage目录，此目录存放各各信息管理页面，页面明细如下： 课程管理首页：course_summary.vue 基本信息修改页面：course_baseinfo.vue 图片管理页面：course_picture.vue 营销信息页面：course_marketinfo.vue 老师信息页面：course_teacher.vue 课程计划页面：course_plan.vue 课程发布页面：course_pub.vue 3、创建路由 12345678910111213141516171819import course_manage from &apos;@/module/course/page/course_manage.vue&apos;;import course_summary from &apos;@/module/course/page/course_manage/course_summary.vue&apos;;import course_picture from &apos;@/module/course/page/course_manage/course_picture.vue&apos;;import course_baseinfo from &apos;@/module/course/page/course_manage/course_baseinfo.vue&apos;;import course_marketinfo from &apos;@/module/course/page/course_manage/course_marketinfo.vue&apos;;import course_teacher from &apos;@/module/course/page/course_manage/course_teacher.vue&apos;;import course_plan from &apos;@/module/course/page/course_manage/course_plan.vue&apos;;import course_pub from &apos;@/module/course/page/course_manage/course_pub.vue&apos;;&#123; path: &apos;/course/manager/:courseid&apos;, name: &apos;管理课程&apos;,component: course_manage,hidden: true , children: [ &#123; path: &apos;/course/manage/plan/:courseid&apos;, name: &apos;课程计划&apos;,component: course_plan,hidden: false &#125;, &#123; path: &apos;/course/manage/baseinfo/:courseid&apos;, name: &apos;基本信息&apos;,component: course_baseinfo,hidden: false &#125;, &#123; path: &apos;/course/manage/picture/:courseid&apos;, name: &apos;课程图片&apos;,component: course_picture,hidden: false &#125;, &#123; path: &apos;/course/manage/marketinfo/:courseid&apos;, name: &apos;营销信息&apos;,component: course_marketinfo,hidden: false &#125;, &#123; path: &apos;/course/manage/teacher/:courseid&apos;, name: &apos;教师信息&apos;,component: course_teacher,hidden: false&#125;, &#123; path: &apos;/course/manage/pub/:courseid&apos;, name: &apos;发布课程&apos;,component: course_pub,hidden: false&#125;, &#123; path: &apos;/course/manage/summary/:courseid&apos;, name: &apos;课程首页&apos;,component: course_summary,hidden: false &#125; ]&#125; 3.3 Api接口修改课程需要如下接口： 1、根据id查询课程信息 2、修改课程提交 接口定义如下： 1) 根据课程ID查询课程信息 12@ApiOperation(&quot;获取课程基础信息&quot;)public CourseBase getCourseBaseById(String courseId) throws RuntimeException; 2）修改课程信息 12@ApiOperation(&quot;更新课程基础信息&quot;)public ResponseResult updateCourseBase(String id,CourseBase courseBase); 3.4 服务端3.4.1 Dao略 3.4.2 Service12345678910111213141516171819202122232425public CourseBase getCoursebaseById(String courseid) &#123; Optional&lt;CourseBase&gt; optional = courseBaseRepository.findById(courseId); if(optional.isPresent())&#123; return optional.get(); &#125; return null;&#125;@Transactional public ResponseResult updateCoursebase(String id, CourseBase courseBase) &#123; CourseBase one = this.getCoursebaseById(id); if(one == null)&#123; //抛出异常.. &#125; //修改课程信息 one.setName(courseBase.getName()); one.setMt(courseBase.getMt()); one.setSt(courseBase.getSt()); one.setGrade(courseBase.getGrade()); one.setStudymodel(courseBase.getStudymodel()); one.setUsers(courseBase.getUsers()); one.setDescription(courseBase.getDescription()); CourseBase save = courseBaseRepository.save(one); return new ResponseResult(CommonCode.SUCCESS); &#125; 3.4.3 Controller1234567891011@Override@GetMapping(&quot;/coursebase/get/&#123;courseId&#125;&quot;)public CourseBase getCourseBaseById(@PathVariable(&quot;courseId&quot;) String courseId) throws RuntimeException &#123; return courseService.getCoursebaseById(courseId);&#125;@Override@PutMapping(&quot;/coursebase/update/&#123;id&#125;&quot;)public ResponseResult updateCourseBase(@PathVariable(&quot;id&quot;) String id, @RequestBody CourseBase courseBase) &#123; return courseService.updateCoursebase(id,courseBase);&#125; 3.5 前端3.5.1 修改页面在course模块下的course_manage目录下创建course_baseinfo.vue页面，本页面实现课程修改 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102&lt;template&gt; &lt;div&gt; &lt;el-form :model=&quot;courseForm&quot; label-width=&quot;80px&quot; :rules=&quot;courseRules&quot; ref=&quot;courseForm&quot;&gt; &lt;el-form-item label=&quot;课程名称&quot; prop=&quot;name&quot;&gt; &lt;el-input v-model=&quot;courseForm.name&quot; auto-complete=&quot;off&quot; &gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;适用人群&quot; prop=&quot;users&quot;&gt; &lt;el-input type=&quot;textarea&quot; v-model=&quot;courseForm.users&quot; auto-complete=&quot;off&quot; &gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;课程分类&quot; prop=&quot;categoryActive&quot;&gt; &lt;el-cascader expand-trigger=&quot;hover&quot; :options=&quot;categoryList&quot; v-model=&quot;categoryActive&quot; :props=&quot;props&quot;&gt; &lt;/el-cascader&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;课程等级&quot; prop=&quot;grade&quot;&gt; &lt;b v-for=&quot;grade in gradeList&quot;&gt; &lt;el-radio v-model=&quot;courseForm.grade&quot; :label=&quot;grade.sdId&quot; &gt;&#123;&#123;grade.sdName&#125;&#125;&lt;/el-radio&gt;&amp;nbsp;&amp;nbsp; &lt;/b&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;学习模式&quot; prop=&quot;studymodel&quot;&gt; &lt;b v-for=&quot;studymodel_v in studymodelList&quot;&gt; &lt;el-radio v-model=&quot;courseForm.studymodel&quot; :label=&quot;studymodel_v.sdId&quot; &gt;&#123;&#123;studymodel_v.sdName&#125;&#125;&lt;/el-radio&gt;&amp;nbsp;&amp;nbsp; &lt;/b&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;课程介绍&quot; prop=&quot;description&quot;&gt; &lt;el-input type=&quot;textarea&quot; v-model=&quot;courseForm.description&quot; &gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;div slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt; &lt;el-button type=&quot;primary&quot; @click.native=&quot;save&quot; :loading=&quot;editLoading&quot;&gt;提交&lt;/el-button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import * as courseApi from &apos;../../api/course&apos;; import utilApi from &apos;../../../../common/utils&apos;; import * as systemApi from &apos;../../../../base/api/system&apos;; export default &#123; data() &#123; return &#123; courseid:&apos;&apos;, studymodelList:[], gradeList:[], editLoading: false, props: &#123; value: &apos;id&apos;, label:&apos;label&apos;, children:&apos;children&apos; &#125;, categoryList: [], categoryActive:[], courseForm: &#123; id:&apos;&apos;, name: &apos;&apos;, users: &apos;&apos;, grade:&apos;&apos;, studymodel:&apos;&apos;, mt:&apos;&apos;, st:&apos;&apos;, description: &apos;&apos; &#125;, courseRules: &#123; name: [ &#123;required: true, message: &apos;请输入课程名称&apos;, trigger: &apos;blur&apos;&#125; ], category: [ &#123;required: true, message: &apos;请选择课程分类&apos;, trigger: &apos;blur&apos;&#125; ], grade: [ &#123;required: true, message: &apos;请选择课程等级&apos;, trigger: &apos;blur&apos;&#125; ], studymodel: [ &#123;required: true, message: &apos;请选择学习模式&apos;, trigger: &apos;blur&apos;&#125; ] &#125; &#125; &#125;, methods: &#123; save () &#123; &#125; &#125;, created()&#123; &#125;, mounted()&#123; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 3.5.2 API方法12345678//获取课程基本信息export const getCoursebaseById = id =&gt; &#123; return http.requestQuickGet(apiUrl+&apos;/course/coursebase/get/&apos;+id)&#125;//更新课程基本信息export const updateCoursebase= (id,course) =&gt; &#123; return http.requestPut(apiUrl+&apos;/course/coursebase/update/&apos;+id,course)&#125; 3.5.4 课程信息显示在mounted钩子方法中查询课程信息及数据字典： 12345678910111213141516171819202122232425mounted()&#123; //查询数据字典字典 systemApi.sys_getDictionary(&apos;201&apos;).then((res) =&gt; &#123;// console.log(res); this.studymodelList = res.dvalue; &#125;); systemApi.sys_getDictionary(&apos;200&apos;).then((res) =&gt; &#123; this.gradeList = res.dvalue; &#125;); //取课程分类 courseApi.category_findlist(&#123;&#125;).then((res) =&gt; &#123; this.categoryList = res.children; &#125;); //查询课程信息 //课程id this.courseid = this.$route.params.courseid; courseApi.getCoursebaseById(this.courseid).then((res) =&gt; &#123;// console.log(res); this.courseForm = res; //课程分类显示，需要两级分类 this.categoryActive.push(this.courseForm.mt); this.categoryActive.push(this.courseForm.st); &#125;); &#125; 3.5.5 课程修改提交编辑课程提交方法： 1234567891011121314151617181920212223242526272829303132methods: &#123; save () &#123; //修改课程 this.$refs.courseForm.validate((valid) =&gt; &#123; if (valid) &#123; this.$confirm(&apos;确认提交吗？&apos;, &apos;提示&apos;, &#123;&#125;).then(() =&gt; &#123; let mt = this.categoryActive[0]; let st = this.categoryActive[1]; this.courseForm.mt = mt; this.courseForm.st = st; let id = this.courseForm.id courseApi.updateCoursebase(id,this.courseForm).then((res) =&gt; &#123; if(res.success)&#123; this.$message(&#123; message: &apos;提交成功&apos;, type: &apos;success&apos; &#125;); &#125;else&#123; if(res.message)&#123; this.$message.error(res.message); &#125;else&#123; this.$message.error(&apos;提交失败&apos;); &#125; &#125; &#125;); &#125;); &#125; &#125;); &#125;&#125;, 4 课程营销4.1 需求分析课程营销信息包括课程价格、课程有效期等信息。 4.2 数据模型课程营销信息使用course_market表存储。 数据模型如下： 12345678910111213141516171819202122@Data@ToString@Entity@Table(name=&quot;course_market&quot;)@GenericGenerator(name = &quot;jpa-assigned&quot;, strategy = &quot;assigned&quot;)public class CourseMarket implements Serializable &#123; private static final long serialVersionUID = -916357110051689486L; @Id @GeneratedValue(generator = &quot;jpa-assigned&quot;) @Column(length = 32) private String id; private String charge; private String valid; private String qq; private Float price; private Float price_old; @Column(name = &quot;start_time&quot;) private Date startTime; @Column(name = &quot;end_time&quot;) private Date endTime;&#125; 4.3 API1) 查询课程营销信息 12@ApiOperation(&quot;获取课程营销信息&quot;)public CourseMarket getCourseMarketById(String courseId); 2）更新课程营销信息 12@ApiOperation(&quot;更新课程营销信息&quot;)public ResponseResult updateCourseMarket(String id,CourseMarket courseMarket); 4.4 课程管理服务4.4.1 Dao12public interface CourseMarketRepository extends JpaRepository&lt;CourseMarket, String&gt; &#123;&#125; 4.4.2 Service1234567public CourseMarket getCourseMarketById(String courseid) &#123; Optional&lt;CourseMarket&gt; optional = courseMarketRepository.findById(courseId); if(!optional.isPresent())&#123; return optional.get(); &#125; return null;&#125; 123456789101112131415161718192021@Transactionalpublic CourseMarket updateCourseMarket(String id, CourseMarket courseMarket) &#123; CourseMarket one = this.getCourseMarketById(id); if(one!=null)&#123; one.setCharge(courseMarket.getCharge()); one.setStartTime(courseMarket.getStartTime());//课程有效期，开始时间 one.setEndTime(courseMarket.getEndTime());//课程有效期，结束时间 one.setPrice(courseMarket.getPrice()); one.setQq(courseMarket.getQq()); one.setValid(courseMarket.getValid()); courseMarketRepository.save(one); &#125;else&#123; //添加课程营销信息 one = new CourseMarket(); BeanUtils.copyProperties(courseMarket, one); //设置课程id one.setId(id); courseMarketRepository.save(one); &#125; return one;&#125; 4.4.3 Controller12345678910111213141516@Override@PostMapping(&quot;/coursemarket/update/&#123;id&#125;&quot;)public ResponseResult updateCourseMarket(@PathVariable(&quot;id&quot;) String id, @RequestBody CourseMarket courseMarket) &#123; CourseMarket courseMarket_u = courseService.updateCourseMarket(id, courseMarket); if(courseMarket_u!=null)&#123; return new ResponseResult(CommonCode.SUCCESS); &#125;else&#123; return new ResponseResult(CommonCode.FAIL); &#125;&#125;@Override@GetMapping(&quot;/coursemarket/get/&#123;courseId&#125;&quot;)public CourseMarket getCourseMarketById(@PathVariable(&quot;courseId&quot;) String courseId) &#123; return courseService.getCourseMarketById(courseId);&#125; 4.5 前端4.5.1 Api 方法12345678//获取课程营销信息export const getCourseMarketById = id =&gt; &#123; return http.requestQuickGet(apiUrl+&apos;/course/coursemarket/get/&apos;+id)&#125;// 更新课程营销信息export const updateCourseMarket =(id,courseMarket) =&gt; &#123; return http.requestPost(apiUrl+&apos;/course/coursemarket/update/&apos;+id,courseMarket)&#125; 4.5.2 页面编写 course_marketinfo.vue 1) template 12345678910111213141516171819202122232425&lt;el-form :model=&quot;courseMarketForm&quot; label-width=&quot;110px&quot; :rules=&quot;courseMarketFormRules&quot; ref=&quot;courseMarketForm&quot;&gt; &lt;el-form-item label=&quot;课程价格&quot; prop=&quot;charge&quot;&gt; &lt;b v-for=&quot;charge in chargeList&quot;&gt; &lt;el-radio v-model=&quot;courseMarketForm.charge&quot; :label=&quot;charge.sdId&quot; &gt;&#123;&#123;charge.sdName&#125;&#125;&lt;/el-radio&gt; &amp;nbsp;&amp;nbsp; &lt;/b&gt; &lt;br/&gt; 金额（元）：&lt;el-input :disabled=&quot;this.courseMarketForm.charge == &apos;203002&apos;?false:true&quot; v-model=&quot;courseMarketForm.price&quot; &gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;课程有效期&quot; prop=&quot;expires&quot;&gt; &lt;b v-for=&quot;valid in validList&quot;&gt; &lt;el-radio v-model=&quot;courseMarketForm.valid&quot; :label=&quot;valid.sdId&quot; &gt;&#123;&#123;valid.sdName&#125;&#125;&lt;/el-radio&gt;&amp;nbsp;&amp;nbsp; &lt;/b&gt; &lt;br/&gt; 过期时间：&lt;br/&gt; &lt;el-date-picker :disabled=&quot;this.courseMarketForm.valid == &apos;204002&apos;?false:true&quot; type=&quot;date&quot; placeholder=&quot;选择日期&quot; v-model=&quot;courseMarketForm.expires&quot;&gt;&lt;/el-date-picker&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;服务咨询QQ&quot; prop=&quot;qq&quot;&gt; &lt;el-input v-model=&quot;courseMarketForm.qq&quot; &gt;&lt;/el-input&gt; &lt;/el-form-item&gt;&lt;/el-form&gt;&lt;div slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt; &lt;el-button type=&quot;primary&quot; @click.native=&quot;save&quot; &gt;提交&lt;/el-button&gt;&lt;/div&gt; 2) 数据对象 1234567891011121314151617181920212223242526272829data() &#123; return &#123; active: 1, dotype:&apos;&apos;, courseid:&apos;&apos;, chargeList:[], validList:[], price_tag:false, expires_tag:false, courseMarketForm: &#123; id:&apos;&apos;, charge:&apos;&apos;, valid:&apos;&apos;, price:&apos;&apos;, expires: &apos;&apos;, users: &apos;&apos;, expiration:[], courseid:this.courseid &#125;, courseMarketFormRules: &#123; free: [ &#123;required: true, message: &apos;请选择收费规则&apos;, trigger: &apos;blur&apos;&#125; ], valid: [ &#123;required: true, message: &apos;请选择有效期&apos;, trigger: &apos;blur&apos;&#125; ] &#125; &#125;&#125; 3）保存方法 123456789101112131415save: function () &#123; this.$refs.courseMarketForm.validate((valid) =&gt; &#123; if (valid) &#123; this.$confirm(&apos;确认提交吗？&apos;, &apos;提示&apos;, &#123;&#125;).then(() =&gt; &#123; courseApi.updateCourseMarket(this.courseid,this.courseMarketForm).then((res) =&gt; &#123; if(res.success)&#123; this.$message.success(&apos;提交失败&apos;); &#125;else&#123; this.$message.error(res.message); &#125; &#125;); &#125;); &#125; &#125;);&#125; 4）在mounted钩子方法 中查询课程营销信息及数据字典信息 123456789101112131415161718192021mounted()&#123; //课程id this.courseid = this.$route.params.courseid; this.courseMarketForm.id = this.courseid; //查询字典 systemApi.sys_getDictionary(&apos;203&apos;).then((res) =&gt; &#123; this.chargeList = res.dvalue; &#125;); systemApi.sys_getDictionary(&apos;204&apos;).then((res) =&gt; &#123; this.validList = res.dvalue; &#125;); //获取课程营销信息 courseApi.getCourseMarketById(this.courseid).then((res) =&gt; &#123; //console.log(res); if(res &amp;&amp; res.id)&#123; this.courseMarketForm = res; &#125; &#125;);&#125;]]></content>
      <categories>
        <category>项目实战-在线学习视频网站</category>
      </categories>
      <tags>
        <tag>PageHelper</tag>
        <tag>数据字典</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在线学习视频（二）—— CMS前端开发]]></title>
    <url>%2Fday02-CMS%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91.html</url>
    <content type="text"><![CDATA[CMS前端开发1 Webpack研究参考Webpack学习 2 CMS前端工程创建2.1 导入系统管理前端工程​ CMS系统使用Vue-cli脚手架创建， Vue-cli是Vue官方提供的快速构建单页应用的脚手架，github地址：https://github.com/vuejs/vue-cli（有兴趣的同学可以参考官方指导使用vue-cli创建前端工程），本项目对Vue-cli创建的工程进行二次封装，下边介绍CMS工程的情况。 2.2.1 工程结构如果我要基于Vue-Cli创建的工程进行开发还需要在它基础上作一些封装，导入课程资料中提供Vue-Cli封装工程。 将课程资料中的xc-ui-pc-sysmanage.7z拷贝到UI工程目录中，并解压，用WebStorm打开xc-ui-pc-sysmanage目录。 2.2.2 package.jsonpackage.json记录了工程所有依赖，及脚本命令： 开发使用：npm run dev 打包使用：npm run build 2.2.3 webpack.base.conf.jswebpack.base.conf.js就是webpack的webpack.config.js配置文件，在此文件中配置了入口文件及各种Loader。 webpack是通过vue-load解析.vue文件，通过css-load打包css文件等。 2.2.4 main.jsmain.js是工程的入口文件，在此文件中加载了很多第三方组件，如：Element-UI、Base64、VueRouter等。 index.html是模板文件。 2.2.5 src目录src目录下存放页面及js代码。 assets：存放一些静态文件，如图片。 base：存放基础组件 ​ base/api：基础api接口 ​ base/component：基础组件，被各各模块都使用的组件 ​ base/router：总的路由配置，加载各模块的路由配置文件。 common：工具类 component：组件目录，本项目不用。 mock：存放前端单元测试方法。 module：存放各业务模块的页面和api方法。 ​ 下级目录以模块名命名，下边以cms举例： ​ cms/api：cms模块的api接口 ​ cms/component：cms模块的组件 ​ cms/page： cms模块的页面 ​ cms/router：cms模块的路由配置 statics：存放第三方组件的静态资源 vuex：存放vuex文件，本项目不使用 static：与src的平级目录，此目录存放静态资源 ​ 它与assets的区别在于，static目录中的文件不被webpack打包处理，会原样拷贝到dist目录下。 2.2 单页面应用介绍什么是单页应用？ 引用百度百科： 单页面应用的优缺点： 优点： 1、用户操作体验好，用户不用刷新页面，整个交互过程都是通过Ajax来操作。 2、适合前后端分离开发，服务端提供http接口，前端请求http接口获取数据，使用JS进行客户端渲染。 缺点： 1、首页加载慢 单页面应用会将js、 css打包成一个文件，在加载页面显示的时候加载打包文件，如果打包文件较大或者网速慢则用户体验不好。 2、SEO不友好 SEO（Search Engine Optimization）为搜索引擎优化。它是一种利用搜索引擎的搜索规则来提高网站在搜索引擎排名的方法。目前各家搜索引擎对JS支持不好，所以使用单页面应用将大大减少搜索引擎对网站的收录。 总结： 本项目的门户、课程介绍不采用单页面应用架构去开发，对于需要用户登录的管理系统采用单页面开发。 3 CMS前端页面查询开发3.1 页面原型3.1.1 创建页面3.1.1.1 页面结构在model目录创建 cms模块的目录结构 在page目录新建page_list.vue，扩展名为.vue。 .vue文件的结构如下： 12345678910&lt;template&gt;&lt;!--编写页面静态部分，即view部分--&gt;测试页面显示...&lt;/template&gt;&lt;script&gt;/*编写页面静态部分，即model及vm部分。*/&lt;/script&gt;&lt;style&gt;/*编写页面样式，不是必须*/&lt;/style&gt; 在页面的template中填写 “测试页面显示…”。 注意：template内容必须有一个根元素，否则vue会报错，这里我们在template标签内定义一个div。 3.1.1.2 页面路由在cms目录下创建page_list.vue页面。 现在先配置路由，实现url访问到页面再进行内容完善与调试。 1、在cms的router下配置路由 123456789101112import Home from &apos;@/module/home/page/home.vue&apos;;import page_list from &apos;@/module/cms/page/page_list.vue&apos;;export default [&#123; path: &apos;/cms&apos;, component: Home, name: &apos;CMS内容管理&apos;, hidden: false, children:[ &#123;path:&apos;/cms/page/list&apos;,name:&apos;页面列表&apos;,component: page_list,hidden:false&#125; ] &#125;] 2、在base目录下的router导入cms模块的路由 123456// // 导入路由规则import HomeRouter from &apos;@/module/home/router&apos;import CmsRouter from &apos;@/module/cms/router&apos;// 合并路由规则concat(HomeRouter)concat(CmsRouter) 3、测试 启动工程，刷新页面，页面可以外正常浏览，并且看到“测试页面显示…”字样 3.1.2 Table组件测试3.1.2.1 Element-UI介绍本项目使用Element-UI来构建界面，Element是一套为开发者、设计师和产品经理准备的基于 Vue 2.0 的桌面端组件库。 Element-UI官方站点：http://element.eleme.io/#/zh-CN/component/installation 3.1.2.2 Table组件测试本功能实现的页面列表，用户可以进行分页查询、输入查询条件查询，通过查看Element-UI库，我们需要Table 表格、Form表单 及Pagination 分页组件。 进入Element-UI官方，找到Table组件，拷贝源代码到vue页面中，如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;template&gt; &lt;div&gt; &lt;!--相当于编写html的内容--&gt; &lt;el-table :data=&quot;tableData&quot; stripe style=&quot;width: 100%&quot;&gt; &lt;el-table-column prop=&quot;date&quot; label=&quot;日期&quot; width=&quot;180&quot;&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;name&quot; label=&quot;姓名&quot; width=&quot;180&quot;&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;address&quot; label=&quot;地址&quot;&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; //填写js代码，实现VM的功能，创建vue实例 export default &#123; data() &#123; return &#123; tableData: [&#123; date: &apos;2016-05-02&apos;, name: &apos;王小虎&apos;, address: &apos;上海市普陀区金沙江路 1518 弄&apos; &#125;, &#123; date: &apos;2016-05-04&apos;, name: &apos;王小虎&apos;, address: &apos;上海市普陀区金沙江路 1517 弄&apos; &#125;, &#123; date: &apos;2016-05-01&apos;, name: &apos;王小虎&apos;, address: &apos;上海市普陀区金沙江路 1519 弄&apos; &#125;, &#123; date: &apos;2016-05-03&apos;, name: &apos;王小虎&apos;, address: &apos;上海市普陀区金沙江路 1516 弄&apos; &#125;] &#125; &#125; &#125;&lt;/script&gt;&lt;style&gt; /*css样式*/&lt;/style&gt; 测试： 通过查看代码发现： el-table组件绑定了tableData模型数据。 tableData模型数据在script标签中定义。 3.1.3页面内容完善根据需求完善页面内容，完善列表字段，添加分页组件。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;template&gt; &lt;div&gt; &lt;el-button type=&quot;primary&quot; v-on:click=&quot;query&quot; size=&quot;small&quot;&gt;查询&lt;/el-button&gt; &lt;el-table :data=&quot;list&quot; stripe style=&quot;width: 100%&quot;&gt; &lt;el-table-column type=&quot;index&quot; width=&quot;60&quot;&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;pageName&quot; label=&quot;页面名称&quot; width=&quot;120&quot;&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;pageAliase&quot; label=&quot;别名&quot; width=&quot;120&quot;&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;pageType&quot; label=&quot;页面类型&quot; width=&quot;150&quot;&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;pageWebPath&quot; label=&quot;访问路径&quot; width=&quot;250&quot;&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;pagePhysicalPath&quot; label=&quot;物理路径&quot; width=&quot;250&quot;&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=&quot;pageCreateTime&quot; label=&quot;创建时间&quot; width=&quot;180&quot; &gt; &lt;/el-table-column&gt; &lt;/el-table&gt; &lt;el-pagination layout=&quot;prev, pager, next&quot; :page-size=&quot;this.params.size&quot; v-on:current-change=&quot;changePage&quot; :total=&quot;total&quot; :current-page=&quot;this.params.page&quot; style=&quot;float:right;&quot;&gt; &lt;/el-pagination&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; list:[], total:50, params:&#123; page:1,//页码 size:2//每页显示个数 &#125; &#125; &#125;, methods:&#123; //分页查询 changePage:function () &#123; this.query() &#125;, //查询 query:function () &#123; alert(&quot;查询&quot;) &#125; &#125; &#125;&lt;/script&gt; 2、测试 3.2 Api调用3.2.1 Api方法定义在cms模块的api目录定义cms.js， 在cms.js中定义如下js方法，此方法实现http请求服务端页面查询接口。 12345//public是对axios的工具类封装，定义了http请求方法import http from &apos;./../../../base/api/public&apos;export const page_list = (page,size,params) =&gt; &#123; return http.requestQuickGet(&apos;http://localhost:31001/cms/page/list/&apos;+page+&apos;/&apos;+size)&#125; axios实现了http方法的封装，vue.js官方不再继续维护vue-resource,推荐使用 axios。 3.2.2 Api调用前端页面导入cms.js，调用js方法请求服务端页面查询接口。 1）导入cms.js 1import * as cmsApi from &apos;../api/cms&apos; 在query方法中调用 page_list方法 12345678//查询query:function () &#123; cmsApi.page_list(this.params.page,this.params.size,this.params).then((res)=&gt;&#123; console.log(res) this.total = res.queryResult.total this.list = res.queryResult.list &#125;)&#125; 3.3 跨域问题解决测试 上边的代理 ，结果 报错如下 ： No ‘Access-Control-Allow-Origin’ header is present on the requested resource. Origin ‘http://localhost:11000&#39; is therefore not allowed access. 原因：浏览器的同源策略不允许跨域访问，所谓同源策略是指协议、域名、端口相同。 解决：采用proxyTable解决。 proxyTable是什么？ vue-cli提供的解决vue开发环境下跨域问题的方法，proxyTable的底层使用了http-proxy-middleware（https://github.com/chimurai/http-proxy-middleware），它是http代理中间件，它依赖node.js，基本原理是用服务端代理解决浏览器跨域： cms跨域解决原理： 1、访问页面http://localhost:11000/ 2、页面请求http://localhost:11000/cms 由于url由http://localhost:31001/cms...改为“http://localhost:11000/cms.“，所以不存在跨域 3、通过proxyTable由node服务器代理请求 http://localhost:31001/cms. 服务端不存在跨域问题 具体的配置如下： 1）修改api方法中url的定义 请求前加/api前缀 1234567//public是对axios的工具类封装，定义了http请求方法import http from &apos;./../../../base/api/public&apos;let sysConfig = require(&apos;@/../config/sysConfig&apos;)let apiUrl = sysConfig.xcApiUrlPre;export const page_list = (page,size,params) =&gt; &#123; return http.requestQuickGet(apiUrl+&apos;/cms/page/list/&apos;+page+&apos;/&apos;+size)&#125; 2）在config/index.js下配置proxyTable。 以/api/cms开头的请求，代理请求http://localhost:31001 12345&apos;/api/cms&apos;: &#123; target: &apos;http://localhost:31001&apos;, pathRewrite: &#123; &apos;^/api&apos;: &apos;&apos;//实际请求去掉/api &#125; 3.4 分页查询测试1、定义分页视图 使用v-on监听更改分页事件 123456&lt;el-pagination layout=&quot;prev, pager, next&quot; :page-size=&quot;this.params.size&quot; v-on:current-change=&quot;changePage&quot; :total=&quot;total&quot; :current-page=&quot;this.params.page&quot; style=&quot;float:right;&quot;&gt; &lt;/el-pagination&gt; 2、定义数据模型对象 123456789data() &#123; return &#123; list:[], total:50, params:&#123; page:1,//页码 size:2//每页显示个数 &#125; &#125; 3、定义分页方法，接收页码参数 12345//分页查询，接收page页码changePage(page)&#123; this.params.page = page; this.query()&#125; 修改完毕，测试分页效果。 3.5 进入页面立即查询目前实现的功能是进入页面点击查询按钮向服务端表求查询，实际的需求是进入页面立即查询。 如何实现？ 这要用到vue的钩子函数，每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做生命周期钩子的函数，这给了用户在不同阶段添加自己的代码的机会。 通常使用最多的是created和mounted两个钩子： created：vue实例已创建但是DOM元素还没有渲染生成。 mounted：DOM元素渲染生成完成后调用。 本例子在两个方法的任意一个都满足需求： 添加如下代码： 1234mounted() &#123; //默认查询页面 this.query()&#125; 重新刷新页面。 4 前后端请求响应流程小结参考 “讲义–&gt;前后端请求响应流程.png”，如下： 1、在浏览器输入前端url 2、前端框架vue.js根据url解析路由，根据路由找到page_list.vue页面 3、首先执行page_list.vue中的钩子方法 4、在钩子方法中调用query方法。 5、在query方法中调用cms.js中的page_list方法 6、cms.js中的page_list方法通过axios请求服务端接口 7、采用proxyTable解决跨域问题，node.js将请求转发到服务端(http://localhost:31001/cms/page/list) 8、服务端处理，将查询结果响应给前端 9、成功响应调用then方法，在then方法中处理响应结果，将查询结果赋值给数据模型中的total和list变量。 10、vue.js通过双向数据绑定将list数据渲染输出。]]></content>
      <categories>
        <category>项目实战-在线学习视频网站</category>
      </categories>
      <tags>
        <tag>Element-UI</tag>
        <tag>解决跨域问题（ProxyTable）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在线学习视频（三）—— CMS页面管理开发]]></title>
    <url>%2Fday03-CMS%E9%A1%B5%E9%9D%A2%E7%AE%A1%E7%90%86%E5%BC%80%E5%8F%91.html</url>
    <content type="text"><![CDATA[CMS页面管理开发1 自定义条件查询1.1 需求分析在页面输入查询条件，查询符合条件的页面信息。 查询条件如下： 站点Id：精确匹配 模板Id：精确匹配 页面别名：模糊匹配 … 1.2 服务端1.2.1 Dao1使用 CmsPageRepository中的findAll(Example&lt;S&gt; var1, Pageable var2)方法实现，无需定义。 下边测试findAll方法实现自定义条件查询： 12345678910111213141516171819202122 //自定义条件查询测试 @Test public void testFindAll() &#123; //条件匹配器 ExampleMatcher exampleMatcher = ExampleMatcher.matching(); exampleMatcher = exampleMatcher.withMatcher(&quot;pageAliase&quot;, ExampleMatcher.GenericPropertyMatchers.contains()); //页面别名模糊查询，需要自定义字符串的匹配器实现模糊查询 //ExampleMatcher.GenericPropertyMatchers.contains() 包含 //ExampleMatcher.GenericPropertyMatchers.startsWith()//开头匹配 //条件值 CmsPage cmsPage = new CmsPage(); //站点ID cmsPage.setSiteId(&quot;5a751fab6abb5044e0d19ea1&quot;); //模板ID cmsPage.setTemplateId(&quot;5a962c16b00ffc514038fafd&quot;);// cmsPage.setPageAliase(&quot;分类导航&quot;); //创建条件实例 Example&lt;CmsPage&gt; example = Example.of(cmsPage, exampleMatcher); Pageable pageable = new PageRequest(0, 10); Page&lt;CmsPage&gt; all = cmsPageRepository.findAll(example, pageable); System.out.println(all); &#125; 1.2.2 Service在PageService的findlist方法中增加自定义条件查询代码 12345678910111213141516171819202122232425262728293031323334353637/** * 页面列表分页查询 * @param page 当前页码 * @param size 页面显示个数 * @param queryPageRequest 查询条件 * @return 页面列表 */ public QueryResponseResult findList(int page,int size,QueryPageRequest queryPageRequest)&#123; //条件匹配器 //页面名称模糊查询，需要自定义字符串的匹配器实现模糊查询 ExampleMatcher exampleMatcher = ExampleMatcher.matching() .withMatcher(&quot;pageAliase&quot;, ExampleMatcher.GenericPropertyMatchers.contains()); //条件值 CmsPage cmsPage = new CmsPage(); //站点ID if(StringUtils.isNotEmpty(queryPageRequest.getSiteId()))&#123; cmsPage.setSiteId(queryPageRequest.getSiteId()); &#125; //页面别名 if(StringUtils.isNotEmpty(queryPageRequest.getPageAliase()))&#123; cmsPage.setPageAliase(queryPageRequest.getPageAliase()); &#125; //创建条件实例 Example&lt;CmsPage&gt; example = Example.of(cmsPage, exampleMatcher); //页码 page = page-1; //分页对象 Pageable pageable = new PageRequest(page, size); //分页查询 Page&lt;CmsPage&gt; all = cmsPageRepository.findAll(example,pageable); QueryResult&lt;CmsPage&gt; cmsPageQueryResult = new QueryResult&lt;CmsPage&gt;(); cmsPageQueryResult.setList(all.getContent()); cmsPageQueryResult.setTotal(all.getTotalElements()); //返回结果 return new QueryResponseResult(CommonCode.SUCCESS,cmsPageQueryResult); &#125; 1.2.3 Controller无需修改 1.2.4 测试使用SwaggerUI测试 1.3 前端1.3.1 页面1、增加查询表单 12345678910111213&lt;!--查询表单--&gt;&lt;el-form :model=&quot;params&quot;&gt; &lt;el-select v-model=&quot;params.siteId&quot; placeholder=&quot;请选择站点&quot;&gt; &lt;el-option v-for=&quot;item in siteList&quot; :key=&quot;item.siteId&quot; :label=&quot;item.siteName&quot; :value=&quot;item.siteId&quot;&gt; &lt;/el-option&gt; &lt;/el-select&gt; 页面别名：&lt;el-input v-model=&quot;params.pageAliase&quot; style=&quot;width: 100px&quot;&gt;&lt;/el-input&gt; &lt;el-button type=&quot;primary&quot; v-on:click=&quot;query&quot; size=&quot;small&quot;&gt;查询&lt;/el-button&gt;&lt;/el-form&gt; 2、数据模型对象 增加siteList、pageAliase、siteId，如下： 12345678910111213data() &#123; return &#123; siteList:[],//站点列表 list:[], total:50, params:&#123; siteId:&apos;&apos;, pageAliase:&apos;&apos;, page:1,//页码 size:2//每页显示个数 &#125; &#125;&#125; 3、在钩子方法中 构建siteList站点列表 123456789101112131415mounted() &#123; //默认查询页面 this.query() //初始化站点列表 this.siteList = [ &#123; siteId:&apos;5a751fab6abb5044e0d19ea1&apos;, siteName:&apos;门户主站&apos; &#125;, &#123; siteId:&apos;102&apos;, siteName:&apos;测试站&apos; &#125; ]&#125; 1.3.2 Api调用1、向服务端传递查询条件，修改 cms.js，如下： 1234567891011//public是对axios的工具类封装，定义了http请求方法import http from &apos;./../../../base/api/public&apos;import querystring from &apos;querystring&apos;let sysConfig = require(&apos;@/../config/sysConfig&apos;)let apiUrl = sysConfig.xcApiUrlPre;export const page_list = (page,size,params) =&gt; &#123; //将json对象转成key/value对 let query = querystring.stringify(params) return http.requestQuickGet(apiUrl+&apos;/cms/page/list/&apos;+page+&apos;/&apos;+size+&apos;/?&apos;+query)&#125; 2、页面调用api方法 12345678//查询query:function () &#123; cmsApi.page_list(this.params.page,this.params.size,this.params).then((res)=&gt;&#123; console.log(res) this.total = res.queryResult.total this.list = res.queryResult.list &#125;)&#125; 测试如下： 2 新增页面2.1 新增页面接口定义1、定义响应模型12345678@Datapublic class CmsPageResult extends ResponseResult &#123; CmsPage cmsPage; public CmsPageResult(ResultCode resultCode,CmsPage cmsPage) &#123; super(resultCode); this.cmsPage = cmsPage; &#125;&#125; 2、定义添加Api 在api工程中添加接口：12@ApiOperation(&quot;添加页面&quot;)public CmsPageResult add(CmsPage cmsPage); 2.2 新增页面服务端开发2.2.1 页面唯一索引在cms_page集中上创建页面名称、站点Id、页面webpath为唯一索引 2.2.2 Dao1、添加根据页面名称、站点Id、页面webpath查询页面方法，此方法用于校验页面是否存在 1234public interface CmsPageRepository extends MongoRepository&lt;CmsPage,String&gt; &#123; //根据页面名称、站点id、页面访问路径查询 CmsPage findByPageNameAndSiteIdAndPageWebPath(String pageName,String siteId,String pageWebPath); 。。。 2、使用 CmsPageRepository提供的save方法 。 2.2.3 Service12345678910111213//添加页面public CmsPageResult add(CmsPage cmsPage)&#123; //校验页面是否存在，根据页面名称、站点Id、页面webpath查询 CmsPage cmsPage1 = cmsPageRepository.findByPageNameAndSiteIdAndPageWebPath(cmsPage.getPageName(), cmsPage.getSiteId(), cmsPage.getPageWebPath()); if(cmsPage1==null)&#123; cmsPage.setPageId(null);//添加页面主键由spring data 自动生成 cmsPageRepository.save(cmsPage); //返回结果 CmsPageResult cmsPageResult = new CmsPageResult(CommonCode.SUCCESS,cmsPage); return cmsPageResult; &#125; return new CmsPageResult(CommonCode.FAIL,null);&#125; 2.2.4 Controller123456//添加页面@Override@PostMapping(&quot;/add&quot;)public CmsPageResult add(@RequestBody CmsPage cmsPage) &#123; return pageService.add(cmsPage);&#125; 2.2.5 接口测试使用postman测试 post请求：http://localhost:31001/cms/page/add 请求内容为json数据，测试数据如下： 12345678910111213141516&#123; &quot;dataUrl&quot;: &quot;string&quot;, &quot;htmlFileId&quot;: &quot;string&quot;, &quot;pageAliase&quot;: &quot;string&quot;, &quot;pageCreateTime&quot;: &quot;2018-06-11T02:01:25.667Z&quot;, &quot;pageHtml&quot;: &quot;string&quot;, &quot;pageName&quot;: &quot;测试页面&quot;, &quot;pageParameter&quot;: &quot;string&quot;, &quot;pagePhysicalPath&quot;: &quot;string&quot;, &quot;pageStatus&quot;: &quot;string&quot;, &quot;pageTemplate&quot;: &quot;string&quot;, &quot;pageType&quot;: &quot;string&quot;, &quot;pageWebPath&quot;: &quot;string&quot;, &quot;siteId&quot;: &quot;string&quot;, &quot;templateId&quot;: &quot;string&quot;&#125; 成功响应结果： 失败响应结果： 2.3 新增页面前端开发2.3.1 新增页面2.3.1.1 编写page_add.vue页面使用Element-UI的form组件编写添加表单内容，页面效果如下： 1、创建page_add.vue页面 2、配置路由 在cms模块的路由文件中配置“添加页面”的路由： 1&#123;path:&apos;/cms/page/add&apos;,name:&apos;新增页面&apos;,component: page_add,hidden:true&#125; 注意：由于“添加页面”不需要显示为一个菜单，这里hidden设置为true隐藏菜单。 测试，在浏览器地址栏输入http://localhost:11000/#/cms/page/add 3、在页面列表添加“添加页面”的按钮 实际情况是用户进入页面查询列表，点击“新增页面”按钮进入新增页面窗口。 在查询按钮的旁边添加： 123&lt;router-link class=&quot;mui-tab-item&quot; :to=&quot;&#123;path:&apos;/cms/page/add/&apos;&#125;&quot;&gt; &lt;el-button type=&quot;primary&quot; size=&quot;small&quot;&gt;新增页面&lt;/el-button&gt;&lt;/router-link&gt; 说明：router-link是vue提供的路由功能，用于在页面生成路由链接，最终在html渲染后就是&lt;a标签。 ​ to：目标路由地址 4、完善页面内容： 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;el-form :model=&quot;pageForm&quot; label-width=&quot;80px&quot; &gt; &lt;el-form-item label=&quot;所属站点&quot; prop=&quot;siteId&quot;&gt; &lt;el-select v-model=&quot;pageForm.siteId&quot; placeholder=&quot;请选择站点&quot;&gt; &lt;el-option v-for=&quot;item in siteList&quot; :key=&quot;item.siteId&quot; :label=&quot;item.siteName&quot; :value=&quot;item.siteId&quot;&gt; &lt;/el-option&gt; &lt;/el-select&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;选择模版&quot; prop=&quot;templateId&quot;&gt; &lt;el-select v-model=&quot;pageForm.templateId&quot; placeholder=&quot;请选择&quot;&gt; &lt;el-option v-for=&quot;item in templateList&quot; :key=&quot;item.templateId&quot; :label=&quot;item.templateName&quot; :value=&quot;item.templateId&quot;&gt; &lt;/el-option&gt; &lt;/el-select&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;页面名称&quot; prop=&quot;pageName&quot;&gt; &lt;el-input v-model=&quot;pageForm.pageName&quot; auto-complete=&quot;off&quot; &gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;别名&quot; prop=&quot;pageAliase&quot;&gt; &lt;el-input v-model=&quot;pageForm.pageAliase&quot; auto-complete=&quot;off&quot; &gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;访问路径&quot; prop=&quot;pageWebPath&quot;&gt; &lt;el-input v-model=&quot;pageForm.pageWebPath&quot; auto-complete=&quot;off&quot; &gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;物理路径&quot; prop=&quot;pagePhysicalPath&quot;&gt; &lt;el-input v-model=&quot;pageForm.pagePhysicalPath&quot; auto-complete=&quot;off&quot; &gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;类型&quot;&gt; &lt;el-radio-group v-model=&quot;pageForm.pageType&quot;&gt; &lt;el-radio class=&quot;radio&quot; label=&quot;0&quot;&gt;静态&lt;/el-radio&gt; &lt;el-radio class=&quot;radio&quot; label=&quot;1&quot;&gt;动态&lt;/el-radio&gt; &lt;/el-radio-group&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;创建时间&quot;&gt; &lt;el-date-picker type=&quot;datetime&quot; placeholder=&quot;创建时间&quot; v-model=&quot;pageForm.pageCreateTime&quot;&gt;&lt;/el-date-picker&gt; &lt;/el-form-item&gt;&lt;/el-form&gt;&lt;div slot=&quot;footer&quot; class=&quot;dialog-footer&quot;&gt; &lt;el-button type=&quot;primary&quot; @click=&quot;addSubmit&quot; &gt;提交&lt;/el-button&gt;&lt;/div&gt; Form Attributes说明： ​ model 表单数据对象 ​ rules 表单验证规则 Form-Item Attributes说明： ​ prop 表单域 model 字段，在使用 validate、resetFields 方法的情况下，该属性是必填的 ​ label 标签文本 详情属性及事件参考http://element.eleme.io/#/zh-CN/component/form 5、数据对象 12345678910111213141516171819202122232425data()&#123; return &#123; //站点列表 siteList:[], //模版列表 templateList:[], //新增界面数据 pageForm: &#123; siteId:&apos;&apos;, templateId:&apos;&apos;, pageName: &apos;&apos;, pageAliase: &apos;&apos;, pageWebPath: &apos;&apos;, pageParameter:&apos;&apos;, pagePhysicalPath:&apos;&apos;, pageType:&apos;&apos;, pageCreateTime: new Date() &#125; &#125;&#125;,methods:&#123; addSubmit()&#123; alert(&quot;提交&quot;) &#125;&#125; 6、站点及模板数据（先使用静态数据） 在created钩子方法中定义，created是在html渲染之前执行，这里推荐使用created。 123456789101112131415161718192021222324created:function()&#123; //初始化站点列表 this.siteList = [ &#123; siteId:&apos;5a751fab6abb5044e0d19ea1&apos;, siteName:&apos;门户主站&apos; &#125;, &#123; siteId:&apos;102&apos;, siteName:&apos;测试站&apos; &#125; ] //模板列表 this.templateList = [ &#123; templateId:&apos;5a962b52b00ffc514038faf7&apos;, templateName:&apos;首页&apos; &#125;, &#123; templateId:&apos;5a962bf8b00ffc514038fafa&apos;, templateName:&apos;轮播图&apos; &#125; ]&#125; 7、测试预览 新增页面按钮： 新增页面表单： 2.3.1.2 添加返回进入新增页面后只能通过菜单再次进入页面列表，可以在新增页面添加“返回”按钮，点击返回按钮返回到页面列表。 1) 新增页面按钮带上参数 12345&lt;router-link class=&quot;mui-tab-item&quot; :to=&quot;&#123;path:&apos;/cms/page/add/&apos;,query:&#123; page: this.params.page, siteId: this.params.siteId&#125;&#125;&quot;&gt; &lt;el-button type=&quot;primary&quot; size=&quot;small&quot;&gt;新增页面&lt;/el-button&gt;&lt;/router-link&gt; 说明：query表示在路由url上带上参数 2）定义返回方法 在page_add.vue上定义返回按钮 1&lt;el-button type=&quot;primary&quot; @click=&quot;go_back&quot; &gt;返回&lt;/el-button&gt; 在page_add.vue上定义返回方法 12345678go_back()&#123; this.$router.push(&#123; path: &apos;/cms/page/list&apos;, query: &#123; page: this.$route.query.page, siteId:this.$route.query.siteId &#125; &#125;)&#125; 说明：this.$route.query 表示取出路由上的参数列表，有两个取路由参数的方法： 12a、通过在路由上添加key/value串使用this.$route.query来取参数，例如：/router1?id=123 ,/router1?id=456 可以通过this.$route.query.id获取参数id的值。b、通过将参数作为路由一部分进行传参数使用this.$route.params来获取，例如：定义的路由为/router1/:id ，请求/router1/123时可以通过this.$route.params.id来获取，此种情况用this.$route.query.id是拿不到的。 3）查询列表支持回显 进入查询列表，从url中获取页码和站点id并赋值给数据模型对象，从而实现页面回显。 url例子：http://localhost:12000/#/cms/page/list?page=2&amp;siteId=5a751fab6abb5044e0d19ea1 12345created() &#123; //从路由上获取参数 this.params.page = Number.parseInt(this.$route.query.page||1); this.params.siteId = this.$route.query.siteId||&apos;&apos;; ..... 小技巧：使用 ||返回第一个有效值 2.3.1.3 表单校验1、配置校验规则： Element-UI的Form组件提供表单校验的方法： 在form属性上配置rules（表单验证规则） 1&lt;el-form :model=&quot;pageForm&quot; :rules=&quot;pageFormRules&quot; label-width=&quot;80px&quot; &gt; 在数据模型中配置校验规则： 1234567891011121314151617pageFormRules: &#123; siteId:[ &#123;required: true, message: &apos;请选择站点&apos;, trigger: &apos;blur&apos;&#125; ], templateId:[ &#123;required: true, message: &apos;请选择模版&apos;, trigger: &apos;blur&apos;&#125; ], pageName: [ &#123;required: true, message: &apos;请输入页面名称&apos;, trigger: &apos;blur&apos;&#125; ], pageWebPath: [ &#123;required: true, message: &apos;请输入访问路径&apos;, trigger: &apos;blur&apos;&#125; ], pagePhysicalPath: [ &#123;required: true, message: &apos;请输入物理路径&apos;, trigger: &apos;blur&apos;&#125; ]&#125; 更多的校验规则参考http://element.eleme.io/#/zh-CN/component/form中“表单验证”的例子。 2、点击提交按钮触发校验 1)在form表单上添加 ref属性（ref=”pageForm”）在校验时引用此表单对象 1&lt;el-form :model=&quot;pageForm&quot; :rules=&quot;pageFormRules&quot; label-width=&quot;80px&quot; ref=&quot;pageForm&quot;&gt; 2）执行校验 12345678this.$refs.pageForm.validate((valid) =&gt; &#123; if (valid) &#123; alert(&apos;提交&apos;); &#125; else &#123; alert(&apos;校验失败&apos;); return false; &#125;&#125;) 2.3.2 Api调用1、在cms.js中定义page_add方法。 1234/*页面添加*/export const page_add = params =&gt; &#123; return http.requestPost(apiUrl+&apos;/cms/page/add&apos;,params)&#125; 2、添加事件 本功能使用到两个UI组件： 1、使用element-ui的message-box组件弹出确认提交窗口（http://element.eleme.io/#/zh-CN/component/message-box）。 1this.$confirm(&apos;确认提交吗？&apos;, &apos;提示&apos;, &#123;&#125;).then(() =&gt; &#123;｝） 2、使用 message组件提示操作结果 （http://element.eleme.io/#/zh-CN/component/message） 1234this.$message(&#123; message: &apos;提交成功&apos;, type: &apos;success&apos;&#125;) 完整的代码如下： 1234567891011121314151617181920addSubmit()&#123; this.$refs.pageForm.validate((valid) =&gt; &#123; if (valid) &#123; this.$confirm(&apos;确认提交吗？&apos;, &apos;提示&apos;, &#123;&#125;).then(() =&gt; &#123; cmsApi.page_add(this.pageForm).then((res) =&gt; &#123; console.log(res); if(res.success)&#123; this.$message(&#123; message: &apos;提交成功&apos;, type: &apos;success&apos; &#125;); this.$refs[&apos;pageForm&apos;].resetFields(); &#125;else&#123; this.$message.error(&apos;提交失败&apos;); &#125; &#125;); &#125;); &#125; &#125;);&#125; 下边是测试： 1、进入页面列表页面 2、点击“增加页面”按钮 3、输入页面信息点击“提交” 3 修改页面修改页面用户操作流程： 1、用户进入修改页面，在页面上显示了修改页面的信息 2、用户修改页面的内容，点击“提交”，提示“修改成功”或“修改失败” 3.1 修改页面接口定义修改页面需要定义的API如下： 12345@ApiOperation(&quot;通过ID查询页面&quot;)public CmsPage findById(String id);@ApiOperation(&quot;修改页面&quot;)public CmsPageResult edit(String id,CmsPage cmsPage); 说明：提交数据使用post、put都可以，只是根据http方法的规范，put方法是对服务器指定资源进行修改，所以这里使用put方法对页面修改进行修改。 3.2 修改页面服务端开发3.2.1Dao使用 Spring Data提供的findById方法完成根据主键查询 。 使用 Spring Data提供的save方法完成数据保存 。 3.2.2Service12345678910111213141516171819202122232425262728293031323334353637 //根据id查询页面 public CmsPage getById(String id)&#123; Optional&lt;CmsPage&gt; optional = cmsPageRepository.findById(id); if(optional.isPresent())&#123; return optional.get(); &#125; //返回空 return null; &#125;//更新页面信息 public CmsPageResult update(String id,CmsPage cmsPage) &#123; //根据id查询页面信息 CmsPage one = this.getById(id); if (one != null) &#123; //更新模板id one.setTemplateId(cmsPage.getTemplateId()); //更新所属站点 one.setSiteId(cmsPage.getSiteId()); //更新页面别名 one.setPageAliase(cmsPage.getPageAliase()); //更新页面名称 one.setPageName(cmsPage.getPageName()); //更新访问路径 one.setPageWebPath(cmsPage.getPageWebPath()); //更新物理路径 one.setPagePhysicalPath(cmsPage.getPagePhysicalPath()); //执行更新 CmsPage save = cmsPageRepository.save(one); if (save != null) &#123; //返回成功 CmsPageResult cmsPageResult = new CmsPageResult(CommonCode.SUCCESS, save); return cmsPageResult; &#125; &#125; //返回失败 return new CmsPageResult(CommonCode.FAIL,null); &#125; 3.2.3Controller1、根据id查询页面 12345@Override@GetMapping(&quot;/get/&#123;id&#125;&quot;)public CmsPage findById(@PathVariable(&quot;id&quot;) String id) &#123; return pageService.getById(id);&#125; 2、保存页面信息 12345@Override@PutMapping(&quot;/edit/&#123;id&#125;&quot;)//这里使用put方法，http 方法中put表示更新public CmsPageResult edit(@PathVariable(&quot;id&quot;) String id, @RequestBody CmsPage cmsPage) &#123; return pageService.update(id,cmsPage);&#125; 3.3 修改页面前端开发3.3.1 页面处理流程页面的处理流程如下： 1、进入页面，通过钩子方法请求服务端获取页面信息，并赋值给数据模型对象 2、页面信息通过数据绑定在表单显示 3、用户修改信息点击“提交”请求服务端修改页面信息接口 3.3.3 修改页面3.3.3.1 编写page_edit页面修改页面的布局同添加页面，可以直接复制添加页面，在添加页面基础上修改。 下边编写页面内容： 1、编写page_edit.vue 页面布局同添加页面，略。 2、配置路由 进入修改页面传入pageId 12import page_edit from &apos;@/module/cms/page/page_edit.vue&apos;;&#123; path: &apos;/cms/page/edit/:pageId&apos;, name:&apos;修改页面&apos;,component: page_edit,hidden:true&#125;, 3、在页面列表添加“编辑”链接 参考table组件的例子，在page_list.vue上添加“操作”列 12345678&lt;el-table-column label=&quot;操作&quot; width=&quot;80&quot;&gt; &lt;template slot-scope=&quot;page&quot;&gt; &lt;el-button size=&quot;small&quot;type=&quot;text&quot; @click=&quot;edit(page.row.pageId)&quot;&gt;编辑 &lt;/el-button&gt; &lt;/template&gt;&lt;/el-table-column&gt; 编写edit方法 123456//修改edit:function (pageId) &#123; this.$router.push(&#123; path: &apos;/cms/page/edit/&apos;+pageId,query:&#123; page: this.params.page, siteId: this.params.siteId&#125;&#125;)&#125; 4、测试预览 点击“编辑”打开修改页面窗口。 3.3.3.2 页面内容显示本功能实现：进入修改页面立即显示要修改的页面信息。 1、定义api方法 1234/*页面查询*/export const page_get = id =&gt; &#123; return http.requestQuickGet(apiUrl+&apos;/cms/page/get/&apos;+id)&#125; 2、定义数据对象 进入修改页面传入pageId参数，在数据模型中添加pageId。 12345678data()&#123; return &#123; ...... //页面id pageId:&apos;&apos;, ...... &#125; &#125; 3、在created钩子方法 中查询页面信息 1234567891011created: function () &#123; //页面参数通过路由传入，这里通过this.$route.params来获取 this.pageId=this.$route.params.pageId; //根据主键查询页面信息 cmsApi.page_get(this.pageId).then((res) =&gt; &#123; console.log(res); if(res.success)&#123; this.pageForm = res.cmsPage; &#125; &#125;);&#125; 7、预览页面回显效果 3.3.4 Api调用1、定义api方法 1234/*页面修改，采用put方法*/export const page_edit = (id,params) =&gt; &#123; return http.requestPut(apiUrl+&apos;/cms/page/edit/&apos;+id,params)&#125; 2、提交按钮方法 添加提交按钮事件： 1&lt;el-button type=&quot;primary&quot; @click=&quot;editSubmit&quot; &gt;提交&lt;/el-button&gt; 3、提交按钮事件内容： 123456789101112131415161718192021editSubmit()&#123; this.$refs.pageForm.validate((valid) =&gt; &#123; if (valid) &#123; this.$confirm(&apos;确认提交吗？&apos;, &apos;提示&apos;, &#123;&#125;).then(() =&gt; &#123; cmsApi.page_edit(this.pageId,this.pageForm).then((res) =&gt; &#123; console.log(res); if(res.success)&#123; this.$message(&#123; message: &apos;修改成功&apos;, type: &apos;success&apos; &#125;); //自动返回 this.go_back(); &#125;else&#123; this.$message.error(&apos;修改失败&apos;); &#125; &#125;); &#125;); &#125; &#125;);&#125; 4、测试 修改页面信息，点击提交。 4 删除页面用户操作流程： 1、用户进入用户列表，点击“删除” 2、执行删除操作，提示“删除成功”或“删除失败” 4.1 删除页面接口定义12@ApiOperation(&quot;通过ID删除页面&quot;)public ResponseResult delete(String id); 4.2 删除页面服务端开发4.2.1Dao使用 Spring Data提供的deleteById方法完成删除操作 。 4.2.2 Service12345678910//删除页面public ResponseResult delete(String id)&#123; CmsPage one = this.getById(id); if(one!=null)&#123; //删除页面 cmsPageRepository.deleteById(id); return new ResponseResult(CommonCode.SUCCESS); &#125; return new ResponseResult(CommonCode.FAIL);&#125; 4.2.3Controller1234@DeleteMapping(&quot;/del/&#123;id&#125;&quot;) //使用http的delete方法完成岗位操作public ResponseResult delete(@PathVariable(&quot;id&quot;) String id) &#123; return pageService.delete(id);&#125; 4.3 删除页面前端开发4.3.1 Api方法1234/*页面删除*/export const page_del = id =&gt; &#123; return http.requestDelete(apiUrl+&apos;/cms/page/del/&apos;+id)&#125; 4.3.2编写页面1、在page_list.vue页面添加删除按钮 123456789101112&lt;el-table-column label=&quot;操作&quot; width=&quot;120&quot;&gt; &lt;template slot-scope=&quot;page&quot;&gt; &lt;el-button size=&quot;small&quot;type=&quot;text&quot; @click=&quot;edit(page.row.pageId)&quot;&gt;编辑 &lt;/el-button&gt; &lt;el-button size=&quot;small&quot;type=&quot;text&quot; @click=&quot;del(page.row.pageId)&quot;&gt;删除 &lt;/el-button&gt; &lt;/template&gt;&lt;/el-table-column&gt; 2、删除事件 123456789101112131415161718192021//删除 del:function (pageId) &#123; this.$confirm(&apos;确认删除此页面吗?&apos;, &apos;提示&apos;, &#123;&#125;).then(() =&gt; &#123; cmsApi.page_del(pageId).then((res)=&gt;&#123; if(res.success)&#123; this.$message(&#123; type: &apos;success&apos;, message: &apos;删除成功!&apos; &#125;); //查询页面 this.query() &#125;else&#123; this.$message(&#123; type: &apos;error&apos;, message: &apos;删除失败!&apos; &#125;); &#125; &#125;) &#125;) &#125; 5 异常处理5.1 异常处理的问题分析从添加页面的service方法中找问题： 12345678910111213 //添加页面 public CmsPageResult add(CmsPage cmsPage)&#123;//校验页面是否存在，根据页面名称、站点Id、页面webpath查询 CmsPage cmsPage1 = cmsPageRepository.findByPageNameAndSiteIdAndPageWebPath(cmsPage.getPageName(), cmsPage.getSiteId(), cmsPage.getPageWebPath()); if(cmsPage1==null)&#123; cmsPage.setPageId(null);//添加页面主键由spring data 自动生成 cmsPageRepository.save(cmsPage); //返回结果 CmsPageResult cmsPageResult = new CmsPageResult(CommonCode.SUCCESS,cmsPage); return cmsPageResult; &#125; return new CmsPageResult(CommonCode.FAIL,null); &#125; 问题： 1、上边的代码只要操作不成功仅向用户返回“错误代码：11111，失败信息：操作失败”，无法区别具体的错误信息。 2、service方法在执行过程出现异常在哪捕获？在service中需要都加try/catch，如果在controller也需要添加try/catch，代码冗余严重且不易维护。 解决方案： 1、在Service方法中的编码顺序是先校验判断，有问题则抛出具体的异常信息，最后执行具体的业务操作，返回成功信息。 2、在统一异常处理类中去捕获异常，无需controller捕获异常，向用户返回统一规范的响应信息。 代码模板如下： 1234567891011121314151617181920//添加页面public CmsPageResult add(CmsPage cmsPage)&#123; //校验cmsPage是否为空 if(cmsPage == null)&#123; //抛出异常，非法请求 //... &#125; //根据页面名称查询（页面名称已在mongodb创建了唯一索引） CmsPage cmsPage1 = cmsPageRepository.findByPageNameAndSiteIdAndPageWebPath(cmsPage.getPageName(), cmsPage.getSiteId(), cmsPage.getPageWebPath()); //校验页面是否存在，已存在则抛出异常 if(cmsPage1 !=null)&#123; //抛出异常，已存在相同的页面名称 //... &#125; cmsPage.setPageId(null);//添加页面主键由spring data 自动生成 CmsPage save = cmsPageRepository.save(cmsPage); //返回结果 CmsPageResult cmsPageResult = new CmsPageResult(CommonCode.SUCCESS,save); return cmsPageResult;&#125; 5.2 异常处理流程系统对异常的处理使用统一的异常处理流程： 1、自定义异常类型。 2、自定义错误代码及错误信息。 3、对于可预知的异常由程序员在代码中主动抛出，由SpringMVC统一捕获。 ​ 可预知异常是程序员在代码中手动抛出本系统定义的特定异常类型，由于是程序员抛出的异常，通常异常信息比较齐全，程序员在抛出时会指定错误代码及错误信息，获取异常信息也比较方便。 4、对于不可预知的异常（运行时异常）由SpringMVC统一捕获Exception类型的异常。 ​ 不可预知异常通常是由于系统出现bug、或一些不要抗拒的错误（比如网络中断、服务器宕机等），异常类型为RuntimeException类型（运行时异常）。 5、可预知的异常及不可预知的运行时异常最终会采用统一的信息格式（错误代码+错误信息）来表示，最终也会随请求响应给客户端。 异常抛出及处理流程： 1、在controller、service、dao中程序员抛出自定义异常；springMVC框架抛出框架异常类型 2、统一由异常捕获类捕获异常，并进行处理 3、捕获到自定义异常则直接取出错误代码及错误信息，响应给用户。 4、捕获到非自定义异常类型首先从Map中找该异常类型是否对应具体的错误代码，如果有则取出错误代码和错误信息并响应给用户，如果从Map中找不到异常类型所对应的错误代码则统一为99999错误代码并响应给用户。 5、将错误代码及错误信息以Json格式响应给用户。 5.3 可预知异常处理5.3.1 自定义异常类在common工程定义异常类型。 12345678910111213141516171819package com.xuecheng.framework.exception;import com.xuecheng.framework.model.response.ResultCode;public class CustomException extends RuntimeException &#123; private ResultCode resultCode; public CustomException(ResultCode resultCode) &#123; //异常信息为错误代码+异常信息 super(&quot;错误代码：&quot;+resultCode.code()+&quot;错误信息：&quot;+resultCode.message()); this.resultCode = resultCode; &#125; public ResultCode getResultCode()&#123; return this.resultCode; &#125;&#125; 5.3.2 异常抛出类1234567891011package com.xuecheng.framework.exception;import com.xuecheng.framework.model.response.ResultCode;public class ExceptionCast &#123; //使用此静态方法抛出自定义异常 public static void cast(ResultCode resultCode)&#123; throw new CustomException(resultCode); &#125;&#125; 5.3.3 异常捕获类使用 @ControllerAdvice和@ExceptionHandler注解来捕获指定类型的异常 1234567891011121314151617181920212223242526package com.xuecheng.framework.exception;import com.xuecheng.framework.model.response.ResponseResult;import com.xuecheng.framework.model.response.ResultCode;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.web.bind.annotation.ControllerAdvice;import org.springframework.web.bind.annotation.ExceptionHandler;import org.springframework.web.bind.annotation.ResponseBody;@ControllerAdvicepublic class ExceptionCatch &#123; private static final Logger LOGGER = LoggerFactory.getLogger(ExceptionCatch.class); //捕获 CustomException异常 @ExceptionHandler(CustomException.class) @ResponseBody public ResponseResult customException(CustomException e) &#123; LOGGER.error(&quot;catch exception : &#123;&#125;\r\nexception: &quot;,e.getMessage(), e); ResultCode resultCode = e.getResultCode(); ResponseResult responseResult = new ResponseResult(resultCode); return responseResult; &#125;&#125; 5.3.4异常处理测试5.3.4.1定义错误代码每个业务操作的异常使用异常代码去标识。 123456789101112131415161718192021222324252627282930313233343536package com.xuecheng.framework.domain.cms.response;import com.xuecheng.framework.model.response.ResultCode;import lombok.ToString;@ToStringpublic enum CmsCode implements ResultCode &#123; CMS_ADDPAGE_EXISTS(false,24001,&quot;页面已存在！&quot;); //操作结果 boolean success; //操作代码 int code; //提示信息 String message; private CmsCode(boolean success, int code, String message)&#123; this.success = success; this.code = code; this.message = message; &#125; @Override public boolean success() &#123; return success; &#125; @Override public int code() &#123; return code; &#125; @Override public String message() &#123; return message; &#125;&#125; 5.3.4.2 异常处理测试1、抛出异常 在controller、service、 dao中都可以抛出异常。 修改PageService的add方法，添加抛出异常的代码 123456/校验页面是否存在，根据页面名称、站点Id、页面webpath查询CmsPage cmsPage1 = cmsPageRepository.findByPageNameAndSiteIdAndPageWebPath(cmsPage.getPageName(), cmsPage.getSiteId(), cmsPage.getPageWebPath());if(cmsPage1 !=null)&#123; //校验页面是否存在，已存在则抛出异常 ExceptionCast.cast(CmsCode.CMS_ADDPAGE_EXISTS);&#125; 2、启动工程，扫描到异常捕获的类ExceptionCatch 在springBoot的启动类中添加 1@ComponentScan(basePackages=&quot;com.xuecheng.framework&quot;)//扫描common工程下的类 3、前端展示异常信息 服务端响应信息如下： 页面提取异常处理 12345678910111213141516171819202122addSubmit()&#123; this.$refs.pageForm.validate((valid) =&gt; &#123; if (valid) &#123; this.$confirm(&apos;确认提交吗？&apos;, &apos;提示&apos;, &#123;&#125;).then(() =&gt; &#123; cmsApi.page_add(this.pageForm).then((res) =&gt; &#123; console.log(res); if(res.success)&#123; this.$message(&#123; message: &apos;提交成功&apos;, type: &apos;success&apos; &#125;); this.$refs[&apos;pageForm&apos;].resetFields(); &#125;else if(res.message)&#123; this.$message.error(res.message); &#125;else&#123; this.$message.error(&apos;提交失败&apos;); &#125; &#125;); &#125;); &#125; &#125;);&#125; 5.4 不可预知异常处理5.4.1 定义异常捕获方法5.4.1.1 异常抛出测试使用postman测试添加页面，不输入cmsPost信息，提交，报错信息如下： 12org.springframework.http.converter.HttpMessageNotReadableException此异常是springMVC在进行参数转换时报的错误。 具体的响应的信息为： 12345678&#123; &quot;timestamp&quot;: 1528712906727, &quot;status&quot;: 400, &quot;error&quot;: &quot;Bad Request&quot;, &quot;exception&quot;: &quot;org.springframework.http.converter.HttpMessageNotReadableException&quot;, &quot;message&quot;: &quot;Required request body is missing: public com.xuecheng.framework.domain.cms.response.CmsPageResult com.xuecheng.manage_cms.web.controller.CmsPageController.add(com.xuecheng.framework.domain.cms.CmsPage)&quot;, &quot;path&quot;: &quot;/cms/page/add&quot;&#125; 上边的响应信息在客户端是无法解析的。 在异常捕获类中添加对Exception异常的捕获： 12345678@ExceptionHandler(Exception.class)@ResponseBodypublic ResponseResult exception(Exception exception)&#123; //记录日志 LOGGER.error(&quot;catch exception:&#123;&#125;&quot;,exception.getMessage()); return null;&#125; 5.4.1.2 异常捕获方法针对上边的问题其解决方案是： 1、我们在map中配置HttpMessageNotReadableException和错误代码。 2、在异常捕获类中对Exception异常进行捕获，并从map中获取异常类型对应的错误代码，如果存在错误代码则返回此错误，否则统一返回99999错误。 具体的开发实现如下： 1、在通用错误代码类CommCode中配置非法参数异常 1INVALID_PARAM(false,10003,&quot;非法参数！&quot;), 2、在异常捕获类中配置 HttpMessageNotReadableException 为非法参数异常。 异常捕获类代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.xuecheng.framework.exception;import com.google.common.collect.ImmutableMap;import com.xuecheng.framework.model.response.CommonCode;import com.xuecheng.framework.model.response.ResponseResult;import com.xuecheng.framework.model.response.ResultCode;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.http.converter.HttpMessageNotReadableException;import org.springframework.web.bind.annotation.ControllerAdvice;import org.springframework.web.bind.annotation.ExceptionHandler;import org.springframework.web.bind.annotation.ResponseBody;/** * @author Administrator * @version 1.0 * @create 2018-06-11 17:16 **/@ControllerAdvicepublic class ExceptionCatch &#123; private static final Logger LOGGER = LoggerFactory.getLogger(ExceptionCatch.class); //使用EXCEPTIONS存放异常类型和错误代码的映射，ImmutableMap的特点的一旦创建不可改变，并且线程安全 private static ImmutableMap&lt;Class&lt;? extends Throwable&gt;,ResultCode&gt; EXCEPTIONS; //使用builder来构建一个异常类型和错误代码的异常 protected static ImmutableMap.Builder&lt;Class&lt;? extends Throwable&gt;,ResultCode&gt; builder = ImmutableMap.builder(); //捕获Exception异常 @ResponseBody @ExceptionHandler(Exception.class) public ResponseResult exception(Exception e) &#123; LOGGER.error(&quot;catch exception : &#123;&#125;\r\nexception: &quot;,e.getMessage(), e); if(EXCEPTIONS == null) EXCEPTIONS = builder.build(); final ResultCode resultCode = EXCEPTIONS.get(e.getClass()); final ResponseResult responseResult; if (resultCode != null) &#123; responseResult = new ResponseResult(resultCode); &#125; else &#123; responseResult = new ResponseResult(CommonCode.SERVER_ERROR); &#125; return responseResult; &#125; //捕获 CustomException异常 @ExceptionHandler(CustomException.class) @ResponseBody public ResponseResult customException(CustomException e) &#123; LOGGER.error(&quot;catch exception : &#123;&#125;\r\nexception: &quot;,e.getMessage(), e); ResultCode resultCode = e.getResultCode(); ResponseResult responseResult = new ResponseResult(resultCode); return responseResult; &#125; static&#123; //在这里加入一些基础的异常类型判断 builder.put(HttpMessageNotReadableException.class,CommonCode.INVALIDPARAM); &#125;&#125; 5.4.3 异常处理测试仍然模拟“问题测试”中的测试步骤，异常结果为“非法参数”。 6 实战此部分为自学内容，根据今天所学知识完成下边的任务。 6.1 查询条件完善页面查询条件增加：页面名称、页面类型。 页面名称对应CmsPage模型类中的pageName属性。 页面类型对应CmsPage模型类中的pageType属性。 查询要求： 页面名称：模糊查询 页面类型：精确匹配，页面类型包括：静态和动态，在数据库中静态用“0”表示，动态用“1”表示。 6.2 页面属性增加DataUrl在CmsPage.java模型类型中有一个dataUrl属性，此属性在页面静态化时需要填写。 本需求要求： 1、在新增页面增加dataUrl输入框，并支持添加。 2、在修改页面增加dataUrl输入框，并支持修改。]]></content>
      <categories>
        <category>项目实战-在线学习视频网站</category>
      </categories>
      <tags>
        <tag>自定义异常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在线学习视频（五）—— 消息队列 GridFS]]></title>
    <url>%2Fday05-%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6RabbitMQ.html</url>
    <content type="text"><![CDATA[消息队列 GridFS1 页面发布1.1 需求分析 业务流程如下： 1、管理员进入管理界面点击“页面发布”，前端请求cms页面发布接口。 2、cms页面发布接口执行页面静态化，并将静态化页面(html文件)存储至GridFS中。 3、静态化成功后，向消息队列发送页面发布的消息。 页面发布的最终目标是将页面发布到服务器。 通过消息队列将页面发布的消息发送给各各服务器。 3、消息队列负责将消息发送给各各服务器上部署的Cms Client(Cms客户端)。 在服务器上部署Cms Client(Cms客户端)，客户端接收消息队列的通知。 4、每个接收到页面发布消息的Cms Client从GridFS获取Html页面文件，并将Html文件存储在本地服务器。 CmsClient根据页面发布消息的内容请求GridFS获取页面文件，存储在本地服务器。 1.2 RabbitMQ研究要实现上边页面发布的功能，有一个重要的环节就是由消息队列将页面发布的消息通知给各各服务器。 本节的教学目标是对MQ的研究： 1、理解MQ的应用场景 2、理解MQ常用的工作模式 RabbitMQ 研究1 RabbitMQ介绍1.1 应用场景​ MQ全称为Message Queue，即消息队列， RabbitMQ是由erlang语言开发，基于AMQP（Advanced Message Queue 高级消息队列协议）协议实现的消息队列，它是一种应用程序之间的通信方法，消息队列在分布式系统开发中应用非常广泛。RabbitMQ官方地址：http://www.rabbitmq.com/ 开发中消息队列通常有如下应用场景： 1、任务异步处理。 将不需要同步处理的并且耗时长的操作由消息队列通知消息接收方进行异步处理。提高了应用程序的响应时间。 2、应用程序解耦合 MQ相当于一个中介，生产方通过MQ与消费方交互，它将应用程序进行解耦合。 市场上还有哪些消息队列？ ActiveMQ，RabbitMQ，ZeroMQ，Kafka，MetaMQ，RocketMQ、Redis。 为什么使用RabbitMQ呢？ 1、使得简单，功能强大。 2、基于AMQP协议。 3、社区活跃，文档完善。 4、高并发性能好，这主要得益于Erlang语言。 5、Spring Boot默认已集成RabbitMQ 1.2 其它相关术语AMQP是什么 ？ 总结：AMQP是一套公开的消息队列协议，最早在2003年被提出，它旨在从协议层定义消息通信数据的标准格式，为的就是解决MQ市场上协议不统一的问题。RabbitMQ就是遵循AMQP标准协议开发的MQ服务。 官方：http://www.amqp.org/ JMS是什么 ？ 总结： JMS是java提供的一套消息服务API标准，其目的是为所有的java应用程序提供统一的消息通信的标准，类似java的jdbc，只要遵循jms标准的应用程序之间都可以进行消息通信。它和AMQP有什么 不同，jms是java语言专属的消息服务标准，它是在api层定义标准，并且只能用于java应用；而AMQP是在协议层定义的标准，是跨语言的 。 2 RabbitMQ工作原理2.1 RabbitMQ工作原理下图是RabbitMQ的基本结构： 组成部分说明如下： Broker：消息队列服务进程，此进程包括两个部分：Exchange和Queue。 Exchange：消息队列交换机，按一定的规则将消息路由转发到某个队列，对消息进行过虑。 Queue：消息队列，存储消息的队列，消息到达队列并转发给指定的消费方。 Producer：消息生产者，即生产方客户端，生产方客户端将消息发送到MQ。 Consumer：消息消费者，即消费方客户端，接收MQ转发的消息。 消息发布接收流程： —–发送消息—– 1、生产者和Broker建立TCP连接。 2、生产者和Broker建立通道。 3、生产者通过通道消息发送给Broker，由Exchange将消息进行转发。 4、Exchange将消息转发到指定的Queue（队列） —-接收消息—– 1、消费者和Broker建立TCP连接 2、消费者和Broker建立通道 3、消费者监听指定的Queue（队列） 4、当有消息到达Queue时Broker默认将消息推送给消费者。 5、消费者接收到消息。 2.2 RabbitMQ下载安装2.2.1 下载安装​ RabbitMQ由Erlang语言开发，Erlang语言用于并发及分布式系统的开发，在电信领域应用广泛，OTP（Open Telecom Platform）作为Erlang语言的一部分，包含了很多基于Erlang开发的中间件及工具库，安装RabbitMQ需要安装Erlang/OTP，并保持版本匹配，如下图： RabbitMQ的下载地址：http://www.rabbitmq.com/download.html 本项目使用Erlang/OTP 20.3版本和RabbitMQ3.7.3版本。 1）下载erlang 地址如下： http://erlang.org/download/otp_win64_20.3.exe 或去老师提供的软件包中找到 otp_win64_20.3.exe，以管理员方式运行此文件，安装。 erlang安装完成需要配置erlang环境变量： ERLANG_HOME=D:\Program Files\erl9.3 在path中添加%ERLANG_HOME%\bin; 2）安装RabbitMQ https://github.com/rabbitmq/rabbitmq-server/releases/tag/v3.7.3 或去老师提供的软件包中找到 rabbitmq-server-3.7.3.exe，以管理员方式运行此文件，安装。 2.2.2启动安装成功后会自动创建RabbitMQ服务并且启动。 1）从开始菜单启动RabbitMQ 完成在开始菜单找到RabbitMQ的菜单： RabbitMQ Service-install :安装服务 RabbitMQ Service-remove 删除服务 RabbitMQ Service-start 启动 RabbitMQ Service-stop 启动 2）如果没有开始菜单则进入安装目录下sbin目录手动启动： 1）安装并运行服务 rabbitmq-service.bat install 安装服务 rabbitmq-service.bat stop 停止服务 rabbitmq-service.bat start 启动服务 2）安装管理插件 安装rabbitMQ的管理插件，方便在浏览器端管理RabbitMQ 管理员身份运行 rabbitmq-plugins.bat enable rabbitmq_management 3、启动成功 登录RabbitMQ 进入浏览器，输入：http://localhost:15672 初始账号和密码：guest/guest 2.2.3 注意事项1、安装erlang和rabbitMQ以管理员身份运行。 2、当卸载重新安装时会出现RabbitMQ服务注册失败，此时需要进入注册表清理erlang 搜索RabbitMQ、ErlSrv，将对应的项全部删除。 2.2 快速入门按照官方教程(http://www.rabbitmq.com/getstarted.html)测试hello world: 2.2.1搭建环境1）java client 生产者和消费者都属于客户端，rabbitMQ的java客户端如下： 我们先用 rabbitMQ官方提供的java client测试，目的是对RabbitMQ的交互过程有个清晰的认识。 参考 ：https://github.com/rabbitmq/rabbitmq-java-client/ 2）创建maven工程 创建生产者工程和消费者工程，分别加入RabbitMQ java client的依赖。 test-rabbitmq-producer：生产者工程 test-rabbitmq-consumer：消费者工程 123456789&lt;dependency&gt; &lt;groupId&gt;com.rabbitmq&lt;/groupId&gt; &lt;artifactId&gt;amqp-client&lt;/artifactId&gt; &lt;version&gt;4.0.3&lt;/version&gt;&lt;!--此版本与spring boot 1.5.9版本匹配--&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;&lt;/dependency&gt; 2.2.2 生产者生产者操作流程如下： 1）创建连接 2）创建通道 3）声明队列 4）发送消息 在生产者工程下的test包中创建测试类如下： 12 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class Producer01 &#123; //队列名称 private static final String QUEUE = &quot;helloworld&quot;; public static void main(String[] args) throws IOException, TimeoutException &#123; Connection connection = null; Channel channel = null; try &#123; ConnectionFactory factory = new ConnectionFactory(); factory.setHost(&quot;localhost&quot;); factory.setPort(5672); factory.setUsername(&quot;guest&quot;); factory.setPassword(&quot;guest&quot;); factory.setVirtualHost(&quot;/&quot;);//rabbitmq默认虚拟机名称为“/”，虚拟机相当于一个独立的mq服务器 //创建与RabbitMQ服务的TCP连接 connection = factory.newConnection(); //创建与Exchange的通道，每个连接可以创建多个通道，每个通道代表一个会话任务 channel = connection.createChannel(); /** * 声明队列，如果Rabbit中没有此队列将自动创建 * param1:队列名称 * param2:是否持久化 * param3:队列是否独占此连接 * param4:队列不再使用时是否自动删除此队列 * param5:队列参数 */ channel.queueDeclare(QUEUE, true, false, false, null); String message = &quot;helloworld小明&quot;+System.currentTimeMillis(); /** * 消息发布方法 * param1：Exchange的名称，如果没有指定，则使用Default Exchange * param2:routingKey,消息的路由Key，是用于Exchange（交换机）将消息转发到指定的消息队列 * param3:消息包含的属性 * param4：消息体 */ /** * 这里没有指定交换机，消息将发送给默认交换机，每个队列也会绑定那个默认的交换机，但是不能显示绑定或解除绑定 * 默认的交换机，routingKey等于队列名称 */ channel.basicPublish(&quot;&quot;, QUEUE, null, message.getBytes()); System.out.println(&quot;Send Message is:&apos;&quot; + message + &quot;&apos;&quot;); &#125; catch(Exception ex) &#123; ex.printStackTrace(); &#125; finally &#123; if(channel != null) &#123; channel.close(); &#125; if(connection != null) &#123; connection.close(); &#125; &#125; &#125;&#125; 2.2.3 消费者消费者操作流程如下： 1）创建连接 2）创建通道 3）声明队列 4）监听队列 5）接收消息 6）ack回复 在消费者工程下的test包中创建测试类如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class Consumer01 &#123; private static final String QUEUE = &quot;helloworld&quot;; public static void main(String[] args) throws IOException, TimeoutException &#123; ConnectionFactory factory = new ConnectionFactory(); //设置MabbitMQ所在服务器的ip和端口 factory.setHost(&quot;127.0.0.1&quot;); factory.setPort(5672); Connection connection = factory.newConnection(); Channel channel = connection.createChannel(); //声明队列 channel.queueDeclare(QUEUE, true, false, false, null); //定义消费方法 DefaultConsumer consumer = new DefaultConsumer(channel) &#123; /** * 消费者接收消息调用此方法 * @param consumerTag 消费者的标签，在channel.basicConsume()去指定 * @param envelope 消息包的内容，可从中获取消息id，消息routingkey，交换机，消息和重传标志(收到消息失败后是否需要重新发送) * @param properties * @param body * @throws IOException */ @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; //交换机 String exchange = envelope.getExchange(); //路由key String routingKey = envelope.getRoutingKey(); //消息id long deliveryTag = envelope.getDeliveryTag(); //消息内容 String msg = new String(body,&quot;utf-8&quot;); System.out.println(&quot;receive message..&quot; + msg); &#125; &#125;; /** * 监听队列String queue, boolean autoAck,Consumer callback * 参数明细 * 1、队列名称 * 2、是否自动回复，设置为true为表示消息接收到自动向mq回复接收到了，mq接收到回复会删除消息，设置为false则需要手动回复 * 3、消费消息的方法，消费者接收到消息后调用此方法 */ channel.basicConsume(QUEUE, true, consumer); &#125;&#125; 3 RabbitMQ工作模式RabbitMQ有以下几种工作模式 ： 1、Work queues 2、Publish/Subscribe 3、Routing 4、Topics 5、Header 6、RPC 3.1 Work queues work queues与入门程序相比，多了一个消费端，两个消费端共同消费同一个队列中的消息。 应用场景：对于 任务过重或任务较多情况使用工作队列可以提高任务处理的速度。 测试： 1、使用入门程序，启动多个消费者。 2、生产者发送多个消息。 结果： 1、一条消息只会被一个消费者接收； 2、rabbit采用轮询的方式将消息是平均发送给消费者的； 3、消费者在处理完某条消息后，才会收到下一条消息。 3.2 Publish/subscribe3.2.1生产者3.2.1.1 发布订阅模式介绍 发布订阅模式： 1、每个消费者监听自己的队列。 2、生产者将消息发给broker，由交换机将消息转发到绑定此交换机的每个队列，每个绑定交换机的队列都将接收到消息 3.2.1.2 生产者代码通过一个案例讲解发布订阅模式： 用户通知，当用户充值成功或转账完成系统通知用户，通知方式有短信、邮件多种方法 。 生产者代码如下： 声明Exchange_fanout_inform交换机。 声明两个队列并且绑定到此交换机，绑定时不需要指定routingkey 发送消息时不需要指定routingkey 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899package com.xuecheng.test.rabbitmq;import com.rabbitmq.client.*;import java.io.IOException;import java.util.concurrent.TimeoutException;public class Producer02_publish &#123; //队列名称 private static final String QUEUE_INFORM_EMAIL = &quot;queue_inform_email&quot;; private static final String QUEUE_INFORM_SMS = &quot;queue_inform_sms&quot;; private static final String EXCHANGE_FANOUT_INFORM=&quot;exchange_fanout_inform&quot;; public static void main(String[] args) &#123; Connection connection = null; Channel channel = null; try &#123; //创建一个与MQ的连接 ConnectionFactory factory = new ConnectionFactory(); factory.setHost(&quot;127.0.0.1&quot;); factory.setPort(5672); factory.setUsername(&quot;guest&quot;); factory.setPassword(&quot;guest&quot;); factory.setVirtualHost(&quot;/&quot;);//rabbitmq默认虚拟机名称为“/”，虚拟机相当于一个独立的mq服务器 //创建一个连接 connection = factory.newConnection(); //创建与交换机的通道，每个通道代表一个会话 channel = connection.createChannel(); //声明交换机 String exchange, BuiltinExchangeType type /** * 参数明细 * 1、交换机名称 * 2、交换机类型，fanout、topic、direct、headers */ channel.exchangeDeclare(EXCHANGE_FANOUT_INFORM, BuiltinExchangeType.FANOUT); //声明队列// (String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments) /** * 参数明细： * 1、队列名称 * 2、是否持久化 * 3、是否独占此队列 * 4、队列不用是否自动删除 * 5、参数 */ channel.queueDeclare(QUEUE_INFORM_EMAIL, true, false, false, null); channel.queueDeclare(QUEUE_INFORM_SMS, true, false, false, null); //交换机和队列绑定String queue, String exchange, String routingKey /** * 参数明细 * 1、队列名称 * 2、交换机名称 * 3、路由key */ channel.queueBind(QUEUE_INFORM_EMAIL,EXCHANGE_FANOUT_INFORM,&quot;&quot;); channel.queueBind(QUEUE_INFORM_SMS,EXCHANGE_FANOUT_INFORM,&quot;&quot;); //发送消息 for (int i=0;i&lt;10;i++)&#123; String message = &quot;inform to user&quot;+i; //向交换机发送消息 String exchange, String routingKey, BasicProperties props, byte[] body /** * 参数明细 * 1、交换机名称，不指令使用默认交换机名称 Default Exchange * 2、routingKey（路由key），根据key名称将消息转发到具体的队列，这里填写队列名称表示消息将发到此队列 * 3、消息属性 * 4、消息内容 */ channel.basicPublish(EXCHANGE_FANOUT_INFORM, &quot;&quot;, null, message.getBytes()); System.out.println(&quot;Send Message is:&apos;&quot; + message + &quot;&apos;&quot;); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (TimeoutException e) &#123; e.printStackTrace(); &#125;finally&#123; if(channel!=null)&#123; try &#123; channel.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (TimeoutException e) &#123; e.printStackTrace(); &#125; &#125; if(connection!=null)&#123; try &#123; connection.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 3.2.2 消费者3.2.2.1 消费者代码邮件发送消费者代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879package com.xuecheng.test.rabbitmq;import com.rabbitmq.client.*;import java.io.IOException;import java.util.concurrent.TimeoutException;/** * @author Administrator * @version 1.0 * @create 2018-06-14 10:32 **/public class Consumer02_subscribe_email &#123; //队列名称 private static final String QUEUE_INFORM_EMAIL = &quot;inform_queue_email&quot;; private static final String EXCHANGE_FANOUT_INFORM=&quot;inform_exchange_fanout&quot;; public static void main(String[] args) throws IOException, TimeoutException &#123; //创建一个与MQ的连接 ConnectionFactory factory = new ConnectionFactory(); factory.setHost(&quot;127.0.0.1&quot;); factory.setPort(5672); factory.setUsername(&quot;guest&quot;); factory.setPassword(&quot;guest&quot;); factory.setVirtualHost(&quot;/&quot;);//rabbitmq默认虚拟机名称为“/”，虚拟机相当于一个独立的mq服务器 //创建一个连接 Connection connection = factory.newConnection(); //创建与交换机的通道，每个通道代表一个会话 Channel channel = connection.createChannel(); //声明交换机 String exchange, BuiltinExchangeType type /** * 参数明细 * 1、交换机名称 * 2、交换机类型，fanout、topic、direct、headers */ channel.exchangeDeclare(EXCHANGE_FANOUT_INFORM, BuiltinExchangeType.FANOUT); //声明队列// channel.queueDeclare(String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments) /** * 参数明细： * 1、队列名称 * 2、是否持久化 * 3、是否独占此队列 * 4、队列不用是否自动删除 * 5、参数 */ channel.queueDeclare(QUEUE_INFORM_EMAIL, true, false, false, null); //交换机和队列绑定String queue, String exchange, String routingKey /** * 参数明细 * 1、队列名称 * 2、交换机名称 * 3、路由key */ channel.queueBind(QUEUE_INFORM_EMAIL,EXCHANGE_FANOUT_INFORM,&quot;&quot;); //定义消费方法 DefaultConsumer defaultConsumer = new DefaultConsumer(channel) &#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; long deliveryTag = envelope.getDeliveryTag(); String exchange = envelope.getExchange(); //消息内容 String message = new String(body, &quot;utf-8&quot;); System.out.println(message); &#125; &#125;; /** * 监听队列String queue, boolean autoAck,Consumer callback * 参数明细 * 1、队列名称 * 2、是否自动回复，设置为true为表示消息接收到自动向mq回复接收到了，mq接收到回复会删除消息，设置为false则需要手动回复 * 3、消费消息的方法，消费者接收到消息后调用此方法 */ channel.basicConsume(QUEUE_INFORM_EMAIL, true, defaultConsumer); &#125;&#125; 按照上边的代码，编写邮件通知的消费代码。 3、短信发送消费者 参考上边的邮件发送消费者代码编写。 3.2.2.2 测试打开RabbitMQ的管理界面，观察交换机绑定情况： 使用生产者发送若干条消息，每条消息都转发到各各队列，每消费者都接收到了消息。 3.2.2.3 小结1、publish/subscribe与work queues有什么区别。 区别： 1）work queues不用定义交换机，而publish/subscribe需要定义交换机。 2）publish/subscribe的生产方是面向交换机发送消息，work queues的生产方是面向队列发送消息(底层使用默认交换机)。 3）publish/subscribe需要设置队列和交换机的绑定，work queues不需要设置，实质上work queues会将队列绑定到默认的交换机 。 相同点： 所以两者实现的发布/订阅的效果是一样的，多个消费端监听同一个队列不会重复消费消息。 2、实质工作用什么 publish/subscribe还是work queues。 建议使用 publish/subscribe，发布订阅模式比工作队列模式更强大，并且发布订阅模式可以指定自己专用的交换机。 3.3 Routing路由模式3.3.1 路由模式介绍 路由模式： 1、每个消费者监听自己的队列，并且设置routingkey。 2、生产者将消息发给交换机，由交换机根据routingkey来转发消息到指定的队列。 3.3.2 生产者声明exchange_routing_inform交换机。 声明两个队列并且绑定到此交换机，绑定时需要指定routingkey 发送消息时需要指定routingkey 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109package com.xuecheng.test.rabbitmq;import com.rabbitmq.client.BuiltinExchangeType;import com.rabbitmq.client.Channel;import com.rabbitmq.client.Connection;import com.rabbitmq.client.ConnectionFactory;import java.io.IOException;import java.util.concurrent.TimeoutException;public class Producer03_routing &#123; //队列名称 private static final String QUEUE_INFORM_EMAIL = &quot;queue_inform_email&quot;; private static final String QUEUE_INFORM_SMS = &quot;queue_inform_sms&quot;; private static final String EXCHANGE_ROUTING_INFORM=&quot;exchange_routing_inform&quot;; public static void main(String[] args) &#123; Connection connection = null; Channel channel = null; try &#123; //创建一个与MQ的连接 ConnectionFactory factory = new ConnectionFactory(); factory.setHost(&quot;127.0.0.1&quot;); factory.setPort(5672); factory.setUsername(&quot;guest&quot;); factory.setPassword(&quot;guest&quot;); factory.setVirtualHost(&quot;/&quot;);//rabbitmq默认虚拟机名称为“/”，虚拟机相当于一个独立的mq服务器 //创建一个连接 connection = factory.newConnection(); //创建与交换机的通道，每个通道代表一个会话 channel = connection.createChannel(); //声明交换机 String exchange, BuiltinExchangeType type /** * 参数明细 * 1、交换机名称 * 2、交换机类型，fanout、topic、direct、headers */ channel.exchangeDeclare(EXCHANGE_ROUTING_INFORM, BuiltinExchangeType.DIRECT); //声明队列// channel.queueDeclare(String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments) /** * 参数明细： * 1、队列名称 * 2、是否持久化 * 3、是否独占此队列 * 4、队列不用是否自动删除 * 5、参数 */ channel.queueDeclare(QUEUE_INFORM_EMAIL, true, false, false, null); channel.queueDeclare(QUEUE_INFORM_SMS, true, false, false, null); //交换机和队列绑定String queue, String exchange, String routingKey /** * 参数明细 * 1、队列名称 * 2、交换机名称 * 3、路由key */ channel.queueBind(QUEUE_INFORM_EMAIL,EXCHANGE_ROUTING_INFORM,QUEUE_INFORM_EMAIL); channel.queueBind(QUEUE_INFORM_SMS,EXCHANGE_ROUTING_INFORM,QUEUE_INFORM_SMS); //发送邮件消息 for (int i=0;i&lt;10;i++)&#123; String message = &quot;email inform to user&quot;+i; //向交换机发送消息 String exchange, String routingKey, BasicProperties props, byte[] body /** * 参数明细 * 1、交换机名称，不指令使用默认交换机名称 Default Exchange * 2、routingKey（路由key），根据key名称将消息转发到具体的队列，这里填写队列名称表示消息将发到此队列 * 3、消息属性 * 4、消息内容 */ channel.basicPublish(EXCHANGE_ROUTING_INFORM, QUEUE_INFORM_EMAIL, null, message.getBytes()); System.out.println(&quot;Send Message is:&apos;&quot; + message + &quot;&apos;&quot;); &#125; //发送短信消息 for (int i=0;i&lt;10;i++)&#123; String message = &quot;sms inform to user&quot;+i; //向交换机发送消息 String exchange, String routingKey, BasicProperties props, byte[] body channel.basicPublish(EXCHANGE_ROUTING_INFORM, QUEUE_INFORM_SMS, null, message.getBytes()); System.out.println(&quot;Send Message is:&apos;&quot; + message + &quot;&apos;&quot;); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (TimeoutException e) &#123; e.printStackTrace(); &#125;finally&#123; if(channel!=null)&#123; try &#123; channel.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (TimeoutException e) &#123; e.printStackTrace(); &#125; &#125; if(connection!=null)&#123; try &#123; connection.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 3.3.3 消费者邮件发送消费者代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package com.xuecheng.test.rabbitmq;import com.rabbitmq.client.*;import java.io.IOException;import java.util.concurrent.TimeoutException;public class Consumer03_routing_email &#123; //队列名称 private static final String QUEUE_INFORM_EMAIL = &quot;inform_queue_email&quot;; private static final String EXCHANGE_ROUTING_INFORM=&quot;inform_exchange_routing&quot;; public static void main(String[] args) throws IOException, TimeoutException &#123; //创建一个与MQ的连接 ConnectionFactory factory = new ConnectionFactory(); factory.setHost(&quot;127.0.0.1&quot;); factory.setPort(5672); factory.setUsername(&quot;guest&quot;); factory.setPassword(&quot;guest&quot;); factory.setVirtualHost(&quot;/&quot;);//rabbitmq默认虚拟机名称为“/”，虚拟机相当于一个独立的mq服务器 //创建一个连接 Connection connection = factory.newConnection(); //创建与交换机的通道，每个通道代表一个会话 Channel channel = connection.createChannel(); //声明交换机 String exchange, BuiltinExchangeType type /** * 参数明细 * 1、交换机名称 * 2、交换机类型，fanout、topic、direct、headers */ channel.exchangeDeclare(EXCHANGE_ROUTING_INFORM, BuiltinExchangeType.DIRECT); //声明队列// channel.queueDeclare(String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments) /** * 参数明细： * 1、队列名称 * 2、是否持久化 * 3、是否独占此队列 * 4、队列不用是否自动删除 * 5、参数 */ channel.queueDeclare(QUEUE_INFORM_EMAIL, true, false, false, null); //交换机和队列绑定String queue, String exchange, String routingKey /** * 参数明细 * 1、队列名称 * 2、交换机名称 * 3、路由key */ channel.queueBind(QUEUE_INFORM_EMAIL,EXCHANGE_ROUTING_INFORM,QUEUE_INFORM_EMAIL); //定义消费方法 DefaultConsumer defaultConsumer = new DefaultConsumer(channel) &#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; long deliveryTag = envelope.getDeliveryTag(); String exchange = envelope.getExchange(); //消息内容 String message = new String(body, &quot;utf-8&quot;); System.out.println(message); &#125; &#125;; /** * 监听队列String queue, boolean autoAck,Consumer callback * 参数明细 * 1、队列名称 * 2、是否自动回复，设置为true为表示消息接收到自动向mq回复接收到了，mq接收到回复会删除消息，设置为false则需要手动回复 * 3、消费消息的方法，消费者接收到消息后调用此方法 */ channel.basicConsume(QUEUE_INFORM_EMAIL, true, defaultConsumer); &#125;&#125; 3、短信发送消费者 参考邮件发送消费者的代码流程，编写短信通知的代码。 3.3.4 测试打开RabbitMQ的管理界面，观察交换机绑定情况： 使用生产者发送若干条消息，交换机根据routingkey转发消息到指定的队列。 3.4.5 小结1、Routing模式和Publish/subscibe有啥区别？ Routing模式要求队列在绑定交换机时要指定routingkey，消息会转发到符合routingkey的队列。 3.4 Topics3.4.1统配符模式介绍 路由模式： 1、每个消费者监听自己的队列，并且设置带统配符的routingkey。 2、生产者将消息发给broker，由交换机根据routingkey来转发消息到指定的队列。 3.4.2生产者案例： 根据用户的通知设置去通知用户，设置接收Email的用户只接收Email，设置接收sms的用户只接收sms，设置两种通知类型都接收的则两种通知都有效。 生产者代码如下： 声明交换机，指定topic类型： 123456789101112/** * 声明交换机 * param1：交换机名称 * param2:交换机类型 四种交换机类型：direct、fanout、topic、headers */ channel.exchangeDeclare(EXCHANGE_TOPICS_INFORM, BuiltinExchangeType.TOPIC);//Email通知channel.basicPublish(EXCHANGE_TOPICS_INFORM, &quot;inform.email&quot;, null, message.getBytes());//sms通知channel.basicPublish(EXCHANGE_TOPICS_INFORM, &quot;inform.sms&quot;, null, message.getBytes());//两种都通知channel.basicPublish(EXCHANGE_TOPICS_INFORM, &quot;inform.sms.email&quot;, null, message.getBytes()); 完整代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104package com.xuecheng.test.rabbitmq;import com.rabbitmq.client.BuiltinExchangeType;import com.rabbitmq.client.Channel;import com.rabbitmq.client.Connection;import com.rabbitmq.client.ConnectionFactory;import java.io.IOException;import java.util.concurrent.TimeoutException;public class Producer04_topics &#123; //队列名称 private static final String QUEUE_INFORM_EMAIL = &quot;queue_inform_email&quot;; private static final String QUEUE_INFORM_SMS = &quot;queue_inform_sms&quot;; private static final String EXCHANGE_TOPICS_INFORM=&quot;exchange_topics_inform&quot;; public static void main(String[] args) &#123; Connection connection = null; Channel channel = null; try &#123; //创建一个与MQ的连接 ConnectionFactory factory = new ConnectionFactory(); factory.setHost(&quot;127.0.0.1&quot;); factory.setPort(5672); factory.setUsername(&quot;guest&quot;); factory.setPassword(&quot;guest&quot;); factory.setVirtualHost(&quot;/&quot;);//rabbitmq默认虚拟机名称为“/”，虚拟机相当于一个独立的mq服务器 //创建一个连接 connection = factory.newConnection(); //创建与交换机的通道，每个通道代表一个会话 channel = connection.createChannel(); //声明交换机 String exchange, BuiltinExchangeType type /** * 参数明细 * 1、交换机名称 * 2、交换机类型，fanout、topic、direct、headers */ channel.exchangeDeclare(EXCHANGE_TOPICS_INFORM, BuiltinExchangeType.TOPIC); //声明队列 /** * 参数明细： * 1、队列名称 * 2、是否持久化 * 3、是否独占此队列 * 4、队列不用是否自动删除 * 5、参数 */ channel.queueDeclare(QUEUE_INFORM_EMAIL, true, false, false, null); channel.queueDeclare(QUEUE_INFORM_SMS, true, false, false, null); //发送邮件消息 for (int i=0;i&lt;10;i++)&#123; String message = &quot;email inform to user&quot;+i; //向交换机发送消息 String exchange, String routingKey, BasicProperties props, byte[] body /** * 参数明细 * 1、交换机名称，不指令使用默认交换机名称 Default Exchange * 2、routingKey（路由key），根据key名称将消息转发到具体的队列，这里填写队列名称表示消息将发到此队列 * 3、消息属性 * 4、消息内容 */ channel.basicPublish(EXCHANGE_TOPICS_INFORM, &quot;inform.email&quot;, null, message.getBytes()); System.out.println(&quot;Send Message is:&apos;&quot; + message + &quot;&apos;&quot;); &#125; //发送短信消息 for (int i=0;i&lt;10;i++)&#123; String message = &quot;sms inform to user&quot;+i; channel.basicPublish(EXCHANGE_TOPICS_INFORM, &quot;inform.sms&quot;, null, message.getBytes()); System.out.println(&quot;Send Message is:&apos;&quot; + message + &quot;&apos;&quot;); &#125; //发送短信和邮件消息 for (int i=0;i&lt;10;i++)&#123; String message = &quot;sms and email inform to user&quot;+i; channel.basicPublish(EXCHANGE_TOPICS_INFORM, &quot;inform.sms.email&quot;, null, message.getBytes()); System.out.println(&quot;Send Message is:&apos;&quot; + message + &quot;&apos;&quot;); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (TimeoutException e) &#123; e.printStackTrace(); &#125;finally&#123; if(channel!=null)&#123; try &#123; channel.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (TimeoutException e) &#123; e.printStackTrace(); &#125; &#125; if(connection!=null)&#123; try &#123; connection.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 3.4.3 消费端队列绑定交换机指定通配符： 统配符规则： 中间以“.”分隔。 符号#可以匹配多个词，符号*可以匹配一个词语。 123456789 //声明队列channel.queueDeclare(QUEUE_INFORM_EMAIL, true, false, false, null);channel.queueDeclare(QUEUE_INFORM_SMS, true, false, false, null);//声明交换机channel.exchangeDeclare(EXCHANGE_TOPICS_INFORM, BuiltinExchangeType.TOPIC);//绑定email通知队列channel.queueBind(QUEUE_INFORM_EMAIL,EXCHANGE_TOPICS_INFORM,&quot;inform.#.email.#&quot;);//绑定sms通知队列 channel.queueBind(QUEUE_INFORM_SMS,EXCHANGE_TOPICS_INFORM,&quot;inform.#.sms.#&quot;); 3.4.4 测试 使用生产者发送若干条消息，交换机根据routingkey统配符匹配并转发消息到指定的队列。 3.4.5 小结1、本案例的需求使用Routing工作模式能否实现？ 使用Routing模式也可以实现本案例，共设置三个 routingkey，分别是email、sms、all，email队列绑定email和all，sms队列绑定sms和all，这样就可以实现上边案例的功能，实现过程比topics复杂。 Topic模式更多加强大，它可以实现Routing、publish/subscirbe模式的功能。 3.5 其它模式3.5.1 Header模式​ header模式与routing不同的地方在于，header模式取消routingkey，使用header中的 key/value（键值对）匹配队列。 案例： 根据用户的通知设置去通知用户，设置接收Email的用户只接收Email，设置接收sms的用户只接收sms，设置两种通知类型都接收的则两种通知都有效。 代码： 1）生产者 队列与交换机绑定的代码与之前不同，如下： 123456Map&lt;String, Object&gt; headers_email = new Hashtable&lt;String, Object&gt;();headers_email.put(&quot;inform_type&quot;, &quot;email&quot;);Map&lt;String, Object&gt; headers_sms = new Hashtable&lt;String, Object&gt;();headers_sms.put(&quot;inform_type&quot;, &quot;sms&quot;);channel.queueBind(QUEUE_INFORM_EMAIL,EXCHANGE_HEADERS_INFORM,&quot;&quot;,headers_email);channel.queueBind(QUEUE_INFORM_SMS,EXCHANGE_HEADERS_INFORM,&quot;&quot;,headers_sms); 通知： 12345678String message = &quot;email inform to user&quot;+i;Map&lt;String,Object&gt; headers = new Hashtable&lt;String, Object&gt;();headers.put(&quot;inform_type&quot;, &quot;email&quot;);//匹配email通知消费者绑定的header//headers.put(&quot;inform_type&quot;, &quot;sms&quot;);//匹配sms通知消费者绑定的headerAMQP.BasicProperties.Builder properties = new AMQP.BasicProperties.Builder();properties.headers(headers);//Email通知channel.basicPublish(EXCHANGE_HEADERS_INFORM, &quot;&quot;, properties.build(), message.getBytes()); 2）发送邮件消费者 1234567channel.exchangeDeclare(EXCHANGE_HEADERS_INFORM, BuiltinExchangeType.HEADERS);Map&lt;String, Object&gt; headers_email = new Hashtable&lt;String, Object&gt;();headers_email.put(&quot;inform_email&quot;, &quot;email&quot;);//交换机和队列绑定channel.queueBind(QUEUE_INFORM_EMAIL,EXCHANGE_HEADERS_INFORM,&quot;&quot;,headers_email);//指定消费队列channel.basicConsume(QUEUE_INFORM_EMAIL, true, consumer); 3)测试 3.5.2 RPC RPC即客户端远程调用服务端的方法 ，使用MQ可以实现RPC的异步调用，基于Direct交换机实现，流程如下： 1、客户端即是生产者就是消费者，向RPC请求队列发送RPC调用消息，同时监听RPC响应队列。 2、服务端监听RPC请求队列的消息，收到消息后执行服务端的方法，得到方法返回的结果 3、服务端将RPC方法 的结果发送到RPC响应队列 4、客户端（RPC调用方）监听RPC响应队列，接收到RPC调用结果。 4 Spring整合RibbitMQ4.1 搭建环境4.1.1 添加依赖我们选择基于Spring-Rabbit去操作RabbitMQ https://github.com/spring-projects/spring-amqp 使用spring-boot-starter-amqp会自动添加spring-rabbit依赖，如下： 123456789101112&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;&lt;/dependency&gt; 4.1.2 配置application.yml配置连接rabbitmq的参数 1234567891011server: port: 44000spring: application: name: test-rabbitmq-producer rabbitmq: host: 127.0.0.1 port: 5672 username: guest passowrd: guest virtualHost: / 4.1.3 配置交换机和队列定义RabbitConfig类，配置Exchange、Queue、及绑定交换机。 本例配置Topic交换机。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.xuecheng.test.rabbitmq.config;import org.springframework.amqp.core.*;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configurationpublic class RabbitmqConfig &#123; public static final String QUEUE_INFORM_EMAIL = &quot;queue_inform_email&quot;; public static final String QUEUE_INFORM_SMS = &quot;queue_inform_sms&quot;; public static final String EXCHANGE_TOPICS_INFORM=&quot;exchange_topics_inform&quot;; /** * 交换机配置 * ExchangeBuilder提供了fanout、direct、topic、header交换机类型的配置 * @return the exchange */ @Bean(EXCHANGE_TOPICS_INFORM) public Exchange EXCHANGE_TOPICS_INFORM() &#123; //durable(true)持久化，消息队列重启后交换机仍然存在 return ExchangeBuilder.topicExchange(EXCHANGE_TOPICS_INFORM).durable(true).build(); &#125; //声明队列 @Bean(QUEUE_INFORM_SMS) public Queue QUEUE_INFORM_SMS() &#123; Queue queue = new Queue(QUEUE_INFORM_SMS); return queue; &#125; //声明队列 @Bean(QUEUE_INFORM_EMAIL) public Queue QUEUE_INFORM_EMAIL() &#123; Queue queue = new Queue(QUEUE_INFORM_EMAIL); return queue; &#125; /** channel.queueBind(INFORM_QUEUE_SMS,&quot;inform_exchange_topic&quot;,&quot;inform.#.sms.#&quot;); * 绑定队列到交换机 . * * @param queue the queue * @param exchange the exchange * @return the binding */ @Bean public Binding BINDING_QUEUE_INFORM_SMS(@Qualifier(QUEUE_INFORM_SMS) Queue queue, @Qualifier(EXCHANGE_TOPICS_INFORM) Exchange exchange) &#123; return BindingBuilder.bind(queue).to(exchange).with(&quot;inform.#.sms.#&quot;).noargs(); &#125; @Bean public Binding BINDING_QUEUE_INFORM_EMAIL(@Qualifier(QUEUE_INFORM_EMAIL) Queue queue, @Qualifier(EXCHANGE_TOPICS_INFORM) Exchange exchange) &#123; return BindingBuilder.bind(queue).to(exchange).with(&quot;inform.#.email.#&quot;).noargs(); &#125;&#125; 4.3 生产者使用RarbbitTemplate发送消息 1234567891011121314151617181920212223242526package com.xuecheng.test.rabbitmq;import com.xuecheng.test.rabbitmq.config.RabbitmqConfig;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.amqp.rabbit.core.RabbitTemplate;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;@SpringBootTest@RunWith(SpringRunner.class)public class Producer05_topics_springboot &#123; @Autowired RabbitTemplate rabbitTemplate; @Test public void testSendByTopics()&#123; for (int i=0;i&lt;5;i++)&#123; String message = &quot;sms email inform to user&quot;+i; rabbitTemplate.convertAndSend(RabbitmqConfig.EXCHANGE_TOPICS_INFORM,&quot;inform.sms.email&quot;,message); System.out.println(&quot;Send Message is:&apos;&quot; + message + &quot;&apos;&quot;); &#125; &#125;&#125; 4.4消费者4.4.1 消费者代码创建消费端工程，添加依赖： 123456789101112&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;&lt;/dependency&gt; 使用@RabbitListener注解监听队列。 123456789101112131415161718192021222324package com.xuecheng.test.rabbitmq.mq;import com.rabbitmq.client.Channel;import com.xuecheng.test.rabbitmq.config.RabbitmqConfig;import org.springframework.amqp.core.Message;import org.springframework.amqp.rabbit.annotation.RabbitListener;import org.springframework.stereotype.Component;@Componentpublic class ReceiveHandler &#123; //监听email队列 @RabbitListener(queues = &#123;RabbitmqConfig.QUEUE_INFORM_EMAIL&#125;) public void receive_email(String msg,Message message,Channel channel)&#123; System.out.println(msg); &#125; //监听sms队列 @RabbitListener(queues = &#123;RabbitmqConfig.QUEUE_INFORM_SMS&#125;) public void receive_sms(String msg,Message message,Channel channel)&#123; System.out.println(msg); &#125;&#125; 4.4.2 测试]]></content>
      <categories>
        <category>项目实战-在线学习视频网站</category>
        <category>RabbitMQ</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在线学习视频（六）—— 页面发布 课程管理]]></title>
    <url>%2Fday06-%E9%A1%B5%E9%9D%A2%E5%8F%91%E5%B8%83%20%E8%AF%BE%E7%A8%8B%E7%AE%A1%E7%90%86.html</url>
    <content type="text"><![CDATA[页面发布 课程管理1 页面发布1.1 技术方案本项目使用MQ实现页面发布的技术方案如下： 技术方案说明： 1、平台包括多个站点，页面归属不同的站点。 2、发布一个页面应将该页面发布到所属站点的服务器上。 3、每个站点服务部署cms client程序，并与交换机绑定，绑定时指定站点Id为routingKey。 指定站点id为routingKey就可以实现cms client只能接收到所属站点的页面发布消息。 4、页面发布程序向MQ发布消息时指定页面所属站点Id为routingKey，将该页面发布到它所在服务器上的cms client。 路由模式分析如下： 发布一个页面，需发布到该页面所属的每个站点服务器，其它站点服务器不发布。 比如：发布一个门户的页面，需要发布到每个门户服务器上，而用户中心服务器则不需要发布。 所以本项目采用routing模式，用站点id作为routingKey，这样就可以匹配页面只发布到所属的站点服务器上。 页面发布流程图如下： 1、前端请求cms执行页面发布。 2、cms执行静态化程序生成html文件。 3、cms将html文件存储到GridFS中。 4、cms向MQ发送页面发布消息 5、MQ将页面发布消息通知给Cms Client 6、Cms Client从GridFS中下载html文件 7、Cms Client将html保存到所在服务器指定目录 1.2 页面发布消费方1.2.1需求分析功能分析： 创建Cms Client工程作为页面发布消费方，将Cms Client部署在多个服务器上，它负责接收到页面发布 的消息后从GridFS中下载文件在本地保存。 需求如下： 1、将cms Client部署在服务器，配置队列名称和站点ID。 2、cms Client连接RabbitMQ并监听各自的“页面发布队列” 3、cms Client接收页面发布队列的消息 4、根据消息中的页面id从mongodb数据库下载页面到本地 调用dao查询页面信息，获取到页面的物理路径，调用dao查询站点信息，得到站点的物理路径 页面物理路径=站点物理路径+页面物理路径+页面名称。 从GridFS查询静态文件内容，将静态文件内容保存到页面物理路径下。 1.2.2创建Cms Client工程1、创建maven工程 ​ pom.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;xc-framework-parent&lt;/artifactId&gt; &lt;groupId&gt;com.xuecheng&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;relativePath&gt;../xc-framework-parent/pom.xml&lt;/relativePath&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;xc-service-manage-cms-client&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.xuecheng&lt;/groupId&gt; &lt;artifactId&gt;xc-framework-model&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 2、配置文件 在resources下配置application.yml和logback-spring.xml。 application.yml的内容如下： 1234567891011121314151617181920server: port: 31000spring: application: name: xc-service-manage-cms-client data: mongodb: uri: mongodb://root:123@localhost:27017 database: xc_cms rabbitmq: host: 127.0.0.1 port: 5672 username: guest password: guest virtualHost: /xuecheng: mq: #cms客户端监控的队列名称（不同的客户端监控的队列不能重复） queue: queue_cms_postpage_01 routingKey: 5a751fab6abb5044e0d19ea1 #此routingKey为门户站点ID 说明：在配置文件中配置队列的名称，每个 cms client在部署时注意队列名称不要重复 3、启动类 12345678910@SpringBootApplication@EntityScan(&quot;com.xuecheng.framework.domain.cms&quot;)//扫描实体类@ComponentScan(basePackages=&#123;&quot;com.xuecheng.framework&quot;&#125;)//扫描common下的所有类@ComponentScan(basePackages=&#123;&quot;com.xuecheng.manage_cms_client&quot;&#125;)public class ManageCmsClientApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ManageCmsClientApplication.class, args); &#125;&#125; 1.2.3 RabbitmqConfig配置类消息队列设置如下： 1、创建“ex_cms_postpage”交换机 2、每个Cms Client创建一个队列与交换机绑定 3、每个Cms Client程序配置队列名称和routingKey，将站点ID作为routingKey。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.xuecheng.manage_cms_client.config;import org.springframework.amqp.core.*;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;/** * @author Administrator * @version 1.0 **/@Configurationpublic class RabbitmqConfig &#123; //队列bean的名称 public static final String QUEUE_CMS_POSTPAGE = &quot;queue_cms_postpage&quot;; //交换机的名称 public static final String EX_ROUTING_CMS_POSTPAGE=&quot;ex_routing_cms_postpage&quot;; //队列的名称 @Value(&quot;$&#123;xuecheng.mq.queue&#125;&quot;) public String queue_cms_postpage_name; //routingKey 即站点Id @Value(&quot;$&#123;xuecheng.mq.routingKey&#125;&quot;) public String routingKey; /** * 交换机配置使用direct类型 * @return the exchange */ @Bean(EX_ROUTING_CMS_POSTPAGE) public Exchange EXCHANGE_TOPICS_INFORM() &#123; return ExchangeBuilder.directExchange(EX_ROUTING_CMS_POSTPAGE).durable(true).build(); &#125; //声明队列 @Bean(QUEUE_CMS_POSTPAGE) public Queue QUEUE_CMS_POSTPAGE() &#123; Queue queue = new Queue(queue_cms_postpage_name); return queue; &#125; /** * 绑定队列到交换机 * * @param queue the queue * @param exchange the exchange * @return the binding */ @Bean public Binding BINDING_QUEUE_INFORM_SMS(@Qualifier(QUEUE_CMS_POSTPAGE) Queue queue, @Qualifier(EX_ROUTING_CMS_POSTPAGE) Exchange exchange) &#123; return BindingBuilder.bind(queue).to(exchange).with(routingKey).noargs(); &#125;&#125; 1.2.4 定义消息格式消息内容采用json格式存储数据，如下： 页面id：发布页面的id 123&#123; &quot;pageId&quot;:&quot;&quot;&#125; 1.2.5 PageDao1、使用CmsPageRepository 查询页面信息 12public interface CmsPageRepository extends MongoRepository&lt;CmsPage,String&gt; &#123;｝ 2、使用CmsSiteRepository查询站点信息，主要获取站点物理路径 12public interface CmsSiteRepository extends MongoRepository&lt;CmsSite,String&gt; &#123;&#125; 1.2.6 PageService在Service中定义保存页面静态文件到服务器物理路径方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102package com.xuecheng.manage_cms_client.service;import com.mongodb.client.gridfs.GridFSBucket;import com.mongodb.client.gridfs.GridFSDownloadStream;import com.mongodb.client.gridfs.model.GridFSFile;import com.xuecheng.framework.domain.cms.CmsPage;import com.xuecheng.framework.domain.cms.CmsSite;import com.xuecheng.framework.domain.cms.response.CmsCode;import com.xuecheng.framework.exception.ExceptionCast;import com.xuecheng.manage_cms_client.dao.CmsPageRepository;import com.xuecheng.manage_cms_client.dao.CmsSiteRepository;import org.apache.commons.io.IOUtils;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.data.mongodb.core.query.Criteria;import org.springframework.data.mongodb.core.query.Query;import org.springframework.data.mongodb.gridfs.GridFsResource;import org.springframework.data.mongodb.gridfs.GridFsTemplate;import org.springframework.stereotype.Service;import java.io.*;import java.util.Optional;/** * @author Administrator * @version 1.0 **/@Servicepublic class PageService &#123; @Autowired CmsPageRepository cmsPageRepository; @Autowired CmsSiteRepository cmsSiteRepository; @Autowired GridFsTemplate gridFsTemplate; @Autowired GridFSBucket gridFSBucket; //将页面html保存到页面物理路径 public void savePageToServerPath(String pageId)&#123; Optional&lt;CmsPage&gt; optional = cmsPageRepository.findById(pageId); if(!optional.isPresent())&#123; ExceptionCast.cast(CmsCode.CMS_PAGE_NOTEXISTS); &#125; //取出页面物理路径 CmsPage cmsPage = optional.get(); //页面所属站点 CmsSite cmsSite = this.getCmsSiteById(cmsPage.getSiteId()); //页面物理路径 String pagePath = cmsSite.getSitePhysicalPath() + cmsPage.getPagePhysicalPath() + cmsPage.getPageName(); //查询页面静态文件 String htmlFileId = cmsPage.getHtmlFileId(); InputStream inputStream = this.getFileById(htmlFileId); if(inputStream == null)&#123; ExceptionCast.cast(CmsCode.CMS_GENERATEHTML_HTMLISNULL); &#125; FileOutputStream fileOutputStream = null; try &#123; fileOutputStream = new FileOutputStream(new File(pagePath)); //将文件内容保存到服务物理路径 IOUtils.copy(inputStream,fileOutputStream); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; try &#123; inputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; try &#123; fileOutputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; //根据文件id获取文件内容 public InputStream getFileById(String fileId)&#123; try &#123; GridFSFile gridFSFile = gridFsTemplate.findOne(Query.query(Criteria.where(&quot;_id&quot;).is(fileId))); GridFSDownloadStream gridFSDownloadStream = gridFSBucket.openDownloadStream(gridFSFile.getObjectId()); GridFsResource gridFsResource = new GridFsResource(gridFSFile,gridFSDownloadStream); return gridFsResource.getInputStream(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return null; &#125; //根据站点id得到站点 public CmsSite getCmsSiteById(String siteId)&#123; Optional&lt;CmsSite&gt; optional = cmsSiteRepository.findById(siteId); if(optional.isPresent())&#123; CmsSite cmsSite = optional.get(); return cmsSite; &#125; return null; &#125;&#125; 1.2.6ConsumerPostPage在cms client工程的mq包下创建ConsumerPostPage类，ConsumerPostPage作为发布页面的消费客户端，监听页面发布队列的消息，收到消息后从mongodb下载文件，保存在本地。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.xuecheng.manage_cms_client.mq;import com.alibaba.fastjson.JSON;import com.xuecheng.framework.domain.cms.CmsPage;import com.xuecheng.manage_cms_client.dao.CmsPageRepository;import com.xuecheng.manage_cms_client.service.PageService;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.amqp.rabbit.annotation.RabbitListener;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;import java.util.Map;import java.util.Optional;/** * @author Administrator * @version 1.0 **/@Componentpublic class ConsumerPostPage &#123; private static final Logger LOGGER = LoggerFactory.getLogger(ConsumerPostPage.class); @Autowired CmsPageRepository cmsPageRepository; @Autowired PageService pageService; @RabbitListener(queues=&#123;&quot;$&#123;xuecheng.mq.queue&#125;&quot;&#125;) public void postPage(String msg)&#123; //解析消息 Map map = JSON.parseObject(msg, Map.class); LOGGER.info(&quot;receive cms post page:&#123;&#125;&quot;,msg.toString()); //取出页面id String pageId = (String) map.get(&quot;pageId&quot;); //查询页面信息 Optional&lt;CmsPage&gt; optional = cmsPageRepository.findById(pageId); if(!optional.isPresent())&#123; LOGGER.error(&quot;receive cms post page,cmsPage is null:&#123;&#125;&quot;,msg.toString()); return ; &#125; //将页面保存到服务器物理路径 pageService.savePageToServerPath(pageId); &#125;&#125; 1.3 页面发布生产方1.3.1 需求分析管理员通过 cms系统发布“页面发布”的消费，cms系统作为页面发布的生产方。 需求如下： 1、管理员进入管理界面点击“页面发布”，前端请求cms页面发布接口。 2、cms页面发布接口执行页面静态化，并将静态化页面存储至GridFS中。 3、静态化成功后，向消息队列发送页面发布的消息。 1） 获取页面的信息及页面所属站点ID。 2） 设置消息内容为页面ID。（采用json格式，方便日后扩展） 3） 发送消息给ex_cms_postpage交换机，并将站点ID作为routingKey。 1.3.2 RabbitMQ配置1、配置Rabbitmq的连接参数 在application.yml添加如下配置： 1234567spring: rabbitmq: host: 127.0.0.1 port: 5672 username: guest password: guest virtualHost: / 2、在pom.xml添加依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;&lt;/dependency&gt; 3、RabbitMQConfig配置 由于cms作为页面发布方要面对很多不同站点的服务器，面对很多页面发布队列，所以这里不再配置队列，只需要配置交换机即可。 在cms工程只配置交换机名称即可。 123456789101112131415161718192021222324252627282930package com.xuecheng.manage_cms.config;import org.springframework.amqp.core.*;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;package com.xuecheng.manage_cms_client.config;import org.springframework.amqp.core.*;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configurationpublic class RabbitmqConfig &#123; //交换机的名称 public static final String EX_ROUTING_CMS_POSTPAGE=&quot;ex_routing_cms_postpage&quot;; /** * 交换机配置使用direct类型 * @return the exchange */ @Bean(EX_ROUTING_CMS_POSTPAGE) public Exchange EXCHANGE_TOPICS_INFORM() &#123; return ExchangeBuilder.directExchange(EX_ROUTING_CMS_POSTPAGE).durable(true).build(); &#125;&#125; 1.3.3 Api接口在api工程定义页面发布接口： 12@ApiOperation(&quot;发布页面&quot;)public ResponseResult post(String pageId); 1.3.4 PageService在PageService中定义页面发布方法，代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//页面发布public ResponseResult postPage(String pageId)&#123; //执行静态化 String pageHtml = this.getPageHtml(pageId); if(StringUtils.isEmpty(pageHtml))&#123; ExceptionCast.cast(CmsCode.CMS_GENERATEHTML_HTMLISNULL); &#125; //保存静态化文件 CmsPage cmsPage = saveHtml(pageId, pageHtml); //发送消息 sendPostPage(pageId); return new ResponseResult(CommonCode.SUCCESS);&#125;//发送页面发布消息private void sendPostPage(String pageId)&#123; CmsPage cmsPage = this.getById(pageId); if(cmsPage == null)&#123; ExceptionCast.cast(CmsCode.CMS_PAGE_NOTEXISTS); &#125; Map&lt;String,String&gt; msgMap = new HashMap&lt;&gt;(); msgMap.put(&quot;pageId&quot;,pageId); //消息内容 String msg = JSON.toJSONString(msgMap); //获取站点id作为routingKey String siteId = cmsPage.getSiteId(); //发布消息 this.rabbitTemplate.convertAndSend(RabbitmqConfig.EX_ROUTING_CMS_POSTPAGE,siteId, msg);&#125;//保存静态页面内容private CmsPage saveHtml(String pageId,String content)&#123; //查询页面 Optional&lt;CmsPage&gt; optional = cmsPageRepository.findById(pageId); if(!optional.isPresent())&#123; ExceptionCast.cast(CmsCode.CMS_PAGE_NOTEXISTS); &#125; CmsPage cmsPage = optional.get(); //存储之前先删除 String htmlFileId = cmsPage.getHtmlFileId(); if(StringUtils.isNotEmpty(htmlFileId))&#123; gridFsTemplate.delete(Query.query(Criteria.where(&quot;_id&quot;).is(htmlFileId))); &#125; //保存html文件到GridFS InputStream inputStream = IOUtils.toInputStream(content); ObjectId objectId = gridFsTemplate.store(inputStream, cmsPage.getPageName()); //文件id String fileId = objectId.toString(); //将文件id存储到cmspage中 cmsPage.setHtmlFileId(fileId); cmsPageRepository.save(cmsPage); return cmsPage;&#125; 1.3.5 CmsPageController编写Controller实现api接口，接收页面请求，调用service执行页面发布。 12345@Override@PostMapping(&quot;/postPage/&#123;pageId&#125;&quot;)public ResponseResult post(@PathVariable(&quot;pageId&quot;) String pageId) &#123; return pageService.postPage(pageId);&#125; 1.4 页面发布前端用户操作流程： 1、用户进入cms页面列表。 2、点击“发布”请求服务端接口，发布页面。 3、提示“发布成功”，或发布失败。 1.4.1 API方法在 cms前端添加 api方法。 1234/*发布页面*/export const page_postPage= id =&gt; &#123; return http.requestPost(apiUrl+&apos;/cms/page/postPage/&apos;+id)&#125; 1.4.2 页面修改page_list.vue，添加发布按钮 1234567&lt;el-table-column label=&quot;发布&quot; width=&quot;80&quot;&gt; &lt;template slot-scope=&quot;scope&quot;&gt; &lt;el-button size=&quot;small&quot; type=&quot;primary&quot; plain @click=&quot;postPage(scope.row.pageId)&quot;&gt;发布 &lt;/el-button&gt; &lt;/template&gt;&lt;/el-table-column&gt; 添加页面发布事件： 123456789101112131415postPage (id) &#123; this.$confirm(&apos;确认发布该页面吗?&apos;, &apos;提示&apos;, &#123; &#125;).then(() =&gt; &#123; cmsApi.page_postPage(id).then((res) =&gt; &#123; if(res.success)&#123; console.log(&apos;发布页面id=&apos;+id); this.$message.success(&apos;发布成功，请稍后查看结果&apos;); &#125;else&#123; this.$message.error(&apos;发布失败&apos;); &#125; &#125;); &#125;).catch(() =&gt; &#123; &#125;);&#125;, 1.5 测试这里测试轮播图页面修改、发布的流程： 1、修改轮播图页面模板或修改轮播图地址 注意：先修改页面原型，页面原型调试正常后再修改页面模板。 2、执行页面预览 3、执行页面发布，查看页面是否写到网站目录 4、刷新门户首页并观察轮播图是否变化。 1.6 思考1、如果发布到服务器的页面内容不正确怎么办？ 2、一个页面需要发布很多服务器，点击“发布”后如何知道详细的发布结果？ 3、一个页面发布到多个服务器，其中有一个服务器发布失败时怎么办？ 2 课程管理2.1 需求分析在线教育平台的课程信息相当于电商平台的商品。课程管理是后台管理功能中最重要的模块。本项目为教学机构提供课程管理功能，教学机构可以添加属于自己的课程，供学生在线学习。 课程管理包括如下功能需求： 1、分类管理 2、新增课程 3、修改课程 4、预览课程 5、发布课程 用户的操作流程如下： 1、进入我的课程 2、点击“添加课程”，进入添加课程界面 3、输入课程基本信息，点击提交 4、课程基本信息提交成功，自动进入“管理课程”界面，点击“管理课程”也可以进入“管理课程”界面 5、编辑图片 上传课程图片。 6、编辑课程营销信息 营销信息主要是设置课程的收费方式及价格。 7、编辑课程计划 添加课程计划： 2.2 教学方法本模块对课程信息管理功能的教学方法采用实战教学方法，旨在通过实战提高接口编写的能力，具体教学方法如下： 1、前后端工程导入 教学管理前端工程采用与系统管理工程相同的技术，直接导入后在此基础上开发。 课程管理服务端工程采用Spring Boot技术构建，技术层技术使用Spring data Jpa（与Spring data Mongodb类似）、Mybatis，直接导入后在此基础上开发。 2、课程计划功能 课程计划功能采用全程教学。 3、我的课程、新增课程、修改课程、课程营销 我的课程、新增课程、修改课程、课程营销四个功能采用实战方式，课堂上会讲解每个功能的需求及技术点，讲解完成学生开始实战，由导师进行技术指导。 4、参考文档 实战结束提供每个功能的开发文档，学生参考文档并修正功能缺陷。 2.3 环境搭建2.3.1 搭建数据库环境1) 创建数据库 课程管理使用MySQL数据库，创建课程管理数据库：xc_course。 导入xc_course.sql脚本 2) 数据表介绍 课程信息内容繁多，将课程信息分类保存在如下表中： 数据表结构如下： 2.3.2导入课程管理服务工程1）持久层技术介绍： 课程管理服务使用MySQL数据库存储课程信息，持久层技术如下： 1、spring data jpa：用于表的基本CRUD。 2、mybatis：用于复杂的查询操作。 3、druid：使用阿里巴巴提供的spring boot 整合druid包druid-spring-boot-starter管理连接池。 druid-spring-boot-starter地址：https://github.com/alibaba/druid/tree/master/druid-spring-boot-starter 2）导入工程 导入资料下的“xc-service-manage-course.zip”。 2.3.3 导入课程管理前端工程​ 课程管理属于教学管理子系统的功能，使用用户为教学机构的管理人员和老师，为保证系统的可维护性，单独创建一个教学管理前端工程。 教学管理前端工程与系统管理前端的工程结构一样，也采用vue.js框架来实现。 从课程资料目录拷贝xc-ui-pc-teach.zip到工程，使用webstorm打开，启动工程： 效果图如下： 3 课程计划3.1 需求分析什么是课程计划？ 课程计划定义了课程的章节内容，学生通过课程计划进行在线学习，下图中右侧显示的就是课程计划。 课程计划包括两级，第一级是课程的大章节、第二级是大章节下属的小章节，每个小章节通常是一段视频，学生点击小章节在线学习。 教学管理人员对课程计划如何管理？ 功能包括：添加课程计划、删除课程计划、修改课程计划等。 3.2 课程计划查询3.2.1需求分析课程计划查询是将某个课程的课程计划内容完整的显示出来，如下图所示： 左侧显示的就是课程计划，课程计划是一个树型结构，方便扩展课程计划的级别。 在上边页面中，点击“添加课程计划”即可对课程计划进行添加操作。 点击修改可对某个章节内容进行修改。 点击删除可删除某个章节。 3.2.2 页面原型3.2.2.1 tree组件介绍本功能使用element-ui 的tree组件来完成 在course_plan.vue文件中添加tree组件的代码，进行测试： 1、组件标签 12345678&lt;el-tree :data=&quot;data&quot; show-checkbox node-key=&quot;id&quot; default-expand-all :expand-on-click-node=&quot;false&quot; :render-content=&quot;renderContent&quot;&gt; &lt;/el-tree&gt; 2、数据对象 1234567891011121314151617181920212223let id = 1000; export default &#123; data() &#123; return &#123; data : [&#123; id: 1, label: &apos;一级 1&apos;, children: [&#123; id: 4, label: &apos;二级 1-1&apos;, children: [&#123; id: 9, label: &apos;三级 1-1-1&apos; &#125;, &#123; id: 10, label: &apos;三级 1-1-2&apos; &#125;] &#125;] &#125;] &#125; &#125; &#125; 3.2.2.2 webstorm配置JSX​ 本组件用到了JSX语法，如下所示： ​ JSX 是Javascript和XML结合的一种格式，它是React的核心组成部分，JSX和XML语法类似，可以定义属性以及子元素。唯一特殊的是可以用大括号来加入JavaScript表达式。遇到 HTML 标签（以 &lt; 开头），就用 HTML 规则解析；遇到代码块（以 { 开头），就用 JavaScript 规则解析。 下面是官方的一个例子： 设置方法 如下： 1、Javascript version 选择 React JSX （如果没有就选择JSX Harmony） 2、HTML 类型文件中增加vue preferences -&gt; Editor -&gt; File Types 中找到上边框中HTML 在下边加一个 *.vue 如果已经在vue template 中已存在.vue 则把它改为.vue2(因为要在Html中添加.vue) 3.2.3 API接口3.2.3.1 数据模型1、表结构 2、模型类 课程计划为树型结构，由树根（课程）和树枝（章节）组成，为了保证系统的可扩展性，在系统设计时将课程计划设置为树型结构。 1234567891011121314151617181920212223@Data@ToString@Entity@Table(name=&quot;teachplan&quot;)@GenericGenerator(name = &quot;jpa-uuid&quot;, strategy = &quot;uuid&quot;)public class Teachplan implements Serializable &#123; private static final long serialVersionUID = -916357110051689485L; @Id @GeneratedValue(generator = &quot;jpa-uuid&quot;) @Column(length = 32) private String id; private String pname; private String parentid; private String grade; private String ptype; private String description; private String courseid; private String status; private Integer orderby; private Double timelength; private String trylearn;&#125; 3.2.3.2 自定义模型类前端页面需要树型结构的数据来展示Tree组件，如下： 12345678[&#123; id: 1, label: &apos;一级 1&apos;, children: [&#123; id: 4, label: &apos;二级 1-1&apos; &#125;] &#125;] 自定义课程计划结点类如下： 12345@Data@ToStringpublic class TeachplanNode extends Teachplan &#123; List&lt;TeachplanNode&gt; children;&#125; 3.2.3.3 接口定义根据课程id查询课程的计划接口如下，在api工程创建course包，创建CourseControllerApi接口类并定义接口方法如下： 1234public interface CourseControllerApi &#123; @ApiOperation(&quot;课程计划查询&quot;) public TeachplanNode findTeachplanList(String courseId);&#125; 3.2.3 课程管理服务3.2.3.1 Sql课程计划是树型结构，采用表的自连接方式进行查询，sql语句如下： 123456789101112131415161718SELECT a.id one_id, a.pname one_pname, b.id two_id, b.pname two_pname, c.id three_id, c.pname three_pname FROM teachplan a LEFT JOIN teachplan b ON a.id = b.parentid LEFT JOIN teachplan c ON b.id = c.parentid WHERE a.parentid = &apos;0&apos; AND a.courseid = &apos;402885816243d2dd016243f24c030002&apos; ORDER BY a.orderby, b.orderby, c.orderby 3.2.3.2 Dao1) mapper接口 1234@Mapperpublic interface TeachplanMapper &#123; public TeachplanNode selectList(String courseId);&#125; 2）mapper映射文件 12345678910111213141516171819202122232425262728293031323334353637&lt;resultMap type=&quot;com.xuecheng.framework.domain.course.ext.TeachplanNode&quot; id=&quot;teachplanMap&quot; &gt; &lt;id property=&quot;id&quot; column=&quot;one_id&quot;/&gt; &lt;result property=&quot;pname&quot; column=&quot;one_name&quot;/&gt; &lt;collection property=&quot;children&quot; ofType=&quot;com.xuecheng.framework.domain.course.ext.TeachplanNode&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;two_id&quot;/&gt; &lt;result property=&quot;pname&quot; column=&quot;two_name&quot;/&gt; &lt;collection property=&quot;children&quot; ofType=&quot;com.xuecheng.framework.domain.course.ext.TeachplanNode&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;three_id&quot;/&gt; &lt;result property=&quot;pname&quot; column=&quot;three_name&quot;/&gt; &lt;/collection&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;select id=&quot;selectList&quot; resultMap=&quot;teachplanMap&quot; parameterType=&quot;java.lang.String&quot; &gt; SELECT a.id one_id, a.pname one_name, b.id two_id, b.pname two_name, c.id three_id, c.pname three_name FROM teachplan a LEFT JOIN teachplan b ON a.id = b.parentid LEFT JOIN teachplan c ON b.id = c.parentid WHERE a.parentid = &apos;0&apos; &lt;if test=&quot;_parameter!=null and _parameter!=&apos;&apos;&quot;&gt; and a.courseid=#&#123;courseId&#125; &lt;/if&gt; ORDER BY a.orderby, b.orderby, c.orderby&lt;/select&gt; 说明：针对输入参数为简单类型#{}中可以是任意类型，判断参数是否为空要用 _parameter（它属于mybatis的内置参数） 3.4.3.3 Service创建CourseService类，定义查询课程计划方法。 12345678910@Servicepublic class CourseService &#123; @Autowired TeachplanMapper teachplanMapper; //查询课程计划 public TeachplanNode findTeachplanList(String courseId)&#123; TeachplanNode teachplanNode = teachplanMapper.selectList(courseId); return teachplanNode; &#125;&#125; 3.4.3.4 Controller12345678910111213@RestController@RequestMapping(&quot;/course&quot;)public class CourseController implements CourseControllerApi &#123; @Autowired CourseService courseService; //查询课程计划 @Override @GetMapping(&quot;/teachplan/list/&#123;courseId&#125;&quot;) public TeachplanNode findTeachplanList(String courseId) &#123; return courseService.findTeachplanList(courseId); &#125;&#125; 3.4.3.5 测试使用postman或swagger-ui测试查询接口。 Get 请求：http://localhost:31200/course/teachplan/list/402885816243d2dd016243f24c030002 3.2.4 前端页面3.2.4.1Api方法定义课程计划查询的api方法： 1234/*查询课程计划*/export const findTeachplanList = courseid =&gt; &#123; return http.requestQuickGet(apiUrl+&apos;/course/teachplan/list/&apos;+courseid)&#125; 3.2.4.2Api调用1、在mounted钩子方法 中查询 课程计划 定义查询课程计划的方法，赋值给数据对象teachplanList 1234567findTeachplan()&#123; courseApi.findTeachplanList(this.courseid).then((res) =&gt; &#123; this.teachplanList = [];//清空树 if(res.children)&#123; this.teachplanList = res.children; &#125; &#125;); 2）在mounted钩子中查询课程计划 123456mounted()&#123; //课程id this.courseid = this.$route.params.courseid; //课程计划 this.findTeachplan();&#125; 3）修改树结点的标签属性 课程计划信息中pname为结点的名称，需要修改树结点的标签属性方可正常显示课程计划名称，如下： 1234defaultProps: &#123; children: &apos;children&apos;, label: &apos;pname&apos;&#125; 3.2.4.3 测试 3.3 添加课程计划3.3.1 需求分析用户操作流程： 1、进入课程计划页面，点击“添加课程计划” 2、打开添加课程计划页面，输入课程计划信息 上级结点说明： 不选择上级结点表示当前添加的课程计划的父结点为课程的根结点。 当添加该课程时，在课程计划中还没有节点的时候要自动添加该课程的根结点。 3、点击提交。 3.3.1.1 页面原型说明添加课程计划采用弹出窗口组件Dialog。 1、视图部分 在course_plan.vue页面添加添加课程计划的弹出窗口代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;el-dialog title=&quot;添加课程计划&quot; :visible.sync=&quot;teachplayFormVisible&quot; &gt; &lt;el-form ref=&quot;teachplayForm&quot; :model=&quot;teachplanActive&quot; label-width=&quot;140px&quot; style=&quot;width:600px;&quot; :rules=&quot;teachplanRules&quot; &gt; &lt;el-form-item label=&quot;上级结点&quot; &gt; &lt;el-select v-model=&quot;teachplanActive.parentid&quot; placeholder=&quot;不填表示根结点&quot;&gt; &lt;el-option v-for=&quot;item in teachplanList&quot; :key=&quot;item.id&quot; :label=&quot;item.pname&quot; :value=&quot;item.id&quot;&gt; &lt;/el-option&gt; &lt;/el-select&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;章节/课时名称&quot; prop=&quot;pname&quot;&gt; &lt;el-input v-model=&quot;teachplanActive.pname&quot; auto-complete=&quot;off&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;课程类型&quot; &gt; &lt;el-radio-group v-model=&quot;teachplanActive.ptype&quot;&gt; &lt;el-radio class=&quot;radio&quot; label=&apos;1&apos;&gt;视频&lt;/el-radio&gt; &lt;el-radio class=&quot;radio&quot; label=&apos;2&apos;&gt;文档&lt;/el-radio&gt; &lt;/el-radio-group&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;学习时长（分钟） 请输入数字&quot; &gt; &lt;el-input type=&quot;number&quot; v-model=&quot;teachplanActive.timelength&quot; auto-complete=&quot;off&quot; &gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;排序字段&quot; &gt; &lt;el-input v-model=&quot;teachplanActive.orderby&quot; auto-complete=&quot;off&quot; &gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;章节/课时介绍&quot; prop=&quot;description&quot;&gt; &lt;el-input type=&quot;textarea&quot; v-model=&quot;teachplanActive.description&quot; &gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=&quot;状态&quot; prop=&quot;status&quot;&gt; &lt;el-radio-group v-model=&quot;teachplanActive.status&quot; &gt; &lt;el-radio class=&quot;radio&quot; label=&quot;0&quot; &gt;未发布&lt;/el-radio&gt; &lt;el-radio class=&quot;radio&quot; label=&apos;1&apos;&gt;已发布&lt;/el-radio&gt; &lt;/el-radio-group&gt; &lt;/el-form-item&gt; &lt;el-form-item &gt; &lt;el-button type=&quot;primary&quot; v-on:click=&quot;addTeachplan&quot;&gt;提交&lt;/el-button&gt; &lt;el-button type=&quot;primary&quot; v-on:click=&quot;resetForm&quot;&gt;重置&lt;/el-button&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;/el-dialog&gt; 2、数据模型 在数据模型中添加如下变量： 1234567891011在数据对象中添加： teachplayFormVisible:false, teachplanRules: &#123; pname: [ &#123;required: true, message: &apos;请输入课程计划名称&apos;, trigger: &apos;blur&apos;&#125; ], status: [ &#123;required: true, message: &apos;请选择状态&apos;, trigger: &apos;blur&apos;&#125; ] &#125;, teachplanActive:&#123;&#125;, 3、 添加按钮 通过变量teachplayFormVisible控制弹出窗口是否显示。 1&lt;el-button type=&quot;primary&quot; @click=&quot;teachplayFormVisible = true&quot;&gt;添加课程计划&lt;/el-button&gt; 4、定义表单提交方法和重置方法 12345678//提交课程计划addTeachplan()&#123; alert()&#125;,//重置表单resetForm()&#123; this.teachplanActive = &#123;&#125;&#125;, 3.3.3 API接口1）添加课程计划 12@ApiOperation(&quot;添加课程计划&quot;)public ResponseResult addTeachplan(Teachplan teachplan); 3.3.4 课程管理服务3.3.3.1 Dao1234public interface TeachplanRepository extends JpaRepository&lt;Teachplan, String&gt; &#123; //定义方法根据课程id和父结点id查询出结点列表，可以使用此方法实现查询根结点 public List&lt;Teachplan&gt; findByCourseidAndParentid(String courseId,String parentId);&#125; 3.3.3.2 Service12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//获取课程根结点，如果没有则添加根结点 public String getTeachplanRoot(String courseId)&#123; //校验课程id Optional&lt;CourseBase&gt; optional = courseBaseRepository.findById(courseId); if(!optional.isPresent())&#123; return null; &#125; CourseBase courseBase = optional.get(); //取出课程计划根结点 List&lt;Teachplan&gt; teachplanList = teachplanRepository.findByCourseidAndParentid(courseId, &quot;0&quot;); if(teachplanList == null || teachplanList.size()==0)&#123; //新增一个根结点 Teachplan teachplanRoot = new Teachplan(); teachplanRoot.setCourseid(courseId); teachplanRoot.setPname(courseBase.getName()); teachplanRoot.setParentid(&quot;0&quot;); teachplanRoot.setGrade(&quot;1&quot;);//1级 teachplanRoot.setStatus(&quot;0&quot;);//未发布 teachplanRepository.save(teachplanRoot); return teachplanRoot.getId(); &#125; Teachplan teachplan = teachplanList.get(0); return teachplan.getId(); &#125; //添加课程计划 @Transactional public ResponseResult addTeachplan(Teachplan teachplan)&#123; //校验课程id和课程计划名称 if(teachplan == null || StringUtils.isEmpty(teachplan.getCourseid()) || StringUtils.isEmpty(teachplan.getPname()))&#123; ExceptionCast.cast(CommonCode.INVALIDPARAM); &#125; //取出课程id String courseid = teachplan.getCourseid(); //取出父结点id String parentid = teachplan.getParentid(); if(StringUtils.isEmpty(parentid))&#123; //如果父结点为空则获取根结点 parentid= getTeachplanRoot(courseid); &#125; //取出父结点信息 Optional&lt;Teachplan&gt; teachplanOptional = teachplanRepository.findById(parentid); if(!teachplanOptional.isPresent())&#123; ExceptionCast.cast(CommonCode.INVALIDPARAM); &#125; //父结点 Teachplan teachplanParent = teachplanOptional.get(); //父结点级别 String parentGrade = teachplanParent.getGrade(); //设置父结点 teachplan.setParentid(parentid); teachplan.setStatus(&quot;0&quot;);//未发布 //子结点的级别，根据父结点来判断 if(parentGrade.equals(&quot;1&quot;))&#123; teachplan.setGrade(&quot;2&quot;); &#125;else if(parentGrade.equals(&quot;2&quot;))&#123; teachplan.setGrade(&quot;3&quot;); &#125; //设置课程id teachplan.setCourseid(teachplanParent.getCourseid()); teachplanRepository.save(teachplan); return new ResponseResult(CommonCode.SUCCESS); &#125; 3.3.3.3 controller123456//添加课程计划@Override@PostMapping(&quot;/teachplan/add&quot;)public ResponseResult addTeachplan(@RequestBody Teachplan teachplan) &#123; return courseService.addTeachplan(teachplan);&#125; 3.3.3.4 测试复杂一些的业务逻辑建议写完服务端代码就进行单元测试。 使用swagger-ui或postman测试上边的课程计划添加接口。 3.3.5前端3.3.5.1 Api调用1、定义 api方法 1234/*添加课程计划*/export const addTeachplan = teachplah =&gt; &#123; return http.requestPost(apiUrl+&apos;/course/teachplan/add&apos;,teachplah)&#125; 2、调用 api 1234567891011121314151617181920addTeachplan()&#123; this.$refs.teachplayForm.validate((valid) =&gt; &#123; if (valid) &#123; //添加课程计划时带上课程id this.teachplanActive.courseid = this.courseid; courseApi.addTeachplan(this.teachplanActive).then((res) =&gt; &#123; if(res.success)&#123; this.$message.success(&apos;提交成功&apos;); //清空表单 this.teachplanActive = &#123;&#125; //刷新整个树 this.findTeachplan(); &#125;else&#123; this.$message.error(&apos;提交失败&apos;); &#125; &#125;); &#125; &#125;)&#125;, 3.3.5 测试测试流程： 1、新建一个课程 2、向新建课程中添加课程计划 ​ 添加一级结点 ​ 添加二级结点]]></content>
      <categories>
        <category>项目实战-在线学习视频网站</category>
        <category>RabbitMQ</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在线学习视频（十八）—— 用户认证 Zuul]]></title>
    <url>%2Fday17%20%E7%94%A8%E6%88%B7%E8%AE%A4%E8%AF%81%20Zuul.html</url>
    <content type="text"><![CDATA[用户认证 Zuul1 用户认证1.1 用户认证流程分析用户认证流程如下： 业务流程说明如下： 1、客户端请求认证服务进行认证。 2、认证服务认证通过向浏览器cookie写入token(身份令牌) 认证服务请求用户中心查询用户信息。 认证服务请求Spring Security申请令牌。 认证服务将token(身份令牌)和jwt令牌存储至redis中。 认证服务向cookie写入 token(身份令牌)。 3、前端携带token请求认证服务获取jwt令牌 前端获取到jwt令牌并存储在sessionStorage。 前端从jwt令牌中解析中用户信息并显示在页面。 4、前端携带cookie中的token身份令牌及jwt令牌访问资源服务 前端请求资源服务需要携带两个token，一个是cookie中的身份令牌，一个是http header中的jwt令牌 前端请求资源服务前在http header上添加jwt请求资源 5、网关校验token的合法性 用户请求必须携带token身份令牌和jwt令牌 网关校验redis中token是否合法，已过期则要求用户重新登录 6、资源服务校验jwt的合法性并完成授权 资源服务校验jwt令牌，完成授权，拥有权限的方法正常执行，没有权限的方法将拒绝访问。 1.2 认证服务查询数据库1.2.1 需求分析认证服务根据数据库中的用户信息去校验用户的身份，即校验账号和密码是否匹配。 认证服务不直接连接数据库，而是通过用户中心服务去查询用户中心数据库。 完整的流程图如下： 1.2.2 搭建环境1.2.2.1 创建用户中心数据库用户中心负责用户管理，包括：用户信息管理、角色管理、权限管理等。 创建xc_user数据库（MySQL） 导入xc_user.sql(已导入不用重复导入) 1.2.2.2 创建用户中心工程导入“资料”-》xc-service-ucenter.zip 1.2.4 查询用户接口完成用户中心根据账号查询用户信息接口功能。 1.2.4.1 Api接口用户中心对外提供如下接口： 1、响应数据类型 此接口将来被用来查询用户信息及用户权限信息，所以这里定义扩展类型 12345678@Data@ToStringpublic class XcUserExt extends XcUser &#123; //权限信息 private List&lt;XcMenu&gt; permissions; //企业信息 private String companyId;&#125; 2、根据账号查询用户信息 1234@Api(value = &quot;用户中心&quot;,description = &quot;用户中心管理&quot;)public interface UcenterControllerApi &#123; public XcUserExt getUserext(String username);&#125; 1.2.4.2 DAO添加XcUser、XcCompantUser两个表的Dao 1234567public interface XcUserRepository extends JpaRepository&lt;XcUser, String&gt; &#123; XcUser findXcUserByUsername(String username);&#125;public interface XcCompanyUserRepository extends JpaRepository&lt;XcCompanyUser,String&gt; &#123; //根据用户id查询所属企业id XcCompanyUser findByUserId(String userId);&#125; 1.2.4.2 Service1234567891011121314151617181920212223242526272829@Servicepublic class UserService &#123; @Autowired private XcUserRepository xcUserRepository; //根据用户账号查询用户信息 public XcUser findXcUserByUsername(String username)&#123; return xcUserRepository.findXcUserByUsername(username); &#125; //根据账号查询用户的信息，返回用户扩展信息 public XcUserExt getUserExt(String username)&#123; XcUser xcUser = this.findXcUserByUsername(username); if(xcUser == null)&#123; return null; &#125; XcUserExt xcUserExt = new XcUserExt(); BeanUtils.copyProperties(xcUser,xcUserExt); //用户id String userId = xcUserExt.getId(); //查询用户所属公司 XcCompanyUser xcCompanyUser = xcCompanyUserRepository.findXcCompanyUserByUserId(userId); if(xcCompanyUser!=null)&#123; String companyId = xcCompanyUser.getCompanyId(); xcUserExt.setCompanyId(companyId); &#125; return xcUserExt; &#125;&#125; 1.2.4.3 Controller12345678910111213@RestController@RequestMapping(&quot;/ucenter&quot;)public class UcenterController implements UcenterControllerApi &#123; @Autowired UserService userService; @Override @GetMapping(&quot;/getuserext&quot;) public XcUserExt getUserext(@RequestParam(&quot;username&quot;) String username) &#123; XcUserExt xcUser = userService.getUserExt(username); return xcUser; &#125; &#125; 1.2.4.4 测试使用Swagger-ui或postman测试用户信息查询接口 1.2.5 调用查询用户接口1.2.5.1 创建client认证服务需要远程调用用户中心服务查询用户，在认证服务中创建Feign客户端 12345@FeignClient(value = XcServiceList.XC_SERVICE_UCENTER)public interface UserClient &#123; @GetMapping(&quot;/ucenter/getuserext&quot;) public XcUserExt getUserext(@RequestParam(&quot;username&quot;) String username)&#125; 1.2.5.2 UserDetailsServiceImpl​ 认证服务调用spring security接口申请令牌，spring security接口会调用UserDetailsServiceImpl从数据库查询用户，如果查询不到则返回 NULL，表示不存在；在UserDetailsServiceImpl中将正确的密码返回， spring security会自动去比对输入密码的正确性。 1、修改UserDetailsServiceImpl的loadUserByUsername方法，调用Ucenter服务的查询用户接口 123456789101112131415161718192021222324252627282930313233343536373839404142434445@Servicepublic class UserDetailsServiceImpl implements UserDetailsService &#123; @Autowired UserClient userClient; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123; //取出身份，如果身份为空说明没有认证 Authentication authentication = SecurityContextHolder.getContext().getAuthentication(); //没有认证统一采用httpbasic认证，httpbasic中存储了client_id和client_secret，开始认证client_id和client_secret if(authentication==null)&#123; ClientDetails clientDetails = clientDetailsService.loadClientByClientId(username); if(clientDetails!=null)&#123; //密码 String clientSecret = clientDetails.getClientSecret(); return new User(username,clientSecret,AuthorityUtils.commaSeparatedStringToAuthorityList(&quot;&quot;)); &#125; &#125; if (StringUtils.isEmpty(username)) &#123; return null; &#125; //请求ucenter查询用户 XcUserExt userext = userClient.getUserext(username); if(userext == null)&#123; //返回NULL表示用户不存在，Spring Security会抛出异常 return null; &#125; //从数据库查询用户正确的密码，Spring Security会去比对输入密码的正确性 String password = userext.getPassword(); String user_permission_string = &quot;&quot;; UserJwt userDetails = new UserJwt(username, password, AuthorityUtils.commaSeparatedStringToAuthorityList(user_permission_string)); //用户id userDetails.setId(userext.getId()); //用户名称 userDetails.setName(userext.getName()); //用户头像 userDetails.setUserpic(userext.getUserpic()); //用户所属企业id userDetails.setCompanyId(userext.getCompanyId()); return userDetails; &#125;&#125; 2、测试，请求http://localhost:40400/auth/userlogin 观察UserDetailsServiceImpl是否正常请求Ucenter的查询用户接口。 1.2.5.3 BCryptPasswordEncoder​ 早期使用md5对密码进行编码，每次算出的md5值都一样，这样非常不安全，Spring Security推荐使用 BCryptPasswordEncoder对密码加随机盐，每次的Hash值都不一样，安全性高。 1、BCryptPasswordEncoder测试程序如下 12345678910111213@Testpublic void testPasswrodEncoder()&#123; String password = &quot;111111&quot;; PasswordEncoder passwordEncoder = new BCryptPasswordEncoder(); for(int i=0;i&lt;10;i++) &#123; //每个计算出的Hash值都不一样 String hashPass = passwordEncoder.encode(password); System.out.println(hashPass); //虽然每次计算的密码Hash值不一样但是校验是通过的 boolean f = passwordEncoder.matches(password, hashPass); System.out.println(f); &#125;&#125; 2、在AuthorizationServerConfig配置类中配置BCryptPasswordEncoder 12345//采用bcrypt对密码进行Hash@Beanpublic PasswordEncoder passwordEncoder() &#123; return new BCryptPasswordEncoder();&#125; 3、测试 请求http://localhost:40400/auth/userlogin，输入正常的账号和密码进行测试 1.2.5.4 解析申请令牌错误信息当账号输入错误应该返回用户不存在的信息，当密码错误要返回用户名或密码错误信息，业务流程图如下： 修改申请令牌的程序解析返回的错误: 由于restTemplate收到400或401的错误会抛出异常，而spring security针对账号不存在及密码错误会返回400及401，所以在代码中控制针对400或401的响应不要抛出异常。 123456789101112131415161718192021222324252627282930313233343536373839Map map = null;try &#123; ((RestTemplate) restTemplate).setErrorHandler(new DefaultResponseErrorHandler() &#123; @Override public void handleError(ClientHttpResponse response) throws IOException &#123; // 设置 当响应400和401时照常响应数据，不要报错 if (response.getRawStatusCode() != 400 &amp;&amp; response.getRawStatusCode() != 401 ) &#123; super.handleError(response); &#125; &#125; &#125;); //http请求spring security的申请令牌接口 ResponseEntity&lt;Map&gt; mapResponseEntity = restTemplate.exchange(path, HttpMethod.POST, new HttpEntity&lt;MultiValueMap&lt;String, String&gt;&gt;(formData, header), Map.class); map = mapResponseEntity.getBody();&#125; catch (Exception e) &#123; e.printStackTrace(); LOGGER.error(&quot;request oauth_token_password error: &#123;&#125;&quot;,e.getMessage()); e.printStackTrace(); ExceptionCast.cast(AuthCode.AUTH_LOGIN_APPLYTOKEN_FAIL);&#125;if(map == null || map.get(&quot;access_token&quot;) == null || map.get(&quot;refresh_token&quot;) == null || map.get(&quot;jti&quot;) == null)&#123;//jti是jwt令牌的唯一标识作为用户身份令牌 //获取spring security返回的错误信息 String error_description = (String) map.get(&quot;error_description&quot;); if(StringUtils.isNotEmpty(error_description))&#123; if(error_description.equals(&quot;坏的凭证&quot;))&#123; ExceptionCast.cast(AuthCode.AUTH_CREDENTIAL_ERROR); &#125;else if(error_description.indexOf(&quot;UserDetailsService returned null&quot;)&gt;=0)&#123; ExceptionCast.cast(AuthCode.AUTH_ACCOUNT_NOTEXISTS); &#125; &#125; ExceptionCast.cast(AuthCode.AUTH_LOGIN_APPLYTOKEN_FAIL);&#125; 用户不存在： 密码错误： 1.2.5.5 测试使用postman请求http://localhost:40400/auth/userlogin 1、输入正确的账号和密码进行测试 从数据库找到测试账号，本课程所提供的用户信息初始密码统一为111111 2、输入错误的账号和密码进行测试 1.3 用户登录前端1.3.1 需求分析点击用户登录固定跳转到用户中心前端的登录页面，如下： 输入账号和密码，登录成功，跳转到首页。 用户中心前端（xc-ui-pc-learning工程）提供登录页面，所有子系统连接到此页面。 说明： 页面有“登录|注册”链接的前端系统有：门户系统、搜索系统、用户中心。 本小节修改门户系统的页头，其它三处可参考门户修改。 1.3.2 Api方法进入xc-ui-pc-learning工程定义api方法，在base模块下定义login.js。 1234567/*登陆*/export const login = params =&gt; &#123; //let loginRequest = querystring.stringify(params) let loginRequest = qs.stringify(params); return http.requestPostForm(&apos;/openapi/auth/userlogin&apos;,loginRequest);&#125; 1.3.3 页面1、登录页面 进入用户中心前端，找到登录页面loginpage.vue： loginpage.vue使用了loginForm.vue组件，loginForm.vue页面包括了登录表单 2、路由配置 在home模块配置路由： 1234567891011121314151617import Home from &apos;@/module/home/page/home.vue&apos;;import Login from &apos;@/module/home/page/loginpage.vue&apos;;import Denied from &apos;@/module/home/page/denied.vue&apos;;import Logout from &apos;@/module/home/page/logout.vue&apos;;import order_pay from &apos;@/module/order/page/order_pay.vue&apos;;export default [&#123; path: &apos;/&apos;, component: Home, name: &apos;个人中心&apos;, hidden: true &#125;, &#123; path: &apos;/login&apos;, component: Login, name: &apos;Login&apos;, hidden: true &#125;, 3、登录后跳转 请求登录页面需携带returnUrl参数，要求此参数使用Base64编码。 登录成功后将跳转到returnUrl，loginForm.vue组件的登录方法如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243login: function () &#123; this.$refs.loginForm.validate((valid) =&gt; &#123; if (valid) &#123; this.editLoading = true; let para = Object.assign(&#123;&#125;, this.loginForm); loginApi.login(para).then((res) =&gt; &#123; this.editLoading = false; if(res.success)&#123; this.$message(&apos;登陆成功&apos;); //刷新 当前页面 // alert(this.returnUrl) console.log(this.returnUrl) if(this.returnUrl!=&apos;undefined&apos; &amp;&amp; this.returnUrl!=&apos;&apos; &amp;&amp; !this.returnUrl.includes(&quot;/userlogout&quot;) &amp;&amp; !this.returnUrl.includes(&quot;/userlogin&quot;))&#123; window.location.href = this.returnUrl; &#125;else&#123; //跳转到首页 window.location.href = &apos;http://www.xuecheng.com/&apos; &#125; &#125;else&#123; if(res.message)&#123; this.$message.error(res.message); &#125;else&#123; this.$message.error(&apos;登陆失败&apos;); &#125; &#125; &#125;, (res) =&gt; &#123; this.editLoading = false; &#125;); &#125; &#125;);&#125;, 1.3.5 点击登录页面在门户的页头点击“登录|注册”连接到用户中心的登录页面，并且携带returnUrl。 修改门户的header.html，代码如下： 123456&lt;a href=&quot;javascript:;&quot; @click=&quot;showlogin&quot; v-if=&quot;logined == false&quot;&gt;登陆&amp;nbsp;|&amp;nbsp;注册&lt;/a&gt;showlogin: function()&#123; //this.loginFormVisible = true; window.location = &quot;http://ucenter.xuecheng.com/#/login?returnUrl=&quot;+ Base64.encode(window.location)&#125; 1.3.6测试测试之前修改认证服务的配置： 修改 application.yml中cookie域名 1cookieDomain: xuecheng.com 测试流程如下： 1、输入&lt;www.xuecheng.com&gt;进入系统（需要在hosts文件配置） 1、输入正确的账号和密码，提交 2、输入错误的账号和密码，提交 登录成功，观察cookie是否存储成功： 2 前端显示当前用户2.1 需求分析用户登录成功在页头显示当前登录的用户名称。 数据流程如下图： 1、用户请求认证服务，登录成功。 2、用户登录成功，认证服务向cookie写入身份令牌，向redis写入user_token（身份令牌及授权jwt授权令牌） 3、客户端携带cookie中的身份令牌请求认证服务获取jwt令牌。 4、客户端解析jwt令牌，并将解析的用户信息存储到sessionStorage中。 jwt令牌中包括了用户的基本信息，客户端解析jwt令牌即可获取用户信息。 5、客户端从sessionStorage中读取用户信息，并在页头显示。 sessionStorage ： ​ sessionStorage 是H5的一个会话存储对象，在SessionStorage中保存的数据只在同一窗口或同一标签页中有效，在关闭窗口之后将会删除SessionStorage中的数据。 ​ seesionStorage的存储方式采用key/value的方式，可保存5M左右的数据（不同的浏览器会有区别）。 2.2 jwt查询接口2.2.1 需求分析认证服务对外提供jwt查询接口，流程如下： 1、客户端携带cookie中的身份令牌请求认证服务获取jwt 2、认证服务根据身份令牌从redis中查询jwt令牌并返回给客户端。 2.2.2 API在认证模块定义 jwt查询接口： 12345@Api(value = &quot;jwt查询接口&quot;,description = &quot;客户端查询jwt令牌内容&quot;)public interface AuthControllerApi &#123; @ApiOperation(&quot;查询userjwt令牌&quot;) public JwtResult userjwt(); 2.2.3 Dao无 2.2.4 Service在AuthService中定义方法如下： 12345678910111213141516//从redis查询令牌 public AuthToken getUserToken(String token)&#123; String userToken = &quot;user_token:&quot;+token; String userTokenString = stringRedisTemplate.opsForValue().get(userToken); if(userToken!=null)&#123; AuthToken authToken = null; try &#123; authToken = JSON.parseObject(userTokenString, AuthToken.class); &#125; catch (Exception e) &#123; LOGGER.error(&quot;getUserToken from redis and execute JSON.parseObject error &#123;&#125;&quot;,e.getMessage()); e.printStackTrace(); &#125; return authToken; &#125; return null; &#125; 2.2.5 Controller12345678910111213141516171819@Override@GetMapping(&quot;/userjwt&quot;)public JwtResult userjwt() &#123; //获取cookie中的令牌 String access_token = getTokenFormCookie(); //根据令牌从redis查询jwt AuthToken authToken = authService.getUserToken(access_token); if(authToken == null)&#123; return new JwtResult(CommonCode.FAIL,null); &#125; return new JwtResult(CommonCode.SUCCESS,authToken.getJwt_token());&#125;//从cookie中读取访问令牌private String getTokenFormCookie()&#123; Map&lt;String, String&gt; cookieMap = CookieUtil.readCookie(request, &quot;uid&quot;); String access_token = cookieMap.get(&quot;uid&quot;); return access_token;&#125; 2.2.6 测试使用postman测试 1、请求 /auth/userlogin 观察cookie是否已存入用户身份令牌。 2、get请求jwt 2.3 前端请求jwt2.3.1 需求分析前端需求如下： 用户登录成功，前端请求认证服务获取jwt令牌。 前端解析jwt令牌的内容，得到用户信息，并将用户信息存储到sessionStorage。 从 sessionStorage取出用户信息在页头显示用户名称。 2.3.2 API方法在login.js中定义getjwt方法： 1234/*获取jwt令牌*/const getjwt = () =&gt; &#123; return requestGet(&apos;/openapi/auth/userjwt&apos;);&#125; 2.3.3 页面修改include/header.html 1、页面视图 123456&lt;span v-if=&quot;logined == true&quot;&gt;欢迎&#123;&#123;this.user.username&#125;&#125;&lt;/span&gt;&lt;a href=&quot;javascript:;&quot; @click=&quot;logout&quot; v-if=&quot;logined == true&quot;&gt;退出&lt;/a&gt;&lt;a href=&quot;http://ucenter.xuecheng.com/&quot; class=&quot;personal&quot; target=&quot;_blank&quot;&gt;我的学习&lt;/a&gt;&lt;a href=&quot;javascript:;&quot; @click=&quot;showlogin&quot; v-if=&quot;logined == false&quot;&gt;登陆&amp;nbsp;|&amp;nbsp;注册&lt;/a&gt;&lt;a href=&quot;http://teacher.xuecheng.com/&quot; class=&quot;personal&quot; target=&quot;_blank&quot;&gt;教学提供方&lt;/a&gt;&lt;a href=&quot;http://system.xuecheng.com/&quot; class=&quot;personal&quot; target=&quot;_blank&quot;&gt;系统后台&lt;/a&gt; 用户登录成功设置数据对象logined为true，设置数据对象user为当前用户信息。 数据对象定义如下： 123456user:&#123; userid:&apos;&apos;, username: &apos;&apos;, userpic: &apos;&apos;&#125;,logined:false 2、解析jwt令牌 在util.js中定义解析jwt令牌方法： 1234567891011121314151617181920//解析jwt令牌，获取用户信息var getUserInfoFromJwt = function (jwt) &#123; if(!jwt)&#123; return ; &#125; var jwtDecodeVal = jwt_decode(jwt); if (!jwtDecodeVal) &#123; return ; &#125; let activeUser=&#123;&#125; //console.log(jwtDecodeVal) activeUser.utype = jwtDecodeVal.utype || &apos;&apos;; activeUser.username = jwtDecodeVal.name || &apos;&apos;; activeUser.userpic = jwtDecodeVal.userpic || &apos;&apos;; activeUser.userid = jwtDecodeVal.userid || &apos;&apos;; activeUser.authorities = jwtDecodeVal.authorities || &apos;&apos;; activeUser.uid = jwtDecodeVal.jti || &apos;&apos;; activeUser.jwt = jwt; return activeUser;&#125; 3、refresh_user() 在mounted钩子方法中获取当前用户信息，并将用户信息存储到sessionStorage 1234mounted()&#123; //刷新当前用户 this.refresh_user()&#125; refresh_user()方法如下： 123456789101112131415161718192021222324252627refresh_user:function()&#123; //从sessionStorage中取出当前用户 let activeUser= getActiveUser(); //取出cookie中的令牌 let uid = getCookie(&quot;uid&quot;) //console.log(activeUser) if(activeUser &amp;&amp; uid &amp;&amp; uid == activeUser.uid)&#123; this.logined = true this.user = activeUser; &#125;else&#123; if(!uid)&#123; return ; &#125; //请求查询jwt getjwt().then((res) =&gt; &#123; if(res.success)&#123; let jwt = res.jwt; let activeUser = getUserInfoFromJwt(jwt) if(activeUser)&#123; this.logined = true this.user = activeUser; setUserSession(&quot;activeUser&quot;,JSON.stringify(activeUser)) &#125; &#125; &#125;) &#125; &#125; 2.3.4 配置代理转发上边实现在首页显示当前用户信息，首页需要通过Nginx代理请求认证服务，所以需要在首页的虚拟主机上配置代理路径： 1234#认证 location ^~ /openapi/auth/ &#123; proxy_pass http://auth_server_pool/auth/; &#125; 注意：其它前端系统要接入认证要请求认证服务也需要配置上边的代理路径。 3 用户退出3.1 需求分析操作流程如下： 1、用户点击退出，弹出退出确认窗口，点击确定 2、退出成功 用户退出要以下动作： 1、删除redis中的token 2、删除cookie中的token 3.2 API认证服务对外提供退出接口。 123@ApiOperation(&quot;退出&quot;)public ResponseResult logout(); 3.3 服务端认证服务提供退出接口。 3.3.1 DAO无。 3.3.2 Service123456//从redis中删除令牌public boolean delToken(String access_token)&#123; String name = &quot;user_token:&quot; + access_token; stringRedisTemplate.delete(name); return true;&#125; 3.3.3 Controller1234567891011121314151617//退出@Override@PostMapping(&quot;/userlogout&quot;)public ResponseResult logout() &#123; //取出身份令牌 String uid = getTokenFormCookie(); //删除redis中token authService.delToken(uid); //清除cookie clearCookie(uid); return new ResponseResult(CommonCode.SUCCESS);&#125;//清除cookieprivate void clearCookie(String token)&#123; CookieUtil.addCookie(response, cookieDomain, &quot;/&quot;, &quot;uid&quot;, token, 0, false);&#125; 3.3.4退出URL放行认证服务默认都要校验用户的身份信息，这里需要将退出url放行。 在WebSecurityConfig类中重写 configure(WebSecurity web)方法，如下： 1234@Overridepublic void configure(WebSecurity web) throws Exception &#123; web.ignoring().antMatchers(&quot;/userlogin&quot;,&quot;/userlogout&quot;);&#125; 3.4 前端3.4.1 需求分析在用户中心前端工程（xc-ui-pc-learning）开发退出页面。 3.4.2 Api方法在用户中心工程增加退出的api方法 在base模块的login.js增加方法如下：1234/*退出*/export const logout = params =&gt; &#123; return http.requestPost(&apos;/openapi/auth/userlogout&apos;);&#125; 3.4.3退出页面1、在用户中心工程创建退出页面 参考： 2、路由配置 123456789101112131415161718192021import Logout from &apos;@/module/home/page/logout.vue&apos;;import order_pay from &apos;@/module/order/page/order_pay.vue&apos;;// import LoginMini from &apos;@/module/home/page/login_mini.vue&apos;;export default [&#123; path: &apos;/&apos;, component: Home, name: &apos;个人中心&apos;, hidden: true &#125;, &#123; path: &apos;/login&apos;, component: Login, name: &apos;Login&apos;, hidden: true &#125;, &#123; path: &apos;/logout&apos;, component: Logout, name: &apos;Logout&apos;, hidden: true &#125;, 3、退出方法 退出成功清除页面的sessionStorage 参考logout.vue 在created钩子方法请求退出方法 1234567891011121314created()&#123; loginApi.logout(&#123;&#125;).then((res) =&gt; &#123; if(res.success)&#123; sessionStorage.removeItem(&apos;activeUser&apos;); this.$message(&apos;退出成功&apos;); this.logoutsuccess = true &#125;else&#123; this.logoutsuccess = false &#125; &#125;, (res) =&gt; &#123; this.logoutsuccess = false &#125;);&#125;, 3.4.4连接到退出页面修改include/header.html 1&lt;a href=&quot;javascript:;&quot; @click=&quot;logout&quot; v-if=&quot;logined == true&quot;&gt;退出&lt;/a&gt; 在include/header.html中添加element-ui库： 12&lt;script src=&quot;/css/el/index.js&quot;&gt;&lt;/script&gt;将此js加到head的最下边 logout方法如下： 123456789 logout: function () &#123; this.$confirm(&apos;确认退出吗?&apos;, &apos;提示&apos;, &#123; &#125;).then(() =&gt; &#123; //跳转到统一登陆 window.location = &quot;http://ucenter.xuecheng.com/#/logout&quot; &#125;).catch(() =&gt; &#123; &#125;);&#125;, 3.4.5 测试1、用户登录成功 2、点击退出 4 Zuul网关4.1 需求分析网关的作用相当于一个过虑器、拦截器，它可以拦截多个系统的请求。 本章节要使用网关校验用户的身份是否合法。 4.2 Zuul介绍什么是Zuul？ ​ Spring Cloud Zuul是整合Netflix公司的Zuul开源项目实现的微服务网关，它实现了请求路由、负载均衡、校验过虑等 功能。 官方：https://github.com/Netflix/zuul 什么是网关？ ​ 服务网关是在微服务前边设置一道屏障，请求先到服务网关，网关会对请求进行过虑、校验、路由等处理。有了服务网关可以提高微服务的安全性，网关校验请求的合法性，请求不合法将被拦截，拒绝访问。 Zuul与Nginx怎么配合使用？ Zuul与Nginx在实际项目中需要配合使用，如下图，Nginx的作用是反向代理、负载均衡，Zuul的作用是保障微服务的安全访问，拦截微服务请求，校验合法性及负载均衡。 4.3 搭建网关工程创建网关工程（xc-govern-gateway）： 1、创建xc-govern-gateway工程 导入“资料”–》xc-govern-gateway.zip 2、@EnableZuulProxy 注意在启动类上使用@EnableZuulProxy注解标识此工程为Zuul网关，启动类代码如下： 12345678@SpringBootApplication@EnableZuulProxypublic class GatewayApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(GatewayApplication.class, args); &#125;&#125; 4.4 路由配置4.4.1需求分析Zuul网关具有代理的功能，根据请求的url转发到微服务，如下图： 客户端请求网关/api/learning，通过路由转发到/learning 客户端请求网关/api/course，通过路由转发到/course 4.4.2 路由配置在appcation.yml中配置： 123456789zuul: routes: manage-course: #路由名称，名称任意，保持所有路由名称唯一 path: /course/** serviceId: xc-service-manage-course #指定服务id，从Eureka中找到服务的ip和端口 #url: http://localhost:31200 #也可指定url strip-prefix: false #true：代理转发时去掉前缀，false:代理转发时不去掉前缀 sensitiveHeaders: #默认zuul会屏蔽cookie，cookie不会传到下游服务，这里设置为空则取消默认的黑名单，如果设置了具体的头信息则不会传到下游服务 # ignoredHeaders: Authorization serviceId：推荐使用serviceId，zuul会从Eureka中找到服务id对应的ip和端口。 strip-prefix: false #true：代理转发时去掉前缀，false:代理转发时不去掉前缀，例如，为true请求/course/coursebase/get/..，代理转发到/coursebase/get/，如果为false则代理转发到/course/coursebase/get sensitiveHeaders：敏感头设置，默认会过虑掉cookie，这里设置为空表示不过虑 ignoredHeaders：可以设置过虑的头信息，默认为空表示不过虑任何头 4.4.3 测试请求http://localhost:50201/api/course/coursepic/list/4028e58161bd22e60161bd23672a0001查询课程图片信息 http://localhost:50201/api是网关地址，通过路由转发到xc-service-manage-course服务。 由于课程管理已经添加了授课拦截，这里为了测试网关功能暂时将“/course/coursepic/list”url排除认证。 在课程管理服务的 ResourceServerConfig类中添加”/course/coursepic/list/*”,代码如下： 1234567891011@Overridepublic void configure(HttpSecurity http) throws Exception &#123; //所有请求必须认证通过 http.authorizeRequests() //下边的路径放行 .antMatchers(&quot;/v2/api-docs&quot;, &quot;/swagger-resources/configuration/ui&quot;, &quot;/swagger-resources&quot;,&quot;/swagger-resources/configuration/security&quot;, &quot;/swagger-ui.html&quot;,&quot;/course/coursepic/list/*&quot;) .permitAll() .anyRequest().authenticated();&#125; 4.4.4 完整的路由配置1234567891011121314151617181920212223242526272829303132zuul: routes: xc-service-learning: #路由名称，名称任意，保持所有路由名称唯一 path: /learning/** serviceId: xc-service-learning #指定服务id，从Eureka中找到服务的ip和端口 strip-prefix: false sensitiveHeaders: manage-course: path: /course/** serviceId: xc-service-manage-course strip-prefix: false sensitiveHeaders: manage-cms: path: /cms/** serviceId: xc-service-manage-cms strip-prefix: false sensitiveHeaders: manage-sys: path: /sys/** serviceId: xc-service-manage-cms strip-prefix: false sensitiveHeaders: service-ucenter: path: /ucenter/** serviceId: xc-service-ucenter sensitiveHeaders: strip-prefix: false xc-service-manage-order: path: /order/** serviceId: xc-service-manage-order sensitiveHeaders: strip-prefix: false 4.5 过虑器Zuul的核心就是过虑器，通过过虑器实现请求过虑，身份校验等。 4.5.1 ZuulFilter自定义过虑器需要继承 ZuulFilter，ZuulFilter是一个抽象类，需要覆盖它的四个方法，如下： 1、 shouldFilter：返回一个Boolean值，判断该过滤器是否需要执行。返回true表示要执行此过虑器，否则不执行。 2、 run：过滤器的业务逻辑。 3、 filterType：返回字符串代表过滤器的类型，如下 pre：请求在被路由之前执行 routing：在路由请求时调用 post：在routing和errror过滤器之后调用 error：处理请求时发生错误调用 4、 filterOrder：此方法返回整型数值，通过此数值来定义过滤器的执行顺序，数字越小优先级越高。 4.5.2测试过虑所有请求，判断头部信息是否有Authorization，如果没有则拒绝访问，否则转发到微服务。 定义过虑器，使用@Component标识为bean。 1234567891011121314151617181920212223242526272829303132333435363738394041@Componentpublic class LoginFilterTest extends ZuulFilter &#123; private static final Logger LOG = LoggerFactory.getLogger(LoginFilterTest.class); @Override public String filterType() &#123; return &quot;pre&quot;; &#125; @Override public int filterOrder() &#123; return 2;//int值来定义过滤器的执行顺序，数值越小优先级越高 &#125; @Override public boolean shouldFilter() &#123;// 该过滤器需要执行 return true; &#125; @Override public Object run() &#123; RequestContext requestContext = RequestContext.getCurrentContext(); HttpServletResponse response = requestContext.getResponse(); HttpServletRequest request = requestContext.getRequest(); //取出头部信息Authorization String authorization = request.getHeader(&quot;Authorization&quot;); if(StringUtils.isEmpty(authorization))&#123; requestContext.setSendZuulResponse(false);// 拒绝访问 requestContext.setResponseStatusCode(200);// 设置响应状态码 ResponseResult unauthenticated = new ResponseResult(CommonCode.UNAUTHENTICATED); String jsonString = JSON.toJSONString(unauthenticated); requestContext.setResponseBody(jsonString); requestContext.getResponse().setContentType(&quot;application/json;charset=UTF-8&quot;); return null; &#125; return null; &#125;&#125; 测试： 请求：http://localhost:50201/api/course/coursebase/get/4028e581617f945f01617f9dabc40000查询课程信息 1、Header中不设置Authorization 响应结果： 12345&#123; &quot;code&quot;: 10001, &quot;message&quot;: &quot;此操作需要登陆系统！&quot;, &quot;success&quot;: false&#125; 2、Header中设置Authorization 成功响应课程信息。 5 身份校验5.1 需求分析本小节实现网关连接Redis校验令牌： 1、从cookie查询用户身份令牌是否存在，不存在则拒绝访问 2、从http header查询jwt令牌是否存在，不存在则拒绝访问 3、从Redis查询user_token令牌是否过期，过期则拒绝访问 5.2 编码代码1、配置application.yml 配置 redis链接参数： 12345678910111213spring: application: name: xc-govern-gateway redis: host: $&#123;REDIS_HOST:127.0.0.1&#125; port: $&#123;REDIS_PORT:6379&#125; timeout: 5000 #连接超时 毫秒 jedis: pool: maxActive: 3 maxIdle: 3 minIdle: 1 maxWait: -1 #连接池最大等行时间 -1没有限制 2、使用StringRedisTemplate查询key的有效期 在service包下定义AuthService类： 12345678910111213141516171819202122232425262728293031323334353637@Servicepublic class AuthService &#123; @Autowired StringRedisTemplate stringRedisTemplate; //查询身份令牌 public String getTokenFromCookie(HttpServletRequest request)&#123; Map&lt;String, String&gt; cookieMap = CookieUtil.readCookie(request, &quot;uid&quot;); String access_token = cookieMap.get(&quot;uid&quot;); if(StringUtils.isEmpty(access_token))&#123; return null; &#125; return access_token; &#125; //从header中查询jwt令牌 public String getJwtFromHeader(HttpServletRequest request)&#123; String authorization = request.getHeader(&quot;Authorization&quot;); if(StringUtils.isEmpty(authorization))&#123; //拒绝访问 return null; &#125; if(!authorization.startsWith(&quot;Bearer &quot;))&#123; //拒绝访问 return null; &#125; return authorization; &#125; //查询令牌的有效期 public long getExpire(String access_token) &#123; //token在redis中的key String key = &quot;user_token:&quot;+access_token; Long expire = stringRedisTemplate.getExpire(key); return expire; &#125;&#125; 说明：由于令牌存储时采用String序列化策略，所以这里用 StringRedisTemplate来查询，使用RedisTemplate无法完成查询。 3、定义LoginFilter 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667@Componentpublic class LoginFilter extends ZuulFilter &#123; private static final Logger LOGG = LoggerFactory.getLogger(LoginFilter.class); @Autowired AuthService authService; @Override public String filterType() &#123; //四种类型：pre、routing、post、error return &quot;pre&quot;; &#125; @Override public int filterOrder() &#123; return 0; &#125; @Override public boolean shouldFilter() &#123; return true; &#125; @Override public Object run() &#123; //上下文对象 RequestContext requestContext = RequestContext.getCurrentContext(); //请求对象 HttpServletRequest request = requestContext.getRequest(); //查询身份令牌 String access_token = authService.getTokenFromCookie(request); if(access_token == null)&#123; //拒绝访问 access_denied(); &#125; //从redis中校验身份令牌是否过期 long expire = authService.getExpire(access_token); if(expire&lt;=0)&#123; //拒绝访问 access_denied(); &#125; //查询jwt令牌 String jwt = authService.getJwtFromHeader(request); if(jwt == null)&#123; //拒绝访问 access_denied(); &#125; return null; &#125; //拒绝访问 private void access_denied()&#123; //上下文对象 RequestContext requestContext = RequestContext.getCurrentContext(); requestContext.setSendZuulResponse(false);//拒绝访问 //设置响应内容 ResponseResult responseResult =new ResponseResult(CommonCode.UNAUTHENTICATED); String responseResultString = JSON.toJSONString(responseResult); requestContext.setResponseBody(responseResultString); //设置状态码 requestContext.setResponseStatusCode(200); HttpServletResponse response = requestContext.getResponse(); response.setContentType(&quot;application/json;charset=utf-8&quot;); &#125;&#125; 5.3 测试1、配置代理 通过nginx转发到gateway，在&lt;www.xuecheng.com&gt;虚拟主机来配置 12345678#微服务网关 upstream api_server_pool&#123; server 127.0.0.1:50201 weight=10; &#125; #微服务网关location /api &#123; proxy_pass http://api_server_pool; &#125; 使用postman测试： Get请求：http://www.xuecheng.com/api/course/coursebase/get/4028e581617f945f01617f9dabc40000 注意：这里通过网关请求了course/coursebase/get地址，课程管理url根据自己的开发情况去配置， 1、正常流程测试 a、执行登录使之向cookie写入身份令牌uid Post请求：http://ucenter.xuecheng.com/openapi/auth/userlogin 并从redis获取jwt令牌的内容 b、手动在postman添加header 成功查询： 2、异常流程测试 手动删除header或清除cookie观察测试结果。]]></content>
      <categories>
        <category>项目实战-在线学习视频网站</category>
      </categories>
      <tags>
        <tag>Zuul</tag>
        <tag>JWT</tag>
        <tag>用户认证</tag>
        <tag>BCryptPasswordEncoder</tag>
        <tag>过滤器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在线学习视频（九）—— 课程预览 Eureka Feign]]></title>
    <url>%2Fday09-%E8%AF%BE%E7%A8%8B%E9%A2%84%E8%A7%88%20Eureka%20Feign.html</url>
    <content type="text"><![CDATA[课程预览 Eureka Feign1 Eureka注册中心1.1 需求分析​ 在前后端分离架构中，服务层被拆分成了很多的微服务，微服务的信息如何管理？Spring Cloud中提供服务注册中心来管理微服务信息。 为什么 要用注册中心？ 1、微服务数量众多，要进行远程调用就需要知道服务端的ip地址和端口，注册中心帮助我们管理这些服务的ip和端口。 2、微服务会实时上报自己的状态，注册中心统一管理这些微服务的状态，将存在问题的服务踢出服务列表，客户端获取到可用的服务进行调用。 1.3 Eureka注册中心1.3.1 Eureka介绍​ Spring Cloud Eureka 是对Netflix公司的Eureka的二次封装，它实现了服务治理的功能，Spring Cloud Eureka提供服务端与客户端，服务端即是Eureka服务注册中心，客户端完成微服务向Eureka服务的注册与发现。服务端和客户端均采用Java语言编写。下图显示了Eureka Server与Eureka Client的关系： 1、Eureka Server是服务端，负责管理各各微服务结点的信息和状态。 2、在微服务上部署Eureka Client程序，远程访问Eureka Server将自己注册在Eureka Server。 3、微服务需要调用另一个微服务时从Eureka Server中获取服务调用地址，进行远程调用。 1.3.2 Eureka Server搭建1.3.2.1 单机环境搭建1、创建xc-govern-center工程： 包结构：com.xuecheng.govern.center 2、添加依赖 在父工程添加：（有了则不用重复添加） 1234567&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Finchley.SR1&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt;&lt;/dependency&gt; 在Eureka Server工程添加： 1234567&lt;dependencies&gt; &lt;!-- 导入Eureka服务的依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 3、启动类 1234567@EnableEurekaServer//标识这是一个Eureka服务@SpringBootApplicationpublic class GovernCenterApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(GovernCenterApplication.class, args); &#125;&#125; 4、@EnableEurekaServer 需要在启动类上用@EnableEurekaServer标识此服务为Eureka服务 5、从其它服务拷贝application.yml和logback-spring.xml。 application.yml的配置内容如下： 12345678910111213141516server: port: 50101 #服务端口spring: application: name: xc-govern-center #指定服务名eureka: client: registerWithEureka: false #服务注册，是否将自己注册到Eureka服务中 fetchRegistry: false #服务发现，是否从Eureka中获取注册信息 serviceUrl: #Eureka客户端与Eureka服务端的交互地址，高可用状态配置对方的地址，单机状态配置自己（如果不配置则默认本机8761端口） defaultZone: http://localhost:50101/eureka/ server: enable-self-preservation: false #是否开启自我保护模式 eviction-interval-timer-in-ms: 60000 #服务注册表清理间隔（单位毫秒，默认是60*1000） registerWithEureka：被其它服务调用时需向Eureka注册 fetchRegistry：需要从Eureka中查找要调用的目标服务时需要设置为true serviceUrl.defaultZone 配置上报Eureka服务地址高可用状态配置对方的地址，单机状态配置自己 enable-self-preservation：自保护设置，下边有介绍。 eviction-interval-timer-in-ms：清理失效结点的间隔，在这个时间段内如果没有收到该结点的上报则将结点从服务列表中剔除。 5、启动Eureka Server 启动Eureka Server，浏览50101端口。 说明： 123上图红色提示信息：THE SELF PRESERVATION MODE IS TURNED OFF.THIS MAY NOT PROTECT INSTANCE EXPIRY IN CASE OF NETWORK/OTHER PROBLEMS.自我保护模式被关闭。在网络或其他问题的情况下可能不会保护实例失效。 Eureka Server有一种自我保护模式，当微服务不再向Eureka Server上报状态，Eureka Server会从服务列表将此服务删除，如果出现网络异常情况（微服务正常），此时Eureka server进入自保护模式，不再将微服务从服务列表删除。 在开发阶段建议关闭自保护模式。 1.3.2.2 高可用环境搭建​ Eureka Server 高可用环境需要部署两个Eureka server，它们互相向对方注册。如果在本机启动两个Eureka需要注意两个Eureka Server的端口要设置不一样，这里我们部署一个Eureka Server工程，将端口可配置，制作两个Eureka Server启动脚本，启动不同的端口，如下图： 1、在实际使用时Eureka Server至少部署两台服务器，实现高可用。 2、两台Eureka Server互相注册。 3、微服务需要连接两台Eureka Server注册，当其中一台Eureka死掉也不会影响服务的注册与发现。 4、微服务会定时向Eureka server发送心跳，报告自己的状态。 5、微服务从注册中心获取服务地址以RESTful方式发起远程调用。 配置如下： 1、端口可配置 12server: port: $&#123;PORT:50101&#125; #服务端口 2、Eureka服务端的交互地址可配置 123456eureka: client: registerWithEureka: true #服务注册，是否将自己注册到Eureka服务中 fetchRegistry: true #服务发现，是否从Eureka中获取注册信息 serviceUrl: #Eureka客户端与Eureka服务端的交互地址，高可用状态配置对方的地址，单机状态配置自己（如果不配置则默认本机8761端口） defaultZone: $&#123;EUREKA_SERVER:http://eureka02:50102/eureka/&#125; 3、配置hostname Eureka 组成高可用，两个Eureka互相向对方注册，这里需要通过域名或主机名访问，这里我们设置两个Eureka服务的主机名分别为 eureka01、eureka02。 完整的eureka配置如下： 1234567891011eureka: client: registerWithEureka: true #服务注册，是否将自己注册到Eureka服务中 fetchRegistry: true #服务发现，是否从Eureka中获取注册信息 serviceUrl: #Eureka客户端与Eureka服务端的交互地址，高可用状态配置对方的地址，单机状态配置自己（如果不配置则默认本机8761端口） defaultZone: $&#123;EUREKA_SERVER:http://eureka02:50102/eureka/&#125; server: enable-self-preservation: false #是否开启自我保护模式 eviction-interval-timer-in-ms: 60000 #服务注册表清理间隔（单位毫秒，默认是60*1000） instance: hostname: $&#123;EUREKA_DOMAIN:eureka01&#125; 4、在IDEA中制作启动脚本 启动1： 启动2： 运行两个启动脚本，分别浏览： http://localhost:50101/ http://localhost:50102/ Eureka主画面如下： 1.3.3 服务注册1.3.3.1 将cms注册到Eureka Server下边实现cms向Eureka Server注册。 1、在cms服务中添加依赖 12345&lt;!-- 导入Eureka客户端的依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt; 2、在application.yml配置 12345678910eureka: client: registerWithEureka: true #服务注册开关 fetchRegistry: true #服务发现开关 serviceUrl: #Eureka客户端与Eureka服务端进行交互的地址，多个中间用逗号分隔 defaultZone: $&#123;EUREKA_SERVER:http://localhost:50101/eureka/&#125; instance: prefer-ip-address: true #将自己的ip地址注册到Eureka服务中 ip-address: $&#123;IP_ADDRESS:127.0.0.1&#125; instance-id: $&#123;spring.application.name&#125;:$&#123;server.port&#125; #指定实例id 3、在启动类上添加注解 1在启动类上添加注解 @EnableDiscoveryClient ，表示它是一个Eureka的客户端 4、刷新Eureka Server查看注册情况 1.3.3.2 将manage-course注册到Eureka Server方法同上。 1、在manage-course工程中添加spring-cloud-starter-eureka依赖： 2、在application.yml配置eureka 3、在启动类上添加注解 @EnableDiscoveryClient 2 Feign远程调用​ 在前后端分离架构中，服务层被拆分成了很多的微服务，服务与服务之间难免发生交互，比如：课程发布需要调用CMS服务生成课程静态化页面，本节研究微服务远程调用所使用的技术。 下图是课程管理服务远程调用CMS服务的流程图： 工作流程如下： 1、cms服务将自己注册到注册中心。 2、课程管理服务从注册中心获取cms服务的地址。 3、课程管理服务远程调用cms服务。 2.1 Ribbon2.1.1 Ribbon介绍​ Ribbon是Netflix公司开源的一个负载均衡的项目（https://github.com/Netflix/ribbon），它是一个基于HTTP、TCP的客户端负载均衡器。 1、什么是负载均衡？ 负载均衡是微服务架构中必须使用的技术，通过负载均衡来实现系统的高可用、集群扩容等功能。负载均衡可通过硬件设备及软件来实现，硬件比如：F5、Array等，软件比如：LVS、Nginx等。 如下图是负载均衡的架构图： 用户请求先到达负载均衡器（也相当于一个服务），负载均衡器根据负载均衡算法将请求转发到微服务。负载均衡算法有：轮训、随机、加权轮训、加权随机、地址哈希等方法，负载均衡器维护一份服务列表，根据负载均衡算法将请求转发到相应的微服务上，所以负载均衡可以为微服务集群分担请求，降低系统的压力。2、什么是客户端负载均衡？ 上图是服务端负载均衡，客户端负载均衡与服务端负载均衡的区别在于客户端要维护一份服务列表，Ribbon从Eureka Server获取服务列表，Ribbon根据负载均衡算法直接请求到具体的微服务，中间省去了负载均衡服务。 如下图是Ribbon负载均衡的流程图： 1、在消费微服务中使用Ribbon实现负载均衡，Ribbon先从EurekaServer中获取服务列表。 2、Ribbon根据负载均衡的算法去调用微服务。 2.1.2 Ribbon测试​ Spring Cloud引入Ribbon配合 restTemplate 实现客户端负载均衡。Java中远程调用的技术有很多，如：webservice、socket、rmi、Apache HttpClient、OkHttp等，互联网项目使用基于http的客户端较多，本项目使用OkHttp。1、在客户端添加Ribbon依赖： 这里在课程管理服务配置ribbon依赖 12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-ribbon&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.squareup.okhttp3&lt;/groupId&gt; &lt;artifactId&gt;okhttp&lt;/artifactId&gt;&lt;/dependency&gt; 由于依赖了spring-cloud-starter-eureka，会自动添加spring-cloud-starter-ribbon依赖 2、配置Ribbon参数 这里在课程管理服务的application.yml中配置ribbon参数123456ribbon: MaxAutoRetries: 2 #最大重试次数，当Eureka中可以找到服务，但是服务连不上时将会重试 MaxAutoRetriesNextServer: 3 #切换实例的重试次数 OkToRetryOnAllOperations: false #对所有操作请求都进行重试，如果是get则可以，如果是post，put等操作没有实现幂等的情况下是很危险的,所以设置为false ConnectTimeout: 5000 #请求连接的超时时间 ReadTimeout: 6000 #请求处理的超时时 3、负载均衡测试 1）启动两个cms服务，注意端口要不一致 启动完成观察Eureka Server的服务列表 2）定义RestTemplate，使用@LoadBalanced注解 在课程管理服务的启动类中定义RestTemplate12345@Bean@LoadBalancedpublic RestTemplate restTemplate() &#123; return new RestTemplate(new OkHttp3ClientHttpRequestFactory());&#125; 3）测试代码 在课程管理服务工程创建单元测试代码，远程调用cms的查询页面接口：123456789101112//负载均衡调用@Testpublic void testRibbon() &#123; //服务id String serviceId = &quot;XC-SERVICE-MANAGE-CMS&quot;; for(int i=0;i&lt;10;i++)&#123; //通过服务id调用 ResponseEntity&lt;CmsPage&gt; forEntity = restTemplate.getForEntity(&quot;http://&quot; + serviceId + &quot;/cms/page/get/5a754adf6abb500ad05688d9&quot;, CmsPage.class); CmsPage cmsPage = forEntity.getBody(); System.out.println(cmsPage); &#125;&#125; 4）负载均衡测试 添加@LoadBalanced注解后，restTemplate会走LoadBalancerInterceptor拦截器，此拦截器中会通过RibbonLoadBalancerClient查询服务地址，可以在此类打断点观察每次调用的服务地址和端口，两个cms服务会轮流被调用。 2.2 Feign2.2.1 Feign介绍​ Feign是Netflix公司开源的轻量级rest客户端，使用Feign可以非常方便的实现Http 客户端。Spring Cloud引入Feign并且集成了Ribbon实现客户端负载均衡调用。 2.2.2 Feign测试例子： 1、在客户端添加依赖 在课程管理服务xc-service-manage-cms和xc-service-manage-course中添加下边的依赖：12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.netflix.feign&lt;/groupId&gt; &lt;artifactId&gt;feign-okhttp&lt;/artifactId&gt;&lt;/dependency&gt; 2、定义FeignClient接口 参考Swagger文档定义FeignClient，注意接口的Url、请求参数类型、返回值类型与Swagger接口一致。 （1）xc-service-manage-cms提供接口 和controller写法一样 12345public interface CmsPageAPI &#123; @GetMapping(&quot;/cms/page/get/&#123;id&#125;&quot;) public CmsPage findById(@PathVariable(&quot;id&quot;) String id); &#125; （2）xc-service-manage-course调用远程接口 @FeignClient(“xc-service-manage-cms”)里写的是被调用接口的项目配置名称 123@FeignClient(&quot;xc-service-manage-cms&quot;)public interface CmsPageClient extends CmsPageAPI &#123;&#125; （3）启动类添加@EnableFeignClients注解 在xc-service-manage-course中的启动类中添加@EnableFeignClients 3、测试 12345678910111213@RunWith(SpringRunner.class)@SpringBootTestpublic class FeignTest &#123; @Autowired CmsPageClient cmsPageClient; @Test public void testFeign() &#123; //通过服务id调用cms的查询页面接口 CmsPage cmsPage = cmsPageClient.findById(&quot;5a754adf6abb500ad05688d9&quot;); System.out.println(cmsPage); &#125;&#125; Feign工作原理如下： 1、 启动类添加@EnableFeignClients注解，Spring会扫描标记了@FeignClient注解的接口，并生成此接口的代理对象 2、 @FeignClient(value = XcServiceList.XC_SERVICE_MANAGE_CMS)即指定了cms的服务名称，Feign会从注册中心获取cms服务列表，并通过负载均衡算法进行服务调用。 3、在接口方法 中使用注解@GetMapping(“/cms/page/get/{id}”)，指定调用的url，Feign将根据url进行远程调用。 2.2.4 Feign注意点SpringCloud对Feign进行了增强兼容了SpringMVC的注解 ，我们在使用SpringMVC的注解时需要注意： 1、feignClient接口 有参数在参数必须加@PathVariable(“XXX”)和@RequestParam(“XXX”) 2、feignClient返回值为复杂对象时其类型必须有无参构造函数。 3 课程预览技术方案3.1 需求分析​ 课程预览是为了保证课程发布后的正确性，通过课程预览可以直观的通过课程详情页面看到课程的信息是否正确，通过课程预览看到的页面内容和课程发布后的页面内容是一致的。 下图是课程详情页面的预览图： 3.2 课程详情页面技术方案​ 课程预览所浏览到的页面就是课程详情页面，需要先确定课程详情页面的技术方案后方可确定课程预览的技术方案。 3.2.1 技术需求​ 课程详情页面是向用户展示课程信息的窗口，课程相当于网站的商品，本页面的访问量会非常大。此页面的内容设计不仅要展示出课程核心重要的内容而且用户访问页面的速度要有保证，有统计显示打开一个页面超过4秒用户就走掉了，所以本页面的性能要求是本页面的重要需求。 ​ 本页面另一个需求就是SEO，要非常有利于爬虫抓取页面上信息，并且生成页面快照，利于用户通过搜索引擎搜索课程信息。 3.2.2 解决方案如何在保证SEO的前提下提高页面的访问速度 ： 方案1： ​ 对于信息获取类的需求，要想提高页面速度就要使用缓存来减少或避免对数据库的访问，从而提高页面的访问速度。下图是使用缓存与不使用缓存的区别 此页面为动态页面，会根据课程的不同而不同，方案一采用传统的JavaEE Servlet/jsp的方式在Tomcat完成页面渲染，相比不加缓存速度会有提升。 优点：使用redis作为缓存，速度有提升。 缺点：采用Servlet/jsp动态页面渲染技术，服务器使用Tomcat，面对高并发量的访问存在性能瓶颈。方案2： ​ 对于不会频繁改变的信息可以采用页面静态化的技术，提前让页面生成html静态页面存储在nginx服务器，用户直接访问nginx即可，对于一些动态信息可以访问服务端获取json数据在页面渲染。 优点：使用Nginx作为web服务器，并且直接访问html页面，性能出色。 缺点：需要维护大量的静态页面，增加了维护的难度。 选择方案2作为课程详情页面的技术解决方案，将课程详情页面生成Html静态化页面，并发布到Nginx上 3.3 课程预览技术方案​ 根据要求：课程详情页面采用静态化技术生成Html页面，课程预览的效果要与最终静态化的Html页面内容一致。 ​ 所以，课程预览功能也采用静态化技术生成Html页面，课程预览使用的模板与课程详情页面模板一致，这样就可以保证课程预览的效果与最终课程详情页面的效果一致。 操作流程： 1、制作课程详情页面模板 2、开发课程详情页面数据模型的查询接口（为静态化提供数据） 3、调用cms课程预览接口通过浏览器浏览静态文件 4 课程详情页面静态化4.1 静态页面测试4.1.1 页面内容组成​ 我们在编写一个页面时需要知道哪些信息是静态信息，哪些信息为动态信息，下图是页面的设计图： 打开静态页面，观察每部分的内容。 红色表示动态信息，红色以外表示静态信息。 红色动态信息：表示一个按钮，根据用户的登录状态、课程的购买状态显示按钮的名称及按钮的事件。 包括以下信息内容： 1、课程信息 ​ 课程标题、价格、课程等级、授课模式、课程图片、课程介绍、课程目录。 2、课程统计信息 ​ 课程时长、评分、收藏人数 3、教育机构信息 ​ 公司名称、公司简介 4、教育机构统计信息 ​ 好评数、课程数、学生人数 5、教师信息 ​ 老师名称、老师介绍 4.1.2 页面拆分将页面拆分成如下页面： 1、页头 本页头文件和门户使用的页头为同一个文件。 参考：代码\页面与模板\include\header.html 2、页面尾 本页尾文件和门户使用的页尾为同一个文件。 参考：代码\页面与模板\include\footer.html 3、课程详情主页面 每个课程对应一个文件，命名规则为：课程id.html（课程id动态变化） 模板页面参考：\代码\页面与模板\course\detail\course_main_template.html 4、教育机构页面 每个教育机构对应一个文件，文件的命名规则为：company_info_公司id.html（公司id动态变化） 参考：代码\页面与模板\company\company_info_template.html 5、老师信息页面 每个教师信息对应一个文件，文件的命名规则为：teacher_info_教师id.html（教师id动态变化） 参考：代码\页面与模板\teacher\teacher_info_template01.html 6、课程统计页面 每个课程对应一个文件，文件的命名规则为：course_stat_课程id.json（课程id动态变化） 参考：\代码\页面与模板\stat\course\course_stat_template.json 7、教育机构统计页面 每个教育机构对应一个文件，文件的命名规则为：company_stat_公司id.json（公司id动态变化） 参考：\代码\页面与模板\stat\company\company_stat_template.json 4.1.2 静态页面测试4.1.2.1页面加载思路打开课程资料中的“静态页面目录”中的课程详情模板页面，研究页面加载的思路。 模板页面路径如下：1静态页面目录\static\course\detail\course_main_template.html 1、主页面 我们需要在主页面中通过SSI加载：页头、页尾、教育机构、教师信息 2、异步加载课程统计与教育机构统计信息 ​ 课程统计信息（json）、教育机构统计信息（json） 3、马上学习按钮事件 用户点击“马上学习”会根据课程收费情况、课程购买情况执行下一步操作。 4.1.2.2 静态资源虚拟主机1、配置静态资源虚拟主机 静态资源虚拟主机负责处理课程详情、公司信息、老师信息、统计信息等页面的请求： 将课程资料中的“静态页面目录”中的目录拷贝到F:/develop/xuecheng/static下 在nginx中配置静态虚拟主机如下：12345678910111213141516171819202122#学成网静态资源server &#123; listen 91; server_name localhost; #公司信息 location /static/company/ &#123; alias F:/develop/xuecheng/static/company/; &#125; #老师信息 location /static/teacher/ &#123; alias F:/develop/xuecheng/static/teacher/; &#125; #统计信息 location /static/stat/ &#123; alias F:/develop/xuecheng/static/stat/; &#125; location /course/detail/ &#123; alias F:/develop/xuecheng/static/course/detail/; &#125; &#125; 2、通过&lt;www.xuecheng.com&gt;虚拟主机转发到静态资源 由于课程页面需要通过SSI加载页头和页尾所以需要通过&lt;www.xuecheng.com&gt;虚拟主机转发到静态资源 在&lt;www.xuecheng.com&gt;虚拟主机加入如下配置：123456789101112location /static/company/ &#123; proxy_pass http://static_server_pool; &#125; location /static/teacher/ &#123; proxy_pass http://static_server_pool; &#125; location /static/stat/ &#123; proxy_pass http://static_server_pool; &#125; location /course/detail/ &#123; proxy_pass http://static_server_pool; &#125; 配置upstream实现请求转发到资源服务虚拟主机：1234#静态资源服务 upstream static_server_pool&#123;server 127.0.0.1:91 weight=10; &#125; 4.1.2.3 门户静态资源路径门户中的一些图片、样式等静态资源统一通过/static路径对外提供服务，在&lt;www.xuecheng.com&gt;虚拟主机中配置如下：12345678910111213141516#静态资源，包括系统所需要的图片，js、css等静态资源location /static/img/ &#123; alias F:/develop/xc_portal_static/img/;&#125; location /static/css/ &#123; alias F:/develop/xc_portal_static/css/;&#125; location /static/js/ &#123; alias F:/develop/xc_portal_static/js/;&#125; location /static/plugins/ &#123; alias F:/develop/xc_portal_static/plugins/; add_header Access-Control-Allow-Origin http://ucenter.xuecheng.com; add_header Access-Control-Allow-Credentials true; add_header Access-Control-Allow-Methods GET;&#125; cors跨域参数： Access-Control-Allow-Origin：允许跨域访问的外域地址 ​ 如果允许任何站点跨域访问则设置为*，通常这是不建议的。 Access-Control-Allow-Credentials： 允许客户端携带证书访问 Access-Control-Allow-Methods：允许客户端跨域访问的方法 4.1.2.4 页面测试请求：http://www.xuecheng.com/course/detail/course_main_template.html测试课程详情页面模板是否可以正常浏览。 4.1.2.5 页面动态脚本​ 为了方便日后的维护，我们将javascript实现的动态部分单独编写一个html 文件,在门户的include目录下定义course_detail_dynamic.html文件，此文件通过ssi包含在课程详情页面中. 文件地址：资料\静态页面目录\include\course_detail_dynamic.html 所有的课程公用一个 页面动态脚本。 在课程详情主页面下端添加如下代码，通过SSI技术包含课程详情页面动态脚本文件：1234&lt;script&gt;var courseId = &quot;template&quot;&lt;/script&gt;&lt;!--#include virtual=&quot;/include/course_detail_dynamic.html&quot;--&gt;&lt;/body&gt;&lt;/html&gt; 本页面使用vue.js动态获取信息，vue实例创建的代码如下： 主要查看 created钩子函数的内容。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566var body= new Vue(&#123; //创建一个Vue的实例 el: &quot;#body&quot;, //挂载点是id=&quot;app&quot;的地方 data: &#123; editLoading: false, title:&apos;测试&apos;, courseId:&apos;&apos;, charge:&apos;&apos;,//203001免费,203002收费 learnstatus:0,//课程状态，1：马上学习，2：立即报名、3：立即购买 course:&#123;&#125;, companyId:&apos;template&apos;, company_stat:[], course_stat:&#123;&quot;s601001&quot;:&quot;&quot;,&quot;s601002&quot;:&quot;&quot;,&quot;s601003&quot;:&quot;&quot;&#125; &#125;, methods: &#123; //学习报名 addopencourse()&#123; ... &#125;, //立即购买 buy()&#123; ... &#125;, createOrder()&#123; ... &#125;, getLearnstatus()&#123;//获取学习状态 ... &#125; &#125;, created() &#123;// this.charge = &apos;203002&apos; this.courseId = courseId; //获取教育机构的统计数据 queryCompanyStat(this.companyId).then((res)=&gt;&#123; console.log(res) if(res.stat)&#123; this.company_stat = res.stat console.log(this.company_stat) &#125; &#125;) //获取课程的统计数据 queryCourseStat(this.courseId).then((res)=&gt;&#123; console.log(res) if(res.stat)&#123; let stat = res.stat for(var i=0;i&lt;stat.length;i++)&#123; this.course_stat[&apos;s&apos;+stat[i].id] = stat[i].value &#125; &#125; console.log(this.course_stat) &#125;) &#125;, mounted()&#123; // alert(courseId) &#125; &#125;) 4.2 课程数据模型查询接口​ 静态化操作需要模型数据方可进行静态化，课程数据模型由课程管理服务提供，仅供课程静态化程序调用使用。 4.2.1 接口定义1、响应结果类型 12345678910@Data@ToString@NoArgsConstructorpublic class CourseView implements Serializable &#123; CourseBase courseBase;//基础信息 CourseMarket courseMarket;//课程营销 CoursePic coursePic;//课程图片 TeachplanNode TeachplanNode;//教学计划&#125; 2、请求类型 String：课程id3、接口定义如下12@ApiOperation(&quot;课程视图查询&quot;)public CourseView courseview(String id); 4.2.2 Dao需要对course_base、course_market、course_pic、teachplan等信息进行查询， 新建课程营销的dao，其它dao已经存在不用再建。12public interface CourseMarketRepository extends JpaRepository&lt;CourseMarket,String&gt; &#123;&#125; 4.2.3 Service123456789101112131415161718192021222324252627//课程视图查询public CourseView getCoruseView(String id) &#123; CourseView courseView = new CourseView(); //查询课程基本信息 Optional&lt;CourseBase&gt; optional = courseBaseRepository.findById(id); if(optional.isPresent())&#123; CourseBase courseBase = optional.get(); courseView.setCourseBase(courseBase); &#125; //查询课程营销信息 Optional&lt;CourseMarket&gt; courseMarketOptional = courseMarketRepository.findById(id); if(courseMarketOptional.isPresent())&#123; CourseMarket courseMarket = courseMarketOptional.get(); courseView.setCourseMarket(courseMarket); &#125; //查询课程图片信息 Optional&lt;CoursePic&gt; picOptional = coursePicRepository.findById(id); if(picOptional.isPresent())&#123; CoursePic coursePic = picOptional.get(); courseView.setCoursePic(picOptional.get()); &#125; //查询课程计划信息 TeachplanNode teachplanNode = teachplanMapper.selectList(id); courseView.setTeachplanNode(teachplanNode); return courseView;&#125; 4.2.4 Controller12345@Override@GetMapping(&quot;/courseview/&#123;id&#125;&quot;)public CourseView courseview(@PathVariable(&quot;id&quot;) String id) &#123; return courseService.getCoruseView(id);&#125; 4.2.5 测试使用swagger-ui或postman测试本接口。 4.3 课程信息模板设计​ 在确定了静态化所需要的数据模型之后，就可以编写页面模板了，课程详情页面由多个静态化页面组成，所以我们需要创建多个页面模板，本章节创建课程详情页面的主模板，即课程信息模板。 4.3.1 模板内容完整的模板请参考 “资料\课程详情页面模板\course.ftl“ 文件，下边列出模板中核心的内容： 课程基本信息： 12345678910111213141516171819202122232425262728293031323334353637&lt;div class=&quot;banner-left&quot;&gt; &lt;p class=&quot;tit&quot;&gt;$&#123;courseBase.name&#125;&lt;/p&gt; &lt;p class=&quot;pic&quot;&gt;&lt;span class=&quot;new-pic&quot;&gt;特惠价格￥$&#123;courseMarket.price&#125;&lt;/span&gt; &lt;span class=&quot;old-pic&quot;&gt;原价￥$&#123;courseMarket.price_old!&#125;&lt;/span&gt;&lt;/p&gt; &lt;p class=&quot;info&quot;&gt; &lt;a href=&quot;http://ucenter.xuecheng.com/#/learning/$&#123;courseBase.id&#125;/0&quot; target=&quot;_blank&quot; v-if=&quot;learnstatus == 1&quot; v-cloak&gt;马上学习&lt;/a&gt; &lt;a href=&quot;#&quot; @click=&quot;addopencourse&quot; v-if=&quot;learnstatus == 2&quot; v-cloak&gt;立即报名&lt;/a&gt; &lt;a href=&quot;#&quot; @click=&quot;buy&quot; v-if=&quot;learnstatus == 3&quot; v-cloak&gt;立即购买&lt;/a&gt; &lt;span&gt;&lt;em&gt;难度等级&lt;/em&gt; &lt;#if courseBase.grade==&apos;200001&apos;&gt; 低级 &lt;#elseif courseBase.grade==&apos;200002&apos;&gt; 中级 &lt;#elseif courseBase.grade==&apos;200003&apos;&gt; 高级 &lt;/#if&gt; &lt;/span&gt; &lt;span&gt;&lt;em&gt;课程时长&lt;/em&gt;&lt;stat v-text=&quot;course_stat.s601001&quot;&gt;&lt;/stat&gt; &lt;/span&gt; &lt;span&gt;&lt;em&gt;评分&lt;/em&gt;&lt;stat v-text=&quot;course_stat.s601002&quot;&gt;&lt;/stat&gt;&lt;/span&gt; &lt;span&gt;&lt;em&gt;授课模式&lt;/em&gt; &lt;#if courseBase.studymodel==&apos;201001&apos;&gt; 自由学习 &lt;#elseif courseBase.studymodel==&apos;201002&apos;&gt; 任务式学习 &lt;/#if&gt; &lt;/span&gt; &lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;banner-rit&quot;&gt; &lt;#if coursePic.pic??&gt; &lt;p&gt;&lt;img src=&quot;http://img.xuecheng.com/$&#123;coursePic.pic&#125;&quot; alt=&quot;&quot; width=&quot;270&quot; height=&quot;156&quot;&gt; &lt;/p&gt; &lt;#else&gt; &lt;p&gt;&lt;img src=&quot;/static/img/widget-video.png&quot; alt=&quot;&quot; width=&quot;270&quot; height=&quot;156&quot;&gt; &lt;/p&gt; &lt;/#if&gt; &lt;p class=&quot;vid-act&quot;&gt;&lt;span&gt; &lt;i class=&quot;i-heart&quot;&gt;&lt;/i&gt;收藏 &lt;stat v-text=&quot;course_stat.s601003&quot;&gt;&lt;/stat&gt; &lt;/span&gt; &lt;span&gt;分享 &lt;i class=&quot;i-weixin&quot;&gt;&lt;/i&gt;&lt;i class=&quot;i-qq&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt; &lt;/div&gt; 课程计划： 123456789101112131415161718&lt;div class=&quot;content&quot;&gt; &lt;#if teachplanNode.children??&gt; &lt;#list teachplanNode.children as firstNode&gt; &lt;div class=&quot;item&quot;&gt; &lt;div class=&quot;title act&quot;&gt;&lt;i class=&quot;i-chevron-top&quot;&gt;&lt;/i&gt;$&#123;firstNode.pname&#125;&lt;/div&gt; &lt;div class=&quot;about&quot;&gt;$&#123;firstNode.description!&#125;&lt;/div&gt; &lt;div class=&quot;drop-down&quot; style=&quot;height: $&#123;firstNode.children?size * 50&#125;px;&quot;&gt; &lt;ul class=&quot;list-box&quot;&gt; &lt;#list firstNode.children as secondNode&gt; &lt;li&gt;$&#123;secondNode.pname&#125;&lt;/li&gt; &lt;/#list&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;/#list&gt; &lt;/#if&gt; &lt;/div&gt; 页头： 局部代码如下： 123&lt;body data-spy=&quot;scroll&quot; data-target=&quot;#articleNavbar&quot; data-offset=&quot;150&quot;&gt;&lt;!-- 页面头部 --&gt;&lt;!--#include virtual=&quot;/include/header.html&quot;--&gt; 页尾： 局部代码如下： 123&lt;!-- 页面底部 --&gt;&lt;!--底部版权--&gt;&lt;!--#include virtual=&quot;/include/footer.html&quot;--&gt; 动态脚本文件： 12345&lt;script&gt; //课程id var courseId = &quot;template&quot;&lt;/script&gt;&lt;!--#include virtual=&quot;/include/course_detail_dynamic.html&quot;--&gt; 教师信息文件： 从课程数据中获取课程所属的教师Id，这里由于教师信息管理功能没有开发我们使用固定的教师信息文件： 1234&lt;div class=&quot;content-com course&quot;&gt; &lt;div class=&quot;title&quot;&gt;&lt;span&gt;课程制作&lt;/span&gt;&lt;/div&gt; &lt;!--#include virtual=&quot;/teacher/teacher_info_template01.html&quot;--&gt;&lt;/div&gt; 教育机构文件： 同教师信息一样，由于教育机构功能模块没有开发，这里我们使用固定的教育机构文件： 1234&lt;div class=&quot;about-teach&quot;&gt; &lt;!--机构信息--&gt; &lt;!--#include virtual=&quot;/company/company_info_template.html&quot;--&gt;&lt;/div&gt; 4.3.2 模板测试使用test-freemarker工程测试模板 编写模板过程采用test-freemarker工程测试模板。 将course.ftl拷贝到test-freemarker工程的resources/templates下，并在test-freemarker工程的controller中添加测试方法 12345678//课程详情页面测试@RequestMapping(&quot;/course&quot;)public String course(Map&lt;String,Object&gt; map)&#123; ResponseEntity&lt;Map&gt; forEntity = restTemplate.getForEntity(&quot;http://localhost:31200/course/courseview/4028e581617f945f01617f9dabc40000&quot;, Map.class); Map body = forEntity.getBody(); map.put(&quot;model&quot;,body); return &quot;course&quot;;&#125; 注意：上边的测试页面不显示样式，原因是页面通过SSI包含了页面头，而使用test-freemarker工程无法加载页头，测试模板主要查看html页面内容是否正确，待课程预览时解决样式不显示问题。 4.3.3 模板保存模板编写并测试通过后要在数据库保存： 1、模板信息保存在xc_cms数据库(mongodb)的cms_template表 2、模板文件保存在mongodb的GridFS中。 第一步：将模板文件上传到GridFS中 由于本教学项目中模板管理模块没有开发，所以我们使用Junit代码向GridFS中保存： 12345678910//文件存储2@Testpublic void testStore2() throws FileNotFoundException &#123; File file = new File(&quot;C:\\Users\\admin\\Desktop\\course.ftl&quot;); FileInputStream inputStream = new FileInputStream(file); //保存模版文件内容 GridFSFile gridFSFile = gridFsTemplate.store(inputStream, &quot;课程详情模板文件&quot;,&quot;&quot;); String fileId = gridFSFile.getId().toString(); System.out.println(fileId);&#125; 保存成功需要记录模板文件的id，即上边代码中的fileId。 第二步：向cms_template表添加模板记录（请不要重复添加） 使用Studio 3T连接mongodb，向cms_template添加记录： 123456｛ &quot;_class&quot; : &quot;com.xuecheng.framework.domain.cms.CmsTemplate&quot;, &quot;siteId&quot; : &quot;5a751fab6abb5044e0d19ea1&quot;, &quot;templateName&quot; : &quot;课程详情页面正式模板&quot;, &quot;templateFileId&quot; : &quot;这里填写上边代码返回的模板文件id&quot;｝ 4.3.4 其它模板除了课程详情主页面需要设计模板所有静态化的页面都要设计模板，如下： 教育机构页面模板、教师信息页面模板、课程统计信息json模板、教育机构统计信息json模板。 本项目我们实现课程详情主页面模板的制作和测试，其它页面模板的开发参考课程详情页面去实现。 5 课程预览功能开发5.1 需求分析课程预览功能将使用cms系统提供的页面预览功能，业务流程如下： 1、用户进入课程管理页面，点击课程预览，请求到课程管理服务 2、课程管理服务远程调用cms添加页面接口向cms添加课程详情页面 3、课程管理服务得到cms返回课程详情页面id，并拼接生成课程预览Url 4、课程管理服务将课程预览Url给前端返回 5、用户在前端页面请求课程预览Url，打开新窗口显示课程详情内容 5.2 CMS页面预览测试​ CMS已经提供了页面预览功能，课程预览功能要使用CMS页面预览接口实现，下边通过cms页面预览接口测试课程预览的效果。 1、向cms_page表插入一条页面记录或者从cms_page找一个页面进行测试。 注意：页面配置一定要正确，需设置正确的模板id和dataUrl。 如下，是一条页面的记录。 12345678910111213&#123; &quot;_id&quot; : ObjectId(&quot;5b3469f794db44269cb2bff1&quot;), &quot;_class&quot; : &quot;com.xuecheng.framework.domain.cms.CmsPage&quot;, &quot;siteId&quot; : &quot;5a751fab6abb5044e0d19ea1&quot;, &quot;pageName&quot; : &quot;4028e581617f945f01617f9dabc40000.html&quot;, &quot;pageAliase&quot; : &quot;课程详情页面测试01&quot;, &quot;pageWebPath&quot; : &quot;/course/detail/&quot;, &quot;pagePhysicalPath&quot; : &quot;/course/detail/&quot;, &quot;pageType&quot; : &quot;1&quot;, &quot;pageCreateTime&quot; : ISODate(&quot;2018-02-25T01:37:25.974+0000&quot;), &quot;templateId&quot; : &quot;5b345a6b94db44269cb2bfec&quot;, &quot;dataUrl&quot; : &quot;http://localhost:31200/course/courseview/4028e581617f945f01617f9dabc40000&quot;&#125; 2、课程详细页面 使用ssi注意 由于Nginx先请求cms的课程预览功能得到html页面，再解析页面中的ssi标签，这里必须保证cms页面预览返回的页面的Content-Type为text/html;charset=utf-8 在cms页面预览的controller方法中添加： 1response.setHeader(&quot;Content-type&quot;,&quot;text/html;charset=utf-8&quot;); 3、测试 请求：http://www.xuecheng.com/cms/preview/5b3469f794db44269cb2bff1传入页面Id，测试效果如下: 5.3 CMS添加页面接口cms服务对外提供添加页面接口，实现：如果不存在页面则添加，否则就更新页面信息。 此接口由课程管理服务在课程预览时调用。 5.3.1 Api接口12@ApiOperation(&quot;保存页面&quot;)public CmsPageResult save(CmsPage cmsPage); 5.3.2 Service123456789101112//添加页面，如果已存在则更新页面public CmsPageResult save(CmsPage cmsPage)&#123; //校验页面是否存在，根据页面名称、站点Id、页面webpath查询 CmsPage cmsPage1 = cmsPageRepository.findByPageNameAndSiteIdAndPageWebPath(cmsPage.getPageName(), cmsPage.getSiteId(), cmsPage.getPageWebPath()); if(cmsPage1 !=null)&#123; //更新 return this.update(cmsPage1.getPageId(),cmsPage); &#125;else&#123; //添加 return this.add(cmsPage); &#125;&#125; 5.3.3 Controller12345@Override@PostMapping(&quot;/save&quot;)public CmsPageResult save(@RequestBody CmsPage cmsPage) &#123; return pageService.save(cmsPage);&#125; 5.4 课程预览服务端5.4.1 Api定义此Api是课程管理前端请求服务端进行课程预览的Api 请求：课程Id 响应：课程预览Url 1、定义响应类型 12345678910@Data@ToString@NoArgsConstructorpublic class CoursePublishResult extends ResponseResult &#123; String previewUrl; public CoursePublishResult(ResultCode resultCode,String previewUrl) &#123; super(resultCode); this.previewUrl = previewUrl; &#125;&#125; 2、接口定义如下 12@ApiOperation(&quot;预览课程&quot;)public CoursePublishResult preview(String id); 5.4.2 创建 Feign Client在课程管理工程创建CMS服务的Feign Client，通过此Client远程请求cms添加页面。 123456@FeignClient(value = XcServiceList.XC_SERVICE_MANAGE_CMS)public interface CmsPageClient&#123; //保存页面 @PostMapping(&quot;/cms/page/save&quot;) public CmsPageResult save(@RequestBody CmsPage cmsPage);&#125; 5.4.3 Service1、配置添加页面参数信息 在application.yml中配置： 1234567course-publish: siteId: 5b30cba5f58b4411fc6cb1e5 templateId: 5b345a6b94db44269cb2bfec previewUrl: http://www.xuecheng.com/cms/preview/ pageWebPath: /course/detail/ pagePhysicalPath: /course/detail/ dataUrlPre: http://localhost:31200/course/courseview/ 2、代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455@Value(&quot;$&#123;course-publish.dataUrlPre&#125;&quot;)private String publish_dataUrlPre;@Value(&quot;$&#123;course-publish.pagePhysicalPath&#125;&quot;)private String publish_page_physicalpath;@Value(&quot;$&#123;course-publish.pageWebPath&#125;&quot;)private String publish_page_webpath;@Value(&quot;$&#123;course-publish.siteId&#125;&quot;)private String publish_siteId;@Value(&quot;$&#123;course-publish.templateId&#125;&quot;)private String publish_templateId;@Value(&quot;$&#123;course-publish.previewUrl&#125;&quot;)private String previewUrl;//根据id查询课程基本信息public CourseBase findCourseBaseById(String courseId)&#123; Optional&lt;CourseBase&gt; baseOptional = courseBaseRepository.findById(courseId); if(baseOptional.isPresent())&#123; CourseBase courseBase = baseOptional.get(); return courseBase; &#125; ExceptionCast.cast(CourseCode.COURSE_GET_NOTEXISTS); return null;&#125;//课程预览public CoursePublishResult preview(String courseId)&#123; CourseBase one = this.findCourseBaseById(courseId); //发布课程预览页面 CmsPage cmsPage = new CmsPage(); //站点 cmsPage.setSiteId(publish_siteId);//课程预览站点 //模板 cmsPage.setTemplateId(publish_templateId); //页面名称 cmsPage.setPageName(courseId+&quot;.html&quot;); //页面别名 cmsPage.setPageAliase(one.getName()); //页面访问路径 cmsPage.setPageWebPath(publish_page_webpath); //页面存储路径 cmsPage.setPagePhysicalPath(publish_page_physicalpath); //数据url cmsPage.setDataUrl(publish_dataUrlPre+courseId); //远程请求cms保存页面信息 CmsPageResult cmsPageResult = cmsPageClient.save(cmsPage); if(!cmsPageResult.isSuccess())&#123; return new CoursePublishResult(CommonCode.FAIL,null); &#125; //页面id String pageId = cmsPageResult.getCmsPage().getPageId(); //页面url String pageUrl = previewUrl+pageId; return new CoursePublishResult(CommonCode.SUCCESS,pageUrl);&#125; 5.4.4 Controller12345@Override@PostMapping(&quot;/preview/&#123;id&#125;&quot;)public CoursePublishResult preview(@PathVariable(&quot;id&quot;) String id) &#123; return courseService.preview(id);&#125; 5.5 前端开发5.5.1 api方法1234/*预览课程*/export const preview = id =&gt; &#123; return http.requestPost(apiUrl+&apos;/course/preview/&apos;+id);&#125; 5.5.2 页面创建 course_pub.vue 1234567891011121314&lt;template&gt; &lt;div&gt; &lt;el-card class=&quot;box-card&quot;&gt; &lt;div slot=&quot;header&quot; class=&quot;clearfix&quot;&gt; &lt;span&gt;课程预览&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;text item&quot;&gt; &lt;el-button type=&quot;primary&quot; @click.native=&quot;preview&quot; &gt;课程预览&lt;/el-button&gt; &lt;br/&gt;&lt;br/&gt; &lt;span v-if=&quot;previewurl &amp;&amp; previewurl!=&apos;&apos;&quot;&gt;&lt;a :href=&quot;previewurl&quot; target=&quot;_blank&quot;&gt;点我查看课程预览页面 &lt;/a&gt; &lt;/span&gt; &lt;/div&gt; &lt;/el-card&gt; &lt;/div&gt;&lt;/template&gt; 数据对象： 1234567data() &#123; return &#123; dotype:&apos;&apos;, courseid:&apos;&apos;, course: &#123;&quot;id&quot;:&quot;&quot;,&quot;name&quot;:&quot;&quot;,&quot;status&quot;:&quot;&quot;&#125;, previewurl:&apos;&apos; &#125; 方法 ： 1234567891011121314//预览preview()&#123; courseApi.preview(this.courseid).then((res) =&gt; &#123; if(res.success)&#123; this.$message.error(&apos;预览页面生成成功，请点击下方预览链接&apos;); if(res.url)&#123; //预览url this.previewurl = res.url &#125; &#125;else&#123; this.$message.error(res.message); &#125; &#125;);&#125;]]></content>
      <categories>
        <category>项目实战-在线学习视频网站</category>
        <category>Eureka Feign</category>
      </categories>
      <tags>
        <tag>Feign远程调用</tag>
        <tag>RestTemplate远程调用</tag>
        <tag>Eureka</tag>
        <tag>Ribbon负载均衡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在线学习视频（八）—— 课程图片管理 分布式文件系统]]></title>
    <url>%2Fday08-%E8%AF%BE%E7%A8%8B%E5%9B%BE%E7%89%87%E7%AE%A1%E7%90%86%20%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F.html</url>
    <content type="text"><![CDATA[课程图片管理 分布式文件系统1 FastDFS研究参考 “Linux下安装FastDFS” 2 上传图片开发2.1 需求分析​ 在很多系统都有上传图片/上传文件的需求，比如：上传课程图片、上传课程资料、上传用户头像等，为了提供系统的可重用性专门设立文件系统服务承担图片/文件的管理，文件系统服务实现对文件的上传、删除、查询等功能进行管理。 ​ 各各子系统不再开发上传文件的请求，各各子系统通过文件系统服务进行文件的上传、删除等操作。文件系统服务最终会将文件存储到fastDSF文件系统中。 下图是各各子系统与文件系统服务之间的关系： 下图是课程管理中上传图片处理流程： 执行流程如下： 1、管理员进入教学管理前端，点击上传图片 2、图片上传至文件系统服务，文件系统请求fastDFS上传文件 3、文件系统将文件入库，存储到文件系统服务数据库中。 4、文件系统服务向前端返回文件上传结果，如果成功则包括文件的Url路径。 5、课程管理前端请求课程管理进行保存课程图片信息到课程数据库。 6、课程管理服务将课程图片保存在课程数据库。 2.2 创建文件系统服务工程导入xc-service-base-filesystem.zip工程。 1）工程目录结构 pom.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;xc-framework-parent&lt;/artifactId&gt; &lt;groupId&gt;com.xuecheng&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;relativePath&gt;../xc-framework-parent/pom.xml&lt;/relativePath&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;xc-service-base-filesystem&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.xuecheng&lt;/groupId&gt; &lt;artifactId&gt;xc-service-api&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.xuecheng&lt;/groupId&gt; &lt;artifactId&gt;xc-framework-model&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.xuecheng&lt;/groupId&gt; &lt;artifactId&gt;xc-framework-common&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.tobato&lt;/groupId&gt; &lt;artifactId&gt;fastdfs-client&lt;/artifactId&gt; &lt;version&gt;1.26.1-RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 2）配置文件 原测试程序中fastdfs-client.properties的配置信息统一放在application.yml application.yml 1234567891011121314151617181920212223242526272829server: port: 22100spring: application: name: xc-service-base-filesystem#mongo配置 data: mongodb: database: xc_fs uri: mongodb://root:123@127.0.0.1:27017#SpringMVC上传文件配置 servlet: multipart: #默认支持文件上传. enabled: true #支持文件写入磁盘. file-size-threshold: 0 # 上传文件的临时目录 location: # 最大支持文件大小 max-file-size: 1MB # 最大支持请求大小 max-request-size: 30MBxuecheng: fastdfs: connect_timeout_in_seconds: 5 network_timeout_in_seconds: 30 charset: UTF-8 tracker_servers: 192.168.101.64:22122 2.3 API接口2.3.1模型类系统的文件信息（图片、文档等小文件的信息）在mongodb中存储，下边是文件信息的模型类。 1) 模型如下： 1234567891011121314151617181920212223242526272829@Data@ToString@Document(collection = &quot;filesystem&quot;)public class FileSystem &#123; @Id private String fileId; //文件请求路径 private String filePath; //文件大小 private long fileSize; //文件名称 private String fileName; //文件类型 private String fileType; //图片宽度 private int fileWidth; //图片高度 private int fileHeight; //用户id，用于授权暂时不用 private String userId; //业务key private String businesskey; //业务标签 private String filetag; //文件元信息 private Map metadata;&#125; 说明： fileId：fastDFS返回的文件ID。 filePath：请求fastDFS浏览文件URL。 filetag：文件标签，由于文件系统服务是公共服务，文件系统服务会为使用文件系统服务的子系统分配文件标签，用于标识此文件来自哪个系统。 businesskey：文件系统服务为其它子系统提供的一个业务标识字段，各子系统根据自己的需求去使用，比如：课程管理会在此字段中存储课程id用于标识该图片属于哪个课程。 metadata：文件相关的元信息。 2) collection 在mongodb创建数据库xc_fs（文件系统数据库），并创建集合 filesystem。 2.3.2 Api接口在api工程下创建com.xuecheng.api.filesystem包， 12345@Api(value = &quot;文件管理接口&quot;, description = &quot;文件管理接口，提供增删改查&quot;)public interface FileSystemControllerApi &#123; @ApiOperation(&quot;图片管理&quot;) public UploadFileResult upload(MultipartFile multipartFile,String filetag,String businesskey,String metadata);&#125; 2.3.3 Dao将文件信息存入数据库，主要存储文件系统中的文件路径。 123public interface FileSystemRepository extends MongoRepository&lt;FileSystem,String&gt; &#123;&#125; 2.3.4 Service1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283@Service@Slf4jpublic class FileSystemService &#123; @Autowired private FastFileStorageClient fileStorageClient; @Autowired private FileSystemRepository fileSystemRepository; //定义文件类型 private static final List&lt;String&gt; ALLOW_TYPES = Arrays.asList(&quot;image/png&quot;, &quot;image/jpeg&quot;,&quot;image/bmp&quot;); /** * 文件上传后将信息存储在mongodb中 * @param file * @param filetag * @param businesskey * @param metadata * @return */ public UploadFileResult upload(MultipartFile file, String filetag, String businesskey, String metadata) &#123; if (file==null)&#123; ExceptionCast.cast(FileSystemCode.FS_UPLOADFILE_FILEISNULL ); &#125; //上传文件,并作为文件id String fileid = upload_fastDFS(file); //创建file对象 FileSystem fileSystem = new FileSystem(); //文件id fileSystem.setFileId(fileid); //文件在fastdfs中的路径 fileSystem.setFilePath(fileid); //业务标识 fileSystem.setBusinesskey(businesskey); //标签 fileSystem.setFiletag(filetag); //元数据 if (StringUtils.isEmpty(metadata))&#123; Map map = JSON.parseObject(metadata, Map.class); fileSystem.setMetadata(map); &#125; //文件名字 fileSystem.setFileName(file.getOriginalFilename()); //大小 fileSystem.setFileSize(file.getSize()); //类型 fileSystem.setFileType(file.getContentType()); fileSystemRepository.save(fileSystem); return new UploadFileResult(CommonCode.SUCCESS,fileSystem); &#125; //上传文件到FastFDFS public String upload_fastDFS(MultipartFile file)&#123; try &#123; //校验文件类型 String contentType = file.getContentType(); if (!ALLOW_TYPES.contains(contentType))&#123; ExceptionCast.cast(FileSystemCode.FS_UPLOADFILE_TYPE); &#125; //校验文件内容 BufferedImage read = ImageIO.read(file.getInputStream()); if (read==null)&#123; ExceptionCast.cast(FileSystemCode.FS_UPLOADFILE_CONTENT); &#125; // 2、将图片上传到FastDFS // 2.1、获取文件后缀名 String extension = StringUtils.substringAfterLast(file.getOriginalFilename(), &quot;.&quot;); // 2.2、图片上传 StorePath storePath = fileStorageClient.uploadFile(file.getInputStream(), file.getSize(), extension, null); //返回路径 return storePath.getFullPath(); //返回路径 &#125; catch (IOException e) &#123; log.error(&quot;上传文件失败&quot;,e); ExceptionCast.cast(FileSystemCode.FS_UPLOADFILE_SERVERFAIL); return null; &#125; &#125;&#125; 2.3.5 Controller123456789101112131415@RestController@RequestMapping(&quot;/filesystem&quot;)public class FileSystemController implements FileSystemControllerApi &#123; @Autowired FileSystemService fileSystemService; @Override @PostMapping(&quot;/upload&quot;) public UploadFileResult upload(@RequestParam(&quot;file&quot;) MultipartFile file, @RequestParam(value = &quot;filetag&quot;, required = true) String filetag, @RequestParam(value = &quot;businesskey&quot;, required = false) String businesskey, @RequestParam(value = &quot;metedata&quot;, required = false) String metadata) &#123; return fileSystemService.upload(file,filetag,businesskey,metadata); &#125;&#125; 2.3.6 测试使用swagger-ui或postman进行测试。 下图是使用swagger-ui进行测试的界面： 2.4 上传课程图片前端2.4.1 需求上传图片界面如下图： 点击“加号”上传图片，图片上传成功自动显示；点击“删除”将删除图片。 2.4.2 页面使用Element-UI的Upload上传组件实现上边的效果。 1) template 1234567891011&lt;el-upload action=&quot;/filesystem/upload&quot; list-type=&quot;picture-card&quot; :before-upload=&quot;setbusinesskey&quot; :on-success=&quot;handleSuccess&quot; :file-list=&quot;fileList&quot; :limit=&quot;picmax&quot; :on-exceed=&quot;rejectupload&quot; :data=&quot;uploadval&quot;&gt; &lt;i class=&quot;el-icon-plus&quot;&gt;&lt;/i&gt;&lt;/el-upload&gt; el-upload参数说明： action：必选参数，上传的地址 list-type：文件列表的类型（text/picture/picture-card） before-upload：上传前执行钩子方法 ，function(file) on-success：上传成功 执行的钩子方法 ，function(response, file, fileList) on-error：上传失败的钩子方法，function(err, file, fileList) on-remove：文件删除的钩子方法，function(file, fileList) file-list：文件列表，此列表为上传成功 的文件 limit：最大允许上传个数 on-exceed：文件超出个数限制时的钩子，方法为：function(files, fileList) data：提交上传的额外参数，需要封装为json对象，最终提交给服务端为key/value串 2)数据模型 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;script&gt; import * as sysConfig from &apos;@/../config/sysConfig&apos;; import * as courseApi from &apos;../../api/course&apos;; import utilApi from &apos;../../../../common/utils&apos;; import * as systemApi from &apos;../../../../base/api/system&apos;; export default &#123; data() &#123; return &#123; picmax:1, courseid:&apos;&apos;, dialogImageUrl: &apos;&apos;, dialogVisible: false, fileList:[], uploadval:&#123;filetag:&quot;course&quot;&#125;, imgUrl:sysConfig.imgUrl &#125; &#125;, methods: &#123; //超出文件上传个数提示信息 rejectupload()&#123; this.$message.error(&quot;最多上传&quot;+this.picmax+&quot;个图片&quot;); &#125;, //在上传前设置上传请求的数据 setuploaddata()&#123; &#125;, //删除图片 handleRemove(file, fileList) &#123; console.log(file) alert(&apos;删除&apos;) &#125;, //上传成功的钩子方法 handleSuccess(response, file, fileList)&#123; console.log(response) alert(&apos;上传成功&apos;) &#125;, //上传失败执行的钩子方法 handleError(err, file, fileList)&#123; this.$message.error(&apos;上传失败&apos;); //清空文件队列 this.fileList = [] &#125; &#125;, mounted()&#123; //课程id this.courseid = this.$route.params.courseid; &#125; &#125;&lt;/script&gt; 2.4.3 测试1、点击“加号”测试上传图片。 3 保存课程图片3.1 需求分析​ 图片上传到文件系统后，其它子系统如果想使用图片可以引用图片的地址，课程管理模块使用图片的方式是将图片地址保存到课程数据库中。 ​ 业务流程如下： 1、上传图片到文件系统服务 2、保存图片地址到课程管理服务 在课程管理服务创建保存课程与图片对应关系的表 course_pic。 3、在course_pic保存图片成功后方可查询课程图片信息。 通过查询course_pic表数据则查询到某课程的图片信息。 3.2 课程管理服务端开发3.2.1 API课程管理需要使用图片则在课程管理服务中要提供保存课程图片的api。 123@ApiOperation(&quot;添加课程图片&quot;)public ResponseResult addCoursePic(String courseId,String pic); 3.2.2 Dao模型： 12345678910111213@Data@ToString@Entity@Table(name=&quot;course_pic&quot;)@GenericGenerator(name = &quot;jpa-assigned&quot;, strategy = &quot;assigned&quot;)public class CoursePic implements Serializable &#123; private static final long serialVersionUID = -916357110051689486L; @Id @GeneratedValue(generator = &quot;jpa-assigned&quot;) private String courseid; private String pic;&#125; API如下： 123public interface CoursePicRepository extends JpaRepository&lt;CoursePic, String&gt; &#123;&#125; 3.2.3 Service12345678910111213141516171819//添加课程图片 @Transactional public ResponseResult saveCoursePic(String courseId,String pic)&#123; //查询课程图片 Optional&lt;CoursePic&gt; picOptional = coursePicRepository.findById(courseId); CoursePic coursePic = null; if(picOptional.isPresent())&#123; coursePic = picOptional.get(); &#125; //没有课程图片则新建对象 if(coursePic == null)&#123; coursePic = new CoursePic(); &#125; coursePic.setCourseid(courseId); coursePic.setPic(pic); //保存课程图片 coursePicRepository.save(coursePic); return new ResponseResult(CommonCode.SUCCESS); &#125; 3.2.4 Controller123456@Override@PostMapping(&quot;/coursepic/add&quot;)public ResponseResult addCoursePic(@RequestParam(&quot;courseId&quot;) String courseId, @RequestParam(&quot;pic&quot;) String pic) &#123; //保存课程图片 return courseService.saveCoursePic(courseId,pic);&#125; 3.3 前端开发前端需要在上传图片成功后保存课程图片信息。 ###3.3.1 Api方法 1234//添加课程图片export const addCoursePic= (courseId,pic) =&gt; &#123; return http.requestPost(apiUrl+&apos;/course/coursepic/add?courseId=&apos;+courseId+&quot;&amp;pic=&quot;+pic)&#125; 3.3.2 页面1）添加上传成功的钩子 :on-success=”handleSuccess” 123456&lt;el-upload action=&quot;/api/filesystem/upload&quot; list-type=&quot;picture-card&quot; :on-success=&quot;handleSuccess&quot;&gt; &lt;i class=&quot;el-icon-plus&quot;&gt;&lt;/i&gt;&lt;/el-upload&gt; 2）在钩子方法 中保存课程图片信息 如果保存图片失败则上传失败，清除文件列表。 123456789101112131415161718192021222324//上传成功的钩子方法 handleSuccess(response, file, fileList)&#123; console.log(response) if(response.success)&#123; //alert(&apos;上传成功&apos;) //图片上传成功将课程图片地址保存到课程数据库 let pic = response.fileSystem.filePath courseApi.addCoursePic(this.courseid,pic).then((res) =&gt; &#123; if(res.success)&#123; this.$message.success(&apos;上传成功&apos;); &#125;else&#123; this.handleError() &#125; &#125;); &#125;else&#123; this.handleError() &#125; &#125;, //上传失败执行的钩子方法 handleError(err, file, fileList)&#123; this.$message.error(&apos;上传失败&apos;); //清空文件队列 this.fileList = [] &#125; 4 图片查询4.1 需求分析课程图片上传成功，再次进入课程上传页面应该显示出来已上传的图片。 4.2 API在课程管理服务定义查询方法 123@ApiOperation(&quot;获取课程基础信息&quot;)public CoursePic findCoursePic(String courseId); 4.3 课程管理服务开发4.3.1Dao使用CoursePicRepository即可，无需再开发。 4.3.2 Service根据课程id查询课程图片 123public CoursePic findCoursepic(String courseId) &#123; return coursePicRepository.findOne(courseId);&#125; 4.3.3 Controller12345@Override@GetMapping(&quot;/coursepic/list/&#123;courseId&#125;&quot;)public CoursePic findCoursePic(@PathVariable(&quot;courseId&quot;) String courseId) &#123; return courseService.findCoursepic(courseId);&#125; 4.4 前端开发4.4.1API方法1234//查询课程图片export const findCoursePicList = courseId =&gt; &#123; return http.requestQuickGet(apiUrl+&apos;/course/coursepic/list/&apos;+courseId)&#125; 4.4.2页面在课程图片页面的mounted钩子方法 中查询课程图片信息，并将图片地址赋值给数据对象 1、定义图片查询方法 123456789101112131415 //查询图片list()&#123; courseApi.findCoursePicList(this.courseid).then((res) =&gt; &#123; console.log(res) if(res.pic)&#123; let name = &apos;图片&apos;; let url = this.imgUrl+res.pic; let fileId = res.courseid; //先清空文件列表，再将图片放入文件列表 this.fileList = [] this.fileList.push(&#123;name:name,url:url,fileId:fileId&#125;); &#125; console.log(this.fileList); &#125;);&#125; 2）mounted钩子方法 在mounted钩子方法中调用服务端查询文件列表并绑定到数据对象。 123456mounted()&#123; //课程id this.courseid = this.$route.params.courseid; //查询图片 this.list()&#125; 4.4.3测试测试流程： 1、上传图片成功 2、进入上传图片页面，观察图片是否显示 5 课程图片删除5.1 需求分析课程图片上传成功后，可以重新上传，方法是先删除现有图片再上传新图片。 注意：此删除只删除课程数据库的课程图片信息，不去删除文件数据库的文件信息及文件系统服务器上的文件，由于课程图片来源于该用户的文件库，所以此图片可能存在多个地方共用的情况，所以要删除文件系统中的文件需要到图片库由用户确认后再删除。 5.2 API在课程管理服务添加删除课程图片api： 123@ApiOperation(&quot;删除课程图片&quot;)public ResponseResult deleteCoursePic(String courseId); 5.3 课程管理服务端开发5.3.1 DaoCoursePicRepository父类提供的delete方法没有返回值，无法知道是否删除成功，这里我们在CoursePicRepository下边自定义方法： 12//删除成功返回1否则返回0long deleteByCourseid(String courseid); 5.3.2 Service12345678910//删除课程图片@Transactionalpublic ResponseResult deleteCoursePic(String courseId) &#123; //执行删除，返回1表示删除成功，返回0表示删除失败 long result = coursePicRepository.deleteByCourseid(courseId); if(result&gt;0)&#123; return new ResponseResult(CommonCode.SUCCESS); &#125; return new ResponseResult(CommonCode.FAIL);&#125; 5.3.3 Controller12345@Override@DeleteMapping(&quot;/coursepic/delete&quot;)public ResponseResult deleteCoursePic(@RequestParam(&quot;courseId&quot;) String courseId) &#123; return courseService.deleteCoursePic(courseId);&#125; 5.4 前端开发5.4.1 API 调用1234//删除课程图片export const deleteCoursePic= courseId =&gt; &#123; return http.requestDelete(apiUrl+&apos;/course/coursepic/delete?courseId=&apos;+courseId)&#125; 5.4.2 页面测试1）before-remove钩子方法 在upload组件的before-remove钩子方法 中实现删除动作。 123456&lt;el-upload action=&quot;/filesystem/upload&quot; list-type=&quot;picture-card&quot; :before-remove=&quot;handleRemove&quot;&gt; &lt;i class=&quot;el-icon-plus&quot;&gt;&lt;/i&gt;&lt;/el-upload&gt; before-remove说明：删除文件之前的钩子，参数为上传的文件和文件列表，若返回 false 或者返回 Promise 且被 reject，则停止删除。 定义handleRemove方法进行测试： handleRemove 返回true则删除页面的图片，返回false则停止删除页面的图片。 123456//删除图片handleRemove(file, fileList) &#123; console.log(file) alert(&apos;删除成功&apos;) return true;｝ ###5.4.3 promise异步调用 在handleRemove方法调用删除图片的api方法，删除成功时return true，删除失败时return false; 12345678910111213141516 //删除图片 handleRemove(file, fileList) &#123; console.log(file)// alert(&apos;删除&apos;)// return true; //删除图片 courseApi.deleteCoursePic(&apos;1&apos;).then((res) =&gt; &#123; if(res.success)&#123; this.$message.success(&apos;删除成功&apos;); return true; &#125;else&#123; this.$message.error(res.message); return false; &#125; &#125;); &#125;, 在上边代码中将提交的课程id故意写错，按照我们预期应该是删除失败，而测试结果却是图片在页面上删除成功。 问题原因： 通过查询deleteCoursePic方法的底层代码，deleteCoursePic最终返回一个promise对象。 Promise是ES6提供的用于异步处理的对象，因为axios提交是异步提交，这里使用promise作为返回值。 Promise的使用方法如下： Promise对象在处理过程中有三种状态： pending：进行中 resolved：操作成功 rejected: 操作失败 Promise的构建方法如下： 12345678const promise = new Promise(function(resolve,reject)&#123; //...TODO... if(操作成功)&#123; resolve(value); &#125;else&#123; reject(error); &#125;&#125;) 上边的构造方法function(resolve,reject)执行流程如下： 1）方法执行一些业务逻辑。 2）如果操作成功将Promise的状态由pending变为resolved，并将操作结果传出去 3）如果操作失败会将promise的状态由pending变为rejected，并将失败结果传出去。 上边说的操作成功将操作结果传给谁了呢？操作失败将失败结果传给谁了呢？ 通过promise的then、catch来指定 123456promise.then(function (result) &#123; console.log(&apos;操作成功：&apos; + result);&#125;);promise.catch(function (reason) &#123; console.log(&apos;操作失败：&apos; + reason);&#125;); 例子如下： 1、定义一个方法，返回promise对象 123456789testpromise(i)&#123; return new Promise((resolve,reject)=&gt;&#123; if(i % 2==0)&#123; resolve(&apos;成功了&apos;) &#125;else&#123; reject(&apos;拒绝了&apos;) &#125; &#125;)&#125; 2、调用此方法 向方法传入偶数、奇数进行测试。 12345this.testpromise(3).then(res=&gt;&#123;//在then中对成功结果进行处理 alert(res)&#125;).catch(res=&gt;&#123;//在catch中对操作失败结果进行处理 alert(res)&#125;) 3、最终将handleRemove方法修改如下 handleRemove方法返回promise对象，当删除成功则resolve，删除失败则reject。 1234567891011121314151617//删除图片 handleRemove(file, fileList) &#123; console.log(file) return new Promise((resolve,reject)=&gt;&#123; //删除图片 courseApi.deleteCoursePic(this.courseid).then((res) =&gt; &#123; if(res.success)&#123; this.$message.success(&apos;删除成功&apos;); resolve()//通过 &#125;else&#123; this.$message.error(res.message); reject()//拒绝 &#125; &#125;); &#125;) &#125;]]></content>
      <categories>
        <category>项目实战-在线学习视频网站</category>
      </categories>
      <tags>
        <tag>Element-UI</tag>
        <tag>图片管理</tag>
        <tag>promise异步调用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在线学习视频（一）—— CMS服务端开发]]></title>
    <url>%2Fday01%20%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83%20CMS%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91.html</url>
    <content type="text"><![CDATA[搭建环境 CMS服务端开发1.项目的功能架构1.1.项目背景学成在线借鉴了MOOC（大型开放式网络课程，即MOOC（massive open online courses））的设计思想，是一个提供IT职业课程在线学习的平台，它为即将和已经加入IT领域的技术人才提供在线学习服务，用户通过在线学习、在线练习、在线考试等学习内容，最终掌握所学的IT技能，并能在工作中熟练应用。 1.2.功能模块 功能模块名称 功能说明 门户 在首页、活动页、专题页等页面提供课程学习入口 学习中心 学生登录学习中心在线学习课程 社交系统 社交系统为老师和学生交流搭建沟通的平台，包括：问答系统、评论系统、论坛等，学生和老师通过问答系统提问问题、回答问题，通过评论系统对老师授课进行评论。 教学管理 中心 | 教师登录教学管理中心进行课程管理、资源管理、考试管理等教学活动。 || 系统管理中心 | 系统管理员登录系统管理中心进行分类管理、运维管理等功能。 | 1.3.项目原型通过项目原型进一步了解项目的功能，包括：门户首页、课程搜索页、在线学习页面、个人中心等参考“项目原型”。 2 项目的技术架构2.1 技术架构学成在线采用当前流行的前后端分离架构开发，由用户层、UI层、微服务层、数据层等部分组成，为PC、App、H5等客户端用户提供服务。下图是系统的技术架构图： 业务流程举例：1、用户可以通过pc、手机等客户端访问系统进行在线学习。2、 系统应用CDN技术，对一些图片、CSS、视频等资源从CDN调度访问。3、所有的请求全部经过负载均衡器。4、对于PC、H5等客户端请求，首先请求UI层，渲染用户界面。5、客户端UI请求服务层获取进行具体的业务操作。6、服务层将数据持久化到数据库。 各模块说明如下： 序号 名称 功能描述 1 用户层 用户层描述了本系统所支持的用户类型包括：pc用户、app用户、h5用户。pc用户通过浏览器访问系统、app用户通过android、ios手机访问系统，H5用户通过h5页面访问系统。 2 CDN CDN全称Content Delivery Network，即内容分发网络，本系统所有静态资源全部通过CDN加速来提高访问速度。系统静态资源包括：html页面、js文件、css文件、image图片、pdf和ppt及doc教学文档、video视频等 3 负载均衡 系统的CDN层、UI层、服务层及数据层均设置了负载均衡服务，上图仅在UI层前边标注了负载均衡。 每一层的负载均衡会根据系统的需求来确定负载均衡器的类型，系统支持4层负载均衡+7层负载均衡结合的方式，4层负载均衡是指在网络传输层进行流程转发，根据IP和端口进行转发，7层负载均衡完成HTTP协议负载均衡及反向代理的功能，根据url进行请求转发。 4 UI层 UI层描述了系统向pc用户、app用户、h5用户提供的产品界面。根据系统功能模块特点确定了UI层包括如下产品界面类型： 1）面向pc用户的门户系统、学习中心系统、教学管理系统、系统管理中心。 2）面向h5用户的门户系统、学习中心系统。 3）面向app用户的门户系统、学习中心系统未在上图标注，在app项目中有详细说明。 5 微服务层 微服务层将系统服务分类三类：前端服务、后端服务及系统服务。 前端服务：主要为学习用户提供学习服务。 后端服务：主要为管理用户提供教学管理服务。 系统服务：公共服务，为系统的所有微服务提供公共服务功能。 服务网关：提供服务路由、负载均衡、认证授权等服务。 6 数据层 数据层描述了系统的数据存储的内容类型，持久化的业务数据使用MySQL和MongoDB保存，其中MongoDB中主要保存系统日志信息。 消息队列：存储系统服务间通信的消息，本身提供消息存取服务，与微服务层的系统服务连接。 索引库：存储课程信息的索引信息，本身提供索引维护及搜索的服务，与微服务层的系统服务连接。 缓存：作为系统的缓存服务，存储课程信息、分类信息、用户信息等，与微服务层的所有服务连接。文件存储：提供系统静态资源文件的分布式存储服务，文件存储服务器作为CDN服务器的数据来源，CDN上的静态资源将最终在文件存储服务器上保存多份。 流媒体服务：作为流媒体服务器，存储所有的流媒体文件 7 外部系统接口 1）微信、QQ、微博登录接口，本系统和微信、QQ、微博系统对接，用户输入微信、QQ、微博的账号和密码即可登录本系统。 2）微信、QQ、微博分享接口，本系统和微信、QQ、微博系统对接，可直接将本系统的课程资源信息分享到微信、QQ、微博。3）支付宝、微信、网银支付接口，本系统提供支付宝、微信、网银三种支付接口。4）短信接口，本系统与第三方平台对接短信发送接口。 5）邮件接口，本系统需要连接第三方的smpt邮件服务器对外发送电子邮件。 6）微信公众号，本系统与微信公众号平台接口，用户通过微信公众号访问H5页面。 7）点播、直播，前期视频点播与直播采用第三方服务方式，本系统与第三方点、直播服务对接，对外提供视频点播与直播服务。 8）OSS存储 ，前期静态资源文件的存储采用第三方服务方式，本系统与第三方提供的OSS存储服务对接，将系统的静态资源文件存储到第三方提供的OSS存储服务器上。 9）CDN，本系统与第三方CDN服务对接，使用CDN加速服务来提高本系统的访问速度 8 DevOps DevOps（英文Development和Operations的组合）是一组过程、方法与系统的统称， 用于促进开发（应用程序/软件工程）、技术运营和质量保障（QA）部门之间的沟通、协作与整合。本项目供了许多开发、运营、维护支撑的系统，包括： Eureka服务治理中心：提供服务治理服务，包括：服务注册、服务获取等。 Spring Cloud Config服务配置管理中心：提供服务配置管理服务，包括：配置文件更新、配置文件下发等。Hystrix Dashboard服务熔断监控：监控熔断的请求响应时间、成功率等 。 Zipkin服务追踪监控：监控服务调用链路健康情况。 Jenkins持续集成服务：提供系统持续集成服务。 Git/GitLab代码管理服务:提供git代码管理服务。 ELK日志分析服务:提供elk日志分析服务，包括系统运行日志分析、告警服务。 Docker容器化部署服务：将本系统所有服务采用容器化部署方式。 Maven项目管理工具：提供管理项目所有的Java包依赖、项目工程打包服务 | 2.2.技术栈下图是项目技术架构的简图，通过简图了解项目所使用的技术栈。 重点了解微服务技术栈： 学成在线服务端基于Spring Boot构建，采用Spring Cloud微服务框架。 持久层：MySQL、MongoDB、Redis、ElasticSearch 数据访问层：使用Spring Data JPA 、Mybatis、Spring Data Mongodb等 业务层：Spring IOC、Aop事务控制、Spring Task任务调度、Feign、Ribbon、Spring AMQP、Spring Data Redis等。 控制层：Spring MVC、FastJSON、RestTemplate、Spring Security Oauth2+JWT等 微服务治理：Eureka、Zuul、Hystrix、Spring Cloud Config等 2.3.开发步骤项目是基于前后端分离的架构进行开发，前后端分离架构总体上包括前端和服务端，通常是多人协作并行开发，开发步骤如下：1、需求分析梳理用户的需求，分析业务流程2、接口定义根据需求分析定义接口3、服务端和前端并行开发依据接口进行服务端接口开发。前端开发用户操作界面，并请求服务端接口完成业务处理。4、前后端集成测试最终前端调用服务端接口完成业务 3 CMS需求分析3.1.什么是CMS1、CMS是什么 ？CMS （Content Management System）即内容管理系统，不同的项目对CMS的定位不同，比如：一个在线教育网站，有些公司认为CMS系统是对所有的课程资源进行管理，而在早期网站刚开始盛行时很多公司的业务是网站制作，当时对CMS的定位是创建网站，即对网站的页面、图片等静态资源进行管理。2、CMS有哪些类型？上边也谈到每个公司对每个项目的CMS定位不同，CMS基本上分为：针对后台数据内容的管理、针对前端页面的管理、针对样式风格的管理等 。比如：一个给企业做网站的公司，其CMS系统主要是网站页面管理及样式风格的管理。 3 、本项目CMS的定位是什么？本项目作为一个大型的在线教育平台，对CMS系统的定位是对各各网站（子站点）页面的管理，主要管理由于运营需要而经常变动的页面，从而实现根据运营需要快速进行页面开发、上线的需求 3.2.静态门户工程搭建本项目CMS是对页面进行管理，对页面如何进行管理呢？我们首先搭建学成网的静态门户工程，根据门户的页面结构来分析页面的管理方案。门户，是一个网站的入口，一般网站都有一个对外的门户，学成在线门户效果图如下： 3.2.1.导入门户工程1、安装WebStorm参考“WebStorm安装手册.md”安装WebStorm-2018.2.3.exe2、安装Nginx下载nginx：http://nginx.org/en/download.html本教程下载 nginx-1.14.0.zip(http://nginx.org/download/nginx-1.14.0.zip)解压nginx-1.14.0.zip到自己的计算机，双击nginx.exe即可运行。访问 ：http://localhost 3、导入门户工程将课程资料中的门户工程拷贝到代码目录。使用WebStorm打开门户工程目录，目录的结构如下，后期会根据开发的推进进行扩充。 3.2.2.配置虚拟主机资料中有window下的nginx软件，解压到不是中文路径下 在nginx中配置虚拟主机： 1234567891011 server&#123;listen 81;server_name www.xuecheng.com;ssi on;ssi_silent_errors on;location / &#123; alias G:/Java-webspace/xc_edu/xc-ui-pc-static-portal/; index index.html;&#125; &#125; 我们将前端页面工程放在：G:/Java-webspace/xc_edu/xc-ui-pc-static-portal/ 4、配置hosts文件通过SwitchHosts修改host 进入浏览器，输入http://www.xuecheng.com 3.3.SSI服务本节分析首页的管理方案。1、页面内容多如何管理？将页面拆分成一个一个的小页面，通过cms去管理这些小页面，当要更改部分页面内容时只需要更改具体某个小页面即可。2、页面拆出来怎么样通过web服务浏览呢？使用web服务(例如nginx)的SSI技术，将多个子页面合并渲染输出。3、SSI是什么？ ssi 包含类似于jsp页面中的incluce指令，ssi是在web服务端将include指定 的页面包含在网页中，渲染html网页响应给客户端 。nginx、apache等多数web容器都支持SSI指令。ssi指令如下： 1&lt;!‐‐#include virtual=&quot;/../....html&quot;‐‐&gt; 4、将首页拆分成 12345index.html：首页主体内容include/header.html：头部区域include/index_banner.html：轮播图include/index_category.html：左侧列表导航include/footer.html：页尾 5、在nginx虚拟主机中开通SSI 123456server&#123; listen 80; server_name www.xuecheng.com; ssi on; ssi_silent_errors on; ...... ssi的配置参数如下： ssi on： 开启ssi支持 ssi_silent_errors on：默认为off，设置为on则在处理SSI文件出错时不输出错误信息 ssi_types：默认为 ssi_types text/html，如果需要支持shtml（服务器执行脚本，类似于jsp）则需要设置为ssi_types text/shtml 6、测试去掉某个#include查看页面效果。 3.3.CMS页面管理需求1、这些页面的管理流程是什么？1）创建站点：一个网站有很多子站点，比如：学成在线有主门户、学习中心、问答系统等子站点。具体的哪个页面是归属于具体的站点，所以要管理页面，先要管理页面所属的站点。2）创建模板：页面如何创建呢？比如电商网站的商品详情页面，每个页面的内容布局、板式是相同的，不同的只是内容，这个页面的布局、板式就是页面模板，模板+数据就组成一个完整的页面，最终要创建一个页面文件需要先定义此页面的模板，最终拿到页面的数据再结合模板就拼装成一个完整的页面。 3 ）创建页面：创建页面是指填写页面的基本信息，如：页面的名称、页面的url地址等。4）页面预览：页面预览是页面发布前的一项工作，页面预览使用静态化技术根据页面模板和数据生成页面内容，并通过浏览器预览页面。页面发布前进行页面预览的目是为了保证页面发布后的正确性。5）页面发布：使用计算机技术将页面发送到页面所在站点的服务器，页面发布成功就可以通过浏览器来访问了。2、本项目要实现什么样的功能？1）页面管理管理员在后台添加、修改、删除页面信息2）页面预览管理员通过页面预览功能预览页面发布后的效果。3）页面发布管理员通过页面发布功能将页面发布到远程门户服务器。页面发布成功，用户即可在浏览器浏览到最新发布的页面，整个页面添加、发布的过程由于软件自动执行，无需人工登录服务器操作。 4 CMS服务端工程搭建4.1 导入基础工程4.1.1.工程结构CMS及其它服务端工程基于maven进行构建，首先需要创建如下基础工程：parent工程：父工程，提供依赖管理。common工程：通用工程，提供各层封装model工程：模型工程，提供统一的模型类管理utils工程：工具类工程，提供本项目所使用的工具类Api工程：接口工程，统一管理本项目的服务接口。 工程结果如下： 基础工程代码及pom.xml配置参考课程资料“基础工程”。 4.1.2.导入父工程1、将课程资料中的parent工程拷贝到代码目录2、点击Import Model，选择parent工程目录 选择Maven，下一步。 3、导入成功 4.1.3导入其它工程依次导入utils、model、common、api工程，方法同parent工和的导入。 4.2 MongoDB 入门详细见window下安装MongoDB笔记 这里我们在CMS中用到MongoDB数据库 4.3.导入CMS数据库导入cms数据库：使用Studio 3T软件导入cms数据库1、创建xc_cms数据库 2、导入 cms数据库右键数据库，点击导入数据库 打开窗口，选择第一个 json。下一步，选择要导入的数据文件（json文件） 下一步操作即可完成。导入成功： 5 页面查询接口定义5.1 定义模型5.1.1 需求分析在梳理完用户需求后就要去定义前后端的接口，接口定义后前端和后端就可以依据接口去开发功能了。本次定义页面查询接口，本接口供前端请求查询页面列表，支持分页及自定义条件查询方式。具体需求如下：1、分页查询CmsPage 集合下的数据2、根据站点Id、模板Id、页面别名查询页面信息3、接口基于Http Get请求，响应Json数据 5.1.2 模型类介绍接口的定义离不开数据模型，根据前边对需求的分析，整个页面管理模块的数据模型如下： CmsSite：站点模型CmsTemplate：页面模板CmsPage：页面信息页面信息如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344@Data@ToString@Document(collection = "cms_page")public class CmsPage &#123; /** * 页面名称、别名、访问地址、类型（静态/动态）、页面模版、状态 */ //站点ID private String siteId; //页面ID @Id private String pageId; //页面名称 private String pageName; //别名 private String pageAliase; //访问地址 private String pageWebPath; //参数 private String pageParameter; //物理路径 private String pagePhysicalPath; //类型（静态/动态） private String pageType; //页面模版 private String pageTemplate; //页面静态化内容 private String pageHtml; //状态 private String pageStatus; //创建时间 private Date pageCreateTime; //模版id private String templateId; //参数列表 private List&lt;CmsPageParam&gt; pageParams; //模版文件Id// private String templateFileId; //静态文件Id private String htmlFileId; //数据Url private String dataUrl;&#125; 属性说明：1、定义一个页面需要指定页面所属站点一个站点包括多个页面，比如：学成在线的门户站点（网站）包括了多个页面。2、定义一个页面需要指定页面使用的模板多个页面可以使用相同的模板，比如：商品信息模板，每个商品就是一个页面，所有商品使用同一个商品信息模板 5.2.定义接口注意： 在CmsPageControllerApi中定义一个接口)```，在cms中实现这个接口，这样就方便以后框架的修改12345678910111213141516171819202122#### 5.2.1.定义请求及响应类型1、定义请求模型QueryPageRequest，此模型作为查询条件类型为后期扩展需求，请求类型统一继承RequestData类型。在xc-framework-model目录下的cms下的request中创建QueryPageRequest```java@Datapublic class QueryPageRequest &#123; //站点id private String siteId; //页面ID private String pageId; //页面名称 private String pageName; //别名 private String pageAliase; //模版id private String templateId;&#125; 2、响应结果类型，分页查询统一使用QueryResponseResult 5.2.2.定义接口在 Api接口工程专门定义接口，在Api工程单独定义接口的原因如下：1、接口集中管理2、Api工程的接口将作为各微服务远程调用使用。页面查询接口定义如下： 在xc-service-api\src\main\java\com\xuecheng\api\cms目录下创建 123public interface CmsPageControllerApi &#123; public QueryResponseResult findList(int page, int size, QueryPageRequest queryPageRequest) ;&#125; 6 页面查询服务端开发6.1 创建CMS服务工程6.1.1 创建CMS工程结构创建maven工程， CMS工程的名称为 xc-service-manage-cms，父工程为xc-framework-parent。pom.xml如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;xc-framework-parent&lt;/artifactId&gt; &lt;groupId&gt;com.xuecheng&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;relativePath&gt;../xc-framework-parent/pom.xml&lt;/relativePath&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.xuecheng&lt;/groupId&gt; &lt;artifactId&gt;xc-service-manage-cms&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.xuecheng&lt;/groupId&gt; &lt;artifactId&gt;xc-service-api&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.xuecheng&lt;/groupId&gt; &lt;artifactId&gt;xc-framework-model&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.xuecheng&lt;/groupId&gt; &lt;artifactId&gt;xc-framework-utils&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.xuecheng&lt;/groupId&gt; &lt;artifactId&gt;xc-framework-common&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-freemarker&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.squareup.okhttp3&lt;/groupId&gt; &lt;artifactId&gt;okhttp&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 2 、创建基本的包结构：com.xuecheng.manage_cms.config：配置类目录，数据库配置、MQ配置等com.xuecheng.manage_cms.dao：dao接口目录com.xuecheng.manage_cms.service：service类目录com.xuecheng.manage_cms.web.controller：controller类目录 工程如下： 3、配置文件在classpath下配置application.yml 123456789server: port: 31001spring: application: name: xc‐service‐manage‐cms data: mongodb: uri: mongodb://root:123@localhost:27017 database: xc_cms 另外从课程资料下“cms工程配置文件”中拷贝logback-spring.xml，此文件为工程的日志配置文件。 4、SpringBoot 启动类 Spring Boot 应用需要创建一个应用启动类，启动过程中会扫描Bean并注入spring 容器注意：此类创建在本工程com.xuecheng.manage_cms包下 : 123456789@SpringBootApplication@EntityScan("com.xuecheng.framework.domain.cms")//扫描实体类@ComponentScan(basePackages=&#123;"com.xuecheng.api"&#125;)//扫描接口@ComponentScan(basePackages=&#123;"com.xuecheng.manage_cms"&#125;)//扫描本项目下的所有类public class ManageCmsApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ManageCmsApplication.class,args); &#125;&#125; 6.1.2 测试Controller使用springMVC完成接口实现开发，这里暂时使用测试数据，稍后会让controller调用service来查询数据。 1234567891011121314151617181920212223@RestController@RequestMapping("/cms/page")public class CmsPageController implements CmsPageControllerApi&#123; @Autowired PageService pageService; @Override @GetMapping("/list/&#123;page&#125;/&#123;size&#125;") public QueryResponseResult findList(@PathVariable("page") int page, @PathVariable("size") int size, QueryPageRequest queryPageRequest) &#123; //空数据 QueryResult&lt;CmsPage&gt; queryResult = new QueryResult&lt;&gt;(); ArrayList&lt;CmsPage&gt; list = new ArrayList&lt;&gt;(); CmsPage cmsPage = new CmsPage(); cmsPage.setPageName("测试页面"); list.add(cmsPage); queryResult.setList(list); queryResult.setTotal(1); QueryResponseResult queryResponseResult = new QueryResponseResult(CommonCode.SUCCESS, queryResult); return queryResponseResult; &#125;&#125; 使用浏览器测试输入：http://localhost:31001/cms/page/list/1/10 查询第1页，每页显示10条记录 6.2 Dao6.2.1 分页查询测试6.2.1.1 定义Dao接口本项目使用Spring Data Mongodb完成Mongodb数据库的查询，Spring Data Mongodb提供一套快捷操作mongodb的方法。创建Dao，继承MongoRepository，并指定实体类型和主键类型。 在xc-service-manage-cms的dao目录下创建CmsPageRepository 12public interface CmsPageRepository extends MongoRepository&lt;CmsPage,String&gt; &#123;&#125; 6.2.1.2编写测试类按住要测试的类shift+ctrl+t创建test方法 test下的包路径与main下的包路径保持一致。测试程序使用@SpringBootTest和@RunWith(SpringRunner.class)注解，启动测试类会从main下找springBoot启动类，加载spring容器。测试代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243@SpringBootTest@RunWith(SpringRunner.class)public class CmsPageRepositoryTest &#123; @Autowired CmsPageRepository cmsPageRepository; @Test /** * 查询所有 */ public void testFindAll() &#123; List&lt;CmsPage&gt; all = cmsPageRepository.findAll(); System.out.println(all); &#125; /** * 分页查询 */ @Test public void testFindPage() &#123; int page=0; int size=10; Pageable pageable = PageRequest.of(page, size); Page&lt;CmsPage&gt; all = cmsPageRepository.findAll(pageable); System.out.println(all); &#125; /** * 修改 */ @Test public void testUpdate() &#123; Optional&lt;CmsPage&gt; optional = cmsPageRepository.findById(""); if (optional.isPresent()) &#123; CmsPage cmsPage = optional.get(); cmsPage.setPageName(""); CmsPage save = cmsPageRepository.save(cmsPage); System.out.println(save); &#125; &#125; &#125; 6.2.2 基础方法测试这里Dao接口继承了MongoRepository，在MongoRepository中定义了很多现成的方法，如save、delete等，通过下边的代码来测试这里父类方法。此小节内容请同学们自行测试。 1、添加 123456789101112131415161718//添加@Testpublic void testInsert()&#123; //定义实体类 CmsPage cmsPage = new CmsPage(); cmsPage.setSiteId("s01"); cmsPage.setTemplateId("t01"); cmsPage.setPageName("测试页面"); cmsPage.setPageCreateTime(new Date()); List&lt;CmsPageParam&gt; cmsPageParams = new ArrayList&lt;&gt;(); CmsPageParam cmsPageParam = new CmsPageParam(); cmsPageParam.setPageParamName("param1"); cmsPageParam.setPageParamValue("value1"); cmsPageParams.add(cmsPageParam); cmsPage.setPageParams(cmsPageParams); cmsPageRepository.save(cmsPage); System.out.println(cmsPage);&#125; 2、删除 12345//删除@Testpublic void testDelete() &#123; cmsPageRepository.deleteById("5b17a2c511fe5e0c409e5eb3");&#125; 3、修改 12345678910//修改@Testpublic void testUpdate() &#123; Optional&lt;CmsPage&gt; optional = cmsPageRepository.findOne("5b17a34211fe5e2ee8c116c9"); if(optional.isPresent())&#123; CmsPage cmsPage = optional.get(); cmsPage.setPageName("测试页面01"); cmsPageRepository.save(cmsPage); &#125; &#125; 关于Optional：Optional是jdk1.8引入的类型，Optional是一个容器对象，它包括了我们需要的对象，使用isPresent方法判断所包含对象是否为空，isPresent方法返回false则表示Optional包含对象为空，否则可以使用get()取出对象进行操作。Optional的优点是：1、提醒你非空判断。2、将对象非空检测标准化 6.2.3 自定义Dao方法同Spring Data JPA一样Spring Data mongodb也提供自定义方法的规则，如下：按照findByXXX，findByXXXAndYYY、countByXXXAndYYY等规则定义方法，实现查询操作。 12345678910public interface CmsPageRepository extends MongoRepository&lt;CmsPage,String&gt; &#123; //根据页面名称查询 CmsPage findByPageName(String pageName); //根据页面名称和类型查询 CmsPage findByPageNameAndPageType(String pageName,String pageType); //根据站点和页面类型查询记录数 int countBySiteIdAndPageType(String siteId,String pageType); //根据站点和页面类型分页查询 Page&lt;CmsPage&gt; findBySiteIdAndPageType(String siteId,String pageType, Pageable pageable);&#125; 6.3 Service定义页面查询方法，根据条件查询暂时不实现： 1234567891011121314151617181920212223242526272829@Servicepublic class PageService &#123; @Autowired CmsPageRepository cmsPageRepository; /** * 页面列表分页查询 * @param page 当前页码，页码从1开始计数 * @param size 每页记录数 * @param queryPageRequest 查询条件 * @return 页面列表 */ public QueryResponseResult findList(int page, int size, QueryPageRequest queryPageRequest) &#123; if (page&lt;=0)&#123; page=1; &#125; page=page-1; if (size&lt;=0) &#123; size=10; &#125; Pageable pageable=PageRequest.of(page,size); Page&lt;CmsPage&gt; all = cmsPageRepository.findAll(pageable); QueryResult queryResult = new QueryResult();//数据列表 queryResult.setTotal(all.getTotalElements());//数据总记录数 queryResult.setList(all.getContent()); QueryResponseResult queryResponseResult = new QueryResponseResult(CommonCode.SUCCESS,queryResult); return queryResponseResult; &#125;&#125; 6.4 Controller使用springMVC完成接口实现开发。 1234567891011@RestController@RequestMapping("/cms/page")public class CmsPageController implements CmsPageControllerApi&#123; @Autowired PageService pageService; @Override @GetMapping("/list/&#123;page&#125;/&#123;size&#125;") public QueryResponseResult findList(@PathVariable("page") int page, @PathVariable("size") int size, QueryPageRequest queryPageRequest) &#123; return pageService.findList(page,size,queryPageRequest); &#125;&#125; 使用浏览器测试输入：http://localhost:31001/cms/page/list/1/10 查询第1页，每页显示10条记录 6.6 接口开发规范6.6.1 Api请求及响应规范为了严格按照接口进行开发，提高效率，对请求及响应格式进行规范化。1、get 请求时，采用key/value格式请求，SpringMVC可采用基本类型的变量接收，也可以采用对象接收。2、Post请求时，可以提交form表单数据（application/x-www-form-urlencoded）和Json数据（Content-Type=application/json），文件等多部件类型（multipart/form-data）三种数据格式，SpringMVC接收Json数据使用@RequestBody注解解析请求的json数据。4、响应结果统一信息为：是否成功、操作代码、提示信息及自定义数据。5、响应结果统一格式为json。 6.6.2 Api定义约束Api 定义使用SpringMVC来完成，由于此接口后期将作为微服务远程调用使用，在定义接口时有如下限制：1、@PathVariable 统一指定参数名称，如：@PathVariable(“id”) 2、@RequestParam统一指定参数名称，如：@RequestParam（”id”） 7 页面查询接口测试​ 上边的代码是基于服务端编写接口，如果前端人员等待服务端人员将接口开发完毕再去开发前端内容这样做效率是非常低下的，所以当接口定义完成，可以使用工具生成接口文档，前端人员查看接口文档即可进行前端开发，这样前端和服务人员并行开发，大大提高了生产效率。 本章节介绍两种接口开发工具，Swagger和Postman。 7.1 Swagger7.1.1 Swagger介绍​ OpenAPI规范（OpenAPI Specification 简称OAS）是Linux基金会的一个项目，试图通过定义一种用来描述API格式或API定义的语言，来规范RESTful服务开发过程，目前版本是V3.0，并且已经发布并开源在github上。 （https://github.com/OAI/OpenAPI-Specification） ​ Swagger是全球最大的OpenAPI规范（OAS）API开发工具框架，支持从设计和文档到测试和部署的整个API生命周期的开发。 (https://swagger.io/) ​ Spring Boot 可以集成Swagger，生成Swagger接口，Spring Boot是Java领域的神器，它是Spring项目下快速构建项目的框架。 7.1.2 Swagger常用注解在Java类中添加Swagger的注解即可生成Swagger接口，常用Swagger注解如下： @Api：修饰整个类，描述Controller的作用 @ApiOperation：描述一个类的一个方法，或者说一个接口 @ApiParam：单个参数描述 @ApiModel：用对象来接收参数 @ApiModelProperty：用对象接收参数时，描述对象的一个字段 @ApiResponse：HTTP响应其中1个描述 @ApiResponses：HTTP响应整体描述 @ApiIgnore：使用该注解忽略这个API @ApiError ：发生错误返回的信息 @ApiImplicitParam：一个请求参数 @ApiImplicitParams：多个请求参数 @ApiImplicitParam属性： 属性 取值 作用 paramType 查询参数类型 path 以地址的形式提交数据 query 直接跟参数完成自动映射赋值 body 以流的形式提交 仅支持POST header 参数在request headers 里边提交 form 以form表单的形式提交 仅支持POST dataType 参数的数据类型 只作为标志说明，并没有实际验证 Long String name 接收参数名 value 接收参数的意义描述 required 参数是否必填 true 必填 false 非必填 defaultValue 默认值 7.1.3 Swagger接口定义修改接口工程中页面查询接口，添加Swagger注解。 添加架包 12345678&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;&lt;/dependency&gt; 代码如下 12345678910@Api(value="cms页面管理接口",description = "cms页面管理接口，提供页面的增、删、改、查")public interface CmsPageControllerApi &#123; @ApiOperation("分页查询页面列表") @ApiImplicitParams(&#123; @ApiImplicitParam(name="page",value = "页码",required=true,paramType="path",dataType="int"), @ApiImplicitParam(name="size",value = "每页记录数",required=true,paramType="path",dataType="int") &#125;) public QueryResponseResult findList(int page, int size, QueryPageRequest queryPageRequest) ;&#125; 在QueryPageRequest类中使用注解 ApiModelProperty 对属性注释： 自定义错误 类中使用ApiModelProperty 注解作为提示 12345678910111213141516171819 @Datapublic class QueryPageRequest extends RequestData &#123; //站点id @ApiModelProperty("站点id") private String siteId; //页面ID @ApiModelProperty("页面ID") private String pageId; //页面名称 @ApiModelProperty("页面名称") private String pageName; //页面别名 @ApiModelProperty("页面别名") private String pageAliase; //模版id @ApiModelProperty("模版id") private String templateId;&#125; 7.1.4 Swagger接口测试Swagger接口生成工作原理： 1、系统启动，扫描到api工程中的Swagger2Configuration类 2、在此类中指定了包路径com.xuecheng，找到在此包下及子包下标记有@RestController注解的controller类 3、根据controller类中的Swagger注解生成接口文档。 启动cms服务工程，查看接口文档，请求：http://localhost:31001/swagger-ui.html 点击“分页查询页面列表”，打开接口详情 使用Swagger工具测试服务接口： 1）在cms服务接口中打断点 2）打开接口文档页面，输入请求参数，点击“Try it out”发起请求。 7.5 PostmanPostman是一款功能强大的http接口测试工具，使用postman可以完成http各种请求的功能测试。 官方地址：https://www.getpostman.com/ 1、安装Postman 本教程使用，双击打开 Postman-win64-6.0.10-Setup.exe 新建一个Postman窗口 2、使用postman测试http接口 3、请求参数设置 1） get请求参数设置 2）post请求参数设置 form-data：将表单的数据转为键值对，并且可以包括文件 x-www-form-urlencoded: content-type为application/x-www-from-urlencoded，将表单的数据转为键值对 raw：请求text、json、xml、html，比如如果请求json数据则使用此格式 binary：content-type为application/octet-stream，可用于上传文件。]]></content>
      <categories>
        <category>项目实战-在线学习视频网站</category>
        <category>在线视频网站介绍</category>
      </categories>
      <tags>
        <tag>CMS服务端开发</tag>
        <tag>在线视频架构</tag>
        <tag>Swagger（API开发工具框架）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在线学习视频（四）—— 页面静态化 页面预览]]></title>
    <url>%2Fday04-%E9%A1%B5%E9%9D%A2%E9%9D%99%E6%80%81%E5%8C%96.html</url>
    <content type="text"><![CDATA[页面静态化 页面预览1 页面静态化需求1、为什么要进行页面管理？ ​ 本项目cms系统的功能就是根据运营需要，对门户等子系统的部分页面进行管理，从而实现快速根据用户需求修改页面内容并上线的需求。 2、如何修改页面的内容？ ​ 在开发中修改页面内容是需要人工编写html及JS文件，CMS系统是通过程序自动化的对页面内容进行修改，通过页面静态化技术生成html页面。 3、如何对页面进行静态化？ 一个页面等于模板加数据，在添加页面的时候我们选择了页面的模板。 页面静态化就是将页面模板和数据通过技术手段将二者合二为一，生成一个html网页文件。 4、页面静态化及页面发布流程图如下： 业务流程如下： 1、获取模型数据 2、制作模板 3、对页面进行静态化 4、将静态化生成的html页面存放文件系统中 5、将存放在文件系统的html文件发布到服务器 2 FreeMarker 研究参考“学成在线-freemarker.pdf” 3 页面静态化3.1 页面静态化流程​ 通过上边对FreeMarker的研究我们得出：模板+数据模型=输出，页面静态化需要准备数据模型和模板，先知道数据模型的结构才可以编写模板，因为在模板中要引用数据模型中的数据，本节将系统讲解CMS页面数据模型获取、模板管理及静态化的过程。 下边讨论一个问题：如何获取页面的数据模型？ ​ CMS管理了各种页面，CMS对页面进行静态化时需要数据模型，但是CMS并不知道每个页面的数据模型的具体内容，它只管执行静态化程序便可对页面进行静态化，所以CMS静态化程序需要通过一种通用的方法来获取数据模型。 ​ 在编辑页面信息时指定一个DataUrl，此DataUrl便是获取数据模型的Url，它基于Http方式，CMS对页面进行静态化时会从页面信息中读取DataUrl，通过Http远程调用的方法请求DataUrl获取数据模型。 管理员怎么知道DataUrl的内容呢？ ​ 举例说明： ​ 此页面是轮播图页面，它的DataUrl由开发轮播图管理的程序员提供。 ​ 此页面是精品课程推荐页面，它的DataUrl由精品课程推荐的程序员提供。 ​ 此页面是课程详情页面，它的DataUrl由课程管理的程序员提供。 页面静态化流程如下图： 1、静态化程序首先读取页面获取DataUrl。 2、静态化程序远程请求DataUrl得到数据模型。 3、获取页面模板。 4、执行页面静态化。 3.2 数据模型3.2.1 轮播图DataUrl接口3.2.1.1 需求分析​ CMS中有轮播图管理、精品课程推荐的功能，以轮播图管理为例说明：轮播图管理是通过可视化的操作界面由管理员指定轮播图图片地址，最后将轮播图图片地址保存在cms_config集合中，下边是轮播图数据模型： ​ 针对首页的轮播图信息、精品推荐等信息的获取统一提供一个Url供静态化程序调用，这样我们就知道了轮播图页面、精品课程推荐页面的DataUrl，管理在页面配置中将此Url配置在页面信息中。 本小节开发一个查询轮播图、精品推荐信息的接口，此接口供静态化程序调用获取数据模型。 3.2.1.2 接口定义轮播图信息、精品推荐等信息存储在MongoDB的cms_config集合中。 cms_config有固定的数据结构，如下： 1234567891011@Data@ToString@Document(collection = &quot;cms_config&quot;)public class CmsConfig &#123; @Id private String id;//主键 private String name;//数据模型的名称 private List&lt;CmsConfigModel&gt; model;//数据模型项目&#125; 数据模型项目内容如下： 12345678910@Data@ToStringpublic class CmsConfigModel &#123; private String key;//主键 private String name;//项目名称 private String url;//项目url private Map mapValue;//项目复杂值 private String value;//项目简单值&#125; 上边的模型结构可以对照cms_config中的数据进行分析。 其中，在mapValue 中可以存储一些复杂的数据模型内容。 根据配置信息Id查询配置信息，定义接口如下： 1234567@Api(value=&quot;cms配置管理接口&quot;,description = &quot;cms配置管理接口，提供数据模型的管理、查询接口&quot;)public interface CmsConfigControllerApi &#123; @ApiOperation(&quot;根据id查询CMS配置信息&quot;) public CmsConfig getmodel(String id);&#125; 3.2.1.3 Dao定义CmsConfig的dao接口： 12public interface CmsConfigRepository extends MongoRepository&lt;CmsConfig,String&gt; &#123;&#125; 3.2.1.4 Service定义CmsConfigService实现根据id查询CmsConfig信息。 1234567891011121314@Servicepublic class CmsConfigService &#123; @Autowired CmsConfigRepository cmsConfigRepository; //根据id查询配置管理信息 public CmsConfig getConfigById(String id)&#123; Optional&lt;CmsConfig&gt; optional = cmsConfigRepository.findById(id); if(optional.isPresent())&#123; CmsConfig cmsConfig = optional.get(); return cmsConfig; &#125; return null; &#125;&#125; 3.2.1.5 Controller123456789101112@RestController@RequestMapping(&quot;/cms/config&quot;)public class CmsConfigController implements CmsConfigControllerApi &#123; @Autowired CmsConfigService cmsConfigService; @Override @GetMapping(&quot;/getmodel/&#123;id&#125;&quot;) public CmsConfig getmodel(@PathVariable(&quot;id&quot;) String id) &#123; return cmsConfigService.getConfigById(id); &#125;&#125; 3.2.1.6 测试使用postman测试接口： get请求：http://localhost:31001/cms/config/getmodel/5a791725dd573c3574ee333f （轮播图信息） 3.2.3 远程请求接口​ SpringMVC提供 RestTemplate请求http接口，RestTemplate的底层可以使用第三方的http客户端工具实现http 的请求，常用的http客户端工具有Apache HttpClient、OkHttpClient等，本项目使用OkHttpClient完成http请求，原因也是因为它的性能比较出众。 1、添加依赖 1234&lt;dependency&gt; &lt;groupId&gt;com.squareup.okhttp3&lt;/groupId&gt; &lt;artifactId&gt;okhttp&lt;/artifactId&gt;&lt;/dependency&gt; 2、配置RestTemplate 在SpringBoot启动类中配置 RestTemplate 12345678910public class ManageCmsApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ManageCmsApplication.class,args); &#125; @Bean public RestTemplate restTemplate() &#123; return new RestTemplate(new OkHttp3ClientHttpRequestFactory()); &#125;&#125; 3、测试RestTemplate 根据url获取数据，并转为map格式。 12345@Testpublic void testRestTemplate()&#123; ResponseEntity&lt;Map&gt; forEntity = restTemplate.getForEntity(&quot;http://localhost:31001/cms/config/get/5a791725dd573c3574ee333f&quot;, Map.class); System.out.println(forEntity);&#125; 3.3 模板管理3.3.1 模板管理业务流程CMS提供模板管理功能，业务流程如下： 1、要增加新模板首先需要制作模板，模板的内容就是Freemarker ftl模板内容。 2、通过模板管理模块功能新增模板、修改模板、删除模板。 3、模板信息存储在MongoDB数据库，其中模板信息存储在cms_template集合中，模板文件存储在GridFS文件系统中。 cms_template集合： 下边是一个模板的例子： 12345678&#123; &quot;_id&quot; : ObjectId(&quot;5a962b52b00ffc514038faf7&quot;), &quot;_class&quot; : &quot;com.xuecheng.framework.domain.cms.CmsTemplate&quot;, &quot;siteId&quot; : &quot;5a751fab6abb5044e0d19ea1&quot;, &quot;templateName&quot; : &quot;首页&quot;, &quot;templateParameter&quot; : &quot;&quot;, &quot;templateFileId&quot; : &quot;5a962b52b00ffc514038faf5&quot;&#125; 上边模板信息中templateFileId是模板文件的ID，此ID对应GridFS文件系统中文件ID。 3.3.2 模板制作3.3.2.1 编写模板文件1、轮播图页面原型 在门户的静态工程目录有轮播图的静态页面，路径是：/include/index_banner.html。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;http://www.xuecheng.com/plugins/normalize-css/normalize.css&quot; /&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;http://www.xuecheng.com/plugins/bootstrap/dist/css/bootstrap.css&quot; /&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;http://www.xuecheng.com/css/page-learing-index.css&quot; /&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;http://www.xuecheng.com/css/page-header.css&quot; /&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;banner-roll&quot;&gt; &lt;div class=&quot;banner-item&quot;&gt; &lt;div class=&quot;item&quot; style=&quot;background-image: url(../img/widget-bannerB.jpg);&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot; style=&quot;background-image: url(../img/widget-bannerA.jpg);&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot; style=&quot;background-image: url(../img/widget-banner3.png);&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot; style=&quot;background-image: url(../img/widget-bannerB.jpg);&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot; style=&quot;background-image: url(../img/widget-bannerA.jpg);&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot; style=&quot;background-image: url(../img/widget-banner3.png);&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;indicators&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;http://www.xuecheng.com/plugins/jquery/dist/jquery.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;http://www.xuecheng.com/plugins/bootstrap/dist/js/bootstrap.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; var tg = $(&apos;.banner-item .item&apos;); var num = 0; for (i = 0; i &lt; tg.length; i++) &#123; $(&apos;.indicators&apos;).append(&apos;&lt;span&gt;&lt;/span&gt;&apos;); $(&apos;.indicators&apos;).find(&apos;span&apos;).eq(num).addClass(&apos;active&apos;); &#125; function roll() &#123; tg.eq(num).animate(&#123; &apos;opacity&apos;: &apos;1&apos;, &apos;z-index&apos;: num &#125;, 1000).siblings().animate(&#123; &apos;opacity&apos;: &apos;0&apos;, &apos;z-index&apos;: 0 &#125;, 1000); $(&apos;.indicators&apos;).find(&apos;span&apos;).eq(num).addClass(&apos;active&apos;).siblings().removeClass(&apos;active&apos;); if (num &gt;= tg.length - 1) &#123; num = 0; &#125; else &#123; num++; &#125; &#125; $(&apos;.indicators&apos;).find(&apos;span&apos;).click(function() &#123; num = $(this).index(); roll(); &#125;); var timer = setInterval(roll, 3000); $(&apos;.banner-item&apos;).mouseover(function() &#123; clearInterval(timer) &#125;); $(&apos;.banner-item&apos;).mouseout(function() &#123; timer = setInterval(roll, 3000) &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2、数据模型为： 通过http 获取到数据模型如下： 下图数据模型的图片路径改成可以浏览的正确路径。 123456789101112131415161718192021222324252627&#123; &quot;id&quot;: &quot;5a791725dd573c3574ee333f&quot;, &quot;name&quot;: &quot;轮播图&quot;, &quot;model&quot;: [ &#123; &quot;key&quot;: &quot;banner1&quot;, &quot;name&quot;: &quot;轮播图1地址&quot;, &quot;url&quot;: null, &quot;mapValue&quot;: null, &quot;value&quot;: &quot;http://www.xuecheng.com/img/widget-bannerB.jpg&quot; &#125;, &#123; &quot;key&quot;: &quot;banner2&quot;, &quot;name&quot;: &quot;轮播图2地址&quot;, &quot;url&quot;: null, &quot;mapValue&quot;: null, &quot;value&quot;: &quot;http://www.xuecheng.com/img/widget-bannerA.jpg&quot; &#125;, &#123; &quot;key&quot;: &quot;banner3&quot;, &quot;name&quot;: &quot;轮播图3地址&quot;, &quot;url&quot;: null, &quot;mapValue&quot;: null, &quot;value&quot;: &quot;http://www.xuecheng.com/img/widget-banner3.jpg&quot; &#125; ]&#125; 3、编写模板 在freemarker测试工程中新建模板index_banner.ftl。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;http://www.xuecheng.com/plugins/normalize-css/normalize.css&quot; /&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;http://www.xuecheng.com/plugins/bootstrap/dist/css/bootstrap.css&quot; /&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;http://www.xuecheng.com/css/page-learing-index.css&quot; /&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;http://www.xuecheng.com/css/page-header.css&quot; /&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;banner-roll&quot;&gt; &lt;div class=&quot;banner-item&quot;&gt; &lt;#if model??&gt; &lt;#list model as item&gt; &lt;div class=&quot;item&quot; style=&quot;background-image: url($&#123;item.value&#125;);&quot;&gt;&lt;/div&gt; &lt;/#list&gt; &lt;/#if&gt; &lt;#-- &lt;div class=&quot;item&quot; style=&quot;background-image: url(../img/widget-bannerA.jpg);&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot; style=&quot;background-image: url(../img/widget-banner3.png);&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot; style=&quot;background-image: url(../img/widget-bannerB.jpg);&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot; style=&quot;background-image: url(../img/widget-bannerA.jpg);&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot; style=&quot;background-image: url(../img/widget-banner3.png);&quot;&gt;&lt;/div&gt;--&gt; &lt;/div&gt; &lt;div class=&quot;indicators&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;http://www.xuecheng.com/plugins/jquery/dist/jquery.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;http://www.xuecheng.com/plugins/bootstrap/dist/js/bootstrap.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; var tg = $(&apos;.banner-item .item&apos;); var num = 0; for (i = 0; i &lt; tg.length; i++) &#123; $(&apos;.indicators&apos;).append(&apos;&lt;span&gt;&lt;/span&gt;&apos;); $(&apos;.indicators&apos;).find(&apos;span&apos;).eq(num).addClass(&apos;active&apos;); &#125; function roll() &#123; tg.eq(num).animate(&#123; &apos;opacity&apos;: &apos;1&apos;, &apos;z-index&apos;: num &#125;, 1000).siblings().animate(&#123; &apos;opacity&apos;: &apos;0&apos;, &apos;z-index&apos;: 0 &#125;, 1000); $(&apos;.indicators&apos;).find(&apos;span&apos;).eq(num).addClass(&apos;active&apos;).siblings().removeClass(&apos;active&apos;); if (num &gt;= tg.length - 1) &#123; num = 0; &#125; else &#123; num++; &#125; &#125; $(&apos;.indicators&apos;).find(&apos;span&apos;).click(function() &#123; num = $(this).index(); roll(); &#125;); var timer = setInterval(roll, 3000); $(&apos;.banner-item&apos;).mouseover(function() &#123; clearInterval(timer) &#125;); $(&apos;.banner-item&apos;).mouseout(function() &#123; timer = setInterval(roll, 3000) &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 3.3.2.2 模板测试在freemarker测试工程编写一个方法测试轮播图模板，代码如下： 1234567891011@AutowiredRestTemplate restTemplate;@RequestMapping(&quot;/banner&quot;)public String index_banner(Map&lt;String, Object&gt; map)&#123; String dataUrl = &quot;http://localhost:31001/cms/config/getmodel/5a791725dd573c3574ee333f&quot;; ResponseEntity&lt;Map&gt; forEntity = restTemplate.getForEntity(dataUrl, Map.class); Map body = forEntity.getBody(); map.putAll(body); return &quot;index_banner&quot;;&#125; 请求：http://localhost:8088/freemarker/banner 3.3.3 GridFS研究3.3.3.1 GridFS介绍​ GridFS是MongoDB提供的用于持久化存储文件的模块，CMS使用MongoDB存储数据，使用GridFS可以快速集成开发。 ​ 它的工作原理是： ​ 在GridFS存储文件是将文件分块存储，文件会按照256KB的大小分割成多个块进行存储，GridFS使用两个集合（collection）存储文件，一个集合是chunks, 用于存储文件的二进制数据；一个集合是files，用于存储文件的元数据信息（文件名称、块大小、上传时间等信息）。 ​ 从GridFS中读取文件要对文件的各各块进行组装、合并。 详细参考：https://docs.mongodb.com/manual/core/gridfs/ 3.3.3.2 GridFS存取文件测试1、存文件 使用GridFsTemplate存储文件测试代码： 向测试程序注入GridFsTemplate。 123456789101112@Testpublic void testGridFs() throws FileNotFoundException &#123; //要存储的文件 File file = new File(&quot;d:/index_banner.html&quot;); //定义输入流 FileInputStream inputStram = new FileInputStream(file); //向GridFS存储文件 ObjectId objectId = = gridFsTemplate.store(inputStram, &quot;轮播图测试文件01&quot;, &quot;&quot;); //得到文件ID String fileId = objectId.toString(); System.out.println(file);&#125; 存储原理说明： 文件存储成功得到一个文件id 此文件id是fs.files集合中的主键。 可以通过文件id查询fs.chunks表中的记录，得到文件的内容。 2、读取文件 1）在config包中定义Mongodb的配置类，如下： GridFSBucket用于打开下载流对象 12345678910111213@Configurationpublic class MongoConfig &#123; @Value(&quot;$&#123;spring.data.mongodb.database&#125;&quot;) String db; @Bean public GridFSBucket getGridFSBucket(MongoClient mongoClient)&#123; MongoDatabase database = mongoClient.getDatabase(db); GridFSBucket bucket = GridFSBuckets.create(database); return bucket; &#125;&#125; 2）测试代码如下 123456789101112131415161718192021222324@SpringBootTest@RunWith(SpringRunner.class)public class GridFsTest &#123; @Autowired GridFsTemplate gridFsTemplate; @Autowired GridFSBucket gridFSBucket; @Test public void queryFile() throws IOException &#123; String fileId = &quot;5b9c54e264c614237c271a99&quot;; //根据id查询文件 GridFSFile gridFSFile = gridFsTemplate.findOne(Query.query(Criteria.where(&quot;_id&quot;).is(fileId))); //打开下载流对象 GridFSDownloadStream gridFSDownloadStream = gridFSBucket.openDownloadStream(gridFSFile.getObjectId()); //创建gridFsResource，用于获取流对象 GridFsResource gridFsResource = new GridFsResource(gridFSFile,gridFSDownloadStream); //获取流中的数据 String s = IOUtils.toString(gridFsResource.getInputStream(), &quot;UTF-8&quot;); System.out.println(s); &#125; ... 3、删除文件 123456//删除文件@Testpublic void testDelFile() throws IOException &#123; //根据文件id删除fs.files和fs.chunks中的记录 gridFsTemplate.delete(Query.query(Criteria.where(&quot;_id&quot;).is(&quot;5b32480ed3a022164c4d2f92&quot;)));&#125; 3.3.4 模板存储根据模板管理的流程，最终将模板信息存储到MongoDB的cms_template中，将模板文件存储到GridFS中。 模板管理功能在课堂中不再讲解，教学中手动向cms_template及GridFS中存储模板，方法如下： 1、添加模板 1）使用GridFS测试代码存储模板文件到GridFS，并得到文件id. 2）向cms_template添加记录。 2、删除模板 1）使用GridFS测试代码根据文件id删除模板文件。 2）根据模板id删除cms_template中的记录。 3、修改模板信息 使用Studio 3T修改cms_template中的记录。 4、修改模板文件 1）通过Studio 3T修改模板文件(此方法限文件小于256K) 可以通过Studio 3T修改模板文件，先找到模板文件，再导入进去： 3.4 静态化测试上边章节完成了数据模型和模板管理的测试，下边测试整个页面静态化的流程，流程如下： 1、填写页面DataUrl 在编辑cms页面信息界面填写DataUrl，将此字段保存到cms_page集合中。 2、静态化程序获取页面的DataUrl 3、静态化程序远程请求DataUrl获取数据模型。 4、静态化程序获取页面的模板信息 5、执行页面静态化 3.4.1 填写页面DataUrl修改页面管理模板代码，实现编辑页面DataUrl。 注意：此地址由程序员提供给系统管理员，由系统管理员录入到系统中。 下边实现页面修改界面录入DataUrl： 1、修改页面管理前端的page_edit.vue 在表单中添加dataUrl输入框： 123&lt;el-form-item label=&quot;数据Url&quot; prop=&quot;dataUrl&quot;&gt; &lt;el-input v-model=&quot;pageForm.dataUrl&quot; auto-complete=&quot;off&quot; &gt;&lt;/el-input&gt;&lt;/el-form-item&gt; 2、修改页面管理服务端PageService 在更新cmsPage数据代码中添加： 12//更新dataUrlone.setDataUrl(cmsPage.getDataUrl()); 3.4.2 静态化程序在PageService中定义页面静态化方法，如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495//页面静态化public String getPageHtml(String pageId)&#123; //获取页面模型数据 Map model = this.getModelByPageId(pageId); if(model == null)&#123; //获取页面模型数据为空 ExceptionCast.cast(CmsCode.CMS_GENERATEHTML_DATAISNULL); &#125; //获取页面模板 String templateContent = getTemplateByPageId(pageId); if(StringUtils.isEmpty(templateContent))&#123; //页面模板为空 ExceptionCast.cast(CmsCode.CMS_GENERATEHTML_TEMPLATEISNULL); &#125; //执行静态化 String html = generateHtml(templateContent, model); if(StringUtils.isEmpty(html))&#123; ExceptionCast.cast(CmsCode.CMS_GENERATEHTML_HTMLISNULL); &#125; return html;&#125;//页面静态化public String generateHtml(String template,Map model)&#123; try &#123; //生成配置类 Configuration configuration = new Configuration(Configuration.getVersion()); //模板加载器 StringTemplateLoader stringTemplateLoader = new StringTemplateLoader(); stringTemplateLoader.putTemplate(&quot;template&quot;,template); //配置模板加载器 configuration.setTemplateLoader(stringTemplateLoader); //获取模板 Template template1 = configuration.getTemplate(&quot;template&quot;); String html = FreeMarkerTemplateUtils.processTemplateIntoString(template1, model); return html; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null;&#125;//获取页面模板public String getTemplateByPageId(String pageId)&#123; //查询页面信息 CmsPage cmsPage = this.getById(pageId); if(cmsPage == null)&#123; //页面不存在 ExceptionCast.cast(CmsCode.CMS_PAGE_NOTEXISTS); &#125; //页面模板 String templateId = cmsPage.getTemplateId(); if(StringUtils.isEmpty(templateId))&#123; //页面模板为空 ExceptionCast.cast(CmsCode.CMS_GENERATEHTML_TEMPLATEISNULL); &#125; Optional&lt;CmsTemplate&gt; optional = cmsTemplateRepository.findById(templateId); if(optional.isPresent())&#123; CmsTemplate cmsTemplate = optional.get(); //模板文件id String templateFileId = cmsTemplate.getTemplateFileId(); //取出模板文件内容 GridFSFile gridFSFile = gridFsTemplate.findOne(Query.query(Criteria.where(&quot;_id&quot;).is(templateFileId))); //打开下载流对象 GridFSDownloadStream gridFSDownloadStream = gridFSBucket.openDownloadStream(gridFSFile.getObjectId()); //创建GridFsResource GridFsResource gridFsResource = new GridFsResource(gridFSFile,gridFSDownloadStream); try &#123; String content = IOUtils.toString(gridFsResource.getInputStream(), &quot;utf-8&quot;); return content; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; return null;&#125;//获取页面模型数据public Map getModelByPageId(String pageId)&#123; //查询页面信息 CmsPage cmsPage = this.getById(pageId); if(cmsPage == null)&#123; //页面不存在 ExceptionCast.cast(CmsCode.CMS_PAGE_NOTEXISTS); &#125; //取出dataUrl String dataUrl = cmsPage.getDataUrl(); if(StringUtils.isEmpty(dataUrl))&#123; ExceptionCast.cast(CmsCode.CMS_GENERATEHTML_DATAURLISNULL); &#125; ResponseEntity&lt;Map&gt; forEntity = restTemplate.getForEntity(dataUrl, Map.class); Map body = forEntity.getBody(); return body;&#125; 单元测试getPageHtml方法，过程略。 4 页面预览4.1 页面预览开发4.1.1 需求分析页面在发布前增加页面预览的步骤，方便用户检查页面内容是否正确。页面预览的流程如下： 1、用户进入cms前端，点击“页面预览”在浏览器请求cms页面预览链接。 2、cms根据页面id查询DataUrl并远程请求DataUrl获取数据模型。 3、cms根据页面id查询页面模板内容 4、cms执行页面静态化。 5、cms将静态化内容响应给浏览器。 6、在浏览器展示页面内容，实现页面预览的功能。 4.1.2 搭建环境在cms服务需要集成freemarker： 1、在CMS服务中加入freemarker的依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-freemarker&lt;/artifactId&gt;&lt;/dependency&gt; 2、在application.yml配置freemarker 12345spring: freemarker: cache: false #关闭模板缓存，方便测试 settings: template_update_delay: 0 4.1.3 Service静态化方法在静态化测试章节已经实现。 4.1.4 Controller调用service的静态化方法，将静态化内容通过response输出到浏览器显示 创建CmsPagePreviewController类，用于页面预览： 请求页面id，查询得到页面的模板信息、数据模型url，根据模板和数据生成静态化内容，并输出到浏览器。 1234567891011121314151617181920@Controllerpublic class CmsPagePreviewController extends BaseController &#123; @Autowired PageService pageService; //接收到页面id @RequestMapping(value=&quot;/cms/preview/&#123;pageId&#125;&quot;,method = RequestMethod.GET) public void preview(@PathVariable(&quot;pageId&quot;)String pageId)&#123; String pageHtml = pageService.getPageHtml(pageId); if(StringUtils.isNotEmpty(pageHtml))&#123; try &#123; ServletOutputStream outputStream = response.getOutputStream(); outputStream.write(pageHtml.getBytes(&quot;utf-8&quot;)); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 4.2 页面预览测试4.2.1 配置Nginx代理为了通过nginx请求静态资源（css、图片等），通过nginx代理进行页面预览。 在&lt;www.xuecheng.com&gt;虚拟主机配置： 1234#页面预览location /cms/preview/ &#123; proxy_pass http://cms_server_pool/cms/preview/;&#125; 配置cms_server_pool将请求转发到cms： 1234#cms页面预览 upstream cms_server_pool&#123; server 127.0.0.1:31001 weight=10;&#125; 重新加载nginx 配置文件。 从cms_page找一个页面进行测试。注意：页面配置一定要正确，需设置正确的模板id和dataUrl。 在浏览器打开：http://www.xuecheng.com/cms/preview/5a795ac7dd573c04508f3a56 5a795ac7dd573c04508f3a56：轮播图页面的id 4.2.2 添加“页面预览”链接在页面列表添加“页面预览”链接，修改page_list.vue: 1234&lt;template slot-scope=&quot;page&quot;&gt; &lt;el-button @click=&quot;edit(page.row.pageId)&quot; type=&quot;text&quot; size=&quot;small&quot;&gt;修改&lt;/el-button&gt; &lt;el-button @click=&quot;del(page.row.pageId)&quot; type=&quot;text&quot; size=&quot;small&quot;&gt;删除&lt;/el-button&gt; &lt;el-button @click=&quot;preview(page.row.pageId)&quot; type=&quot;text&quot; size=&quot;small&quot;&gt;页面预览&lt;/el-button&gt; 添加preview方法： 1234//页面预览preview(pageId)&#123; window.open(&quot;http://www.xuecheng.com/cms/preview/&quot;+pageId)&#125;, 效果： 点击轮播图页面的“页面预览”，预览页面效果。]]></content>
      <categories>
        <category>项目实战-在线学习视频网站</category>
      </categories>
      <tags>
        <tag>FreeMarker</tag>
        <tag>RestTemplate远程调用</tag>
        <tag>存储模块GridFs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在线学习视频（十七）—— Spring Security Oauth2 JWT]]></title>
    <url>%2Fday16%20Spring%20Security%20Oauth2.html</url>
    <content type="text"><![CDATA[Spring Security Oauth2 JWT1 用户认证需求分析1.1 用户认证与授权​ 截至目前，项目已经完成了在线学习功能，用户通过在线学习页面点播视频进行学习。如何去记录学生的学习过程呢？要想掌握学生的学习情况就需要知道用户的身份信息，记录哪个用户在什么时间学习什么课程；如果用户要购买课程也需要知道用户的身份信息。所以，去管理学生的学习过程最基本的要实现用户的身份认证。 什么是用户身份认证？ ​ 用户身份认证即用户去访问系统资源时系统要求验证用户的身份信息，身份合法方可继续访问。常见的用户身份认证表现形式有：用户名密码登录，指纹打卡等方式。 什么是用户授权？ ​ 用户认证通过后去访问系统的资源，系统会判断用户是否拥有访问资源的权限，只允许访问有权限的系统资源，没有权限的资源将无法访问，这个过程叫用户授权。 1.2 单点登录需求​ 本项目包括多个子项目，如：学习系统，教学管理中心、系统管理中心等，为了提高用户体验性需要实现用户只认证一次便可以在多个拥有访问权限的系统中访问，这个功能叫做单点登录。 引用百度百科：单点登录（Single Sign On），简称为 SSO，是目前比较流行的企业业务整合的解决方案之一。SSO的定义是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。 下图是SSO的示意图，用户登录学成网一次即可访问多个系统。 1.3 第三方认证需求​ 作为互联网项目难免需要访问外部系统的资源，同样本系统也要访问第三方系统的资源接口，一个场景如下： ​ 一个微信用户没有在学成在线注册，本系统可以通过请求微信系统来验证该用户的身份，验证通过后该用户便可在本系统学习，它的基本流程如下： ​ 从上图可以看出，微信不属于本系统，本系统并没有存储微信用户的账号、密码等信息，本系统如果要获取该用户的基本信息则需要首先通过微信的认证系统（微信认证）进行认证，微信认证通过后本系统便可获取该微信用户的基本信息，从而在本系统将该微信用户的头像、昵称等信息显示出来，该用户便不用在本系统注册却可以直接学习。 什么是第三方认证（跨平台认证）？ 当需要访问第三方系统的资源时需要首先通过第三方系统的认证（例如：微信认证），由第三方系统对用户认证通过，并授权资源的访问权限。 2 用户认证技术方案2.1 单点登录技术方案分布式系统要实现单点登录，通常将认证系统独立抽取出来，并且将用户身份信息存储在单独的存储介质，比如：MySQL、Redis，考虑性能要求，通常存储在Redis中，如下图： 单点登录的特点是： 1、认证系统为独立的系统。 2、各子系统通过Http或其它协议与认证系统通信，完成用户认证。 3、用户身份信息存储在Redis集群。 Java中有很多用户认证的框架都可以实现单点登录： 1、Apache Shiro. 2、CAS 3、Spring security CAS 2.2 Oauth2认证2.2.1 Oauth2认证流程​ 第三方认证技术方案最主要是解决认证协议的通用标准 问题，因为要实现 跨系统认证，各系统之间要遵循一定的接口协议。 ​ OAUTH协议为用户资源的授权提供了一个安全的、开放而又简易的标准。同时，任何第三方都可以使用OAUTH认证服务，任何服务提供商都可以实现自身的OAUTH认证服务，因而OAUTH是开放的。业界提供了OAUTH的多种实现如PHP、JavaScript，Java，Ruby等各种语言开发包，大大节约了程序员的时间，因而OAUTH是简易的。互联网很多服务如Open API，很多大公司如Google，Yahoo，Microsoft等都提供了OAUTH认证服务，这些都足以说明OAUTH标准逐渐成为开放资源授权的标准。 ​ Oauth协议目前发展到2.0版本，1.0版本过于复杂，2.0版本已得到广泛应用。 参考：https://baike.baidu.com/item/oAuth/7153134?fr=aladdin Oauth协议：https://tools.ietf.org/html/rfc6749 下边分析一个Oauth2认证的例子，黑马程序员网站使用微信认证的过程： 1、客户端请求第三方授权 用户进入黑马程序的登录页面，点击微信的图标以微信账号登录系统，用户是自己在微信里信息的资源拥有者。 点击“微信”出现一个二维码，此时用户扫描二维码，开始给黑马程序员授权。 2、资源拥有者同意给客户端授权 资源拥有者扫描二维码表示资源拥有者同意给客户端授权，微信会对资源拥有者的身份进行验证， 验证通过后，微信会询问用户是否给授权黑马程序员访问自己的微信数据，用户点击“确认登录”表示同意授权，微信认证服务器会颁发一个授权码，并重定向到黑马程序员的网站。 3、客户端获取到授权码，请求认证服务器申请令牌 此过程用户看不到，客户端应用程序请求认证服务器，请求携带授权码。 4、认证服务器向客户端响应令牌 认证服务器验证了客户端请求的授权码，如果合法则给客户端颁发令牌，令牌是客户端访问资源的通行证。 此交互过程用户看不到，当客户端拿到令牌后，用户在黑马程序员看到已经登录成功。 5、客户端请求资源服务器的资源 客户端携带令牌访问资源服务器的资源。 黑马程序员网站携带令牌请求访问微信服务器获取用户的基本信息。 6、资源服务器返回受保护资源 资源服务器校验令牌的合法性，如果合法则向用户响应资源信息内容。 注意：资源服务器和认证服务器可以是一个服务也可以分开的服务，如果是分开的服务资源服务器通常要请求认证服务器来校验令牌的合法性。 Oauth2.0认证流程如下： 引自Oauth2.0协议rfc6749 https://tools.ietf.org/html/rfc6749 Oauth2包括以下角色： 1、客户端 本身不存储资源，需要通过资源拥有者的授权去请求资源服务器的资源，比如：学成在线Android客户端、学成在线Web客户端（浏览器端）、微信客户端等。 2、资源拥有者 通常为用户，也可以是应用程序，即该资源的拥有者。 3、授权服务器（也称认证服务器） 用来对资源拥有的身份进行认证、对访问资源进行授权。客户端要想访问资源需要通过认证服务器由资源拥有者授权后方可访问。 4、资源服务器 存储资源的服务器，比如，学成网用户管理服务器存储了学成网的用户信息，学成网学习服务器存储了学生的学习信息，微信的资源服务存储了微信的用户信息等。客户端最终访问资源服务器获取资源信息。 2.2.2 Oauth2在本项目的应用Oauth2是一个标准的开放的授权协议，应用程序可以根据自己的要求去使用Oauth2，本项目使用Oauth2实现如下目标： 1、学成在线访问第三方系统的资源 2、外部系统访问学成在线的资源 3、学成在线前端（客户端） 访问学成在线微服务的资源。 4、学成在线微服务之间访问资源，例如：微服务A访问微服务B的资源，B访问A的资源。 2.3 Spring security Oauth2认证解决方案​ 本项目采用 Spring security + Oauth2完成用户认证及用户授权，Spring security 是一个强大的和高度可定制的身份验证和访问控制框架，Spring security 框架集成了Oauth2协议，下图是项目认证架构图： 1、用户请求认证服务完成认证。 2、认证服务下发用户身份令牌，拥有身份令牌表示身份合法。 3、用户携带令牌请求资源服务，请求资源服务必先经过网关。 4、网关校验用户身份令牌的合法，不合法表示用户没有登录，如果合法则放行继续访问。 5、资源服务获取令牌，根据令牌完成授权。 6、资源服务完成授权则响应资源信息。 3 Spring Security Oauth2研究3.1 目标​ 本项目认证服务基于Spring Security Oauth2进行构建，并在其基础上作了一些扩展，采用JWT令牌机制，并自定义了用户身份信息的内容。 本教程的主要目标是学习在项目中集成Spring Security Oauth2的方法和流程，通过spring Security Oauth2的研究需要达到以下目标： 1、理解Oauth2的授权码认证流程及密码认证的流程。 2、理解spring Security Oauth2的工作流程。 3、掌握资源服务集成spring Security框架完成Oauth2认证的流程。 3.2 搭建认证服务器3.2.1导入基础工程​ 导入“资料”目录下的 xc-service-ucenter-auth工程，该工程是基于Spring Security Oauth2的一个二次封装的工程，导入此工程研究Oauth2认证流程。 3.2.2 创建数据库导入资料目录下的 xc_user.sql，创建用户数据库 以“oauth_”开头的表都是spring Security 自带的表。 本项目中spring Security 主要使用oauth_client_details表： client_id：客户端id resource_ids：资源id（暂时不用） client_secret：客户端密码 scope：范围 access_token_validity：访问token的有效期（秒） refresh_token_validity：刷新token的有效期（秒） authorized_grant_type：授权类型，authorization_code,password,refresh_token,client_credentials 3.3 Oauth2授权码模式3.3.1 Oauth2授权模式Oauth2有以下授权模式： 授权码模式（Authorization Code） 隐式授权模式（Implicit） 密码模式（Resource Owner Password Credentials） 客户端模式（Client Credentials） 其中授权码模式和密码模式应用较多，本小节介绍授权码模式。 3.3.2 授权码授权流程上边例举的黑马程序员网站使用微信认证的过程就是授权码模式，流程如下： 1、客户端请求第三方授权 2、用户(资源拥有者)同意给客户端授权 3、客户端获取到授权码，请求认证服务器申请令牌 4、认证服务器向客户端响应令牌 5、客户端请求资源服务器的资源，资源服务校验令牌合法性，完成授权 6、资源服务器返回受保护资源 3.3.2 申请授权码请求认证服务获取授权码： Get请求：1localhost:40400/auth/oauth/authorize?client_id=XcWebApp&amp;response_type=code&amp;scop=app&amp;redirect_uri=http://localhost 参数列表如下： client_id：客户端id，和授权配置类中设置的客户端id一致。 response_type：授权码模式固定为code scop：客户端范围，和授权配置类中设置的scop一致。 redirect_uri：跳转uri，当授权码申请成功后会跳转到此地址，并在后边带上code参数（授权码）。 首先跳转到登录页面： 输入账号和密码，点击Login。 Spring Security接收到请求会调用UserDetailsService接口的loadUserByUsername方法查询用户正确的密码。 当前导入的基础工程中将正确的密码硬编码为“123”，所以这里账号随意输入，密码输入123即可认证通过。 接下来进入授权页面： 点击“同意”。 接下来返回授权码： 认证服务携带授权码跳转redirect_uri 3.3.3 申请令牌拿到授权码后，申请令牌。 Post请求：http://localhost:40400/auth/oauth/token 参数如下： grant_type：授权类型，填写authorization_code，表示授权码模式 code：授权码，就是刚刚获取的授权码，注意：授权码只使用一次就无效了，需要重新申请。 redirect_uri：申请授权码时的跳转url，一定和申请授权码时用的redirect_uri一致。 此链接需要使用 http Basic认证。 什么是http Basic认证？ http协议定义的一种认证方式，将客户端id和客户端密码按照“客户端ID:客户端密码”的格式拼接，并用base64编码，放在header中请求服务端，一个例子： Authorization：Basic WGNXZWJBcHA6WGNXZWJBcHA= WGNXZWJBcHA6WGNXZWJBcHA= 是用户名:密码的base64编码。 认证失败服务端返回 401 Unauthorized 以上测试使用postman完成： http basic认证： 客户端Id和客户端密码会匹配数据库oauth_client_details表中的客户端id及客户端密码。 Post请求参数： 点击发送： 申请令牌成功： access_token：访问令牌，携带此令牌访问资源 token_type：有MAC Token与Bearer Token两种类型，两种的校验算法不同，RFC 6750建议Oauth2采用 Bearer Token（http://www.rfcreader.com/#rfc6750）。 refresh_token：刷新令牌，使用此令牌可以延长访问令牌的过期时间。 expires_in：过期时间，单位为秒。 scope：范围，与定义的客户端范围一致。 3.3.4 资源服务授权3.3.4.1 资源服务授权流程资源服务拥有要访问的受保护资源，客户端携带令牌访问资源服务，如果令牌合法则可成功访问资源服务中的资源，如下图： 上图的业务流程如下： 1、客户端请求认证服务申请令牌 2、认证服务生成令牌 认证服务采用非对称加密算法，使用私钥生成令牌。 3、客户端携带令牌访问资源服务 客户端在Http header 中添加： Authorization：Bearer 令牌。 4、资源服务请求认证服务校验令牌的有效性 资源服务接收到令牌，使用公钥校验令牌的合法性。 5、令牌有效，资源服务向客户端响应资源信息 3.3.4.2 资源服务授权配置​ 基本上所有微服务都是资源服务，这里我们在课程管理服务上配置授权控制，当配置了授权控制后如要访问课程信息则必须提供令牌。 1、配置公钥 认证服务生成令牌采用非对称加密算法，认证服务采用私钥加密生成令牌，对外向资源服务提供公钥，资源服务使用公钥 来校验令牌的合法性。 将公钥拷贝到 publickey.txt文件中，将此文件拷贝到资源服务工程的classpath下 2、添加依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-oauth2&lt;/artifactId&gt;&lt;/dependency&gt; 4、在config包下创建ResourceServerConfig类： 123456789101112131415161718192021222324252627282930313233343536373839404142@Configuration@EnableResourceServer@EnableGlobalMethodSecurity(prePostEnabled = true, securedEnabled = true)//激活方法上的PreAuthorize注解public class ResourceServerConfig extends ResourceServerConfigurerAdapter &#123; //公钥 private static final String PUBLIC_KEY = &quot;publickey.txt&quot;; //定义JwtTokenStore，使用jwt令牌 @Bean public TokenStore tokenStore(JwtAccessTokenConverter jwtAccessTokenConverter) &#123; return new JwtTokenStore(jwtAccessTokenConverter); &#125; //定义JJwtAccessTokenConverter，使用jwt令牌 @Bean public JwtAccessTokenConverter jwtAccessTokenConverter() &#123; JwtAccessTokenConverter converter = new JwtAccessTokenConverter(); converter.setVerifierKey(getPubKey()); return converter; &#125; /** * 获取非对称加密公钥 Key * @return 公钥 Key */ private String getPubKey() &#123; Resource resource = new ClassPathResource(PUBLIC_KEY); try &#123; InputStreamReader inputStreamReader = new InputStreamReader(resource.getInputStream()); BufferedReader br = new BufferedReader(inputStreamReader); return br.lines().collect(Collectors.joining(&quot;\n&quot;)); &#125; catch (IOException ioe) &#123; return null; &#125; &#125; //Http安全配置，对每个到达系统的http请求链接进行校验 @Override public void configure(HttpSecurity http) throws Exception &#123; //所有请求必须认证通过 http.authorizeRequests().anyRequest().authenticated(); &#125;&#125; 3.3.4.3 资源服务授权测试这里我们测试课程图片查询 get http://localhost:31200/course/coursepic/list/4028e58161bd3b380161bd3bcd2f0000 请求时没有携带令牌则报错： 1234&#123; &quot;error&quot;: &quot;unauthorized&quot;, &quot;error_description&quot;: &quot;Full authentication is required to access this resource&quot;&#125; 请求时携带令牌： 在http header中添加 Authorization： Bearer 令牌 当输入错误的令牌也无法正常访问资源。 3.3.4.4 解决swagger-ui无法访问当课程管理加了授权之后再访问swagger-ui则报错： 修改授权配置类ResourceServerConfig的configure方法： 针对swagger-ui的请求路径进行放行： 1234567891011//Http安全配置，对每个到达系统的http请求链接进行校验@Overridepublic void configure(HttpSecurity http) throws Exception &#123; //所有请求必须认证通过 http.authorizeRequests() //下边的路径放行 .antMatchers(&quot;/v2/api-docs&quot;, &quot;/swagger-resources/configuration/ui&quot;, &quot;/swagger-resources&quot;,&quot;/swagger-resources/configuration/security&quot;, &quot;/swagger-ui.html&quot;,&quot;/webjars/**&quot;).permitAll() .anyRequest().authenticated();&#125; 注意： 通过上边的配置虽然可以访问swagger-ui，但是无法进行单元测试，除非去掉认证的配置或在上边配置中添加所有请求均放行（”/**”）。 3.4 Oauth2密码模式授权密码模式（Resource Owner Password Credentials）与授权码模式的区别是申请令牌不再使用授权码，而是直接通过用户名和密码即可申请令牌。 测试如下： Post请求：http://localhost:40400/auth/oauth/token 参数： grant_type：密码模式授权填写password username：账号 password：密码 并且此链接需要使用 http Basic认证。 上边参数使用x-www-form-urlencoded方式传输，使用postman测试如下： 注意：当令牌没有过期时同一个用户再次申请令牌则不再颁发新令牌。 3.5校验令牌Spring Security Oauth2提供校验令牌的端点，如下： Get: http://localhost:40400/auth/oauth/check_token?token= 参数： token：令牌 使用postman测试如下： 结果如下：1234567891011121314&#123; &quot;companyId&quot;: null, &quot;userpic&quot;: null, &quot;user_name&quot;: &quot;mrt&quot;, &quot;scope&quot;: [ &quot;app&quot; ], &quot;name&quot;: null, &quot;utype&quot;: null, &quot;id&quot;: null, &quot;exp&quot;: 1531254828, &quot;jti&quot;: &quot;6a00f227-4c30-47dc-a959-c0c147806462&quot;, &quot;client_id&quot;: &quot;XcWebApp&quot;&#125; exp：过期时间，long类型，距离1970年的秒数（new Date().getTime()可得到当前时间距离1970年的毫秒数）。 user_name： 用户名 client_id：客户端Id，在oauth_client_details中配置 scope：客户端范围，在oauth_client_details表中配置 jti：与令牌对应的唯一标识 companyId、userpic、name、utype、id：这些字段是本认证服务在Spring Security基础上扩展的用户身份信息 3.5刷新令牌​ 刷新令牌是当令牌快过期时重新生成一个令牌，它于授权码授权和密码授权生成令牌不同，刷新令牌不需要授权码也不需要账号和密码，只需要一个刷新令牌、客户端id和客户端密码。 测试如下： Post：http://localhost:40400/auth/oauth/token 参数： grant_type： 固定为 refresh_token refresh_token：刷新令牌（注意不是access_token，而是refresh_token） 刷新令牌成功，会重新生成新的访问令牌和刷新令牌，令牌的有效期也比旧令牌长。 刷新令牌通常是在令牌快过期时进行刷新。 3.6 JWT研究3.6.1 JWT介绍​ 在介绍JWT之前先看一下传统校验令牌的方法，如下图： ​ 问题： ​ 传统授权方法的问题是用户每次请求资源服务，资源服务都需要携带令牌访问认证服务去校验令牌的合法性，并根据令牌获取用户的相关信息，性能低下。 ​ 解决： ​ 使用JWT的思路是，用户认证通过会得到一个JWT令牌，JWT令牌中已经包括了用户相关的信息，客户端只需要携带JWT访问资源服务，资源服务根据事先约定的算法自行完成令牌校验，无需每次都请求认证服务完成授权。 JWT令牌授权过程如下图： 什么是JWT？ JSON Web Token（JWT）是一个开放的行业标准（RFC 7519），它定义了一种简介的、自包含的协议格式，用于在通信双方传递json对象，传递的信息经过数字签名可以被验证和信任。JWT可以使用HMAC算法或使用RSA的公钥/私钥对来签名，防止被篡改。 官网：https://jwt.io/ 标准：https://tools.ietf.org/html/rfc7519 JWT令牌的优点： 1、jwt基于json，非常方便解析。 2、可以在令牌中自定义丰富的内容，易扩展。 3、通过非对称加密算法及数字签名技术，JWT防止篡改，安全性高。 4、资源服务使用JWT可不依赖认证服务即可完成授权。 缺点： １、JWT令牌较长，占存储空间比较大。 3.6.1.1 令牌结构通过学习JWT令牌结构为自定义jwt令牌打好基础。 JWT令牌由三部分组成，每部分中间使用点（.）分隔，比如：xxxxx.yyyyy.zzzzz Header 头部包括令牌的类型（即JWT）及使用的哈希算法（如HMAC SHA256或RSA） 一个例子如下： 下边是Header部分的内容 123456789101112&#123; &quot;alg&quot;: &quot;HS256&quot;, &quot;typ&quot;: &quot;JWT&quot; &#125; 将上边的内容使用Base64Url编码，得到一个字符串就是JWT令牌的第一部分。 Payload 第二部分是负载，内容也是一个json对象，它是存放有效信息的地方，它可以存放jwt提供的现成字段，比如：iss（签发者）,exp（过期时间戳）, sub（面向的用户）等，也可自定义字段。 此部分不建议存放敏感信息，因为此部分可以解码还原原始内容。 最后将第二部分负载使用Base64Url编码，得到一个字符串就是JWT令牌的第二部分。 一个例子： 123456789101112131415&#123; &quot;sub&quot;: &quot;1234567890&quot;, &quot;name&quot;: &quot;456&quot;, &quot;admin&quot;: true &#125; Signature 第三部分是签名，此部分用于防止jwt内容被篡改。 这个部分使用base64url将前两部分进行编码，编码后使用点（.）连接组成字符串，最后使用header中声明签名算法进行签名。 一个例子： 1234567891011HMACSHA256( base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(payload), secret) base64UrlEncode(header)：jwt令牌的第一部分。 base64UrlEncode(payload)：jwt令牌的第二部分。 secret：签名所使用的密钥。 3.6.3 JWT入门Spring Security 提供对JWT的支持，本节我们使用Spring Security 提供的JwtHelper来创建JWT令牌，校验JWT令牌等操作。 3.6.3.1 生成私钥和公钥JWT令牌生成采用非对称加密算法 1、生成密钥证书 下边命令生成密钥证书，采用RSA 算法每个证书包含公钥和私钥 keytool -genkeypair -alias xckey -keyalg RSA -keypass xuecheng -keystore xc.keystore -storepass xuechengkeystore Keytool 是一个java提供的证书管理工具 -alias：密钥的别名 -keyalg：使用的hash算法 -keypass：密钥的访问密码 -keystore：密钥库文件名，xc.keystore保存了生成的证书 -storepass：密钥库的访问密码 查询证书信息： keytool -list -keystore xc.keystore 删除别名 keytool -delete -alias xckey -keystore xc.keystore 2、导出公钥 openssl是一个加解密工具包，这里使用openssl来导出公钥信息。 安装 openssl：http://slproweb.com/products/Win32OpenSSL.html 安装资料目录下的Win64OpenSSL-1_1_0g.exe 配置openssl的path环境变量，本教程配置在D:\OpenSSL-Win64\bin cmd进入xc.keystore文件所在目录执行如下命令： 1keytool -list -rfc --keystore xc.keystore | openssl x509 -inform pem -pubkey 输入密钥库密码： 下边这一段就是公钥内容： —–BEGIN PUBLIC KEY—–MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAijyxMdq4S6L1Af1rtB8SjCZHNgsQG8JTfGy55eYvzG0B/E4AudR2prSRBvF7NYPL47scRCNPgLnvbQczBHbBug6uOr78qnWsYxHlW6Aa5dI5NsmOD4DLtSw8eX0hFyK5Fj6ScYOSFBz9cd1nNTvx2+oIv0lJDcpQdQhsfgsEr1ntvWterZt/8r7xNN83gHYuZ6TM5MYvjQNBc5qC7Krs9wM7UoQuL+s0X6RlOib7/mcLn/lFLsLDdYQAZkSDx/6+t+1oHdMarChIPYT1sx9Dwj2j2mvFNDTKKKKAq0cv14Vrhz67Vjmz2yMJePDqUi0JYS2r0iIo7n8vN7s83v5uOQIDAQAB—–END PUBLIC KEY—– 将上边的公钥拷贝到文本文件中，合并为一行。 3.6.3.2 生成jwt令牌在认证工程创建测试类，测试jwt令牌的生成与验证。 1234567891011121314151617181920212223242526272829303132//生成一个jwt令牌@Testpublic void testCreateJwt()&#123; //证书文件 String key_location = &quot;xc.keystore&quot;; //密钥库密码 String keystore_password = &quot;xuechengkeystore&quot;; //访问证书路径 ClassPathResource resource = new ClassPathResource(key_location); //密钥工厂 KeyStoreKeyFactory keyStoreKeyFactory = new KeyStoreKeyFactory(resource, keystore_password.toCharArray()); //密钥的密码，此密码和别名要匹配 String keypassword = &quot;xuecheng&quot;; //密钥别名 String alias = &quot;xckey&quot;; //密钥对（密钥和公钥） KeyPair keyPair = keyStoreKeyFactory.getKeyPair(alias,keypassword.toCharArray()); //私钥 RSAPrivateKey aPrivate = (RSAPrivateKey) keyPair.getPrivate(); //定义payload信息 Map&lt;String, Object&gt; tokenMap = new HashMap&lt;&gt;(); tokenMap.put(&quot;id&quot;, &quot;123&quot;); tokenMap.put(&quot;name&quot;, &quot;mrt&quot;); tokenMap.put(&quot;roles&quot;, &quot;r01,r02&quot;); tokenMap.put(&quot;ext&quot;, &quot;1&quot;); //生成jwt令牌 Jwt jwt = JwtHelper.encode(JSON.toJSONString(tokenMap), new RsaSigner(aPrivate)); //取出jwt令牌 String token = jwt.getEncoded(); System.out.println(&quot;token=&quot;+token);&#125; 3.6.3.3 验证jwt令牌123456789101112131415//资源服务使用公钥验证jwt的合法性，并对jwt解码 @Test public void testVerify()&#123; //jwt令牌 String token =&quot;eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHQiOiIxIiwicm9sZXMiOiJyMDEscjAyIiwibmFtZSI6Im1ydCIsImlkIjoiMTIzIn0.KK7_67N5d1Dthd1PgDHMsbi0UlmjGRcm_XJUUwseJ2eZyJJWoPP2IcEZgAU3tUaaKEHUf9wSRwaDgwhrwfyIcSHbs8oy3zOQEL8j5AOjzBBs7vnRmB7DbSaQD7eJiQVJOXO1QpdmEFgjhc_IBCVTJCVWgZw60IEW1_Lg5tqaLvCiIl26K48pJB5f-le2zgYMzqR1L2LyTFkq39rG57VOqqSCi3dapsZQd4ctq95SJCXgGdrUDWtD52rp5o6_0uq-mrbRdRxkrQfsa1j8C5IW2-T4eUmiN3f9wF9JxUK1__XC1OQkOn-ZTBCdqwWIygDFbU7sf6KzfHJTm5vfjp6NIA&quot;; //公钥 String publickey = &quot;-----BEGIN PUBLIC KEY-----MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAijyxMdq4S6L1Af1rtB8SjCZHNgsQG8JTfGy55eYvzG0B/E4AudR2prSRBvF7NYPL47scRCNPgLnvbQczBHbBug6uOr78qnWsYxHlW6Aa5dI5NsmOD4DLtSw8eX0hFyK5Fj6ScYOSFBz9cd1nNTvx2+oIv0lJDcpQdQhsfgsEr1ntvWterZt/8r7xNN83gHYuZ6TM5MYvjQNBc5qC7Krs9wM7UoQuL+s0X6RlOib7/mcLn/lFLsLDdYQAZkSDx/6+t+1oHdMarChIPYT1sx9Dwj2j2mvFNDTKKKKAq0cv14Vrhz67Vjmz2yMJePDqUi0JYS2r0iIo7n8vN7s83v5uOQIDAQAB-----END PUBLIC KEY-----&quot;; //校验jwt Jwt jwt = JwtHelper.decodeAndVerify(token, new RsaVerifier(publickey)); //获取jwt原始内容 String claims = jwt.getClaims(); //jwt令牌 String encoded = jwt.getEncoded(); System.out.println(encoded); &#125; 4 认证接口开发4.1 需求分析用户登录的流程图如下： 执行流程： 1、用户登录，请求认证服务 2、认证服务认证通过，生成jwt令牌，将jwt令牌及相关信息写入Redis，并且将身份令牌写入cookie 3、用户访问资源页面，带着cookie到网关 4、网关从cookie获取token，并查询Redis校验token,如果token不存在则拒绝访问，否则放行 5、用户退出，请求认证服务，清除redis中的token，并且删除cookie中的token 使用redis存储用户的身份令牌有以下作用： 1、实现用户退出注销功能，服务端清除令牌后，即使客户端请求携带token也是无效的。 2、由于jwt令牌过长，不宜存储在cookie中，所以将jwt令牌存储在redis，由客户端请求服务端获取并在客户端存储。 4.2 Redis配置4.2.1 安装Redis1、安装Redis服务 下载Windows版本的redis：https://github.com/MicrosoftArchive/redis/tags 下载Redis-x64-3.2.100版本，解压Redis-x64-3.2.100.zip 进入cmd命令行，进入Redis-x64-3.2.100目录。 运行： 1redis-server redis.windows.conf 出现 下图说明 redis启动成功： 注册为服务： 1redis-server --service-install redis.windows-service.conf --loglevel verbose 刷新服务，会看到多了一个redis服务。 常用的redis服务命令如下： 进入redis安装目录： 卸载服务：redis-server.exe –service-uninstall 开启服务：redis-server.exe –service-start 停止服务：redis-server.exe –service-stop 2、redis-desktop-manager 下载windows版本的redis客户端：https://redisdesktop.com/download 下载redis-desktop-manager-0.9.2.806.exe 安装后启动redis客户端： 配置redis链接： 连接成功： 4.2.2 redis连接配置在认证服务的application.yml文件中添加如下配置： 12345678910111213spring: application: name: xc-service-ucenter-auth redis: host: $&#123;REDIS_HOST:127.0.0.1&#125; port: $&#123;REDIS_PORT:6379&#125; timeout: 5000 #连接超时 毫秒 jedis: pool: maxActive: 3 maxIdle: 3 minIdle: 1 maxWait: -1 #连接池最大等行时间 -1没有限制 4.2.3 测试1234567891011121314151617181920212223@SpringBootTest@RunWith(SpringRunner.class)public class RedisTest &#123; @Autowired private StringRedisTemplate stringRedisTemplate; @Test public void testRedis()&#123; //定义key String key = &quot;user_token:9734b68f-cf5e-456f-9bd6-df578c711390&quot;; //定义Map Map&lt;String,String&gt; mapValue = new HashMap&lt;&gt;(); mapValue.put(&quot;id&quot;,&quot;101&quot;); mapValue.put(&quot;username&quot;,&quot;itcast&quot;); String value = JSON.toJSONString(mapValue); //向redis中存储字符串 stringRedisTemplate.boundValueOps(key).set(value,60, TimeUnit.SECONDS); //读取过期时间，已过期返回-2 Long expire = stringRedisTemplate.getExpire(key); //根据key获取value String s = stringRedisTemplate.opsForValue().get(key); System.out.println(s); &#125;｝ 4.3 认证服务4.3.1 需求分析认证服务需要实现的功能如下： 1、登录接口 前端post提交账号、密码等，用户身份校验通过，生成令牌，并将令牌存储到redis。 将令牌写入cookie。 2、退出接口 校验当前用户的身份为合法并且为已登录状态。 将令牌从redis删除。 删除cookie中的令牌。 业务流程如下： 4.3.2 Api接口12345678910@Api(value = &quot;用户认证&quot;,description = &quot;用户认证接口&quot;)public interface AuthControllerApi &#123; @ApiOperation(&quot;登录&quot;) public LoginResult login(LoginRequest loginRequest); @ApiOperation(&quot;退出&quot;) public ResponseResult logout();&#125; 4.3.3 配置参数在application.yml中配置参数 123456auth: tokenValiditySeconds: 1200 #token存储到redis的过期时间 clientId: XcWebApp clientSecret: XcWebApp cookieDomain: localhost cookieMaxAge: -1 4.3.4 申请令牌测试​ 为了不破坏Spring Security的代码，我们在Service方法中通过RestTemplate请求Spring Security所暴露的申请令牌接口来申请令牌，下边是测试代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263@SpringBootTest@RunWith(SpringRunner.class)public class TestClient &#123; @Autowired LoadBalancerClient loadBalancerClient; @Autowired RestTemplate restTemplate; @Test public void testClient()&#123; //采用客户端负载均衡，从eureka获取认证服务的ip 和端口 ServiceInstance serviceInstance = loadBalancerClient.choose(XcServiceList.XC_SERVICE_UCENTER_AUTH); URI uri = serviceInstance.getUri(); String authUrl = uri+&quot;/auth/oauth/token&quot;; //URI url, HttpMethod method, HttpEntity&lt;?&gt; requestEntity, Class&lt;T&gt; responseType // url就是 申请令牌的url /oauth/token //method http的方法类型 //requestEntity请求内容 //responseType，将响应的结果生成的类型 //请求的内容分两部分 //1、header信息，包括了http basic认证信息 MultiValueMap&lt;String, String&gt; headers = new LinkedMultiValueMap&lt;String, String&gt;(); String httpbasic = httpbasic(&quot;XcWebApp&quot;, &quot;XcWebApp&quot;); //&quot;Basic WGNXZWJBcHA6WGNXZWJBcHA=&quot; headers.add(&quot;Authorization&quot;, httpbasic); //2、包括：grant_type、username、passowrd MultiValueMap&lt;String, String&gt; body = new LinkedMultiValueMap&lt;String, String&gt;(); body.add(&quot;grant_type&quot;,&quot;password&quot;); body.add(&quot;username&quot;,&quot;itcast&quot;); body.add(&quot;password&quot;,&quot;123&quot;); HttpEntity&lt;MultiValueMap&lt;String, String&gt;&gt; multiValueMapHttpEntity = new HttpEntity&lt;MultiValueMap&lt;String, String&gt;&gt;(body, headers); //指定 restTemplate当遇到400或401响应时候也不要抛出异常，也要正常返回值 restTemplate.setErrorHandler(new DefaultResponseErrorHandler()&#123; @Override public void handleError(ClientHttpResponse response) throws IOException &#123; //当响应的值为400或401时候也要正常响应，不要抛出异常 if(response.getRawStatusCode()!=400 &amp;&amp; response.getRawStatusCode()!=401)&#123; super.handleError(response); &#125; &#125; &#125;); //远程调用申请令牌 ResponseEntity&lt;Map&gt; exchange = restTemplate.exchange(authUrl, HttpMethod.POST, multiValueMapHttpEntity, Map.class); Map body1 = exchange.getBody(); System.out.println(body1); &#125; private String httpbasic(String clientId,String clientSecret)&#123; //将客户端id和客户端密码拼接，按“客户端id:客户端密码” String string = clientId+&quot;:&quot;+clientSecret; //进行base64编码 byte[] encode = Base64.encode(string.getBytes()); return &quot;Basic &quot;+new String(encode); &#125;&#125; 4.3.4 Dao暂时使用静态数据，待用户登录调通再连接数据库校验用户信息。 4.3.5 Service调用认证服务申请令牌，并将令牌存储到 redis。 1、AuthToken 创建 AuthToken模型类，存储申请的令牌，包括身份令牌、刷新令牌、jwt令牌 身份令牌：用于校验用户是否认证 刷新令牌：jwt令牌快过期时执行刷新令牌 jwt令牌：用于授权 12345678@Data@ToString@NoArgsConstructorpublic class AuthToken &#123; String access_token;//身份token String refresh_token;//刷新token String jwt_token;//jwt令牌&#125; 申请令牌的service方法如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116@Servicepublic class AuthService &#123; private static final Logger LOGGER = LoggerFactory.getLogger(AuthService.class); @Value(&quot;$&#123;auth.tokenValiditySeconds&#125;&quot;) int tokenValiditySeconds; @Autowired RestTemplate restTemplate; @Autowired LoadBalancerClient loadBalancerClient; @Autowired StringRedisTemplate stringRedisTemplate; //认证方法 public AuthToken login(String username,String password,String clientId,String clientSecret)&#123; //申请令牌 AuthToken authToken = applyToken(username,password,clientId, clientSecret); if(authToken == null)&#123; ExceptionCast.cast(AuthCode.AUTH_LOGIN_APPLYTOKEN_FAIL); &#125; //将 token存储到redis String access_token = authToken.getAccess_token(); String content = JSON.toJSONString(authToken); boolean saveTokenResult = saveToken(access_token, content, tokenValiditySeconds); if(!saveTokenResult)&#123; ExceptionCast.cast(AuthCode.AUTH_LOGIN_TOKEN_SAVEFAIL); &#125; return authToken; &#125; //存储令牌到redis private boolean saveToken(String access_token,String content,long ttl)&#123; //令牌名称 String name = &quot;user_token:&quot; + access_token; //保存到令牌到redis stringRedisTemplate.boundValueOps(name).set(content,ttl, TimeUnit.SECONDS); //获取过期时间 Long expire = stringRedisTemplate.getExpire(name); return expire&gt;0; &#125; //认证方法 private AuthToken applyToken(String username,String password,String clientId,String clientSecret)&#123; //选中认证服务的地址 ServiceInstance serviceInstance = loadBalancerClient.choose(XcServiceList.XC_SERVICE_UCENTER_AUTH); if (serviceInstance == null) &#123; LOGGER.error(&quot;choose an auth instance fail&quot;); ExceptionCast.cast(AuthCode.AUTH_LOGIN_AUTHSERVER_NOTFOUND); &#125; //获取令牌的url String path = serviceInstance.getUri().toString()+&quot;/auth/oauth/token&quot;; //定义body MultiValueMap&lt;String,String&gt; formData = new LinkedMultiValueMap&lt;&gt;(); //授权方式 formData.add(&quot;grant_type&quot;, &quot;password&quot;); //账号 formData.add(&quot;username&quot;,username); //密码 formData.add(&quot;password&quot;, password); //定义头 MultiValueMap&lt;String,String&gt; header = new LinkedMultiValueMap&lt;&gt;(); header.add(&quot;Authorization&quot;, httpbasic(clientId,clientSecret)); //指定 restTemplate当遇到400或401响应时候也不要抛出异常，也要正常返回值 restTemplate.setErrorHandler(new DefaultResponseErrorHandler()&#123; @Override public void handleError(ClientHttpResponse response) throws IOException &#123; //当响应的值为400或401时候也要正常响应，不要抛出异常 if(response.getRawStatusCode()!=400 &amp;&amp; response.getRawStatusCode()!=401)&#123; super.handleError(response); &#125; &#125; &#125;); Map map = null; try &#123; //http请求spring security的申请令牌接口 ResponseEntity&lt;Map&gt; mapResponseEntity = restTemplate.exchange(path, HttpMethod.POST, new HttpEntity&lt;MultiValueMap&lt;String, String&gt;&gt;(formData, header), Map.class); map = mapResponseEntity.getBody(); &#125; catch (RestClientException e) &#123; e.printStackTrace(); LOGGER.error(&quot;request oauth_token_password error: &#123;&#125;&quot;,e.getMessage()); e.printStackTrace(); ExceptionCast.cast(AuthCode.AUTH_LOGIN_APPLYTOKEN_FAIL); &#125; if(map == null || map.get(&quot;access_token&quot;) == null || map.get(&quot;refresh_token&quot;) == null || map.get(&quot;jti&quot;) == null)&#123;//jti是jwt令牌的唯一标识作为用户身份令牌 ExceptionCast.cast(AuthCode.AUTH_LOGIN_APPLYTOKEN_FAIL); &#125; AuthToken authToken = new AuthToken(); //访问令牌(jwt) String jwt_token = (String) map.get(&quot;access_token&quot;); //刷新令牌(jwt) String refresh_token = (String) map.get(&quot;refresh_token&quot;); //jti，作为用户的身份标识 String access_token = (String) map.get(&quot;jti&quot;); authToken.setJwt_token(jwt_token); authToken.setAccess_token(access_token); authToken.setRefresh_token(refresh_token); return authToken; &#125; //获取httpbasic认证串 private String httpbasic(String clientId,String clientSecret)&#123; //将客户端id和客户端密码拼接，按“客户端id:客户端密码” String string = clientId+&quot;:&quot;+clientSecret; //进行base64编码 byte[] encode = Base64.encode(string.getBytes()); return &quot;Basic &quot;+new String(encode); &#125;&#125; 4.3.6 ControllerAuthController代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@RestControllerpublic class AuthController implements AuthControllerApi &#123; @Value(&quot;$&#123;auth.clientId&#125;&quot;) String clientId; @Value(&quot;$&#123;auth.clientSecret&#125;&quot;) String clientSecret; @Value(&quot;$&#123;auth.cookieDomain&#125;&quot;) String cookieDomain; @Value(&quot;$&#123;auth.cookieMaxAge&#125;&quot;) int cookieMaxAge; @Value(&quot;$&#123;auth.tokenValiditySeconds&#125;&quot;) int tokenValiditySeconds; @Autowired AuthService authService; @Override @PostMapping(&quot;/userlogin&quot;) public LoginResult login(LoginRequest loginRequest) &#123; //校验账号是否输入 if(loginRequest == null || StringUtils.isEmpty(loginRequest.getUsername()))&#123; ExceptionCast.cast(AuthCode.AUTH_USERNAME_NONE); &#125; //校验密码是否输入 if(StringUtils.isEmpty(loginRequest.getPassword()))&#123; ExceptionCast.cast(AuthCode.AUTH_PASSWORD_NONE); &#125; AuthToken authToken = authService.login(loginRequest.getUsername(), loginRequest.getPassword(), clientId, clientSecret); //将令牌写入cookie //访问token String access_token = authToken.getAccess_token(); //将访问令牌存储到cookie saveCookie(access_token); return new LoginResult(CommonCode.SUCCESS,access_token); &#125; //将令牌保存到cookie private void saveCookie(String token)&#123; HttpServletResponse response = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getResponse(); //添加cookie 认证令牌，最后一个参数设置为false，表示允许浏览器获取 CookieUtil.addCookie(response, cookieDomain, &quot;/&quot;, &quot;uid&quot;, token, cookieMaxAge, false); &#125; @Override @PostMapping(&quot;/userlogout&quot;) public ResponseResult logout() &#123; return null; &#125;&#125; 4.3.7 登录url放行认证服务默认都要校验用户的身份信息，这里需要将登录url放行。 在WebSecurityConfig类中重写 configure(WebSecurity web)方法，如下： 12345@Overridepublic void configure(WebSecurity web) throws Exception &#123; web.ignoring().antMatchers(&quot;/userlogin&quot;);&#125; 4.3.8 测试认证接口使用postman测试： Post请求：http://localhost:40400/auth/userlogin 4.3.9 测试写入Cookiecookie最终会写到xuecheng.com域名下，可通过nginx代理进行认证，测试cookie是否写成功。 1、配置nginx代理 在ucenter.xuecheng.com下配置代理路径 1234#认证location ^~ /openapi/auth/ &#123; proxy_pass http://auth_server_pool/auth/; &#125; 添加： 1234#认证服务upstream auth_server_pool&#123; server 127.0.0.1:40400 weight=10;&#125; 2、请求：http://ucenter.xuecheng.com/openapi/auth/userlogin 观察cookie写入结果]]></content>
      <categories>
        <category>项目实战-在线学习视频网站</category>
        <category>安全认证</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>JWT</tag>
        <tag>Spring Security</tag>
        <tag>Oauth2</tag>
        <tag>非对称加密算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在线学习视频（十）—— 课程发布]]></title>
    <url>%2Fday10-%E8%AF%BE%E7%A8%8B%E5%8F%91%E5%B8%83%20%E8%AF%BE%E7%A8%8B%E5%8F%91%E5%B8%83.html</url>
    <content type="text"><![CDATA[课程发布1 课程发布1.1 需求分析课程发布后将生成正式的课程详情页面，课程发布后用户即可浏览课程详情页面，并开始课程的学习。 课程发布生成课程详情页面的流程与课程预览业务流程相同，如下： 1、用户进入教学管理中心，进入某个课程的管理界面 2、点击课程发布，前端请求到课程管理服务 3、课程管理服务远程调用CMS生成课程发布页面，CMS将课程详情页面发布到服务器 4、课程管理服务修改课程发布状态为 “已发布”，并向前端返回发布成功 5、用户在教学管理中心点击“课程详情页面”链接，查看课程详情页面内容 1.2 CMS一键发布接口1.2.1 需求分析根据需求分析内容，需要在cms服务增加页面发布接口供课程管理服务调用，此接口的功能如下： 1、接收课程管理服务发布的页面信息 2、将页面信息添加到 数据库（mongodb） 3、对页面信息进行静态化 4、将页面信息发布到服务器 1.2.3 接口定义1、创建响应结果类型 页面发布成功cms返回页面的url 页面Url= cmsSite.siteDomain+cmsSite.siteWebPath+ cmsPage.pageWebPath + cmsPage.pageName123456789@Data@NoArgsConstructor//无参构造器注解public class CmsPostPageResult extends ResponseResult &#123; String pageUrl; public CmsPostPageResult(ResultCode resultCode,String pageUrl) &#123; super(resultCode); this.pageUrl = pageUrl; &#125;&#125; 2、在api工程定义页面发布接口123@ApiOperation(&quot;一键发布页面&quot;)public CmsPostPageResult postPageQuick(CmsPage cmsPage); 2.2.4 Dao1、站点dao 接口中需要获取站点的信息（站点域名、站点访问路径等） 12public interface CmsSiteRepository extends MongoRepository&lt;CmsSite,String&gt; &#123;&#125; 2.2.5 Service1、添加页面，如果已存在则更新页面123456789101112//添加页面，如果已存在则更新页面public CmsPageResult save(CmsPage cmsPage)&#123; //校验页面是否存在，根据页面名称、站点Id、页面webpath查询 CmsPage cmsPage1 = cmsPageRepository.findByPageNameAndSiteIdAndPageWebPath(cmsPage.getPageName(), cmsPage.getSiteId(), cmsPage.getPageWebPath()); if(cmsPage1 !=null)&#123; //更新 return this.update(cmsPage1.getPageId(),cmsPage); &#125;else&#123; //添加 return this.add(cmsPage); &#125;&#125; 2、页面发布方法123456789101112131415161718192021222324252627282930313233343536373839404142//一键发布页面 public CmsPostPageResult postPageQuick(CmsPage cmsPage)&#123; //添加页面 CmsPageResult save = this.save(cmsPage); if(!save.isSuccess())&#123; return new CmsPostPageResult(CommonCode.FAIL,null); &#125; CmsPage cmsPage1 = save.getCmsPage(); //要布的页面id String pageId = cmsPage1.getPageId(); //发布页面 ResponseResult responseResult = this.postPage(pageId); if(!responseResult.isSuccess())&#123; return new CmsPostPageResult(CommonCode.FAIL,null); &#125; //得到页面的url //页面url=站点域名+站点webpath+页面webpath+页面名称 //站点id String siteId = cmsPage1.getSiteId(); //查询站点信息 CmsSite cmsSite = findCmsSiteById(siteId); //站点域名 String siteDomain = cmsSite.getSiteDomain(); //站点web路径 String siteWebPath = cmsSite.getSiteWebPath(); //页面web路径 String pageWebPath = cmsPage1.getPageWebPath(); //页面名称 String pageName = cmsPage1.getPageName(); //页面的web访问地址 String pageUrl = siteDomain+siteWebPath+pageWebPath+pageName; return new CmsPostPageResult(CommonCode.SUCCESS,pageUrl); &#125; //根据id查询站点信息 public CmsSite findCmsSiteById(String siteId)&#123; Optional&lt;CmsSite&gt; optional = cmsSiteRepository.findById(siteId); if(optional.isPresent())&#123; return optional.get(); &#125; return null; &#125; 2.2.6 Controller12345@Override@PostMapping(&quot;/postPageQuick&quot;)public CmsPostPageResult postPageQuick(@RequestBody CmsPage cmsPage) &#123; return pageService.postPageQuick(cmsPage);&#125; 1.3 课程发布接口1.3.1 Api接口此Api接口由课程管理提供，由课程管理前端调用此Api接口，实现课程发布。 在api工程下课程管理包下定义接口：123@ApiOperation(&quot;发布课程&quot;)public CoursePublishResult publish(@PathVariable String id); 1.3.2 创建Feign Client在课程管理工程创建CMS服务页面发布的Feign Client123456@FeignClient(value = XcServiceList.XC_SERVICE_MANAGE_CMS)public interface CmsPageClient &#123; //一键发布页面 @PostMapping(&quot;/cms/page/postPageQuick&quot;) public CmsPostPageResult postPageQuick(CmsPage cmsPage);&#125; 1.3.3 Service1、配置课程发布页面参数 在application.yml中配置1234567course-publish: siteId: 5b30cba5f58b4411fc6cb1e5 templateId: 5ad9a24d68db5239b8fef199 previewUrl: http://www.xuecheng.com/cms/preview/ pageWebPath: /course/detail/ pagePhysicalPath: /course/detail/ dataUrlPre: http://localhost:31200/course/courseview/ siteId：站点id templateId：模板id dataurlPre：数据url的前缀 pageWebPath: 页面的web访问路径 pagePhysicalPath：页面的物理存储路径。 2、Service方法如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667@Value(&quot;$&#123;course-publish.dataUrlPre&#125;&quot;)private String publish_dataUrlPre;@Value(&quot;$&#123;course-publish.pagePhysicalPath&#125;&quot;)private String publish_page_physicalpath;@Value(&quot;$&#123;course-publish.pageWebPath&#125;&quot;)private String publish_page_webpath;@Value(&quot;$&#123;course-publish.siteId&#125;&quot;)private String publish_siteId;@Value(&quot;$&#123;course-publish.templateId&#125;&quot;)private String publish_templateId;@Value(&quot;$&#123;course-publish.previewUrl&#125;&quot;)private String previewUrl;@AutowiredCmsPageClient cmsPageClient; //课程发布 @Transactional public CoursePublishResult publish(String courseId)&#123; //课程信息 CourseBase one = this.findCourseBaseById(courseId); //发布课程详情页面 CmsPostPageResult cmsPostPageResult = publish_page(courseId); if(!cmsPostPageResult.isSuccess())&#123; ExceptionCast.cast(CommonCode.FAIL); &#125; //更新课程状态 CourseBase courseBase = saveCoursePubState(courseId); //课程索引... //课程缓存... //页面url String pageUrl = cmsPostPageResult.getPageUrl(); return new CoursePublishResult(CommonCode.SUCCESS,pageUrl); &#125; //更新课程发布状态 private CourseBase saveCoursePubState(String courseId)&#123; CourseBase courseBase = this.findCourseBaseById(courseId); //更新发布状态 courseBase.setStatus(&quot;202002&quot;); CourseBase save = courseBaseRepository.save(courseBase); return save; &#125; //发布课程正式页面 public CmsPostPageResult publish_page(String courseId)&#123; CourseBase one = this.findCourseBaseById(courseId); //发布课程预览页面 CmsPage cmsPage = new CmsPage(); //站点 cmsPage.setSiteId(publish_siteId);//课程预览站点 //模板 cmsPage.setTemplateId(publish_templateId); //页面名称 cmsPage.setPageName(courseId+&quot;.html&quot;); //页面别名 cmsPage.setPageAliase(one.getName()); //页面访问路径 cmsPage.setPageWebPath(publish_page_webpath); //页面存储路径 cmsPage.setPagePhysicalPath(publish_page_physicalpath); //数据url cmsPage.setDataUrl(publish_dataUrlPre+courseId); //发布页面 CmsPostPageResult cmsPostPageResult = cmsPageClient.postPageQuick(cmsPage); return cmsPostPageResult; &#125; 1.3.4 Controller12345@Override@PostMapping(&quot;/publish/&#123;id&#125;&quot;)public CoursePublishResult publish(@PathVariable String id) &#123; return courseService.publish(id);&#125; 1.4 测试CMS一键发布接口1.4.1 配置虚拟主机在nginx配置课程详情页面的虚拟主机，实现访问：&lt;www.xuecheng.com/course/detail/.....html&gt;。 123456789101112131415161718192021222324#静态资源服务 upstream static_server_pool&#123; server 127.0.0.1:91 weight=10; &#125; server &#123; listen 80; server_name www.xuecheng.com; ssi on; ssi_silent_errors on; #课程预览 location /course/detail/ &#123; proxy_pass http://static_server_pool; &#125; &#125;#学成网静态资源server &#123; listen 91; server_name localhost; #公司信息 location /static/company/ &#123; alias F:/develop/xuecheng/static/company/; &#125; ... cms会将课程预览页面发布到服务器的F:/develop/xuecheng/static/course/detail/下，通过 &lt;www.xuecheng.com/course/detail/&gt;来访问。 1.4.2 新增站点和模板1、新增课程详情页面的站点信息 如果已增加课程详情页面的站点则忽略此步骤。 向cms_site中新增如下信息123456789&#123; &quot;_id&quot; : ObjectId(&quot;5b30b052f58b4411fc6cb1cf&quot;), &quot;_class&quot; : &quot;com.xuecheng.framework.domain.cms.CmsSite&quot;, &quot;siteName&quot; : &quot;课程详情站点&quot;, &quot;siteDomain&quot; : &quot;http://www.xuecheng.com&quot;, &quot;sitePort&quot; : &quot;80&quot;, &quot;siteWebPath&quot; : &quot;&quot;, &quot;siteCreateTime&quot; : ISODate(&quot;2018-02-03T02:34:19.113+0000&quot;)&#125; 2、新增课程详情模板信息 可直接使用前边章节制作的课程详情信息模板。 可以GridFS的测试代码添加模板，如果已添加则不用重复添加。 使用测试GridFS Api将模板文件存储到mongodb:12345678910//文件存储2@Testpublic void testStore2() throws FileNotFoundException &#123; File file = new File(&quot;C:\\Users\\admin\\Desktop\\coursedetail_t.html&quot;); FileInputStream inputStream = new FileInputStream(file); //保存模版文件内容 GridFSFile gridFSFile = gridFsTemplate.store(inputStream, &quot;测试文件&quot;,&quot;&quot;); String fileId = gridFSFile.getId().toString(); System.out.println(fileId);&#125; 1.4.3 单元测试1、启动RabbitMQ服务 2、启动cms服务 3、启动cms_client，注意配置routingKey和队列名称 12345xuecheng: mq: #cms客户端监控的队列名称（不同的客户端监控的队列不能重复） queue: queue_cms_postpage_03 routingKey: 5b30b052f58b4411fc6cb1cf #此routingKey为门户站点ID 1.5 前端开发1.5.1API方法1234/*发布课程*/export const publish = id =&gt; &#123; return http.requestPost(apiUrl+&apos;/course/publish/&apos;+id);&#125; 1.5.2 页面修改 course_pub.vue 添加： 12345678910111213141516171819202122&lt;el-card class=&quot;box-card&quot;&gt; &lt;div slot=&quot;header&quot; class=&quot;clearfix&quot;&gt; &lt;span&gt;课程发布&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;text item&quot;&gt; &lt;div v-if=&quot;course.status == &apos;202001&apos;&quot;&gt; 状态：制作中&lt;br/&gt; &lt;el-button type=&quot;primary&quot; @click.native=&quot;publish&quot; &gt;新课程发布&lt;/el-button&gt; &lt;/div&gt; &lt;div v-else-if=&quot;course.status == &apos;202003&apos;&quot;&gt; 状态：已下线 &lt;br/&gt;&lt;br/&gt; &lt;span&gt;&lt;a :href=&quot;&apos;http://www.xuecheng.com/course/detail/&apos;+this.courseid+&apos;.html&apos;&quot; target=&quot;_blank&quot;&gt;点我查看课程详情页面 &lt;/a&gt; &lt;/span&gt; &lt;/div&gt; &lt;div v-else-if=&quot;course.status == &apos;202002&apos;&quot;&gt; 状态：已发布&lt;br/&gt; &lt;el-button type=&quot;primary&quot; @click.native=&quot;publish&quot; &gt;修改发布&lt;/el-button&gt; &lt;br/&gt;&lt;br/&gt; &lt;span&gt;&lt;a :href=&quot;&apos;http://www.xuecheng.com/course/detail/&apos;+this.courseid+&apos;.html&apos;&quot; target=&quot;_blank&quot;&gt;点我查看课程详情页面 &lt;/a&gt; &lt;/span&gt; &lt;/div&gt; &lt;/div&gt;&lt;/el-card&gt; 发布方法 ,发布成功重新查询课程，如果课程状态已更改则显示课程详情页面的链接。123456789101112131415161718192021222324//发布 publish()&#123; this.$confirm(&apos;课程发布后将不允许回退，是否继续？&apos;, &apos;提示&apos;, &#123;&#125;).then(() =&gt; &#123; courseApi.publish(this.courseid).then((res) =&gt; &#123; if(res.success)&#123; this.$message.error(&apos;发布成功&apos;); //查询课程信息 this.getcourse() &#125;else&#123; this.$message.error(&apos;发布失败&apos;); &#125; &#125;); &#125;); &#125;, //查询课程信息 getcourse()&#123; courseApi.getCoursebaseById(this.courseid).then((res) =&gt; &#123; console.log(res); this.course = res; &#125;); &#125; 在钩子方法中查询课程信息：1234567mounted()&#123; //课程id this.courseid = this.$route.params.courseid; console.log(&quot;courseid=&quot; + this.courseid) //查询课程信息 this.getcourse()&#125;]]></content>
      <categories>
        <category>项目实战-在线学习视频网站</category>
      </categories>
      <tags>
        <tag>Feign远程调用</tag>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CMS服务端开发]]></title>
    <url>%2Fwebpack%E5%AD%A6%E4%B9%A0.html</url>
    <content type="text"><![CDATA[1 webpack开发技术1.1 webpack介绍使用vue.js开发大型应用需要使用webpack打包工具，本节研究webpack的使用方法。 Webpack 是一个前端资源的打包工具，它可以将js、image、css等资源当成一个模块进行打包。 从图中我们可以看出，Webpack 可以将js、css、png等多种静态资源 进行打包，使用webpack有什么好处呢？ 1、模块化开发 程序员在开发时可以分模块创建不同的js、 css等小文件方便开发，最后使用webpack将这些小文件打包成一个文件，减少了http的请求次数。 webpack可以实现按需打包，为了避免出现打包文件过大可以打包成多个文件。 2、 编译typescript、ES6等高级js语法 随着前端技术的强大，开发中可以使用javascript的很多高级版本，比如：typescript、ES6等，方便开发，webpack可以将打包文件转换成浏览器可识别的js语法。 3、CSS预编译 webpack允许在开发中使用Sass 和 Less等原生CSS的扩展技术，通过sass-loader、less-loader将Sass 和 Less的语法编译成浏览器可识别的css语法。 webpack的缺点： 1、配置有些繁琐 2、文档不丰富 1.2 安装webpack1.2.1 安装Node.jswebpack基于node.js运行，首先需要安装node.js。 为什么会有node.js？ ​ 传统意义上的 JavaScript 运行在浏览器上，Chrome 使用的 JavaScript 引擎是 V8，Node.js 是一个运行在服务端的框架，它的底层就使用了 V8 引擎，这样就可以使用javascript去编写一些服务端的程序，这样也就实现了用javaScript去开发 Apache + PHP 以及 Java Servlet所开发的服务端功能，这样做的好处就是前端和后端都采用javascript，即开发一份js程序即可以运行在前端也可以运行的服务端，这样比一个应用使用多种语言在开发效率上要高，不过node.js属于新兴产品，一些公司也在尝试使用node.js完成一些业务领域，node.js基于V8引擎，基于事件驱动机制，在特定领域性能出色，比如用node.js实现消息推送、状态监控等的业务功能非常合适。 下边我们去安装Node.js： 1、下载对应你系统的Node.js版本: https://nodejs.org/en/download/ 推荐下载LTS版本，本教程安装9.4.0。 2、选安装目录进行安装 默认即可 安装完成检查PATH环境变量是否设置了node.js的路径。 3、测试 在命令提示符下输入命令 1node -v 会显示当前node的版本 1.2.2 安装NPM1、自动安装NPM npm全称Node Package Manager，他是node包管理和分发的工具，使用NPM可以对应用的依赖进行管理，NPM的功能和服务端项目构建工具maven差不多，我们通过npm 可以很方便地下载js库，打包js文件。 node.js已经集成了npm工具，在命令提示符输入 npm -v 可查看当前npm版本 2、设置包路径 包路径就是npm从远程下载的js包所存放的路径。 使用 npm config ls 查询NPM管理包路径（NPM下载的依赖包所存放的路径） NPM默认的管理包路径在C:/用户/[用户名]/AppData/Roming/npm/node_meodules，为了方便对依赖包管理，我们将管理包的路径设置在单独的地方，本教程将安装目录设置在node.js的目录下，创建npm_modules和npm_cache，执行下边的命令： 本教程安装node.js在D:\Program Files\nodejs下所以执行命令如下： npm config set prefix “C:\Program Files\nodejs\npm_modules” npm config set cache “c:\Program Files\nodejs\npm_cache” 此时再使用 npm config ls 查询NPM管理包路径发现路径已更改 3、安装cnpm npm默认会去国外的镜像去下载js包，在开发中通常我们使用国内镜像，这里我们使用淘宝镜像 下边我们来安装cnpm： 有时我们使用npm下载资源会很慢，所以我们可以安装一个cnmp(淘宝镜像)来加快下载速度。 输入命令，进行全局安装淘宝镜像。 npm install -g cnpm –registry=https://registry.npm.taobao.org 安装后，我们可以使用以下命令来查看cnpm的版本 cnpm -v nrm ls 查看镜像已经指向taobao 使nrm use XXX切换 镜像 如果nrm没有安装则需要进行全局安装：cnpm install -g nrm 4、非连网环境安装cnpm 从本小节第3步开始就需要连网下载npm包，如果你的环境不能连网在老师的资料文件下有已经下载好的webpack相关包，下边是安装方法。 1）配置环境变量 NODE_HOME = D:\Program Files\nodejs (node.js安装目录) 在PATH变量中添加：%NODE_HOME%;%NODE_HOME%\npm_modules; 2）找到npm包路径 根据上边的安装说明npm包路径被设置到了node.js安装目录下的npm_modules目录。 可以使用npm config ls查看。 拷贝课程资料中的 npm_modules.zip到node.js安装目录，并解压npm_modules.zip覆盖本目录下的npm_modules文件夹。 3）完成上边步骤测试 cnpm -v 1.2.3 安装webpack1、连网安装 webpack安装分为本地安装和全局安装： 本地安装：仅将webpack安装在当前项目的node_modules目录中，仅对当前项目有效。 全局安装：将webpack安装在本机，对所有项目有效，全局安装会锁定一个webpack版本，该版本可能不适用某个项目。全局安装需要添加 -g 参数。 进入webpacktest测试目录目录，运行： 1）本地安装： 只在我的项目中使用webpack，需要进行本地安装，因为项目和项目所用的webpack的版本不一样。本地安装就会将webpack的js包下载到项目下的npm_modeuls目录下。 在门户目录下创建webpack测试目录webpacktest01： npm install –save-dev webpack 或 cnpm install –save-dev webpack npm install –save-dev webpack-cli (4.0以后的版本需要安装webpack-cli) 2）全局安装加-g，如下： 全局安装就将webpack的js包下载到npm的包路径下。 npm install webpack -g 或 cnpm install webpack -g 3）安装webpack指定的版本： 本教程使用webpack3.6.0，安装webpack3.6.0： 进入webpacktest测试目录，运行：cnpm install –save-dev webpack@3.6.0 全局安装：npm install webpack@3.6.0 -g或 cnpm install webpack@3.6.0 -g 2、非连网安装 参考上边 “非连网环境安装cnpm”描述，将课程资料中的 npm_modules.zip到node.js安装目录，并解压npm_modules.zip覆盖本目录下的npm_modules文件夹。 说明：已执行 “非连网环境安装cnpm”下的操作不用重复执行。 测试： 在cmd状态输入webpack，出现如下提示说明 webpack安装成功 1.3 入门程序通过本入门程序体会webpack打包的过程及模块化开发的思想。 1.3.1 需求分析通过入门程序实现对js文件的打包，体会webpack是如何对应用进行模块化管理。 对上边1+1=2的例子使用webpack进行模块化管理 1.3.2 定义模块创建webpacktest01目录，将vue.min.js及vue_02.html拷贝到目录下。 1、定义module01.js 在webpacktest01目录下创建module01.js 将本程序使用的加法运算的js方法抽取到一个js文件，此文件就是一个模块 123456// 定义add函数function add(x, y) &#123; return x + y&#125;// 导出add方法module.exports.add = add; 2、定义main.js 在webpacktest01目录下创建main.js，main.js是本程序的js主文件，包括如下内容： 1、在此文件中会引用module01.js模块 2、引用vue.min.js（它也一个模块） 3、将html页面中构建vue实例的代码放在main.js中。 main.js的代码如下 1234567891011121314151617181920var add = require(&apos;./module01.js&apos;);var Vue = require(&apos;./vue.min&apos;);var VM = new Vue(&#123; el:&quot;#app&quot;,//表示当前vue对象接管app的div区域 data:&#123; name:&apos;黑马程序员&apos;,// 相当于是MVVM中的Model这个角色 num1:0, num2:0, result:0, url:&apos;http://www.itcast.cn&apos; &#125;, methods:&#123; add:function()&#123; //这里使用了导入的module01.js文件中的add方法 this.result = add(Number.parseInt(this.num1),Number.parseInt(this.num2)) alert(this.result) &#125; &#125;&#125;); 1.3.3 打包测试上边将mode01.js模块及main.js主文件编写完成，下边使用webpack对这些js文件进行打包 1、进入程序目录，执行webpack main.js build.js ，这段指令表示将main.js打包输出为 build.js文件 执行完成，观察程序目录是否出现build.js。 2、在html中引用build.js 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:v-on=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;vue.js入门程序&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt;&lt;a v-bind:href=&quot;url&quot;&gt;&lt;span v-text=&quot;name&quot;&gt;&lt;/span&gt;&lt;/a&gt;&lt;input type=&quot;text&quot; v-model=&quot;num1&quot;&gt;+&lt;input type=&quot;text&quot; v-model=&quot;num2&quot;&gt;=&lt;span v-text=&quot;result&quot;&gt;&lt;/span&gt; &lt;button v-on:click=&quot;add&quot;&gt;计算&lt;/button&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src=&quot;build.js&quot;&gt;&lt;/script&gt;&lt;script&gt;&lt;/script&gt;&lt;/html&gt; 3、测试 测试功能： 1）输入任意加数，其和会自动计算 2）点击“计算”会调用module01.js中的add方法 1.3.4 导出多个方法需求分析： 在上边的例子定义subtraction方法实现减法运算，效果如下： 1、定义subtraction方法 在module01.js中定义subtraction方法 12345678function add(x,y)&#123; return x+y;&#125;function subtraction(x,y)&#123; return x-y;&#125;module.exports.add = add;module.exports.subtraction = subtraction; 也可以采用es6的写法，如下： 123456export const add=(x,y)=&gt;&#123; return x+y;&#125;;export const subtraction=(x,y)=&gt;&#123; return x-y;&#125;; 2、使用subtraction方法 在main.js中导入subtraction方法 123456789101112131415161718192021222324var &#123;add,subtraction&#125; = require(&apos;./module01&apos;)//es6写法// import &#123;add,subtraction&#125; from &apos;./module01&apos;var Vue = require(&apos;./vue.min&apos;)var VM = new Vue(&#123; el:&quot;#app&quot;, data:&#123; name:&quot;黑马程序员&quot;, num1:0, num2:0, result:0, url:&quot;http://www.itcast.cn/&quot; &#125;, methods:&#123; add:function()&#123; this.result = add(Number.parseInt(this.num1),Number.parseInt(this.num2)) alert(this.result) &#125;, subtraction:function()&#123; this.result = subtraction(Number.parseInt(this.num1),Number.parseInt(this.num2)) alert(this.result) &#125; &#125;&#125;) 在vuetest_02.html中使用subtraction方法： 1&lt;input type=&quot;button&quot; value=&quot;计算减&quot; v-on:click=&quot;subtraction&quot;&gt; 1.3.5 小结webpack可以将js分模块开发，开发完成对各模块代码打包成一个统一的文件。 前端模块开发的思想和服务端模块开发的思想是一致的，有利于多人协助开发。 1.4 webpack-dev-serverwebpack-dev-server开发服务器，它的功能可以实现热加载 并且自动刷新浏览器。 1.4.1安装配置1、安装webpack-dev-server 1）创建一个新的程序目录 这里我们创建webpacktest02目录，并在目录下创建src目录、dist目录。 将main.js、module01.js、vue.min.js拷贝到src目录。 2）使用 webpack-dev-server需要安装webpack、 webpack-dev-server和 html-webpack-plugin三个包。 cnpm install webpack@3.6.0 webpack-dev-server@2.9.1 html-webpack-plugin@2.30.1 –save-dev 安装完成，会发现程序目录出现一个package.json文件，此文件中记录了程序的依赖。 没有联网的同学拷贝老师提供的node_modules.zip到webpacktest02目录下，解压到node_modules目录下。 目录结构如下： 2、配置webpack-dev-server 在package.json中配置script 123&quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;webpack-dev-server --inline --hot --open --port 5008&quot;&#125;, –inline：自动刷新 –hot：热加载 –port：指定端口 –open：自动在默认浏览器打开 –host：可以指定服务器的 ip，不指定则为127.0.0.1，如果对外发布则填写公网ip地址 package.json的文件内容如下： 12345678910&#123; &quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;webpack-dev-server --inline --hot --open --port 5008&quot; &#125;, &quot;devDependencies&quot;: &#123; &quot;html-webpack-plugin&quot;: &quot;^2.30.1&quot;, &quot;webpack&quot;: &quot;^3.6.0&quot;, &quot;webpack-dev-server&quot;: &quot;^2.9.1&quot; &#125;&#125; devDependencies：开发人员在开发过程中所需要的依赖。 scripts：可执行的命令 1.4.2 配置webpack.config.js在webpacktest02目录下创建 webpack.config.js， webpack.config.js是webpack的配置文件。在此文件中可以配置应用的入口文件、输出配置、插件等，其中要实现热加载自动刷新功能需要配置html-webpack-plugin插件。 html-webpack-plugin的作用是根据html模板在内存生成html文件，它的工作原理是根据模板文件在内存中生成一个index.html文件。 1、配置模板文件 将原来的vue_02.html作为模板文件，为了和内存中的index.html文件名区别，注意将vue_02.html中的script标签去掉，内容如下： 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; xmlns:v-on=&quot;http://www.w3.org/1999/xhtml&quot; xmlns:v-bind=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;vue.js入门程序&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt; &lt;a v-bind:href=&quot;url&quot; target=&quot;_blank&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/a&gt;&lt;input type=&quot;text&quot; v-model=&quot;num1&quot;&gt;+&lt;input type=&quot;text&quot; v-model=&quot;num2&quot;&gt;= &lt;span v-text=&quot;result&quot;&gt;&lt;/span&gt; &lt;input type=&quot;button&quot; value=&quot;计算加&quot; v-on:click=&quot;add&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;计算减&quot; v-on:click=&quot;subtraction&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 2、配置 html-webpack-plugin 在webpack.config.js中配置html-webpack-plugin插件 123456789101112131415var htmlwp = require(&apos;html-webpack-plugin&apos;);module.exports=&#123; entry:&apos;./src/main.js&apos;, //指定打包的入口文件 output:&#123; path : __dirname+&apos;/dist&apos;, // 注意：__dirname表示webpack.config.js所在目录的绝对路径 filename:&apos;build.js&apos; //输出文件 &#125;, plugins:[ new htmlwp(&#123; title: &apos;首页&apos;, //生成的页面标题&lt;head&gt;&lt;title&gt;首页&lt;/title&gt;&lt;/head&gt; filename: &apos;index.html&apos;, //webpack-dev-server在内存中生成的文件名称，自动将build注入到这个页面底部，才能实现自动刷新功能 template: &apos;vue_02.html&apos; //根据index1.html这个模板来生成(这个文件请程序员自己生成) &#125;) ]&#125; 1.4.3 启动启动文件： 1、进入 webpacktest02目录，执行npm run dev 2、使用webstorm，右键package.json文件，选择“Show npm Scripts” 打开窗口： 双击 dev。 注意：dev就是在package.json中配置的webpack dev server命令。 发现启动成功自动打开浏览器。 修改src中的任意文件内容，自动加载并刷新浏览器。 1.5 webpack debug调试使用了webpack之后就不能采用传统js的调试方法在chrome中打断点。 webpack将多个源文件打包成一个文件，并且文件的内容产生了很大的变化，webpack提供devtool进行调试，devtool是基于sourcemap的方式，在调试时会生成一个map文件，其内容记录生成文件和源文件的内容映射，即生成文件中的哪个位置对应源文件中的哪个位置，有了sourcemap就可以在调试时看到源代码。 配置如下： 1、在webpack.config.js中配置： 1devtool: &apos;eval-source-map&apos;, webpack.config.js部分内容如下： 123456789var htmlwp = require(&apos;html-webpack-plugin&apos;);module.exports=&#123; entry:&apos;./src/main.js&apos;, //指定打包的入口文件 output:&#123; path : __dirname+&apos;/dist&apos;, // 注意：__dirname表示webpack.config.js所在目录的绝对路径 filename:&apos;build.js&apos; //输出文件 &#125;, devtool: &apos;eval-source-map&apos;, ...... 2、在js中跟踪代码的位置上添加debugger 一个例子： 在add方法中添加debugger 12345// 定义add函数function add(x, y) &#123; debugger return x + y&#125; 启动应用，刷新页面跟踪代码： 点击“计算” 即进入debugger代码位置，此时可以使用chrome进行调试了。]]></content>
      <categories>
        <category>webpack介绍</category>
      </categories>
      <tags>
        <tag>webpack介绍</tag>
        <tag>webpack-dev-server启动</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[window下安装mongodb]]></title>
    <url>%2Fmongodb%E5%AE%89%E8%A3%85%E5%8F%8A%E5%85%A5%E9%97%A8.html</url>
    <content type="text"><![CDATA[typora-copy-images-to: mongodb_img mongodb安装1 mongodb介绍 2下载mongodb​ MongoDB 提供了可用于 32 位和 64 位系统的预编译二进制包，你可以从MongoDB官网下载安装。 官方地址：https://www.mongodb.com/ 本教程下载3.4版本：http://downloads.mongodb.org/win32/mongodb-win32-x86_64-2008plus-ssl-v3.4-latest-signed.msi 3安装mongodb在win7系统安装mongodb需要vc++运行库，如果没有则会提示“无法启动此程序，因为计算机中丢失VCRUNTIME140.dll”。 去网上下载或使用360安装： 运行 mongodb-win32-x86_64-2008plus-ssl-v3.4-latest-signed.msi 4 启动mongodb创建几个文件夹具体如下：数据库路径（data目录）、日志路径（logs目录）和日志文件（mongo.log文件） 创建配置文件mongo.conf，文件内容如下： 123456789101112#数据库路径 dbpath=d:\MongoDB\Server\3.4\data #日志输出文件路径 logpath=d:\MongoDB\Server\3.4\logs\mongo.log #错误日志采用追加模式 logappend=true #启用日志文件，默认启用 journal=true #这个选项可以过滤掉一些无用的日志信息，若需要调试使用请设置为false quiet=true #端口号 默认为27017 port=27017 安装 MongoDB服务 通过执行bin/mongod.exe，使用–install选项来安装服务，使用–config选项来指定之前创建的配置文件。 cmd进入d:\MongoDB\Server\3.4\bin 1mongod.exe --config &quot;d:\MongoDB\Server\3.4\mongo.conf&quot; --install 启动MongoDB服务 1net start MongoDB 关闭MongoDB服务 1net stop MongoDB 移除MongoDB服务 1&quot; d:\MongoDB\Server\3.4\bin\mongod.exe&quot; --remove 启动mongodb服务， 命令执行后，浏览器中输入http://127.0.0.1:27017看到如下界面即说明启动成功 出现下图说明安装成功 也可以通过bin目录下的mongo.exe连接mongodb 5 安装studio3tstudio3t是mongodb优秀的客户端工具。官方地址在https://studio3t.com/ 下载studio3t 安装并启动： 创建一个新连接： 填写连接信息： 连接成功： 修改字体： 默认Studio3t的字体太小，需要修改字体： 点击菜单：Edit—&gt;Preferences 6 mongodb入门6.1 基础概念在mongodb中是通过数据库、集合、文档的方式来管理数据，下边是mongodb与关系数据库的一些概念对比： SQL术语/概念 MongoDB术语/概念 解释/说明 database database 数据库 table collection 数据库表/集合 row document 数据记录行/文档 column field 数据字段/域 index index 索引 table joins 表连接（MongoDB不支持） primary key primary key 主键,MongoDB自动在每个集合中添加_id的主键 1、一个mongodb实例可以创建多个数据库 2、一个数据库可以创建多个集合 3、一个集合可以包括多个文档。 6.2 连接mongodbmongodb的使用方式是客户服务器模式，即使用一个客户端连接mongodb数据库（服务端）。 1、 命令格式 1mongodb://[username:password@]host1[:port1][,host2[:port2],...[,hostN[:portN]]][/[database][?options]] mongodb:// 固定前缀 username：账号，可不填 password：密码，可不填 host：主机名或ip地址，只有host主机名为必填项。 port：端口，可不填，默认27017 /database：连接某一个数据库 ?options：连接参数，key/value对 例子：123mongodb://localhost 连接本地数据库27017端口mongodb://root:itcast@localhost 使用用户名root密码为itcast连接本地数据库27017端口mongodb://localhost,localhost:27018,localhost:27019，连接三台主从服务器，端口为27017、27018、27019 2、使用mongodb自带的javascript shell（mongo.exe）连接 windows版本的mongodb安装成功，在安装目录下的bin目录有mongo.exe客户端程序 cmd状态执行mongo.exe： 此时就可以输入命令来操作mongodb数据库了，javascript shell可以运行javascript程序。 3、使用studio3T连接 4、使用java程序连接 详细参数：http://mongodb.github.io/mongo-java-driver/3.4/driver/tutorials/connect-to-mongodb/ 添加依赖： 12345&lt;dependency&gt; &lt;groupId&gt;org.mongodb&lt;/groupId&gt; &lt;artifactId&gt;mongo-java-driver&lt;/artifactId&gt; &lt;version&gt;3.4.3&lt;/version&gt;&lt;/dependency&gt; 测试程序： 1234567891011121314151617@Testpublic void testConnection()&#123; //创建mongodb 客户端 MongoClient mongoClient = new MongoClient( &quot;localhost&quot; , 27017 ); //或者采用连接字符串 //MongoClientURI connectionString = new MongoClientURI(&quot;mongodb://root:root@localhost:27017&quot;); //MongoClient mongoClient = new MongoClient(connectionString); //连接数据库 MongoDatabase database = mongoClient.getDatabase(&quot;test&quot;); // 连接collection MongoCollection&lt;Document&gt; collection = database.getCollection(&quot;student&quot;); //查询第一个文档 Document myDoc = collection.find().first(); //得到文件内容 json串 String json = myDoc.toJson(); System.out.println(json);&#125; 6.3 数据库1、查询数据库 show dbs 查询全部数据库 db 显示当前数据库 2、创建数据库 命令格式： 1use DATABASE_NAME 例子： use test02 有test02数据库则切换到此数据库，没有则创建。 注意： ​ 新创建的数据库不显示，需要至少包括一个集合。 3、删除数据库（慎用！！！） 命令格式：1db.dropDatabase() 例子： 删除test02数据库 先切换数据库：use test02 再执行删除：db.dropDatabase() 6.4 集合集合相当于关系数据库中的表，一个数据库可以创建多个集合，一个集合是将相同类型的文档管理起来。 1、创建集合 123db.createCollection(name, options)name: 新创建的集合名称options: 创建参数 2、删除集合 123db.collection.drop()例子：db.student.drop() 删除student集合 6.5 文档6.5.1 插入文档mongodb中文档的格式是json格式，下边就是一个文档，包括两个key：_id主键和name 12 1234&#123; &quot;_id&quot; : ObjectId(&quot;5b2cc4bfa6a44812707739b5&quot;), &quot;name&quot; : &quot;黑马程序员&quot;&#125; 插入命令： 1db.COLLECTION_NAME.insert(document) 每个文档默认以_id作为主键，主键默认类型为ObjectId（对象类型），mongodb会自动生成主键值。 例子： 1db.student.insert(&#123;&quot;name&quot;:&quot;黑马程序员&quot;,&quot;age&quot;:10&#125;) 注意：同一个集合中的文档的key可以不相同！但是建议设置为相同的。 6.5.2 更新文档命令格式： 12345678db.collection.update( &lt;query&gt;, &lt;update&gt;, &lt;options&gt;)query:查询条件，相当于sql语句的where update：更新文档内容options：选项 1、替换文档 将符合条件 “name”:”北京黑马程序”的第一个文档替换为{“name”:”北京黑马程序员”,”age”:10}。 1db.student.update(&#123;&quot;name&quot;:&quot;黑马程序员&quot;&#125;,&#123;&quot;name&quot;:&quot;北京黑马程序员&quot;,&quot;age&quot;:10&#125;) 2、$set修改器 使用$set修改器指定要更新的key，key不存在则创建，存在则更新。 将符合条件 “name”:”北京黑马程序”的所有文档更新name和age的值。 1db.student.update(&#123;&quot;name&quot;:&quot;黑马程序员&quot;&#125;,&#123;$set:&#123;&quot;name&quot;:&quot;北京黑马程序员&quot;,&quot;age&quot;:10&#125;&#125;,&#123;multi:true&#125;) multi：false表示更新第一个匹配的文档，true表示更新所有匹配的文档。 6.5.3 删除文档命令格式： 12db.student.remove(&lt;query&gt;)query：删除条件，相当于sql语句中的where 1、删除所有文档 db.student.remove({}) 2、删除符合条件的文档 db.student.remove({“name”:”黑马程序员”}) 6.5.4 查询文档命令格式： 123db.collection.find(query, projection)query：查询条件，可不填projection：投影查询key，可不填 1、 查询全部 1db.student.find() 2、查询符合条件的记录 查询name等为”黑马程序员”的文档。 1db.student.find(&#123;&quot;name&quot;:&quot;黑马程序员&quot;&#125;) 3、投影查询 只显示name和age两个key，_id主键不显示。 1db.student.find(&#123;&quot;name&quot;:&quot;黑马程序员&quot;&#125;,&#123;name:1,age:1,_id:0&#125;) 6.6 用户6.6.1 创建用户语法格式： 123456789mongo&gt;db.createUser(&#123; user: &quot;&lt;name&gt;&quot;, pwd: &quot;&lt;cleartext password&gt;&quot;, customData: &#123; &lt;any information&gt; &#125;, roles: [ &#123; role: &quot;&lt;role&gt;&quot;, db: &quot;&lt;database&gt;&quot; &#125; | &quot;&lt;role&gt;&quot;, ... ]&#125;) 例子： 创建root用户，角色为root 12345678use admindb.createUser( &#123; user:&quot;root&quot;, pwd:&quot;123&quot;, roles:[&#123;role:&quot;root&quot;,db:&quot;admin&quot;&#125;] &#125; ) 内置角色如下： 数据库用户角色：read、readWrite; 数据库管理角色：dbAdmin、dbOwner、userAdmin； 集群管理角色：clusterAdmin、clusterManager、clusterMonitor、hostManager； 备份恢复角色：backup、restore； 所有数据库角色：readAnyDatabase、readWriteAnyDatabase、userAdminAnyDatabase、dbAdminAnyDatabase 超级用户角色：root 6.6.2 认证登录为了安全需要，Mongodb要打开认证开关，即用户连接Mongodb要进行认证，其中就可以通过账号密码方式进行认证。 1、在mono.conf中设置 auth=true 2、重启Mongodb 3、使用账号和密码连接数据库 1）mongo.exe连接 1mongo.exe -u root -p 123 --authenticationDatabase admin 2）Studio 3T连接 6.6.3 查询用户查询当前库下的所有用户： show users 6.6.4 删除用户语法格式： db.dropUser(“用户名”) 例子： 删除test1用户 db.dropUser(“test1”) 6.6.5 修改用户语法格式： 1234567891011db.updateUser( &quot;&lt;username&gt;&quot;, &#123; customData : &#123; &lt;any information&gt; &#125;, roles : [ &#123; role: &quot;&lt;role&gt;&quot;, db: &quot;&lt;database&gt;&quot; &#125; | &quot;&lt;role&gt;&quot;, ... ], pwd: &quot;&lt;cleartext password&gt;&quot; &#125;, writeConcern: &#123; &lt;write concern&gt; &#125;) 例子： 先创建test1用户： 1234567db.createUser( &#123; user:&quot;test1&quot;, pwd:&quot;test1&quot;, roles:[&#123;role:&quot;root&quot;,db:&quot;admin&quot;&#125;] &#125; ) 修改test1用户的角色为readWriteAnyDatabase 12use admindb.updateUser(&quot;test1&quot;,&#123;roles:[&#123;role:&quot;readWriteAnyDatabase&quot;,db:&quot;admin&quot;&#125;]&#125;) 6.6.6 修改密码语法格式： 1db.changeUserPassword(&quot;username&quot;,&quot;newPasswd&quot;) 例子： 修改test1用户的密码为123 12use admindb.changeUserPassword(&quot;test1&quot;,&quot;123&quot;) 6.6.2.认证登入为了安全需要, Mongodb要打开认证开关,即用户连接Mongodb要进行认证,其中就可以通过账号密码方式进行认证。1、在mono.conf中设置auth=true2、重启Mongodb3、使用账号和密码连接数据库1 ) mongo.exe连接 12# 认证mongo.exe -u root -p cxg200888 --authenticationDatabase admin 2）Studio 3T连接]]></content>
      <categories>
        <category>MongoDB</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis安装]]></title>
    <url>%2Fredis%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE.html</url>
    <content type="text"><![CDATA[redis安装和配置1.安装 下载安装包上次课前资料提供的安装包，或者:官网下载建议上传到我们的home下：/home/leyou/ 解压 12在/home/leyou目录下解压 tar -xvf redis-4.0.9.tar.gz 编译安装 123mv redis-4.0.9 rediscd redismake &amp;&amp; make install 2.配置修改安装目录下的redis.conf文件1vim redis.conf 修改以下配置：123#bind 127.0.0.1 # 将这行代码注释，监听所有的ip地址，外网可以访问protected-mode no # 把yes改成no，允许外网访问daemonize yes # 把no改成yes，后台运行 3.启动或停止redis提供了服务端命令和客户端命令： redis-server 服务端命令，可以包含以下参数：start 启动stop 停止 1如：redis-server redis.conf redis-cli 客户端控制台，包含参数：-h xxx 指定服务端地址，缺省值是127.0.0.1-p xxx 指定服务端端口，缺省值是6379 1redis-cli Windows桌面 4.设置开机启动1) 输入命令，新建文件 1vim /etc/init.d/redis 输入下面内容： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#!/bin/sh# chkconfig: 2345 90 10# description: Redis is a persistent key-value databasePATH=/usr/local/bin:/sbin:/usr/bin:/binREDISPORT=6379EXEC=/usr/local/bin/redis-serverREDIS_CLI=/usr/local/bin/redis-cliPIDFILE=/var/run/redis.pidCONF="/home/leyou/redis/redis.conf"case "$1" in start) if [ -f $PIDFILE ] then echo "$PIDFILE exists, process is already running or crashed" else echo "Starting Redis server..." $EXEC $CONF fi if [ "$?"="0" ] then echo "Redis is running..." fi ;; stop) if [ ! -f $PIDFILE ] then echo "$PIDFILE does not exist, process is not running" else PID=$(cat $PIDFILE) echo "Stopping ..." $REDIS_CLI -p $REDISPORT SHUTDOWN while [ -x $&#123;PIDFILE&#125; ] do echo "Waiting for Redis to shutdown ..." sleep 1 done echo "Redis stopped" fi ;; restart|force-reload) $&#123;0&#125; stop $&#123;0&#125; start ;; *) echo "Usage: /etc/init.d/redis &#123;start|stop|restart|force-reload&#125;" &gt;&amp;2 exit 1 esac 然后保存退出 注意：以下信息需要根据安装目录进行调整： EXEC=/usr/local/bin/redis-server # 执行脚本的地址 REDIS_CLI=/usr/local/bin/redis-cli # 客户端执行脚本的地址 PIDFILE=/var/run/redis.pid # 进程id文件地址 CONF=”/usr/local/src/redis-3.0.2/redis.conf” #配置文件地址 2）设置权限 1chmod 755 /etc/init.d/redis 3）启动测试 1/etc/init.d/redis start 启动成功会提示如下信息： 12Starting Redis server...Redis is running... 4）设置开机自启动 12chkconfig --add /etc/init.d/redischkconfig redis on]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下安装FastDFS]]></title>
    <url>%2Flinux%E4%B8%8B%E5%AE%89%E8%A3%85FastDFS.html</url>
    <content type="text"><![CDATA[1.FastDFS1.1.什么是分布式文件系统分布式文件系统（Distributed File System）是指文件系统管理的物理存储资源不一定直接连接在本地节点上，而是通过计算机网络与节点相连。 通俗来讲： 传统文件系统管理的文件就存储在本机。 分布式文件系统管理的文件存储在很多机器，这些机器通过网络连接，要被统一管理。无论是上传或者访问文件，都需要通过管理中心来访问 1.2.什么是FastDFSFastDFS是由淘宝的余庆先生所开发的一个轻量级、高性能的开源分布式文件系统。用纯C语言开发，功能丰富： 文件存储 文件同步 文件访问（上传、下载） 存取负载均衡 在线扩容 适合有大容量存储需求的应用或系统。同类的分布式文件系统有谷歌的GFS、HDFS（Hadoop）、TFS（淘宝）等。 1.3.FastDFS的架构1.3.1.架构图先上图： FastDFS两个主要的角色：Tracker Server 和 Storage Server 。 Tracker Server：跟踪服务器，主要负责调度storage节点与client通信，在访问上起负载均衡的作用，和记录storage节点的运行状态，是连接client和storage节点的枢纽。 Storage Server：存储服务器，保存文件和文件的meta data（元数据），每个storage server会启动一个单独的线程主动向Tracker cluster中每个tracker server报告其状态信息，包括磁盘使用情况，文件同步情况及文件上传下载次数统计等信息 Group：文件组，多台Storage Server的集群。上传一个文件到同组内的一台机器上后，FastDFS会将该文件即时同步到同组内的其它所有机器上，起到备份的作用。不同组的服务器，保存的数据不同，而且相互独立，不进行通信。 Tracker Cluster：跟踪服务器的集群，有一组Tracker Server（跟踪服务器）组成。 Storage Cluster ：存储集群，有多个Group组成。 1.3.2.上传和下载流程 上传 Client通过Tracker server查找可用的Storage server。 Tracker server向Client返回一台可用的Storage server的IP地址和端口号。 Client直接通过Tracker server返回的IP地址和端口与其中一台Storage server建立连接并进行文件上传。 上传完成，Storage server返回Client一个文件ID，文件上传结束。 下载 Client通过Tracker server查找要下载文件所在的的Storage server。 Tracker server向Client返回包含指定文件的某个Storage server的IP地址和端口号。 Client直接通过Tracker server返回的IP地址和端口与其中一台Storage server建立连接并指定要下载文件。 下载文件成功。 2. Centos下安装FastDFS2.1 安装准备将下面文件上传到linux下的/home/leyou/fdfs目录: FastDFS_v5.08.tar.gz fastdfs-nginx-module_v1.16.tar.gz libevent-2.0.22-stable.tar.gz libfastcommon-master.zip 2.2 安装依赖FastDFS运行需要一些依赖，在课前资料提供的虚拟中已经安装好了这些依赖，如果大家想要从头学习，可以按下面方式安装： 2.2.1 安装GCC依赖GCC用来对C语言代码进行编译运行，使用yum命令安装： 1yum -y install gcc 2.2.2 安装unzip工具unzip工具可以帮我们对压缩包进行解压 1yum install -y unzip zip 2.2.3 安装libevent1yum -y install libevent 2.2.4 安装Nginx所需依赖1yum -y install pcre pcre-devel zlib zlib-devel openssl openssl-devel 2.2.5 安装libfastcommon-master这个没有yum包，只能通过编译安装： 解压刚刚上传的libfastcommon-master.zip 1[root@promote fdfs]# unzip libfastcommon-master.zip 进入解压完成的目录： 1[root@promote fdfs]# cd libfastcommon-master 编译并且安装： 1[root@promote libfastcommon-master]# ./make.sh &amp;&amp; ./make.sh install 到这里为止，所有依赖都已经安装完毕，接下来我们安装FastDFS： 2.3 安装FastDFS2.3.1 编译安装这里我们也采用编译安装，步骤与刚才的编译安装方式一样： 解压 1[root@promote fdfs]# tar -xvf FastDFS_v5.08.tar.gz 进入目录 1[root@promote fdfs]# cd FastDFS 编译并安装 1[root@promote FastDFS]# ./make.sh &amp;&amp; ./make.sh install 校验安装结果 1）安装完成，我们应该能在/etc/init.d/目录，通过命令ll /etc/init.d/ | grep fdfs看到FastDFS提供的启动脚本： 其中： fdfs_trackerd 是tracker启动脚本 fdfs_storaged 是storage启动脚本 2）我们可以在 /etc/fdfs目录，通过命令查看到以下配置文件模板： 其中： tarcker.conf.sample 是tracker的配置文件模板 storage.conf.sample 是storage的配置文件模板 client.conf.sample 是客户端的配置文件模板 2.3.2 /etc/fdfs中修改trackerFastDFS的tracker和storage在刚刚的安装过程中，都已经被安装了，因此我们安装这两种角色的方式是一样的。不同的是，两种需要不同的配置文件。 我们要启动tracker，就修改刚刚看到的tarcker.conf，并且启动fdfs_trackerd脚本即可。 编辑tracker配置 首先我们将模板文件进行赋值和重命名： 123[root@promote ~]# cd /etc/fdfs/[root@promote fdfs]# cp tracker.conf.sample tracker.conf [root@promote fdfs]# vim tracker.conf 打开tracker.conf，修改base_path配置： 1base_path=/leyou/fdfs/tracker # tracker的数据和日志存放目录 创建目录 刚刚配置的目录可能不存在，我们在根目录上创建leyou 出来 1[root@promote fdfs]# mkdir -p /leyou/fdfs/tracker 启动tracker 我们可以使用 sh /etc/init.d/fdfs_trackerd 启动，不过安装过程中，fdfs已经被设置为系统服务，我们可以采用熟悉的服务启动方式： 1[root@promote fdfs]# service fdfs_trackerd start # 启动fdfs_trackerd服务，停止用stop 查看是否运行 1[root@promote fdfs]# ps -ef | grep fdfs 另外，我们可以通过以下命令，设置tracker开机启动： 1chkconfig fdfs_trackerd on 2.3.3 /etc/fdfs中启动storage我们要启动tracker，就修改刚刚看到的tarcker.conf，并且启动fdfs_trackerd脚本即可。 编辑storage配置 首先我们将模板文件进行赋值和重命名： 123 在etc/fdfs目录下[root@promote fdfs]# cp storage.conf.sample storage.conf[root@promote fdfs]# vim storage.conf 打开storage.conf，修改base_path配置： 123base_path=/leyou/fdfs/storage # storage的数据和日志存放目录store_path0=/leyou/fdfs/storage # storage的上传文件存放路径tracker_server=192.168.56.101:22122 # tracker的地址（服务器IP地址192.168.25.128） 创建目录 刚刚配置的目录可能不存在，我们创建出来 1[root@promote fdfs]# mkdir -p /leyou/fdfs/storage 启动storage 我们可以使用 sh /etc/init.d/fdfs_storaged 启动，同样我们可以用服务启动方式： 1[root@promote fdfs]# service fdfs_storaged start # 启动fdfs_storaged服务，停止用stop 另外，我们可以通过以下命令，设置tracker开机启动： 1[root@promote fdfs]# chkconfig fdfs_storaged on 最后，通过ps -ef | grep fdfs 查看进程： 2.3.4.测试上传进入/etc/fdfs目录，修改client.config 修改配置 12tracker_service=192.168.25.128:22122base_path=/image #要上传的文件目录 运行： /usr/bin/fdfs_upload_file：脚本 /etc/fdfs/client.conf ：配置文件 /image：要上传文件的 目录 1[root@promote fdfs]# /usr/bin/fdfs_upload_file /etc/fdfs/client.conf /image/1.jpg 成功后返回图片的id： group1/M00/00/00/wKgZgFwDWcGASgnlAAE74lc0orE837.jpg group1：组信息 M00：对应store_path0 /00/00：磁盘路径 2.4 安装Nginx及FastDFS模块2.4.1 FastDFS的Nginx模块 解压/home/leyou/fdfs下的 1[root@promote fdfs]# tar -xvf fastdfs-nginx-module_v1.16.tar.gz 配置config文件 123456# 进入配置目录[root@promote fdfs]# cd /home/leyou/fdfs/fastdfs-nginx-module/src/# 修改配置[root@promote src]# vim config# 执行下面命令（将配置中的/usr/local改为/usr）：:%s+/usr/local/+/usr/+g 配置mod_fastdfs.conf 1234# 将src目录下的mod_fastdfs.conf复制到 /etc/fdfs目录：[root@promote src]# cp mod_fastdfs.conf /etc/fdfs/# 编辑该文件[root@promote src]# vim /etc/fdfs/mod_fastdfs.cof 修改一下配置： 1234connect_timeout=10 # 客户端访问文件连接超时时长（单位：秒）tracker_server=192.168.25.128:22122 # tracker服务IP和端口url_have_group_name=true # 访问链接前缀加上组名store_path0=/leyou/fdfs/storage # 文件存储路径 复制 FastDFS的部分配置文件到/etc/fdfs目录 12[root@promote src]# cd /home/leyou/fdfs/FastDFS/conf/[root@promote conf]# http.conf mime.types /etc/fdfs/ 2.4.2 配置Nginx已经安装了nginx中配置 配置 在/home/leyou/nginx目录下 1[root@promote nginx]# ./configure --prefix=/opt/nginx --sbin-path=/usr/bin/nginx --add-module=/home/leyou/fdfs/fastdfs-nginx-module/src 编译安装 1[root@promote nginx]# make 备份之前的/usr/bin/nginx 1[root@promote nginx]# mv /usr/bin/nginx /usr/bin/nginx-bck 用刚刚编译的nginx替换之前安装的nginx 1[root@promote nginx]# cp /home/leyou/nginx/objs/nginx /usr/bin/ 配置nginx整合fastdfs-module模块 我们需要修改nginx配置文件，在/opt/nginx/config/nginx.conf文件中： 1[root@promote nginx]# vim /opt/nginx/conf/nginx.conf 将文件中，添加如下代码： 1234567891011121314151617181920server &#123; listen 80; server_name image.taotao.com; # 监听域名中带有group的，交给FastDFS模块处理 location ~/group([0-9])/ &#123; ngx_fastdfs_module; &#125; location / &#123; root html; index index.html index.htm; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; &#125; 启动 1234[root@promote objs]# nginx # 启动ngx_http_fastdfs_set pid=8152 # 启动成功[root@promote objs]# nginx -s stop # 停止[root@promote objs]# nginx -s reload # 重新加载配置 测试 http://image.leyou.com/group1/M00/00/00/wKgZgFwDWcGASgnlAAE74lc0orE837.jpg 设置nginx开机启动 创建一个开机启动的脚本： 1[root@promote nginx]# vim /etc/init.d/nginx 添加以下内容： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131#!/bin/sh## nginx - this script starts and stops the nginx daemon## chkconfig: - 85 15# description: NGINX is an HTTP(S) server, HTTP(S) reverse \# proxy and IMAP/POP3 proxy server# processname: nginx# config: /etc/nginx/nginx.conf# config: /etc/sysconfig/nginx# pidfile: /var/run/nginx.pid# Source function library.. /etc/rc.d/init.d/functions# Source networking configuration.. /etc/sysconfig/network# Check that networking is up.[ "$NETWORKING" = "no" ] &amp;&amp; exit 0#nginx脚本地址nginx="/usr/bin/nginx"prog=$(basename $nginx)#nginx配置目录NGINX_CONF_FILE="/opt/nginx/conf/nginx.conf"[ -f /etc/sysconfig/nginx ] &amp;&amp; . /etc/sysconfig/nginxlockfile=/var/lock/subsys/nginxmake_dirs() &#123; # make required directories user=`$nginx -V 2&gt;&amp;1 | grep "configure arguments:.*--user=" | sed 's/[^*]*--user=\([^ ]*\).*/\1/g' -` if [ -n "$user" ]; then if [ -z "`grep $user /etc/passwd`" ]; then useradd -M -s /bin/nologin $user fi options=`$nginx -V 2&gt;&amp;1 | grep 'configure arguments:'` for opt in $options; do if [ `echo $opt | grep '.*-temp-path'` ]; then value=`echo $opt | cut -d "=" -f 2` if [ ! -d "$value" ]; then # echo "creating" $value mkdir -p $value &amp;&amp; chown -R $user $value fi fi done fi&#125;start() &#123; [ -x $nginx ] || exit 5 [ -f $NGINX_CONF_FILE ] || exit 6 make_dirs echo -n $"Starting $prog: " daemon $nginx -c $NGINX_CONF_FILE retval=$? echo [ $retval -eq 0 ] &amp;&amp; touch $lockfile return $retval&#125;stop() &#123; echo -n $"Stopping $prog: " killproc $prog -QUIT retval=$? echo [ $retval -eq 0 ] &amp;&amp; rm -f $lockfile return $retval&#125;restart() &#123; configtest || return $? stop sleep 1 start&#125;reload() &#123; configtest || return $? echo -n $"Reloading $prog: " killproc $nginx -HUP RETVAL=$? echo&#125;force_reload() &#123; restart&#125;configtest() &#123; $nginx -t -c $NGINX_CONF_FILE&#125;rh_status() &#123; status $prog&#125;rh_status_q() &#123; rh_status &gt;/dev/null 2&gt;&amp;1&#125;case "$1" in start) rh_status_q &amp;&amp; exit 0 $1 ;; stop) rh_status_q || exit 0 $1 ;; restart|configtest) $1 ;; reload) rh_status_q || exit 7 $1 ;; force-reload) force_reload ;; status) rh_status ;; condrestart|try-restart) rh_status_q || exit 0 ;; *) echo $"Usage: $0 &#123;start|stop|status|restart|condrestart|try-restart|reload|force-reload|configtest&#125;" exit 2esac 修改文件权限，并加入服务列表 1234# 修改权限（最高）chmod 777 /etc/init.d/nginx # 添加到服务列表chkconfig --add /etc/init.d/nginx 设置开机启动 1chkconfig nginx on]]></content>
      <categories>
        <category>分布式文件系统</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>FastDFS</tag>
        <tag>分布式文件系统</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx安装]]></title>
    <url>%2FNginx%E7%9A%84%E5%AE%89%E8%A3%85.html</url>
    <content type="text"><![CDATA[nginx的介绍Nginx是一款高性能的http 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器。由俄罗斯的程序设计师Igor Sysoev所开发，官方测试nginx能够支支撑5万并发链接，并且cpu、内存等资源消耗却非常低，运行非常稳定。 安装准备 虚拟机VM Linux CentOs6.8系统 电脑 安装依赖需要安装gcc的环境1[root@localhost ~]# yum install gcc-c++ 第三方的开发包 PCRE:​PCRE，(Perl Compatible Regular Expressions)是一个Perl库，包括 perl兼容的正则表达式库。nginx的http模块使用pcre来解析正则表达式 1[root@localhost ~]# yum install -y pcre pcre-devel zlib:zlib库提供了很多种压缩和解压缩的方式，nginx使用zlib对http包的内容进行gzip，所以需要在linux上安装zlib库。 1[root@localhost ~]# yum install -y zlib zlib-devel openssl:OpenSSL 是一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及SSL协议，并提供丰富的应用程序供测试或其它目的使用。nginx不仅支持http协议，还支持https（即在ssl协议上传输http），所以需要在linux安装openssl库。 1[root@localhost ~]# yum install -y openssl openssl-devel 下载nginxhttp://nginx.org/download/为nginx下载地址 1[root@localhost ~]# wget http://nginx.org/download/nginx-1.10.0.tar.gz 安装nginx 创建一个work文件: 12[root@localhost home]# mkdir work 将nginx-1.10.0.tar.gz 复制到/home/work目录下 1[root@localhost ~]# cp nginx-1.10.0.tar.gz /home/work 解压nginx： 1[root@localhost work]# tar -xvf nginx-1.10.0.tar.gz 改名字： 1[root@localhost work]# mv nginx-1.10.0 nginx 配置nginx:安装目录是/opt/nginx 1234//进入解压好的nginx[root@localhost work]#cd nginx//安装[root@localhost nginx]# ./configure --prefix=/opt/nginx --sbin-path=/usr/bin/nginx 编译安装: 1[root@localhost nginx]# make &amp;&amp; make install 启动： 1[root@localhost nginx]# nginx 测试输入linux的ip地址 停止和重新加载在存放nginx的目录下/home/leyou/nginx操作 停止：1[root@localhost nginx]# nginx -s stop 重新加载：1[root@localhost nginx]# nginx -s reload]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
</search>
