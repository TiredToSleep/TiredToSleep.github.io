<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[微服务商城（十八）—— 购物车]]></title>
    <url>%2Fday17.html</url>
    <content type="text"><![CDATA[1.购物车功能分析1.1.需求需求描述： 用户可以在登录状态下将商品添加到购物车 放入数据库 放入redis（采用） 用户可以在未登录状态下将商品添加到购物车 放入localstorage 用户可以使用购物车一起结算下单 用户可以查询自己的购物车 用户可以在购物车中修改购买商品的数量。 用户可以在购物车中删除商品。 在购物车中展示商品优惠信息 提示购物车商品价格变化 对商品结算下单 1.2.业务分析在需求描述中，不管用户是否登入，都需要实现加入购物车功能，那么已登入下，购物车数据应该存放在哪里呢？ 未登入购物车 用户如果未登录，将数据保存在服务端存在一些问题： 无法确定用户身份，需要借助与客户端存储识别身份 服务端数据存储压力增加，而且可能是无效数据 那么我们应该用把数据保存在客户端，这样每个用户保存自己的数据，就不存在身份识别的问题了，而且也解决了服务端数据存储压力问题。 已登入购物车 用户登录时，数据保存在哪里呢? 大家首先想到的应该是数据库，不过购物车数据比较特殊，读和写都比较频繁，存储数据库压力会比较大。因此我们可以考虑存入Redis中。 不过大家可能会担心Redis存储空间问题，我们可以效仿淘宝，限制购物车最多只能添加99件商品，或者更少。 2.未登录购物车2.1.准备2.1.1购物车的数据结构首先分析一下未登录购物车的数据结构。 我们看下页面展示需要什么数据： 因此每一个购物车信息，都是一个对象，包含： 12345678&#123; skuId:2131241, title:"小米6", image:"", price:190000, num:1, ownSpec:"&#123;"机身颜色":"陶瓷黑尊享版","内存":"6GB","机身存储":"128GB"&#125;"&#125; 另外，购物车中不止一条数据，因此最终会是对象的数组。即： 123[ &#123;...&#125;,&#123;...&#125;,&#123;...&#125;] 2.1.2.web本地存储知道了数据结构，下一个问题，就是如何保存购物车数据。前面我们分析过，可以使用Localstorage来实现。Localstorage是web本地存储的一种，那么，什么是web本地存储呢？ 什么是web本地存储？ web本地存储主要有两种方式： LocalStorage：localStorage 方法存储的数据没有时间限制。第二天、第二周或下一年之后，数据依然可用。 SessionStorage：sessionStorage 方法针对一个 session 进行数据存储。当用户关闭浏览器窗口后，数据会被删除。 LocalStorage的用法语法非常简单： 123localStorage.setItem("key","value"); // 存储数据localStorage.getItem("key"); // 获取数据localStorage.removeItem("key"); // 删除数据 注意：localStorage和SessionStorage都只能保存字符串。 不过，在我们的common.js中，已经对localStorage进行了简单的封装： 示例： 2.1.3.获取num添加购物车需要知道购物的数量，所以我们需要获取数量大小。我们在Vue中定义num，保存数量： 然后将num与页面的input框绑定，同时给+和-的按钮绑定事件： 编写事件： 2.2.添加购物车2.2.1.点击事件我们看下商品详情页： 现在点击加入购物车会跳转到购物车成功页面。 不过我们不这么做，我们绑定点击事件，然后实现添加购物车功能。 addCart方法中判断用户的登录状态： 2.2.2.获取数量，添加购物车12345678910111213141516171819202122232425262728293031323334addCart()&#123; // 判断登录状态 ly.http.get("/auth/verify") .then(resp =&gt; &#123; &#125;) .catch(() =&gt; &#123; // 未登录，添加到localstorage // 1、查询本地购物车 const carts = ly.store.get("carts") || []; let cart = carts.find(c =&gt; c.skuId === this.sku.id); // 2、判断是否存在 if(cart)&#123; // 3、存在，改数量 cart.num += this.num; &#125;else &#123; // 4、不存在，新增 cart = &#123; skuId: this.sku.id, title: this.sku.title, image: this.images[0], price: this.sku.price, num: this.num, ownSpec: JSON.stringify(this.ownSpec) &#125;; carts.push(cart); &#125; // 把carts写回localstorage ly.store.set("carts", carts); // 跳转 window.location.href = "http://www.leyou.com/cart.html"; &#125;);&#125; 结果： 添加完成后，页面会跳转到购物车结算页面：cart.html 2.3.查询购物车2.3.1.校验用户登录因为会多次校验用户登录状态，因此我们封装一个校验的方法： 在common.js中： 2.3.2.查询购物车页面加载时，就应该去查询购物车。 12345678910111213141516171819202122232425262728var cartVm = new Vue(&#123; el: "#cartApp", data: &#123; ly, carts: [],// 购物车数据 &#125;, created() &#123; this.loadCarts(); &#125;, methods: &#123; loadCarts() &#123; // 先判断登录状态 ly.verifyUser() .then(() =&gt; &#123; // 已登录 &#125;) .catch(() =&gt; &#123; // 未登录 this.carts = ly.store.get("carts") || []; this.selected = this.carts; &#125;) &#125; &#125; components: &#123; shortcut: () =&gt; import("/js/pages/shortcut.js") &#125;&#125;) 刷新页面，查看控制台Vue实例： 2.5.2.渲染到页面接下来，我们在页面中展示carts的数据： 页面位置： 修改后： 要注意，价格的展示需要进行格式化，这里使用的是我们在common.js中定义的formatPrice方法： 效果： 2.6.修改数量我们给页面的 + 和 -绑定点击事件，修改num 的值： 两个事件： 12345678910111213141516171819202122232425increment(c) &#123; c.num++; ly.verifyUser() .then(() =&gt; &#123; // TODO 已登录，向后台发起请求 &#125;) .catch(() =&gt; &#123; // 未登录，直接操作本地数据 ly.store.set("carts", this.carts); &#125;)&#125;,decrement(c) &#123; if (c.num &lt;= 1) &#123; return; &#125; c.num--; this.verifyUser() .then(() =&gt; &#123; // TODO 已登录，向后台发起请求 &#125;) .catch(() =&gt; &#123; // 未登录，直接操作本地数据 ly.store.set("carts", this.carts); &#125;)&#125;, 2.7.删除商品给删除按钮绑定事件： 点击事件中删除商品： 1234567891011deleteCart(i) &#123; this.verifyUser() .then(() =&gt; &#123; // 已登录 &#125;) .catch(() =&gt; &#123; // 未登录 this.carts.splice(i, 1); ly.store.set("carts", this.carts); &#125;)&#125; 2.8.选中商品在页面中，每个购物车商品左侧，都有一个复选框，用户可以选择部分商品进行下单，而不一定是全部： 我们定义一个变量，记录所有被选中的商品： 2.8.1.选中一个我们给商品前面的复选框与selected绑定，并且指定其值为当前购物车商品： 2.8.2.初始化全选我们在加载完成购物车查询后，初始化全选： 2.8.4.总价格然后编写一个计算属性，计算出选中商品总价格： 12345computed: &#123; totalPrice() &#123; return this.selected.map(c =&gt; c.num * c.price).reduce((p1, p2) =&gt; p1 + p2, 0); &#125;&#125; 在页面中展示总价格： 效果： 3.搭建购物车服务3.1.创建module 3.2.pom依赖123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;leyou&lt;/artifactId&gt; &lt;groupId&gt;com.leyou.parent&lt;/groupId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.service&lt;/groupId&gt; &lt;artifactId&gt;ly-cart&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 3.3.配置文件123456789101112131415161718server: port: 8088spring: application: name: cart-service redis: host: 192.168.25.128eureka: client: service-url: defaultZone: http://127.0.0.1:10086/eureka registry-fetch-interval-seconds: 5 instance: prefer-ip-address: true ip-address: 127.0.0.1 instance-id: $&#123;eureka.instance.ip-address&#125;.$&#123;server.port&#125; lease-renewal-interval-in-seconds: 3 lease-expiration-duration-in-seconds: 10 3.4.启动类123456789@SpringBootApplication@EnableDiscoveryClient@EnableFeignClientspublic class LyCartApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(LyCartApplication.class, args); &#125;&#125; 3.5.路由1234zuul: prefix: /api routes: cart-service: /cart/** 4.已登录购物车接下来，我们完成已登录购物车。 在刚才的未登录购物车编写时，我们已经预留好了编写代码的位置，逻辑也基本一致。 4.1.添加登录校验购物车系统只负责登录状态的购物车处理，因此需要添加登录校验，我们通过JWT鉴权即可实现。 4.1.1.引入JWT相关依赖我们引入之前写的鉴权工具：ly-auth-common 12345678910&lt;dependency&gt; &lt;groupId&gt;com.leyou.service&lt;/groupId&gt; &lt;artifactId&gt;ly-auth-common&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.leyou.service&lt;/groupId&gt; &lt;artifactId&gt;ly-common&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt; 4.1.2.配置公钥1234ly: jwt: pubKeyPath: D:/heima/rsa/rsa.pub # 公钥地址 cookieName: LY_TOKEN # cookie的名称 4.1.3.加载公钥 代码： 12345678910111213141516171819@Data@ConfigurationProperties(prefix = "ly.jwt")public class JwtProperties &#123; private String pubKeyPath;// 公钥 private String CookieName; private Integer CookieMaxage; private PublicKey publicKey; //对象一旦实例化后，就应该读取公钥和私钥 @PostConstruct //实例化后执行 public void init() throws Exception &#123; //读取公钥和私钥 this.publicKey = RsaUtils.getPublicKey(pubKeyPath); &#125;&#125; 4.1.4.编写过滤器因为很多接口都需要进行登录，我们直接编写SpringMVC拦截器，进行统一登录校验。同时，我们还要把解析得到的用户信息保存起来，以便后续的接口可以使用。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243@Slf4jpublic class UserInterceptor implements HandlerInterceptor &#123; @Autowired private JwtProperties jwtProperties; //线程，用来传递值 private static final ThreadLocal&lt;UserInfo&gt; tl=new ThreadLocal&lt;&gt;(); public UserInterceptor(JwtProperties jwtProperties)&#123; this.jwtProperties=jwtProperties; &#125; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; //获取cookie String token = CookieUtils.getCookieValue(request, jwtProperties.getCookieName()); try &#123; //解析token UserInfo user = JwtUtils.getInfoFromToken(jwtProperties.getPublicKey(), token); //传递user tl.set(user); //放行 return true; &#125;catch (Exception e)&#123; log.error("[购物车服务] 解析身份失败",e); return false; &#125; &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) &#123; //最后用完数据清空 tl.remove(); &#125; //取出userinfo public static UserInfo getUser()&#123; return tl.get(); &#125;&#125; 注意： 这里我们使用了ThreadLocal来存储查询到的用户信息，线程内共享，因此请求到达Controller后可以共享User 并且对外提供了静态的方法：getLoginUser()来获取User信息 4.1.5.配置过滤器配置SpringMVC，使过滤器生效： 12345678910@Configuration@EnableConfigurationProperties(JwtProperties.class)public class MvcConfig implements WebMvcConfigurer &#123; @Autowired private JwtProperties jwtProperties; @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(new UserInterceptor(jwtProperties)).addPathPatterns("/**"); &#125;&#125; 4.2.后台购物车设计数据结构设计当用户登录时，我们需要把购物车数据保存到后台，可以选择保存在数据库。但是购物车是一个读写频率很高的数据。因此我们这里选择读写效率比较高的Redis作为购物车存储。 Redis有5种不同数据结构，这里选择哪一种比较合适呢？ 首先不同用户应该有独立的购物车，因此购物车应该以用户的作为key来存储，Value是用户的所有购物车信息。这样看来基本的k-v结构就可以了。 但是，我们对购物车中的商品进行增、删、改操作，基本都需要根据商品id进行判断，为了方便后期处理，我们的购物车也应该是k-v结构，key是商品id，value才是这个商品的购物车信息。 综上所述，我们的购物车结构是一个双层Map：Map&lt;String,Map&lt;String,String&gt;&gt; 第一层Map，Key是用户id 第二层Map，Key是购物车中商品id，值是购物车数据 实体类12345678910@Datapublic class Cart &#123; private Long userId;// 用户id private Long skuId;// 商品id private String title;// 标题 private String image;// 图片 private Long price;// 加入购物车时的价格 private Integer num;// 购买数量 private String ownSpec;// 商品规格参数&#125; 4.3.添加商品到购物车4.3.1.页面发起请求：已登录情况下，向后台添加购物车： 这里发起的是Json请求。那么我们后台也要以json接收。 4.3.2.后台添加购物车controller先分析一下： 请求方式：新增，肯定是Post 请求路径：/cart ，这个其实是Zuul路由的路径，我们可以不管 请求参数：Json对象，包含skuId和num属性 返回结果：无 123456789101112131415161718@RequestMappingpublic class CartController &#123; @Autowired private CartService cartService; /** * 添加商品到购物车 * @param cart * @return */ @PostMapping public ResponseEntity&lt;Void&gt;addCart(@RequestBody Cart cart)&#123; cartService.addCart(cart); return ResponseEntity.status(HttpStatus.OK).build(); &#125;&#125; Service这里我们不访问数据库，而是直接操作Redis。基本思路： 先查询之前的购物车数据 判断要添加的商品是否存在 存在：则直接修改数量后写回Redis 不存在：新建一条数据，然后写入Redis 代码： 12345678910111213141516171819202122232425262728293031323334@Servicepublic class CartService &#123; private static final String KEY_CART="cart:user:id:"; @Autowired private StringRedisTemplate redisTemplate; /** * 第一层Map，Key是用户id * 第二层Map，Key是购物车中商品id(skuid)，值是购物车数据 * @param cart */ public void addCart(Cart cart) &#123; //获取登入的用户 UserInfo user = UserInterceptor.getUser(); //key String key=KEY_CART+user.getId(); //hashKey String hashKey = cart.getSkuId().toString(); //绑定key BoundHashOperations&lt;String, Object, Object&gt; operations = redisTemplate.boundHashOps(key); //判断当前购物车商品是否存在 if (operations.hasKey(hashKey))&#123; //是，修改数量 String json = operations.get(hashKey).toString(); //将json转成cart类型 Cart cachCart = JsonUtils.toBean(json, Cart.class); cachCart.setNum(cachCart.getNum()+cart.getNum()); operations.put(hashKey,JsonUtils.toString(cachCart)); &#125;else &#123; //否，新增 operations.put(hashKey,JsonUtils.toString(cart)); &#125; &#125;&#125; 4.3.3.结果： 4.4.查询购物车4.4.1.页面发起请求 4.4.2.后台实现 Controller 12345678/** * 查询购物车 * @return */ @GetMapping("list") public ResponseEntity&lt;List&lt;Cart&gt;&gt; selectCart()&#123; return ResponseEntity.ok(cartService.queryCartList()); &#125; Service 123456789101112131415public List&lt;Cart&gt; queryCartList() &#123; //获取登入的用户 UserInfo user = UserInterceptor.getUser(); //key String key=KEY_CART+user.getId(); if (!redisTemplate.hasKey(key))&#123; throw new LyException(ExceptionEnums.CART_NOT_FOUND); &#125; //获取登入用户的所有购物车 //绑定key BoundHashOperations&lt;String, Object, Object&gt; operations = redisTemplate.boundHashOps(key); List&lt;Cart&gt; carts = operations.values().stream().map(o -&gt; JsonUtils.toBean(o.toString(), Cart.class)).collect(Collectors.toList()); return carts;&#125; 4.4.3.测试 4.5.修改商品数量4.5.1.页面发起请求 4.5.2.后台实现 Controller 123456789101112/** * 修改购物车的商品数量 * @param skuId * @param num * @return */ @PutMapping public ResponseEntity&lt;Void&gt; updateCartNum(@RequestParam("skuId")Long skuId,@RequestParam("num")Integer num)&#123; cartService.updateCartNum(skuId,num); return ResponseEntity.status(HttpStatus.OK).build(); &#125; Service 1234567891011121314151617public void updateCartNum(Long skuId, Integer num) &#123; //获取登入的用户 UserInfo user = UserInterceptor.getUser(); //key String key=KEY_CART+user.getId(); //绑定key BoundHashOperations&lt;String, Object, Object&gt; operations = redisTemplate.boundHashOps(key); if (!operations.hasKey(skuId.toString()))&#123; throw new LyException(ExceptionEnums.SKU_NOT_FOUND); &#125; //通过skuId获取redis中购物车的商品信息 Cart cart = JsonUtils.toBean(operations.get(skuId.toString()).toString(), Cart.class); cart.setNum(num); //保存到redis中 operations.put(skuId.toString(),JsonUtils.toString(cart));&#125; 4.6.删除购物车商品4.6.1.页面发起请求 注意：后台成功响应后，要把页面的购物车中数据也删除 4.6.2.后台实现 Controller 1234567891011/** * 删除购物车 * @param skuId * @return */@DeleteMapping("&#123;skuId&#125;")public ResponseEntity&lt;Void&gt; deleteCart(@PathVariable("skuId")Long skuId)&#123; cartService.deleteCart(skuId); return ResponseEntity.status(HttpStatus.OK).build();&#125; Service 12345678910111213141516public void deleteCart(Long skuId) &#123; //获取登入的用户 UserInfo user = UserInterceptor.getUser(); //key String key=KEY_CART+user.getId(); //判断是否存在 if (!redisTemplate.hasKey(key))&#123; throw new LyException(ExceptionEnums.CART_NOT_FOUND); &#125; redisTemplate.opsForHash().delete(key,skuId.toString());&#125; 5.登录后购物车合并（作业）当跳转到购物车页面，查询购物车列表前，需要判断用户登录状态， 如果登录： 首先检查用户的LocalStorage中是否有购物车信息， 如果有，则提交到后台保存， 清空LocalStorage 如果未登录，直接查询即可 修改cart.html即可]]></content>
      <categories>
        <category>项目实战-微服务商城</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务商城（十九）—— 下单、微信支付]]></title>
    <url>%2Fday19-%E4%B8%8B%E5%8D%95%20.html</url>
    <content type="text"><![CDATA[0.学习目标 搭建订单微服务 创建订单 微信支付下单 生成二维码 1.创建订单微服务1.1.搭建服务创建Model ly-order 依赖pom.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;leyou&lt;/artifactId&gt; &lt;groupId&gt;com.leyou.parent&lt;/groupId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.service&lt;/groupId&gt; &lt;artifactId&gt;ly-order&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.leyou.service&lt;/groupId&gt; &lt;artifactId&gt;ly-item-interface&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.leyou.common&lt;/groupId&gt; &lt;artifactId&gt;ly-common&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.leyou.service&lt;/groupId&gt; &lt;artifactId&gt;ly-auth-common&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.wxpay&lt;/groupId&gt; &lt;artifactId&gt;wxpay-sdk&lt;/artifactId&gt; &lt;version&gt;0.0.3&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; application： 12345678910111213141516171819202122232425server: port: 8089spring: application: name: order-service datasource: url: jdbc:mysql://localhost:3306/leyou-new?serverTimezone=Asia/Shanghai&amp;characterEncoding=utf8 username: root password: cxg200888 hikari: maximum-pool-size: 30 minimum-idle: 10eureka: client: service-url: defaultZone: http://127.0.0.1:10086/eureka registry-fetch-interval-seconds: 5 instance: lease-renewal-interval-in-seconds: 5 # 每隔5秒发送一次心跳 lease-expiration-duration-in-seconds: 10 # 10秒不发送就过期 prefer-ip-address: true ip-address: 127.0.0.1 instance-id: $&#123;spring.application.name&#125;:$&#123;server.port&#125;mybatis: type-aliases-package: com.leyou.order.pojo 启动类：12345678@SpringBootApplication@EnableDiscoveryClient@MapperScan("com.leyou.order.mapper")public class LyOrderApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(LyOrderApplication.class, args); &#125;&#125; 在ly-gateway中添加路由 1234zuul: prefix: /api # 添加路由前缀 routes: order-service: /order/** # 订单微服务 1.2.用户登入校验 1.2.1.配置密钥12345678910111213141516171819@Data@ConfigurationProperties(prefix = "ly.jwt")public class JwtProperties &#123; private String pubKeyPath;// 公钥 private String CookieName; private Integer CookieMaxage; private PublicKey publicKey; //对象一旦实例化后，就应该读取公钥和私钥 @PostConstruct //实例化后执行 public void init() throws Exception &#123; //读取公钥和私钥 this.publicKey = RsaUtils.getPublicKey(pubKeyPath); &#125;&#125; 1.2.2.拦截器1234567891011121314151617181920212223242526272829303132333435363738394041@Slf4jpublic class UserInterceptor implements HandlerInterceptor &#123; @Autowired private JwtProperties jwtProperties; private static final ThreadLocal&lt;UserInfo&gt; tl=new ThreadLocal&lt;&gt;(); public UserInterceptor(JwtProperties jwtProperties)&#123; this.jwtProperties=jwtProperties; &#125; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; //获取cookie String token = CookieUtils.getCookieValue(request, jwtProperties.getCookieName()); try &#123; //解析token UserInfo user = JwtUtils.getInfoFromToken(jwtProperties.getPublicKey(), token); //传递user tl.set(user); //放行 return true; &#125;catch (Exception e)&#123; log.error("[购物车服务] 解析身份失败",e); return false; &#125; &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) &#123; //最后用完数据清空 tl.remove(); &#125; //取出userinfo public static UserInfo getUser()&#123; return tl.get(); &#125;&#125; 1.3.数据结构订单表： 123456789101112131415161718192021222324252627CREATE TABLE `tb_order` ( `order_id` bigint(20) NOT NULL COMMENT &apos;订单id&apos;, `total_pay` bigint(20) NOT NULL COMMENT &apos;总金额，单位为分&apos;, `actual_pay` bigint(20) NOT NULL COMMENT &apos;实付金额。单位:分。如:20007，表示:200元7分&apos;, `promotion_ids` varchar(256) COLLATE utf8_bin DEFAULT &apos;&apos;, `payment_type` tinyint(1) unsigned zerofill NOT NULL COMMENT &apos;支付类型，1、在线支付，2、货到付款&apos;, `post_fee` bigint(20) NOT NULL COMMENT &apos;邮费。单位:分。如:20007，表示:200元7分&apos;, `create_time` datetime DEFAULT NULL COMMENT &apos;订单创建时间&apos;, `shipping_name` varchar(20) COLLATE utf8_bin DEFAULT NULL COMMENT &apos;物流名称&apos;, `shipping_code` varchar(20) COLLATE utf8_bin DEFAULT NULL COMMENT &apos;物流单号&apos;, `user_id` varchar(32) COLLATE utf8_bin NOT NULL COMMENT &apos;用户id&apos;, `buyer_message` varchar(128) COLLATE utf8_bin DEFAULT NULL COMMENT &apos;买家留言&apos;, `buyer_nick` varchar(32) COLLATE utf8_bin NOT NULL COMMENT &apos;买家昵称&apos;, `buyer_rate` tinyint(1) DEFAULT NULL COMMENT &apos;买家是否已经评价,0未评价，1已评价&apos;, `receiver_state` varchar(128) COLLATE utf8_bin DEFAULT &apos;&apos; COMMENT &apos;收获地址（省）&apos;, `receiver_city` varchar(256) COLLATE utf8_bin DEFAULT &apos;&apos; COMMENT &apos;收获地址（市）&apos;, `receiver_district` varchar(256) COLLATE utf8_bin DEFAULT &apos;&apos; COMMENT &apos;收获地址（区/县）&apos;, `receiver_address` varchar(256) COLLATE utf8_bin DEFAULT &apos;&apos; COMMENT &apos;收获地址（街道、住址等详细地址）&apos;, `receiver_mobile` varchar(11) COLLATE utf8_bin DEFAULT NULL COMMENT &apos;收货人手机&apos;, `receiver_zip` varchar(16) COLLATE utf8_bin DEFAULT NULL COMMENT &apos;收货人邮编&apos;, `receiver` varchar(32) COLLATE utf8_bin DEFAULT NULL COMMENT &apos;收货人&apos;, `invoice_type` int(1) DEFAULT &apos;0&apos; COMMENT &apos;发票类型(0无发票1普通发票，2电子发票，3增值税发票)&apos;, `source_type` int(1) DEFAULT &apos;2&apos; COMMENT &apos;订单来源：1:app端，2：pc端，3：M端，4：微信端，5：手机qq端&apos;, PRIMARY KEY (`order_id`), KEY `create_time` (`create_time`), KEY `buyer_nick` (`buyer_nick`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin 订单条目： 123456789101112CREATE TABLE `tb_order_detail` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &apos;订单详情id &apos;, `order_id` bigint(20) NOT NULL COMMENT &apos;订单id&apos;, `sku_id` bigint(20) NOT NULL COMMENT &apos;sku商品id&apos;, `num` int(11) NOT NULL COMMENT &apos;购买数量&apos;, `title` varchar(256) NOT NULL COMMENT &apos;商品标题&apos;, `own_spec` varchar(1024) DEFAULT &apos;&apos; COMMENT &apos;商品动态属性键值集&apos;, `price` bigint(20) NOT NULL COMMENT &apos;价格,单位：分&apos;, `image` varchar(128) DEFAULT &apos;&apos; COMMENT &apos;商品图片&apos;, PRIMARY KEY (`id`), KEY `key_order_id` (`order_id`) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=126 DEFAULT CHARSET=utf8 COMMENT=&apos;订单详情表&apos; 订单状态 123456789101112CREATE TABLE `tb_order_status` ( `order_id` bigint(20) NOT NULL COMMENT &apos;订单id&apos;, `status` int(1) DEFAULT NULL COMMENT &apos;状态：1、未付款 2、已付款,未发货 3、已发货,未确认 4、交易成功 5、交易关闭 6、已评价&apos;, `create_time` datetime DEFAULT NULL COMMENT &apos;订单创建时间&apos;, `payment_time` datetime DEFAULT NULL COMMENT &apos;付款时间&apos;, `consign_time` datetime DEFAULT NULL COMMENT &apos;发货时间&apos;, `end_time` datetime DEFAULT NULL COMMENT &apos;交易完成时间&apos;, `close_time` datetime DEFAULT NULL COMMENT &apos;交易关闭时间&apos;, `comment_time` datetime DEFAULT NULL COMMENT &apos;评价时间&apos;, PRIMARY KEY (`order_id`), KEY `status` (`status`) USING BTREE) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&apos;订单状态表&apos; 1.4.基本代码实体类 Order.java 12345678910111213141516171819202122232425262728293031323334@Data@Table(name = "tb_order")public class Order &#123; @Id private Long orderId;// id private Long totalPay;// 总金额 private Long actualPay;//实付金额 private Integer paymentType; //支付类型，1、在线支付，2、货到付款 private String promotionIds; //参与促销活动的id private Long postFee=0L ;// 邮费 private Date createTime;//创建时间 private String shippingName;// 物流名称 private String shippingCode;// 物流单号 private Long userId;//用户id private String buyerMessage;//买家留言 private String buyerNick;//买家昵称 private Boolean buyerRate;//买家是否已经评价 private String receiver; //收货人全名 private String receiverMobile; //移动电话 private String receiverState; //省份 private String receiverCity; //城市 private String receiverDistrict; //区/县 private String receiverAddress; //收货地址，如: xx路xx号 private String receiverZip; //邮政编码，如: 310001 private Integer invoiceType = 0;//发票类型，8无发票，1普通发票，2电子发票，3增值税发票 private Integer sourceType = 1;//订单来源1:app端，2: pc端，3: M端，4:微信端，5: 手机qq端 @Transient private OrderStatus orderStatus; @Transient private List&lt;OrderDetail&gt; orderDetails;&#125; OrderDetail.java 12345678910111213141516171819202122@Data@Table(name = "tb_order_detail")public class OrderDetail &#123; @Id @KeySql(useGeneratedKeys = true)private Long id; private Long orderId; // 订单1d private Long skuId;// 商品id private Integer num;//商品购买数量 private String title;// 商品标题 private Long price;// 商品单价 private String ownSpec;// 商品规格数据 private String image;// 图片&#125; OrderStatus.java 123456789101112131415161718192021@Data@Table(name = "tb_order_status")public class OrderStatus &#123; @Id private Long orderId; private Integer status; private Date createTime;// 创建时间 private Date paymentTime;// 付款时间 private Date consignTime;// 发货时间 private Date endTime;//交易结束时间 private Date closeTime;// 交易关闭时间 private Date commentTime;// 评价时间&#125; 2.订单结算页2.1.页面跳转在购物车页面的最下方，有一个去结算按钮： 当点击结算，我们应该跳转到订单结算页，即：getOrderInfo.html 查看购物车cart.html的结算按钮： 可以看到，地址是正确的。但是只有登录用户才可以去结算付款，因此我们不能直接跳转，而是在跳转前校验用户的登录状态，如果发现是未登录，应该重定向到登录页！ 我们给这个按钮绑定点击事件： 事件中判断登录状态，进行页面跳转： 12345678910toOrderInfo() &#123; // 判断是否登录 ly.verifyUser().then(() =&gt; &#123; // 已登录 window.location.href = "/getOrderInfo.html" &#125;).catch(() =&gt; &#123; // 未登录 window.location.href = "/login.html?returnUrl=" + window.location.href; &#125;)&#125; 登录后测试： 此处页面需要渲染的内容主要包含3部分： 收货人信息 支付方式 商品信息 2.2.收货人信息（作业） 这里的收货人信息肯定是当前登录用户的收货地址。所以需要根据当前登录用户去查询，目前我们在页面是写的假数据： 大家可以在在后台提供地址的增删改查接口，然后页面加载时根据当前登录用户查询，而后赋值给addresses即可。 2.3.支付方式支付方式有2种： 微信支付 货到付款 与我们订单数据中的paymentType关联： 所以我们可以在Vue实例中定义一个属性来记录支付方式： 然后在页面渲染时与这个变量关联： 2.4.商品清单效果图： 这里的送货清单，其实就是购物车中用户选择的要付款的商品 因此，我们需要在购物车跳转过来的同时，携带选中的购物车的信息 2.4.1.购物车信息获取我们修改cart.html中的页面跳转逻辑，把用户选中的购物车信息传递过来： 然后在created钩子函数中获取购物车数据，保存到本地属性，要注意的是，我们应该在获取数据前校验用户登录状态，如果发现未登录，则直接重定向到登录页： 然后重新加载页面，查看控制台： 2.4.2.页面渲染要修改的页面位置：每一个li就是一件商品 我们修改为： 1234567891011121314151617181920212223242526&lt;ul class="send-detail"&gt; &lt;li v-for="(cart,index) in carts" :key="index"&gt; &lt;div class="sendGoods"&gt; &lt;ul class="yui3-g"&gt; &lt;li class="yui3-u-1-6"&gt; &lt;span&gt;&lt;img width="70px" height="70px" :src="cart.image"/&gt;&lt;/span&gt; &lt;/li&gt; &lt;li class="yui3-u-7-12"&gt; &lt;div class="desc"&gt;&#123;&#123;cart.title&#125;&#125;&lt;/div&gt; &lt;div class="seven"&gt; &lt;span v-for="(v) in JSON.parse(cart.ownSpec)"&gt;&#123;&#123;v + " "&#125;&#125; &lt;/span&gt; &lt;/div&gt; &lt;/li&gt; &lt;li class="yui3-u-1-12"&gt; &lt;div class="price"&gt;￥&#123;&#123;ly.formatPrice(cart.price * cart.num)&#125;&#125;&lt;/div&gt; &lt;/li&gt; &lt;li class="yui3-u-1-12"&gt; &lt;div class="num"&gt;&#123;&#123;cart.num&#125;&#125;&lt;/div&gt; &lt;/li&gt; &lt;li class="yui3-u-1-12"&gt; &lt;div class="exit"&gt;有货&lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/li&gt;&lt;/ul&gt; 2.5.总金额另外在商品列表下面，还有一个总金额的计算： 可以看出这里主要有4个数据： 总金额：totalPay 优惠返现：discount 运费：postFee 实付金额：actualPay 不过我们没有做优惠活动，另外运费需要结合物流系统来计算，暂时我们都设置为0，在order属性中写死： 我们通过计算属性来得到totalPay和actualPay值： 1234567891011computed: &#123; totalNum()&#123; return this.carts.reduce((c1, c2) =&gt; c1 + c2.num, 0) &#125;, totalPay()&#123; return this.carts.reduce((c1, c2) =&gt; c1 + c2.price * c2.num, 0); &#125;, actualPay()&#123; return this.totalPay + this.order.postFee - this.order.discount; &#125;&#125;, 然后在页面渲染： 效果： 2.6.提交订单2.6.1.页面提交来看下订单接口所需要的数据： 参数说明： addressId：收货人地址信息的id，需要去用户中心查询收货人地址 carts：购物车中的商品数据，可以有多个对象 num：购物车中指定商品的购买数量 skuId：购物车中的某商品id paymentType：付款方式 1：在线支付 2：货到付款 getOrderInfo.html对应的js代码 给提交按钮绑定事件： 可以看到返回的提交订单成功，返回的应该是订单的编号id。 3.创建订单接口订单信息共有3张表，内容喝多，但是前台提交的数据却很少，也就是说我们需要自己填很多数据。 3.1.Controller请求分析： 请求方式：POST 请求路径：/order 请求参数：包含收货人地址id、付款方式、购物车商品数据集合的json内容，我们需要封装一个对象来接收 123456789101112@Data@AllArgsConstructor@NoArgsConstructorpublic class OrderDTO &#123; @NotNull private Long addressId;// 收货人地址id @NotNull private Integer paymentType;// 付款方式 @NotNull private List&lt;CartDTO&gt; carts;// 订单详情&#125; 其中的购物车数据再次封装对象： 1234567@Data@AllArgsConstructor@NoArgsConstructorpublic class CartDTO &#123; private Long skuId;// 商品skuId private Integer num;// 购买数量&#125; 返回结果：订单id 具体代码 123456789@RestControllerpublic class OrderController &#123; @Autowired private OrderService orderService; @PostMapping("/order") public ResponseEntity&lt;Long&gt; createOrder(@RequestBody OrderDTO orderDTO)&#123; return ResponseEntity.ok(orderService.createOrder(orderDTO)); &#125;&#125; 3.2.Service创建订单逻辑比较复杂，需要组装订单数据，基本步骤如下: 获取登录用户信息 生成订单编号，初始化订单基本信息 查询商品信息弄 查询收货人信息 封装OrderDetail信息 计算总金额、实付金额 保存订单状态信息 删除购物车中已购买商品 减库存 3.2.1.生成订单编号 订单id的特殊性 订单数据非常庞大，将来一定会做分库分表，name这种情况下，要保证id的唯一，就不能靠数据库自增，而是自己来实现算法，生成唯一id。 雪花算法 这里的订单id是通过一个工具类生成： 而工具类所采用的生成id算法，是由Twitter公司开源的snowflake（雪花）算法。 简单原理 雪花算法会生成一个64位的二进制数据，位一个long型，（转换成字符串后长度最多19），其基本结构： 第一位:为未使用 第二部分: 41位为毫秒级时间(41位的长度可以使用69年) 第三部分: 5位datacenterld和5位workerld(10位的长度 最多支持部署1024个节点) 第四部分:最后12位是毫秒内的计数(12位 的计数顺序号支持每个节点每毫秒产生4096个ID序号) snowflake生成的ID整体上按照时间自增排序，并且整个分布式系统内不会产生ID碰撞(由datacenter和workerld作区分)，并且效率较高。经测试snowflake每秒能够产生26万个ID。 配置 为了保证不重复，我们在application.yml中给每个部署的节点都配置机器id： 放入ly-order的application.yml中 1234ly: worker: workerId:1 dataCenterId:1 在config中编写 加载属性： 123456@Data@ConfigurationProperties(prefix = "ly.worker")public class idWorkerProperties &#123; private long workerId;// 当前机器id private long dataCenterId;// 序列号&#125; 在config中 编写配置类： 1234567891011121314@Configuration@EnableConfigurationProperties(IdWorkerProperties.class)public class IdWorkerConfig &#123; /** * 注册IdWorker * @param prop * @return */ @Bean public IdWorker idWorker(IdWorkerProperties prop) &#123; return new IdWorker(prop.getWorkerId(), prop.getDataCenterId()); &#125;&#125; 3.2.2.查询sku的接口创建订单过程中，肯定需要查询sku信息，因为我们需要在商品微服务提供根据skuId查询sku的接口： 在ly-item-interface的GoodsApi中添加接口： 1234567/** * 根据sku的id集合查询sku * @param ids * @return */@GetMapping("sku/list/ids")List&lt;Sku&gt; querySkuByids(@RequestParam("ids")List&lt;Long&gt; ids); 在ly-item-service的GoodsController中编写业务 123456789/** * 根据sku的id集合查询sku * @param ids * @return */@GetMapping("sku/list/ids")public ResponseEntity&lt;List&lt;Sku&gt;&gt; querySkuByids(@RequestParam("ids")List&lt;Long&gt; ids)&#123; return ResponseEntity.ok(goodsService.querySkuByids(ids));&#125; service和mapper代码略 3.2.3.减库存接口创建订单，肯定需要减库存，我们还要在商品微服务提供减库的接口 在ly-item-interface的GoodsApi中添加接口： 1234567/** * 减库存 * @param carts * @return */ @PostMapping("stock/decrease") void decreaseStock(@RequestBody List&lt;CartDTO&gt; carts); 在ly-item-service的 GoodController中编写业务 12345678910/** * 减库存 * @param carts * @return */@PostMapping("stock/decrease")public ResponseEntity&lt;Void&gt; decreaseStock(@RequestBody List&lt;CartDTO&gt; carts)&#123; goodsService.decreaseStock(carts); return ResponseEntity.status(HttpStatus.NO_CONTENT).build();&#125; 在ly-item-service的 GoodService中编写业务 12345678public void decreaseStock(List&lt;CartDTO&gt; carts) &#123; for (CartDTO cart : carts) &#123; int count = stockMapper.decreaseStock(cart.getSkuId(), cart.getNum()); if (count!=1)&#123; throw new LyException(ExceptionEnums.STOCK_NOT_ENOUGH); &#125; &#125;&#125; 此处采用了手写sql在mapper中： 1234public interface StockMapper extends BaseMapper&lt;Stock&gt; &#123; @Update("update tb_stock set stock = stock- #&#123;num&#125; where sku_id=#&#123;id&#125; and stock&gt;=#&#123;num&#125;") int decreaseStock(@Param("id") Long id, @Param("num") Integer num);&#125; 这里减库存并没有采用先查询库存，判断充足才减库存的方案，那样会有线程安全问题，当然可以通过加锁解决，不过我们此处为了效率，并没有使用悲观锁，而是对库存采用了乐观锁方案。 3.2.4.准备物流假数据我们前端页面传递来的是addressId，我们需要根据id查询物流信息，但是因为还没做物流地址管理，所以我们准备一些加数据。 首先是实体类： 123456789101112@Datapublic class AddressDTO &#123; private Long id; private String name;// 收件人姓名 private String phone;// 电话 private String state;// 省份 private String city;// 城市 private String district;// 区 private String address;// 街道地址 private String zipCode;// 邮编 private Boolean isDefault;&#125; 然后是一个常量类： 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.leyou.order.client;import com.leyou.order.dto.AddressDTO;import java.util.ArrayList;import java.util.List;public abstract class AddressClient &#123; public static final List&lt;AddressDTO&gt; addressList = new ArrayList&lt;AddressDTO&gt;()&#123; &#123; AddressDTO address = new AddressDTO(); address.setId(1L); address.setAddress("航头镇航头路18号传智播客 3号楼"); address.setCity("上海"); address.setDistrict("浦东新区"); address.setName("虎哥"); address.setPhone("15800000000"); address.setState("上海"); address.setZipCode("21000"); address.setIsDefault(true); add(address); AddressDTO address2 = new AddressDTO(); address2.setId(2L); address2.setAddress("天堂路 3号楼"); address2.setCity("北京"); address2.setDistrict("朝阳区"); address2.setName("张三"); address2.setPhone("13600000000"); address2.setState("北京"); address2.setZipCode("100000"); address2.setIsDefault(false); add(address2); &#125; &#125;; public static AddressDTO findById(Long id)&#123; for (AddressDTO addressDTO : addressList) &#123; if(addressDTO.getId().equals(id)) &#123;return addressDTO;&#125; &#125; return null; &#125;&#125; 3.2.5.创建订单代码3.2.6.订单状态枚举此处我们为订单状态定义了枚举 ly-order中enums创建OrderStatusEnum 12345678910111213141516171819public enum OrderStatusEnum &#123; UN_PAY(1,"未付款"), PAYED(2,"已付款,未发货"), DELIVERED(3,"已发货,未确认"), SUCCESS(4,"交易成功"), CLOSED(1,"交易关闭"), RATED(1,"已评价"), ; private int code; private String desc; OrderStatusEnum(int code, String desc) &#123; this.code = code; this.desc = desc; &#125; public Integer value()&#123; return this.code; &#125;&#125; 3.3.测试 查看数据库，发现订单已经生成： 订单 订单详情 订单状态 4.微信支付4.1.介绍微信支付官方文档：https://pay.weixin.qq.com/wiki/doc/api/native.php?chapter=6_1 我们选择开发文档，而后进入选择页面： 选择扫码支付： 此处我们使用模式二来开发： 4.2.开发流程模式二与模式一相比，流程更为简单，不依赖设置的回调支付URL。 商户后台系统先调用微信支付的统一下单接口，微信后台系统返回链接参数code_url； 商户后台系统将code_url值生成二维码图片，用户使用微信客户端扫码后发起支付。 注意：code_url有效期为2小时，过期后扫码不能再发起支付。 流程图： 这里我们把商户（我们）要做的事情总结一下： 1、商户生成订单 2、商户调用微信下单接口，获取预交易的链接 3、商户将链接生成二维码图片，展示给用户； 4、用户支付并确认 5、支付结果通知： 微信异步通知商户支付结果，商户告知微信支付接收情况 商户如果没有收到通知，可以调用接口，查询支付状态 6、如果支付成功，发货，修改订单状态 在前面的业务中，我们已经完成了： 1、生成订单 接下来，我们需要做的是： 2、调用微信接口，生成链接。 3、并且生成二维码图片 4、支付成功后修改订单状态 4.3.下单并生成支付链接4.3.1.API说明在微信支付文档中，可以查询到下面信息： 支付路径 URL地址：https://api.mch.weixin.qq.com/pay/unifiedorde 请求参数 查看官方文档：https://pay.weixin.qq.com/wiki/doc/api/native.php?chapter=9_1 其中，appid、mch_id、nonce_str、sign等都是可以提前配置，或者随即生成。可以统一配置 但是其他参数都需要我们自己组织。 虽然请求参数比较复杂，但官方已经提供SDK，供我们使用 4.3.2.统一配置在微信支付参数中个，appid、mch_id可以提前配置，sign签名需要商户密钥我们需要提前配置，另外请求的超时时长等，所以微信sdk提供了统一配置 在ly-order的config中创建PayConfig 123456789101112131415161718@Datapublic class PayConfig implements WXPayConfig&#123; private String appId; // 公众账号ID private String mchId; // 商户号 private String key; // 生成签名的密钥 private int connectTimeoutMs; // 连接超时时间 private int readTimeoutMs;// 读取超时时间 private String notifyUrl; // 通知地址 @Override public InputStream getCertStream()&#123;return null;&#125;&#125; 我们将这些属性定义到application.yml中 12345678ly: pay: appID: wx8397f8696b538317 mchID: 1473426802 key: T6m9iK73b0kn9g5v426MKfHQH7X8rKwb httpConnectTimeoutMs: 1000 httpReadTimeoutMs: 8000 notifyUrl: http://www.leyou.com 4.3.3.回调url参数中一个非常重要的，叫做notify_url的： 基于上文的介绍我们知道，这个地址是在支付成功后的异步结果通知。官网介绍如下: 支付完成后，微信会把相关支付结果和用户信息发送给商户，商户需要接收处理，并返回应答。 所以，此处的地址必须是-个外网可访问地址，而且我们要定义好回调的处理接口。 内网穿透此处我们肯定不能写: http://api.leyou.com/api/order/, 这个域名未经备案，是不被识别的。如何才能获取一个能够外网访问的域名呢? 我们可以通过内网穿透来实现，那么什么是内网穿透呢? 简单说：让外网能访问你本地的应用，例如在外网打开你本地http://127.0.0.1指定的web站点 学习内网穿透：https://blog.csdn.net/zhangguo5/article/details/77848658 使用natapp地址：https://natapp.cn 通过官网的教程/文档：NATAPP1分钟快速新手图文教程（https://natapp.cn/article/natapp_newbie） 下载客户端在客户端下配置 config.ini config.ini 123456789#将本文件放置于natapp同级目录 程序将读取 [default] 段#在命令行参数模式如 natapp -authtoken=xxx 等相同参数将会覆盖掉此配置#命令行参数 -config= 可以指定任意config.ini文件[default]authtoken=35fb8777346645fa #对应一条隧道的authtokenclienttoken= #对应客户端的clienttoken,将会忽略authtoken,若无请留空,log=none #log 日志文件,可指定本地文件, none=不做记录,stdout=直接屏幕输出 ,默认为noneloglevel=INFO #日志等级 DEBUG, INFO, WARNING, ERROR 默认为 DEBUGhttp_proxy= #代理设置 如 http://10.123.10.10:3128 非代理上网用户请务必留空 配置修改application.yml配置文件 12345678ly: pay: appID: wx8397f8696b538317 mchID: 1473426802 key: T6m9iK73b0kn9g5v426MKfHQH7X8rKwb httpConnectTimeoutMs: 1000 httpReadTimeoutMs: 8000 notifyUrl: http://g9i654.natappfree.cc/notify/pay 4.3.4.支付工具类将资料下的三个文件添加到ly-order的config中 4.3.5.创建下单支付链接 controller 在ly-order下的web中OrderController创建 123456789/** * 创建支付链接 * @param orderId * @return */@GetMapping("/url/&#123;id&#125;")public ResponseEntity&lt;String&gt; createPayUrl(@PathVariable("id")Long orderId)&#123; return ResponseEntity.ok(orderService.createPayUrl(orderId));&#125; 在ly-order下的service中OrderService创建 12345678910111213141516public String createPayUrl(Long orderId) &#123; //查询订单 Order order = queryOrderById(orderId); //判断订单状态 Integer status = order.getOrderStatus().getStatus(); if (!status.equals(OrderStatusEnum.UN_PAY.value()))&#123; throw new LyException(ExceptionEnums.ORDER_STATUS_ERROR); &#125; //支付金额 Long actualPay = /*order.getActualPay()*/1L; //商品描述 OrderDetail orderDetail = order.getOrderDetails().get(0); String desc = orderDetail.getTitle(); return payHelper.createPayUrl(orderId,actualPay,desc);&#125; 我们先根据订单的编号，调用后台服务，生成交易链接，而后才能根据链接生成二维码。 在页面发起请求： 12345678910111213141516171819202122232425var payVm = new Vue(&#123; el:"#payVm", data:&#123; ly, orderId:0,// 订单编号 &#125;, created()&#123; // 判断登录状态 ly.http.get("/auth/verify").then(() =&gt; &#123; // 获取订单编号 this.orderId = ly.getUrlParam("orderId"); // 获取请求链接 ly.http.get("/order/url/" + this.orderId) .then(resp =&gt; &#123; console.log(resp.data); &#125;) &#125;.catch(() =&gt; &#123; // 未登录，跳转至登录页 location.href = "/login.html?returnUrl=" + location.href; &#125;) &#125;, components: &#123; shortcut: () =&gt; import("./js/pages/shortcut.js") &#125;&#125;); 后台已经定义好生成付款地址的接口。 刷新页面查看： 4.4.生成二维码4.4.1.什么是二维码二维码又称QR Code, QR全 称Quick Response,是一个近几年来移动设备上超流行的一种编码方式，它比传统的Bar Code条形码能存更多的信息，也能表示更多的数据类型。 二维条码/二维码(2-dimensional bar code)是用某种特定的几何图形按一定规律在平面(二维方向上)分布的黑白相间的图形记录数据符号信息的;在代码编制上1巧妙地利用构成计算机内部逻辑基础的“0”、“1”比特 流的概念，使用若千个与二进制相对应的几何形体来表示文字数值信息，通过图象输入设备或光电扫描设备自动识读以实现信息自动处理:它具有条码技术的一些共性:每种码制有其特定的字符集;每个字符占有一定的宽度;具有一定的校验功能等。同时还具有对不同行的信息自动识别功能、及处理图形旋转变化点。 4.4.2.二维码优势 信息容量大,可以容纳多达1850个大写字母或2710个数字或500多个汉字 应用范围广,支持文字，声音图片，指纹等等… 容错能力强,即使图片出现部分破损也能使用 成本低，容易制作 4.4.3.二维码容错级别 L级(低) 7%的码字可以被恢复。 M级(中) 15%的码字可以被恢复。 Q级(四分) 25%的码字可以被恢复。 H级(高) 30%的码字可以被恢复。 4.4.4.二维码生成插件qriousqrious是一. 款基于HTML5 Canvas的纯JS二维码生成插件。通过qrious.js可以快速生成各种二维码，你可以控制二维码的尺寸颜色，还可以将生成的二维码进行Base64编码。 官网qrious.js二维码插件的可用配置参数如下: 这里我们使用一个生成二维码的JS插件：qrcode，官网：https://github.com/davidshimjs/qrcodejs 我们把课这个js脚本引入到项目中： 官方使用案例： 然后在页面引用： 页面定义一个div，用于展示二维码： 然后获取到付款链接后，根据链接生成二维码： 1234567891011121314151617181920// 判断登录状态ly.http.get("/auth/verify").then(() =&gt; &#123; // 获取订单编号 this.orderId = ly.getUrlParam("orderId"); // 获取请求链接 ly.http.get("/order/url/" + this.orderId) .then(resp =&gt; &#123; new QRCode(document.getElementById("qrImage"), &#123; text: resp.data, width: 250, height: 250, colorDark: "#000000", colorLight: "#ffffff", correctLevel: QRCode.CorrectLevel.H &#125;); &#125;)&#125;).catch(() =&gt; &#123; // 未登录，跳转至登录页 location.href = "/login.html?returnUrl=" + location.href;&#125;) 刷新页面，查看效果： 此时，客户用手机扫描二维码，可以看到付款页面。 4.5.异步回调4.5.1.官方API还记得刚才下单时填写的notify_url吗？ 应用场景 支付完成后，微信会把相关支付结果及用户信息通过数据流的形式发送给商户，商户需要接收处理，并按文档规范返回应答。 后台通知交互时，如果微信收到商户的应答不符合规范或超时，微信会判定本次通知失败，重新发送通知，直到成功为止（在通知一直不成功的情况下，微信总共会发起10次通知，通知频率为15s/15s/30s/3m/10m/20m/30m/30m/30m/60m/3h/3h/3h/6h/6h - 总计 24h4m） 注意:同样的通知可能会多次发送给商户系统。商户系统必须能够正确处理重复的通知。 推荐的做法是，当收到通知进行处理时，首先检查对应业务数据的状态，判断该通知是否已经处理过，如果没有处理过再进行处理，如果处理过直接返回结果成功。在对业务数据进行状态检查和处理之前，要采用数据锁进行并发控制，以避免函数重入造成的数据混乱。 特别提醒:商户系统对于支付结果通知的内容一定要做 签名验证,并校验返回的订单金额是否与商户侧的订单金额一致，防止数据泄漏导致出现“假通知”，造成资金损失。 支付完成后，微信服务会自动向notify_url地址发生POST请求，请求参数xml格式： 通信成功，会返回下面信息 我们需要返回给微信 1234&lt;xml&gt; &lt;return_code&gt;&lt;![CDATA[SUCCESS]]&gt;&lt;/return_code&gt; &lt;return_msg&gt;&lt;![CDATA[OK]]&gt;&lt;/return_msg&gt; &lt;/xml&gt; 4.5.2.编写回调接口先分析接口需要的四个数据: 请求方式:官方文档虽然没有明说，但是测试得出是POST请求 请求路径:我们之前指定的notify. url的路径是: /wxpay/notify 请求参数:应该是xml格式数据 返回结果:也是xml,表明是否成功 因为要接收xmI格式数据，因此我们需要引入解析xml的依赖: 12345&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.dataformat&lt;/groupId&gt; &lt;artifactId&gt;jackson-dataformat-xml&lt;/artifactId&gt; &lt;version&gt;2.9.3&lt;/version&gt;&lt;/dependency&gt; 在ly-order中编写controller 123456789101112131415161718192021222324@Slf4j@RestController@RequestMapping("notify")public class NotifyController &#123; @Autowired private OrderService orderService; /** * 微信支付成功回调 * @param result * @return */ @PostMapping(value = "pay",produces = "application/xml") public Map&lt;String,String&gt; hello(@RequestBody Map&lt;String,String&gt; result)&#123; //处理回调 orderService.handleNotify(result); log.info("[支付回调] 订单支付成功，订单号：&#123;&#125;",result.get("out_trade_no")); Map&lt;String,String&gt; msg=new HashMap&lt;&gt;(); msg.put("return_code","SUCCESS"); msg.put("retrun_msg","OK"); return msg; &#125;&#125; 在ly-order中编写OrderService 123456789101112131415161718192021222324252627282930313233public void handleNotify(Map&lt;String, String&gt; result) &#123; //1 数据校验 payHelper.isSuccess(result); //2 校验签名 payHelper.isValidSign(result); //3 校验金额 String totalFeeStr = result.get("total_fee"); String outTradeNo = result.get("out_trade_no"); if (StringUtils.isEmpty(totalFeeStr)|| StringUtils.isEmpty(outTradeNo)) &#123; throw new LyException(ExceptionEnums.INVALID_ORDER_PARAM); &#125; //将totalFeeStr转成long,获取结果的金额totalFee Long totalFee = Long.valueOf(totalFeeStr); //获取订单中的金额 Long orderId = Long.valueOf(outTradeNo); Order order = orderMapper.selectByPrimaryKey(orderId); Long actualPay = order.getActualPay(); //结果金额和订单金额是否一样 if (!totalFee.equals(actualPay))&#123; throw new LyException(ExceptionEnums.INVALID_ORDER_PARAM); &#125; //4 修改订单状态 OrderStatus orderStatus = new OrderStatus(); orderStatus.setStatus(OrderStatusEnum.PAYED.value()); orderStatus.setOrderId(orderId); orderStatus.setPaymentTime(new Date()); int i = orderStatusMapper.updateByPrimaryKeySelective(orderStatus); if (i!=1)&#123; throw new LyException(ExceptionEnums.UPDATE_ORDER_ERROR); &#125; log.info("[订单回调] ，订单支付成功",orderId);&#125; 4.6.付款状态查询当用户扫码支付成功，会自动调用回调接口，从而修改订单状态，完成订单支付。但是，页面上并不知道支付是否成功。怎么办? 4.6.1.页面查询支付状态因为不知道用户什么时候会支付，也不知道支付有没有成功，因此页面会采用定时任务，不断查询订单支付的状态: 123456789101112131415161718192021// 开启定时任务，查询付款状态const taskId = setInterval(() =&gt; &#123; ly.http.get("/order-service/order/state/" + id) .then(resp =&gt; &#123; let i = resp.data; if (i === 1) &#123; // 付款成功 clearInterval(taskId); // 跳转到付款成功页 location.href = "/paysuccess.html?orderId=" + id; &#125; else if (i === 2) &#123; // 付款失败 clearInterval(taskId); // 跳转到付款失败页 location.href = "/payfail.html"; &#125; &#125;).catch((e) =&gt; &#123; alert("支付状态查询失败，请刷新页面重试。"); clearInterval(taskId); &#125;)&#125;, 3000); 每隔3秒会查询一次。 4.6.2.微信查询支付状态接口应用场景该接口提供所有微信支付订单的查询，商户可以通过查询订单接口主动查询订单状态，完成下一步的业务逻辑。需要调用查询接口的情况 当商户后台、网络、服务器等出现异常，商户系统最终未接收到支付通知 调用支付接口后，返回系统错误或未知交易状态情况 调用刷卡支付API，返回USERPAYING的状态 调用关单或撤销接口API之前，需确认支付状态 接口链接 https://api.mch.weixin.qg.com/pay/orderquery 是否需要证书不需要 请求参数 举例如下： 1234567&lt;xml&gt; &lt;appid&gt;wx2421b1 c4370ec43b&lt;/appid&gt; &lt;mch_id&gt;10000100&lt;/mch_id&gt; &lt;nonce_str&gt;ec2316275641faa3aac f3cc599e8730f&lt;/nonce_str&gt; &lt;transaction_id&gt;1008450740201411110805820873&lt;/transaction_id&gt; &lt;sign&gt;FDD167FAA73459FD921B144BAF4F4CA2&lt;/sign&gt;&lt;/xml&gt; 返回结果返回结果中，比较重要的是状态信息： 通信状态： 查询状态码： 支付状态： 4.6.3.工具类我们查询完成后，把支付交易状态分为3种情况: 0，通信失败或未支付，需要重新查询。 1，支付成功 2,支付失败 我们定义一个枚举来表示： 在ly-order中的enums中创建 12345678910public enum PayState &#123; NOT_PAY(0),SUCCESS(1),FAIL(2); PayState(int value)&#123; this.value=value; &#125; int value; public int getValue()&#123; return value; &#125;&#125; 然后在工具类PayHelper中添加查询逻辑： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public PayState queryPayStatus(Long orderId) &#123; try &#123; //组织请求参数 Map&lt;String, String&gt; data = new HashMap&lt;&gt;(); //订单号 data.put("out_trade_no", orderId.toString()); //查询状态 Map&lt;String, String&gt; result = wxPay.orderQuery(data); // 通信和业务校验 isSuccess(result); //校验签名 isValidSign(result); //3 校验金额 String totalFeeStr = result.get("total_fee"); String outTradeNo = result.get("out_trade_no"); if (StringUtils.isEmpty(totalFeeStr)|| StringUtils.isEmpty(outTradeNo)) &#123; throw new LyException(ExceptionEnums.INVALID_ORDER_PARAM); &#125; //将totalFeeStr转成long,获取结果的金额totalFee Long totalFee = Long.valueOf(totalFeeStr); //获取订单中的金额 Order order = orderMapper.selectByPrimaryKey(orderId); Long actualPay = order.getActualPay(); //结果金额和订单金额是否一样 if (!totalFee.equals(/*actualPay*/1))&#123; throw new LyException(ExceptionEnums.INVALID_ORDER_PARAM); &#125; /** * 判断支付是否成功或失败 * SUCCESS—支付成功 * * REFUND—转入退款 * * NOTPAY—未支付 * * CLOSED—已关闭 * * REVOKED—已撤销（付款码支付） * * USERPAYING--用户支付中（付款码支付） * * PAYERROR--支付失败 */ String state = result.get("trade_state"); if (WXPayConstants.SUCCESS.equals(state))&#123; //4 修改订单状态 OrderStatus orderStatus = new OrderStatus(); orderStatus.setStatus(OrderStatusEnum.PAYED.value()); orderStatus.setOrderId(orderId); orderStatus.setPaymentTime(new Date()); int i = orderStatusMapper.updateByPrimaryKeySelective(orderStatus); if (i!=1)&#123; throw new LyException(ExceptionEnums.UPDATE_ORDER_ERROR); &#125; return PayState.SUCCESS; &#125; if ("NOTPAY".equals(state)||"USERPAYING".equals(state))&#123; return PayState.NOT_PAY; &#125; return PayState.FAIL; &#125; catch (Exception e) &#123; return PayState.NOT_PAY; &#125;&#125; 在ly-order中的orderController中编写controller 123456789/** * 查询订单状态 * @param orderId * @return */@GetMapping("state/&#123;id&#125;")public ResponseEntity&lt;Integer&gt; queryStatusById(@PathVariable("id")Long orderId)&#123; return ResponseEntity.ok(orderService.queryStatusById(orderId).getValue());&#125; 在ly-order的service中编写 123456789101112public PayState queryStatusById(Long orderId) &#123; //查询订单状态 OrderStatus orderStatus = orderStatusMapper.selectByPrimaryKey(orderId); Integer status = orderStatus.getStatus(); //判断是否支付 if (!status.equals(OrderStatusEnum.UN_PAY.value())) &#123; //如果已支付，真的是已支付 return PayState.SUCCESS; &#125; //如果未支付，但是其实不一定未支付，必须去微信查询状态 return payHelper.queryPayStatus(orderId);&#125;]]></content>
      <categories>
        <category>项目实战-微服务商城</category>
      </categories>
      <tags>
        <tag>微信支付</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务商城（十七）—— 授权中心]]></title>
    <url>%2Fday16-%E6%8E%88%E6%9D%83%E4%B8%AD%E5%BF%83.html</url>
    <content type="text"><![CDATA[0.学习目标1.无状态登录原理1.1.什么是有状态？有状态服务，即服务端需要记录每次会话的客户端信息，从而识别客户端身份，根据用户身份进行请求的处理，典型的设计如tomcat中的session。 例如登录：用户登录后，我们把登录者的信息保存在服务端session中，并且给用户一个cookie值，记录对应的session。然后下次请求，用户携带cookie值来，我们就能识别到对应session，从而找到用户的信息。 缺点是什么？ 服务端保存大量数据，增加服务端压力 服务端保存用户状态，无法进行水平扩展 客户端请求依赖服务端，多次请求必须访问同一台服务器 1.2.什么是无状态微服务集群中的每个服务，对外提供的都是Rest风格的接口。而Rest风格的一个最重要的规范就是：服务的无状态性，即： 服务端不保存任何客户端请求者信息 客户端的每次请求必须具备自描述信息，通过这些信息识别客户端身份 带来的好处是什么呢？ 客户端请求不依赖服务端的信息，任何多次请求不需要必须访问到同一台服务 服务端的集群和状态对客户端透明 服务端可以任意的迁移和伸缩 减小服务端存储压力 1.3.如何实现无状态无状态登录的流程： 当客户端第一次请求服务时，服务端对用户进行信息认证（登录） 认证通过，将用户信息进行加密形成token，返回给客户端，作为登录凭证 以后每次请求，客户端都携带认证的token 服务端对token进行解密，判断是否有效。 流程图： 整个登录过程中，最关键的点是什么？ token的安全性 token是识别客户端身份的唯一标示，如果加密不够严密，被人伪造那就完蛋了。 采用何种方式加密才是安全可靠的呢？ 我们将采用JWT + RSA非对称加密 1.4.JWT1.4.1.简介JWT，全称是Json Web Token， 是JSON风格轻量级的授权和身份认证规范，可实现无状态、分布式的Web应用授权；官网：https://jwt.io GitHub上jwt的java客户端：https://github.com/jwtk/jjwt 1.4.2.数据格式JWT包含三部分数据： Header：头部，通常头部有两部分信息： 声明类型，这里是JWT 加密算法，自定义 我们会对头部进行base64加密（可解密），得到第一部分数据 Payload：载荷，就是有效数据，一般包含下面信息： 用户身份信息（注意，这里因为采用base64加密，可解密，因此不要存放敏感信息） 注册声明：如token的签发时间，过期时间，签发人等 这部分也会采用base64加密，得到第二部分数据 Signature：签名，是整个数据的认证信息。一般根据前两步的数据，再加上服务的的密钥（secret）（不要泄漏，最好周期性更换），通过加密算法生成。用于验证整个数据完整和可靠性 生成的数据格式： 可以看到分为3段，每段就是上面的一部分数据 1.4.3.JWT交互流程流程图： 步骤翻译： 1、用户登录 2、服务的认证，通过后根据secret生成token 3、将生成的token返回给浏览器 4、用户每次请求携带token 5、服务端利用公钥解读jwt签名，判断签名有效后，从Payload中获取用户信息 6、处理请求，返回响应结果 因为JWT签发的token中已经包含了用户的身份信息，并且每次请求都会携带，这样服务的就无需保存用户信息，甚至无需去数据库查询，完全符合了Rest的无状态规范。 1.4.4.非对称加密加密技术是对信息进行编码和解码的技术，编码是把原来可读信息（又称明文）译成代码形式（又称密文），其逆过程就是解码（解密），加密技术的要点是加密算法，加密算法可以分为三类： 对称加密，如AES 基本原理：将明文分成N个组，然后使用密钥对各个组进行加密，形成各自的密文，最后把所有的分组密文进行合并，形成最终的密文。 优势：算法公开、计算量小、加密速度快、加密效率高 缺陷：双方都使用同样密钥，安全性得不到保证 非对称加密，如RSA 基本原理：同时生成两把密钥：私钥和公钥，私钥隐秘保存，公钥可以下发给信任客户端 私钥加密，持有私钥或公钥才可以解密 公钥加密，持有私钥才可解密 优点：安全，难以破解 缺点：算法比较耗时 不可逆加密，如MD5，SHA 基本原理：加密过程中不需要使用密钥，输入明文后由系统直接经过加密算法处理成密文，这种加密后的数据是无法被解密的，无法根据密文推算出明文。 RSA算法历史： 1977年，三位数学家Rivest、Shamir 和 Adleman 设计了一种算法，可以实现非对称加密。这种算法用他们三个人的名字缩写：RSA 1.5.结合Zuul的鉴权流程我们逐步演进系统架构设计。需要注意的是：secret是签名的关键，因此一定要保密，我们放到鉴权中心保存，其它任何服务中都不能获取secret。 1.5.1.没有RSA加密时在微服务架构中，我们可以把服务的鉴权操作放到网关中，将未通过鉴权的请求直接拦截，如图： 1、用户请求登录 2、Zuul将请求转发到授权中心，请求授权 3、授权中心校验完成，颁发JWT凭证 4、客户端请求其它功能，携带JWT 5、Zuul将jwt交给授权中心校验，通过后放行 6、用户请求到达微服务 7、微服务将jwt交给鉴权中心，鉴权同时解析用户信息 8、鉴权中心返回用户数据给微服务 9、微服务处理请求，返回响应 发现什么问题了？ 每次鉴权都需要访问鉴权中心，系统间的网络请求频率过高，效率略差，鉴权中心的压力较大。 1.5.2.结合RSA的鉴权直接看图： 我们首先利用RSA生成公钥和私钥。私钥保存在授权中心，公钥保存在Zuul和各个微服务 用户请求登录 授权中心校验，通过后用私钥对JWT进行签名加密 返回jwt给用户 用户携带JWT访问 Zuul直接通过公钥解密JWT，进行验证，验证通过则放行 请求到达微服务，微服务直接用公钥解析JWT，获取用户信息，无需访问授权中心 2.授权中心2.1.创建授权中心授权中心的主要职责： 用户鉴权： 接收用户的登录请求，通过用户中心的接口进行校验，通过后生成JWT 使用私钥生成JWT并返回 服务鉴权：微服务间的调用不经过Zuul，会有风险，需要鉴权中心进行认证 原理与用户鉴权类似，但逻辑稍微复杂一些（此处我们不做实现） 因为生成jwt，解析jwt这样的行为以后在其它微服务中也会用到，因此我们会抽取成工具。我们把鉴权中心进行聚合，一个工具module，一个提供服务的module 2.1.1.创建父module我们先创建父module，名称为：ly-auth 将pom打包方式改为pom： 12345678910111213141516&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;leyou&lt;/artifactId&gt; &lt;groupId&gt;com.leyou.parent&lt;/groupId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.auth&lt;/groupId&gt; &lt;artifactId&gt;leyou-auth&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;&lt;/project&gt; 2.1.2.通用module然后是授权服务的通用模块：ly-auth-common： pom.xml： 12345678910111213141516&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;leyou-auth&lt;/artifactId&gt; &lt;groupId&gt;com.leyou.auth&lt;/groupId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.auth&lt;/groupId&gt; &lt;artifactId&gt;leyou-auth-common&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/project&gt; 结构： 2.1.3.授权服务ly-auth-service pom.xml： 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;ly-auth&lt;/artifactId&gt; &lt;groupId&gt;com.leyou.service&lt;/groupId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.service&lt;/groupId&gt; &lt;artifactId&gt;ly-auth-service&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.leyou.service&lt;/groupId&gt; &lt;artifactId&gt;ly-auth-common&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.leyou.common&lt;/groupId&gt; &lt;artifactId&gt;ly-common&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 引导类： 123456789@SpringBootApplication@EnableDiscoveryClient@EnableFeignClientspublic class LyAuthApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(LyAuthApplication.class, args); &#125;&#125; application.yml 12345678910111213141516server: port: 8087spring: application: name: auth-serviceeureka: client: service-url: defaultZone: http://127.0.0.1:10086/eureka registry-fetch-interval-seconds: 10 instance: lease-renewal-interval-in-seconds: 5 # 每隔5秒发送一次心跳 lease-expiration-duration-in-seconds: 10 # 10秒不发送就过期 prefer-ip-address: true ip-address: 127.0.0.1 instance-id: $&#123;spring.application.name&#125;:$&#123;server.port&#125; 结构： 在ly-gateway工程的application.yml中，修改路由： 1234567zuul: prefix: /api # 路由路径前缀 routes: item-service: /item/** # 商品微服务的映射路径 search-service: /search/** # 搜索微服务 user-service: /user/** # 用户微服务 auth-service: /auth/** # 授权中心微服务 2.2.JWT工具类我们在ly-auth-common中导入课前资料中的工具类： 在资料中的JWT攻工具类中 UserInfo：载荷类 JwtConstans：其中定义了jwt中的payload的常用key JwtUtils：公钥秘钥操作token ObjectUtils：从jwt解析得到的数据是Object类型，转换为具体类型可能出现空指针，这个工具类进行了一些转换 RsaUtils：对秘钥公钥操作 需要在ly-auth-common中引入JWT依赖： 123456789101112131415&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt&lt;/artifactId&gt; &lt;version&gt;0.9.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;joda-time&lt;/groupId&gt; &lt;artifactId&gt;joda-time&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 2.3.测试工具类我们在ly-auth-common中编写测试类： ==注测试类不需要@RunWith(SpringRunner.class)，@SpringBootTest== 1234567891011121314151617181920212223242526272829303132333435363738public class JwtTest &#123; private static final String pubKeyPath = "D:\\heima\\rsa\\rsa.pub"; private static final String priKeyPath = "D:\\heima\\rsa\\rsa.pri"; private PublicKey publicKey; private PrivateKey privateKey; @Test public void testRsa() throws Exception &#123; RsaUtils.generateKey(pubKeyPath, priKeyPath, "234"); &#125; @Before public void testGetRsa() throws Exception &#123; this.publicKey = RsaUtils.getPublicKey(pubKeyPath); this.privateKey = RsaUtils.getPrivateKey(priKeyPath); &#125; @Test public void testGenerateToken() throws Exception &#123; // 生成token String token = JwtUtils.generateToken(new UserInfo(20L, "jack"), privateKey, 5); System.out.println("token = " + token); &#125; @Test public void testParseToken() throws Exception &#123; String token = "eyJhbGciOiJSUzI1NiJ9.eyJpZCI6MjAsInVzZXJOYW1lIjoiamFjayIsImV4cCI6MTUyNzMzMDY5NX0.VpGNedy1z0aR262uAp2sM6xB4ljuxa4fzqyyBpZcGTBNLodIfuCNZkOjdlqf-km6TQPoz3epYf8cc_Rf9snsGdz4YPIwpm6X14JKU9jwL74q6zy61J8Nl9q7Zu3YnLibAvcnC_y9omiqKN8-iCi7-MvM-LwVS7y_Cx9eu0aaY8E"; // 解析token UserInfo user = JwtUtils.getInfoFromToken( publicKey,token); System.out.println("id: " + user.getId()); System.out.println("userName: " + user.getName()); &#125;&#125; 测试生成公钥和私钥，我们运行这段代码： 运行之后，查看目标目录： 公钥和私钥已经生成了！ 测试生成token，把@Before的注释去掉的： 将上述得到的token复制到testParseToken（）中，并测试解析token： 正常情况： 解析得到 任意改动token，发现报错了： 2.3.编写登录授权接口接下来，我们需要在ly-auth-servcice编写一个接口，对外提供登录授权服务。基本流程如下： 客户端携带用户名和密码请求登录 授权中心调用客户中心接口，根据用户名和密码查询用户信息 如果用户名密码正确，能获取用户，否则为空，则登录失败 如果校验成功，则生成JWT并返回 2.3.1.生成公钥和私钥我们需要在授权中心 ly-auth-service 中生成真正的公钥和私钥。我们必须有一个生成公钥和私钥的secret，这个可以配置到application.yml中： 123456ly: jwt: secret: leyou@Login(Auth&#125;*^31)&amp;heiMa% # 登录校验的密钥 pubKeyPath: D:\\heima\\rsa\\rsa.pub # 公钥地址 priKeyPath: D:\\heima\\rsa\\rsa.pri # 私钥地址 expire: 30 # 过期时间,单位分钟 然后编写属性类，加载这些数据： 在ly-auth-service的pom.xml添加 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; ly-auth-service中com.leyou.auth.config中创建 1234567891011121314151617181920212223242526272829303132333435363738394041@Data@ConfigurationProperties(prefix = "ly.jwt")public class JwtProperties &#123; private String secret; // 密钥 private String pubKeyPath;// 公钥 private String priKeyPath;// 私钥 private int expire;// token过期时间 private PublicKey publicKey; // 公钥 private PrivateKey privateKey; // 私钥 private static final Logger logger = LoggerFactory.getLogger(JwtProperties.class); /** * @PostContruct：在构造方法执行之后执行该方法 */ @PostConstruct public void init()&#123; try &#123; File pubKey = new File(pubKeyPath); File priKey = new File(priKeyPath); if (!pubKey.exists() || !priKey.exists()) &#123; // 生成公钥和私钥 RsaUtils.generateKey(pubKeyPath, priKeyPath, secret); &#125; // 获取公钥和私钥 this.publicKey = RsaUtils.getPublicKey(pubKeyPath); this.privateKey = RsaUtils.getPrivateKey(priKeyPath); &#125; catch (Exception e) &#123; logger.error("初始化公钥和私钥失败！", e); throw new RuntimeException(); &#125; &#125; // getter setter ...&#125; 2.3.2.Controller编写授权接口，我们接收用户名和密码，校验成功后，写入cookie中。 请求方式：post 请求路径：/accredit 请求参数：username和password 返回结果：无 代码： 123456789101112131415161718192021222324252627282930313233/** * @version V1.0 * @ClassName:$&#123;file_name&#125; * @Description:授权中心 * @author:cxg * @Date:$&#123;time&#125; */public class AuthController &#123; @Autowired private AuthService authService; @Autowired private JwtProperties jwtProperties; /** * 登入授权功能 * @param username * @param password * @return */ @PostMapping("login") public ResponseEntity&lt;Void&gt; login( @RequestParam("username")String username, @RequestParam("password")String password, HttpServletRequest request, HttpServletResponse response)&#123; //登入校验 String token = authService.login(username, password); //将token写入cookie,并指定httpOnly为true，防止通过JS获取和修改 //同CookieUtils.newBuilder(response).httpOnly().request(request).build(cookieName,token)一样 CookieUtils.setCookie(request,response,jwtProperties.getCookieName(),token,jwtProperties.getCookieMaxage(),true); return ResponseEntity.status(HttpStatus.NO_CONTENT).build(); &#125;&#125; 这里的cookie的name和生存时间，我们配置到属性文件：application.yml： 然后在JwtProperties中添加属性： 2.3.3.CookieUtils要注意，这里我们使用了一个工具类，CookieUtils，可以在课前资料中找到，我们把它添加到leyou-common中，然后引入servlet相关依赖即可： 1234&lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-core&lt;/artifactId&gt;&lt;/dependency&gt; 代码：略 2.3.3.UserAPi和UserClient UserAPi 在ly-user-service中编写对外接口 1234567891011public interface UserAPi &#123; /** * 根据用户名和密码查询用户 * @param username * @param password * @return */ @GetMapping("query") public User queryUser(@RequestParam("username")String username, @RequestParam("password")String password);&#125; UserClient 接下来我们肯定要对用户密码进行校验，所以我们需要通过FeignClient去访问 user-service微服务： 在ly-anth-service中的pom.xml中引入user-service依赖： 12345&lt;dependency&gt; &lt;groupId&gt;com.leyou.service&lt;/groupId&gt; &lt;artifactId&gt;ly-user-service&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt; 编写FeignClient： 123@FeignClient(value = "user-service")public interface UserClient extends UserApi &#123;&#125; 2.3.4.Servicely-auth-service中的service 123456789101112131415161718192021222324252627282930@Servicepublic class AuthService &#123; @Autowired private UserClient userClient; @Autowired private JwtProperties properties; public String authentication(String username, String password) &#123; try &#123; // 调用微服务，执行查询 User user = this.userClient.queryUser(username, password); // 如果查询结果为null，则直接返回null if (user == null) &#123; return null; &#125; // 如果有查询结果，则生成token String token = JwtUtils.generateToken(new UserInfo(user.getId(), user.getUsername()), properties.getPrivateKey(), properties.getExpire()); return token; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125; 2.3.5.项目结构 2.3.6.测试 2.4.登录页面接下来，我们看看登录页面，是否能够正确的发出请求。 我们在页面输入登录信息，然后点击登录： 查看控制台： 发现请求的路径不对，我们的认证接口是： 1/api/auth/login 我们打开login.html，修改路径信息： 页面ajax请求： 然后再次测试，成功跳转到了首页： 2.5.解决cookie写入问题接下来我们查看首页cookie： 什么都没有，为什么？ 2.5.1.问题分析我们在之前测试时，清晰的看到了响应头中，有Set-Cookie属性，为什么在这里却什么都没有？ 我们之前在讲cors跨域时，讲到过跨域请求cookie生效的条件： 服务的响应头中需要携带Access-Control-Allow-Credentials并且为true。 响应头中的Access-Control-Allow-Origin一定不能为*，必须是指定的域名 浏览器发起ajax需要指定withCredentials 为true 看看我们的服务端cors配置： 没有任何问题。 再看客户端浏览器的ajax配置，我们在js/common.js中对axios进行了统一配置： 一切OK。 那说明，问题一定出在响应的set-cookie头中。我们再次仔细看看刚才的响应头： 我们发现cookie的 domain属性似乎不太对。 cookie也是有域 的限制，一个网页，只能操作当前域名下的cookie，但是现在我们看到的地址是0.0.1，而页面是www.leyou.com,域名不匹配，cookie设置肯定失败了！ 2.5.2.跟踪CookieUtils我们去Debug跟踪CookieUtils，看看到底是怎么回事： 我们发现内部有一个方法，用来获取Domain： 它获取domain是通过服务器的host来计算的，然而我们的地址竟然是：127.0.0.1:8087，因此后续的运算，最终得到的domain就变成了： 问题找到了：我们请求时的serverName明明是：api.leyou.com，现在却被变成了：127.0.0.1，因此计算domain是错误的，从而导致cookie设置失败！ 2.5.3.解决host地址的变化那么问题来了：为什么我们这里的请求serverName变成了：127.0.0.1:8087呢？ 这里的server name其实就是请求时的主机名：Host，之所以改变，有两个原因： 我们使用了nginx反向代理，当监听到api.leyou.com的时候，会自动将请求转发至127.0.0.1:10010，即Zuul。 而后请求到达我们的网关Zuul，Zuul就会根据路径匹配，我们的请求是/api/auth，根据规则被转发到了 127.0.0.1:8087 ，即我们的授权中心。 我们首先去更改nginx配置，让它不要修改我们的host：proxy_set_header Host $host; 把nginx进行reload： 1nginx -s reload 这样就解决了nginx这里的问题。但是Zuul还会有一次转发，所以要去修改网关的配置（ly-gateway工程）： 重启后，我们再次测试。 最后计算得到的domain： 完美！ 2.5.4.再次测试我们再次登录，发现依然没有cookie！！ 怎么回事呢？ 我们通过RestClient访问下看看： 发现，响应头中根本没有set-cookie了。 这是怎么回事？？ 2.5.5.Zuul的敏感头过滤Zuul内部有默认的过滤器，会对请求和响应头信息进行重组，过滤掉敏感的头信息： 会发现，这里会通过一个属性为SensitiveHeaders的属性，来获取敏感头列表，然后添加到IgnoredHeaders中，这些头信息就会被忽略。 而这个SensitiveHeaders的默认值就包含了set-cookie： 解决方案有两种： 全局设置： zuul.sensitive-headers= 指定路由设置： zuul.routes.&lt;routeName&gt;.sensitive-headers= zuul.routes.&lt;routeName&gt;.custom-sensitive-headers=true 思路都是把敏感头设置为null 2.5.6.最后的测试再次重启后测试： 3.首页判断登录状态虽然cookie已经成功写入，但是我们首页的顶部，登录状态依然没能判断出用户信息： 这里需要向后台发起请求，根据cookie获取当前用户的信息。 我们先看页面实现 3.1.页面JS代码页面的顶部已经被我们封装为一个独立的Vue组件，在/js/pages/shortcut.js中 打开js，发现里面已经定义好了Vue组件，并且在created函数中，查询用户信息： 查看网络控制台，发现发起了请求： 因为token在cookie中，因此本次请求肯定会携带token信息在头中。 3.2.后台实现校验用户接口我们在ly-auth-service中定义用户的校验接口，通过cookie获取token，然后校验通过返回用户信息。 请求方式：GET 请求路径：/verify 请求参数：无，不过我们需要从cookie中获取token信息 返回结果：UserInfo，校验成功返回用户信息；校验失败，则返回401 代码： 12345678910111213141516/** * 校验用户登入状态，获取用户名显示在前端 * @param token * @return */@GetMapping("verify")public ResponseEntity&lt;UserInfo&gt; verify(@CookieValue("LY_TOKEN")String token)&#123; try &#123; UserInfo info = JwtUtils.getInfoFromToken(jwtProperties.getPublicKey(), token); return ResponseEntity.ok(info); &#125;catch (Exception e)&#123; //token已经过期，或者，token已经被篡改 throw new LyException(ExceptionEnums.UN_AUTHORIZED); &#125;&#125; 3.3.测试 页面效果： 3.4.刷新token每当用户在页面进行新的操作，都应该刷新token的过期时间，否则30分钟后用户的登录信息就无效了。而刷新其实就是重新生成一份token，然后写入cookie即可。 那么问题来了：我们怎么知道用户有操作呢？ 事实上，每当用户来查询其个人信息，就证明他正在浏览网页，此时刷新cookie是比较合适的时机。因此我们可以对刚刚的校验用户登录状态的接口进行改进，加入刷新token的逻辑。 12345678910111213141516171819202122/** * 校验用户登入状态，获取用户名显示在前端 * @param token * @return */@GetMapping("verify")public ResponseEntity&lt;UserInfo&gt; verify(@CookieValue("LY_TOKEN")String token, HttpServletRequest request, HttpServletResponse response)&#123; try &#123; UserInfo info = JwtUtils.getInfoFromToken(jwtProperties.getPublicKey(), token); //重新刷新token String newToken = JwtUtils.generateToken(info, jwtProperties.getPrivateKey(), jwtProperties.getExpire()); //写入cookie CookieUtils.newBuilder(response).httpOnly().maxAge(jwtProperties.getCookieMaxage()).request(request).build(jwtProperties.getCookieName(),newToken); return ResponseEntity.ok(info); &#125;catch (Exception e)&#123; //token已经过期，或者，token已经被篡改 throw new LyException(ExceptionEnums.UN_AUTHORIZED); &#125;&#125; 4.网关的登录拦截器接下来，我们在Zuul编写拦截器，对用户的token进行校验，如果发现未登录，则进行拦截。 4.1.引入jwt相关配置既然是登录拦截，一定是前置拦截器，我们在ly-gateway中定义。 首先在pom.xml中，引入所需要的依赖： 12345678910&lt;dependency&gt; &lt;groupId&gt;com.leyou.common&lt;/groupId&gt; &lt;artifactId&gt;ly-common&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.leyou.auth&lt;/groupId&gt; &lt;artifactId&gt;ly-auth-common&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt; 然后编写application.yml属性文件，添加如下内容： 1234ly: jwt: pubKeyPath: D:\\heima\\rsa\\rsa.pub # 公钥地址 CookieName: LY_TOKEN 编写属性类，读取公钥： 12345678910111213141516171819@Data@ConfigurationProperties(prefix = "ly.jwt")public class JwtProperties &#123; private String pubKeyPath;// 公钥 private String CookieName; private Integer CookieMaxage; private PublicKey publicKey; //对象一旦实例化后，就应该读取公钥和私钥 @PostConstruct //实例化后执行 public void init() throws Exception &#123; //读取公钥和私钥 this.publicKey = RsaUtils.getPublicKey(pubKeyPath); &#125;&#125; 4.2.编写过滤器逻辑基本逻辑： 获取cookie中的token 通过JWT对token进行校验 通过：则放行；不通过：则重定向到登录页 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051@Component@EnableConfigurationProperties(JwtProperties.class)public class AuthFilter extends ZuulFilter&#123; @Autowired private JwtProperties jwtProperties; @Override public String filterType() &#123; return FilterConstants.PRE_TYPE;//过滤器类型，前置过滤 &#125; @Override public int filterOrder() &#123; return FilterConstants.PRE_DECORATION_FILTER_ORDER-1;//过滤器顺序 &#125; /** * 放行逻辑 * true：过滤 * false：不过滤 * @return */ @Override public boolean shouldFilter() &#123; return true; &#125; @Override public Object run() throws ZuulException &#123; //获取上下文 RequestContext ctx = RequestContext.getCurrentContext(); //获取request HttpServletRequest request = ctx.getRequest(); //获取cookie中的token String token = CookieUtils.getCookieValue(request, jwtProperties.getCookieName()); try &#123; //解析token UserInfo userInfo = JwtUtils.getInfoFromToken(jwtProperties.getPublicKey(), token); //todo 校验权限 &#125;catch (Exception e)&#123; //解析token失败，未登入，拦截 ctx.setSendZuulResponse(false); ctx.setResponseStatusCode(403); &#125; return null; &#125;&#125; 4.2.1测试http://api.leyou.com/api/item/category/list?pid=0 同时一切请求都被拦截下来 重启，刷新页面，发现请求校验的接口也被拦截了： 证明我们的拦截器生效了，但是，似乎有什么不对的。这个路径似乎不应该被拦截啊！ 4.3.白名单要注意，并不是所有的路径我们都需要拦截，例如： 登录校验接口：/auth/** 注册接口：/user/register 数据校验接口：/user/check/** 发送验证码接口：/user/code 搜索接口：/search/** 另外，跟后台管理相关的接口，因为我们没有做登录和权限，因此暂时都放行，但是生产环境中要做登录校验： 后台商品服务：/item/** 所以，我们需要在拦截时，配置一个白名单，如果在名单内，则不进行拦截。 在ly-gateway中application.yaml中添加规则： 123456789ly: filter: allowPaths: - /api/auth - /api/search - /api/user/register - /api/user/check - /api/user/code - /api/item 然后读取这些属性： 内容： 12345@Data@ConfigurationProperties(prefix = "ly.filter")public class FilterProperties &#123; private List&lt;String&gt; allowPaths;&#125; 在过滤器中的shouldFilter方法中添加判断逻辑： 代码： 修改ly-gateway拦截页面AuthFilter.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475@Component@EnableConfigurationProperties(&#123;JwtProperties.class, FilterProperties.class&#125;)public class AuthFilter extends ZuulFilter&#123; @Autowired private JwtProperties jwtProperties; @Autowired private FilterProperties filterProperties; @Override public String filterType() &#123; return FilterConstants.PRE_TYPE;//过滤器类型，前置过滤 &#125; @Override public int filterOrder() &#123; return FilterConstants.PRE_DECORATION_FILTER_ORDER-1;//过滤器顺序 &#125; /** * 放行逻辑 * true：过滤 * false：不过滤 * @return */ @Override public boolean shouldFilter() &#123; //获取上下文 RequestContext ctx = RequestContext.getCurrentContext(); //获取request HttpServletRequest request = ctx.getRequest(); //获取请求的url路径 String requestURL = request.getRequestURI(); //判断是否放行，否则返回false boolean isAllowPath=isAllowPath(requestURL); return !isAllowPath; &#125; /** * 判断路径 * @param requestURL * @return */ private Boolean isAllowPath(String requestURL) &#123; for (String allowPath : filterProperties.getAllowPaths()) &#123; //判断路径是否相等 if (requestURL.startsWith(allowPath))&#123; return true; &#125; &#125; return false; &#125; @Override public Object run() throws ZuulException &#123; //获取上下文 RequestContext ctx = RequestContext.getCurrentContext(); //获取request HttpServletRequest request = ctx.getRequest(); //获取cookie中的token String token = CookieUtils.getCookieValue(request, jwtProperties.getCookieName()); try &#123; //解析token UserInfo userInfo = JwtUtils.getInfoFromToken(jwtProperties.getPublicKey(), token); //todo 校验权限 &#125;catch (Exception e)&#123; //解析token失败，未登入，拦截 ctx.setSendZuulResponse(false); ctx.setResponseStatusCode(403); &#125; return null; &#125;&#125; 再次测试： 4.4.可优化的点授权登录还需要完善: 需要引入权限控制系统 在AuthFiter中， 应该判断权限 授权中心还可以做服务鉴权 面试点: 如果cookie被禁用怎么办? 首先可以提示用户，网站必须使用cookie,不能禁用。 把token放入头中返回，JS中获取头信息，存入web存储(localStorage,SessionStorage) ,每次请求都需要手动携带token,写入头中。 如果cookie被盗用怎么办？ 我们的cookie无法篡改 加入ip地址识别身份(不太好)。使用HTTPS协议，防止数据泄漏 如果你的微服务地址暴露怎么办? 首先地址不会暴露，因为所有微服务都是通过Zuuli进行访问，对外暴露的只有Zuul 万一暴露了呢? 服务间鉴权。 1querySkuByids]]></content>
      <categories>
        <category>项目实战-微服务商城</category>
      </categories>
      <tags>
        <tag>JWT工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务商城（十六）——用户注册]]></title>
    <url>%2Fday15-%E7%94%A8%E6%88%B7%E6%B3%A8%E5%86%8C.html</url>
    <content type="text"><![CDATA[0.学习目标 独立创建用户中心 了解面向接口开发方式 实现数据校验功能 实现短信发送功能 实现注册功能 实现根据用户名和密码查询用户功能 1.创建用户中心用户搜索到自己心仪的商品，接下来就要去购买，但是购买必须先登录。所以接下来我们编写用户中心，实现用户的登录和注册功能。 用户中心的提供的服务： 用户的注册 用户登录 用户个人信息管理 用户地址管理 用户收藏管理 我的订单 优惠券管理 这里我们暂时先实现基本的：注册和登录功能，其它功能大家可以自行补充完整。 因为用户中心的服务其它微服务也会调用，因此这里我们做聚合。 ly-user：父工程，包含2个子工程： ly-user-interface：实体及接口 ly-user-service：业务和服务 1.1.创建父module创建 1.2.创建子工程ly-user-interface在leyou-user下，创建module： 位置： pom： 12345678910111213141516&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;ly-user&lt;/artifactId&gt; &lt;groupId&gt;com.leyou.service&lt;/groupId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.service&lt;/groupId&gt; &lt;artifactId&gt;ly-user-interface&lt;/artifactId&gt;&lt;/project&gt; 1.3.创建子工程ly-user-service创建module 位置 pom 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;ly-user&lt;/artifactId&gt; &lt;groupId&gt;com.leyou.service&lt;/groupId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.service&lt;/groupId&gt; &lt;artifactId&gt;ly-user-service&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- mybatis启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 通用Mapper启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- mysql驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.leyou.service&lt;/groupId&gt; &lt;artifactId&gt;ly-user-interface&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 启动类 123456789@SpringBootApplication@EnableDiscoveryClient@MapperScan("com.leyou.user.mapper")public class LyUserApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(LyUserApplication.class, args); &#125;&#125; 配置： 12345678910111213141516171819202122232425server: port: 8085spring: application: name: user-service datasource: url: jdbc:mysql://localhost:3306/leyou-new?serverTimezone=Asia/Shanghai&amp;characterEncoding=utf8 username: root password: cxg200888 hikari: maximum-pool-size: 30 minimum-idle: 10eureka: client: service-url: defaultZone: http://127.0.0.1:10086/eureka instance: prefer-ip-address: true ip-address: 127.0.0.1 instance-id: $&#123;eureka.instance.ip-address&#125;.$&#123;server.port&#125; lease-renewal-interval-in-seconds: 5 lease-expiration-duration-in-seconds: 15mybatis: type-aliases-package: com.leyou.user.pojo 父工程lyeyou-user的pom： 12345678910111213141516171819&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;leyou&lt;/artifactId&gt; &lt;groupId&gt;com.leyou.parent&lt;/groupId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.service&lt;/groupId&gt; &lt;artifactId&gt;ly-user&lt;/artifactId&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;modules&gt; &lt;module&gt;ly-user-interface&lt;/module&gt; &lt;module&gt;ly-user-service&lt;/module&gt; &lt;/modules&gt;&lt;/project&gt; 1.4.添加网关路由我们修改ly-gateway，添加路由规则，对ly-user-service进行路由: 2.后台功能准备2.1.接口文档整个用户中心的开发，我们将模拟公司内面向接口的开发。 现在假设项目经理已经设计好了接口文档，详见：《用户中心接口说明.md》 我们将根据文档直接编写后台功能，不关心页面实现。 2.2.数据结构12345678910CREATE TABLE `tb_user` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `username` varchar(50) NOT NULL COMMENT &apos;用户名&apos;, `password` varchar(32) NOT NULL COMMENT &apos;密码，加密存储&apos;, `phone` varchar(20) DEFAULT NULL COMMENT &apos;注册手机号&apos;, `created` datetime NOT NULL COMMENT &apos;创建时间&apos;, `salt` varchar(32) NOT NULL COMMENT &apos;密码加密的salt值&apos;, PRIMARY KEY (`id`), UNIQUE KEY `username` (`username`) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=28 DEFAULT CHARSET=utf8 COMMENT=&apos;用户表&apos;; 数据结构比较简单，因为根据用户名查询的频率较高，所以我们给用户名创建了索引 2.3.基本代码 2.3.1.实体类123456789101112131415161718@Table(name = "tb_user")public class User &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; private String username;// 用户名 @JsonIgnore private String password;// 密码 private String phone;// 电话 private Date created;// 创建时间 @JsonIgnore private String salt;// 密码的盐值&#125; 注意：为了安全考虑。这里对password和salt添加了注解@JsonIgnore，这样在json序列化时，就不会把password和salt返回。 2.3.2.mapper12public interface UserMapper extends Mapper&lt;User&gt; &#123;&#125; 2.3.3.Service123456@Servicepublic class UserService &#123; @Autowired private UserMapper userMapper;&#125; 2.3.4.controller1234567@Controllerpublic class UserController &#123; @Autowired private UserService userService; &#125; 3.数据验证功能3.1.接口说明实现用户数据的校验，主要包括对：手机号、用户名的唯一性校验。 接口路径： 1GET /check/&#123;data&#125;/&#123;type&#125; 参数说明： 参数 说明 是否必须 数据类型 默认值 data 要校验的数据 是 String 无 type 要校验的数据类型：1，用户名；2，手机； 否 Integer 1 返回结果： 返回布尔类型结果： true：可用 false：不可用 状态码： 200：校验成功 400：参数有误 500：服务器内部异常 3.2.controller因为有了接口，我们可以不关心页面，所有需要的东西都一清二楚： 请求方式：GET 请求路径：/check/{data}/{type} 请求参数：param,type 返回结果：true或false 12345678910111213141516171819@RestControllerpublic class UserController &#123; @Autowired private UserService userService; /** * 校验数据是否可用 * @param data 数据 * @param type 要校验的数据类型：1，用户名；2，手机； * @return */ @GetMapping("/check/&#123;data&#125;/&#123;type&#125;") public ResponseEntity&lt;Boolean&gt; checkData(@PathVariable("data") String data, @PathVariable("type")Integer type)&#123; return ResponseEntity.ok(userService.checkData(data,type)); &#125; &#125; 3.3.Service123456789101112131415161718192021@Servicepublic class UserService &#123; @Autowired private UserMapper userMapper; public Boolean checkData(String data, Integer type) &#123; User user = new User(); //判断数据类型用switch switch (type) &#123; case 1: user.setUsername(data); break; case 2: user.setPhone(data); break; default: throw new LyException(ExceptionEnums.INVALID_DATA_TYPE); &#125; return userMapper.selectCount(user)==0; &#125;&#125; 3.4.测试我们在数据库插入一条假数据： 然后在浏览器调用接口，测试： 4.发送短信功能短信微服务已经准备好，我们就可以继续编写用户中心接口了。 4.1.接口说明 这里的业务逻辑是这样的： 1）我们接收页面发送来的手机号码 2）生成一个随机验证码 3）将验证码保存在服务端 4）发送短信，将验证码发送到用户手机 那么问题来了：验证码保存在哪里呢？ 验证码有一定有效期，一般是5分钟，我们可以利用Redis的过期机制来保存。 4.2.UserControllerly-user中ly-user-service的web中 12345678910/** * 发送手机生成验证码 * @param phone * @return */@PostMapping("code")public ResponseEntity&lt;Void&gt; sendCode(@RequestParam("phone")String phone)&#123; userService.sendCode(phone); return ResponseEntity.status(HttpStatus.NO_CONTENT).build();&#125; 4.3.UserServicely-user中ly-user-service的service中 这里的逻辑会稍微复杂： 生成随机验证码 将验证码保存到Redis中，用来在注册的时候验证 发送验证码到ly-sm服务，发送短信 因此，我们需要引入Redis和AMQP： 12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;&lt;/dependency&gt; 添加RabbitMQ和Redis配置： 123456789101112131415spring: redis: host: 192.168.25.128 rabbitmq: host: 192.168.25.128 username: 2850105498 password: cxg200888 virtual-host: /leyou template: retry: enabled: true initial-interval: 10000ms max-interval: 210000ms multiplier: 2 publisher-confirms: true 另外还要用到工具类，生成6位随机码，这个我们封装到了leyou-common中，因此需要引入依赖： 12345&lt;dependency&gt; &lt;groupId&gt;com.leyou.common&lt;/groupId&gt; &lt;artifactId&gt;ly-common&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt; 生成随机码的工具：ly-common中的工具类NumberUtils方法generateCode 123456789101112/** * 生成指定位数的随机数字 * @param len 随机数的位数 * @return 生成的随机数 */public static String generateCode(int len)&#123; len = Math.min(len, 8); int min = Double.valueOf(Math.pow(10, len - 1)).intValue(); int num = new Random().nextInt( Double.valueOf(Math.pow(10, len + 1)).intValue() - 1) + min; return String.valueOf(num).substring(0,len);&#125; Service代码： 12345678910111213141516171819202122232425262728@Autowiredprivate UserMapper userMapper;@Autowiredprivate AmqpTemplate amqpTemplate;@Autowiredprivate StringRedisTemplate redisTemplate;private static final String KEY_CODE="user:code:phone:";public void sendCode(String phone) &#123; //随机生成六位数字 String code= NumberUtils.generateCode(6); String key=KEY_CODE+phone; try &#123; HashMap&lt;Object, Object&gt; msg = new HashMap&lt;&gt;(); msg.put("phone", phone); msg.put("code", code); redisTemplate.opsForValue().set(key,code,5, TimeUnit.MINUTES); //发送验证码 amqpTemplate.convertAndSend("ly.sms.exchange","sms.verify.code",msg); &#125; catch (Exception e) &#123; log.error("发送短信失败。phone：&#123;&#125;， code：&#123;&#125;", phone, code); &#125; &#125; 注意：要设置短信验证码在Redis的缓存时间为5分钟 4.4.测试通过RestClient发送请求试试： 查看Redis中的数据： 查看短信： 5.注册功能5.1.接口说明 5.2.UserControllerly-user中ly-user-server的web： 123456789101112/** * 注册 * @param user * @param code * @return */@PostMapping("register")public ResponseEntity&lt;Void&gt; register(User user,@RequestParam("code")String code)&#123; userService.register(user,code); return ResponseEntity.status(HttpStatus.CREATED).build();&#125; 5.3.UserServicely-user中ly-user-server的service： 基本逻辑： 1）校验短信验证码 2）生成盐 3）对密码加密 4）写入数据库 5）删除Redis中的验证码 1234567891011121314151617181920212223public void register(User user, String code) &#123; String key=KEY_CODE+user.getPhone(); //redis中取code String redisCode = redisTemplate.opsForValue().get(key); //校验验证码 if (!StringUtils.equals(code,redisCode))&#123; throw new LyException(ExceptionEnums.INVALID_USER_CODE); &#125; //生成盐 String salt = CodecUtils.generateSalt(); user.setSalt(salt); //对密码加密 user.setPassword(CodecUtils.md5Hex(user.getPassword(),salt)); user.setCreated(new Date()); user.setId(null); //写入数据库 int insert = userMapper.insert(user); //注册成功删除code的验证码 if (insert==1)&#123; redisTemplate.delete(key); &#125; &#125; 5.4.测试我们通过RestClient测试： 查看数据库： 5.5.服务端数据校验刚才虽然实现了注册，但是服务端并没有进行数据校验，而前端的校验是很容易被有心人绕过的。所以我们必须在后台添加数据校验功能： 我们这里会使用Hibernate-Validator框架完成数据校验： 而SpringBoot的web启动器中已经集成了相关依赖： 5.5.1.什么是Hibernate ValidatorHibernate Validator是Hibernate提供的一个开源框架，使用注解方式非常方便的实现服务端的数据校验。 官网：http://hibernate.org/validator/ hibernate Validator 是 Bean Validation 的参考实现 。 Hibernate Validator 提供了 JSR 303 规范中所有内置 constraint（约束） 的实现，除此之外还有一些附加的 constraint。 在日常开发中，Hibernate Validator经常用来验证bean的字段，基于注解，方便快捷高效。 5.5.2.Bean校验的注解常用注解如下： Constraint 详细信息 @Valid 被注释的元素是一个对象，需要检查此对象的所有字段值 @Null 被注释的元素必须为 null @NotNull 被注释的元素必须不为 null @AssertTrue 被注释的元素必须为 true @AssertFalse 被注释的元素必须为 false @Min(value) 被注释的元素必须是一个数字，其值必须大于等于指定的最小值 @Max(value) 被注释的元素必须是一个数字，其值必须小于等于指定的最大值 @DecimalMin(value) 被注释的元素必须是一个数字，其值必须大于等于指定的最小值 @DecimalMax(value) 被注释的元素必须是一个数字，其值必须小于等于指定的最大值 @Size(max, min) 被注释的元素的大小必须在指定的范围内 @Digits (integer, fraction) 被注释的元素必须是一个数字，其值必须在可接受的范围内 @Past 被注释的元素必须是一个过去的日期 @Future 被注释的元素必须是一个将来的日期 @Pattern(value) 被注释的元素必须符合指定的正则表达式 @Email 被注释的元素必须是电子邮箱地址 @Length 被注释的字符串的大小必须在指定的范围内 @NotEmpty 被注释的字符串的必须非空 @Range 被注释的元素必须在合适的范围内 @NotBlank 被注释的字符串的必须非空 @URL(protocol=,host=, port=,regexp=, flags=) 被注释的字符串必须是一个有效的url @CreditCardNumber 被注释的字符串必须通过Luhn校验算法，银行卡，信用卡等号码一般都用Luhn计算合法性 5.5.3.给User添加校验我们在ly-user-interface中添加Hibernate-Validator依赖： 1234&lt;dependency&gt; &lt;groupId&gt;org.hibernate.validator&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;&lt;/dependency&gt; 我们在User对象的部分属性上添加注解： 1234567891011121314151617181920@Table(name = "tb_user")public class User &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @Length(min = 4, max = 30, message = "用户名只能在4~30位之间") private String username;// 用户名 @JsonIgnore @Length(min = 4, max = 30, message = "用户名只能在4~30位之间") private String password;// 密码 @Pattern(regexp = "^1[35678]\\d&#123;9&#125;$", message = "手机号格式不正确") private String phone;// 电话 private Date created;// 创建时间 @JsonIgnore private String salt;// 密码的盐值&#125; 5.5.4.在controller上进行控制在controller中只需要给User添加 @Valid注解即可。 5.5.5.测试我们故意填错： 然后SpringMVC会自动返回错误信息： 6.根据用户名和密码查询用户6.1.接口说明功能说明查询功能，根据参数中的用户名和密码查询指定用户 接口路径1GET /query 参数说明：form表单格式 参数 说明 是否必须 数据类型 默认值 username 用户名，格式为4~30位字母、数字、下划线 是 String 无 password 用户密码，格式为4~30位字母、数字、下划线 是 String 无 返回结果：用户的json格式数据 123456&#123; "id": 6572312, "username":"test", "phone":"13688886666", "created": 1342432424&#125; 状态码： 200：注册成功 400：用户名或密码错误 500：服务器内部异常，注册失败 6.2.UserControllerly-user —— ly-user-service————web中 1234567891011/** * 根据用户名和密码查询用户 * @param username * @param password * @return */ @GetMapping("query") public ResponseEntity&lt;User&gt; queryUser(@RequestParam("username")String username, @RequestParam("password")String password)&#123; return ResponseEntity.ok(userService.queryUser(username,password)); &#125; 6.3.UserServicely-user —— ly-user-service————service中 123456789101112131415public User queryUser(String username, String password) &#123; //查询用户 User recode = new User(); recode.setUsername(username); User user = userMapper.selectOne(recode); //校验 if (user==null)&#123; throw new LyException(ExceptionEnums.INVALID_USERNAME_PASSWORD); &#125; //校验密码和加密是否相等 if (!StringUtils.equals(user.getPassword(), CodecUtils.md5Hex(password,user.getSalt()))) &#123; throw new LyException(ExceptionEnums.INVALID_USERNAME_PASSWORD); &#125; return user;&#125; 要注意，查询时也要对密码进行加密后判断是否一致。 6.4.测试我们通过RestClient测试： 7.在注册页进行测试在注册页填写信息： 提交发现页面自动跳转到了登录页，查看数据库：]]></content>
      <categories>
        <category>项目实战-微服务商城</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[微服务商城（十五）——数据同步]]></title>
    <url>%2Fday14-%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5.html</url>
    <content type="text"><![CDATA[1.实现数据同步接下来，我们就改造项目，实现搜索服务、商品静态页的数据同步。 1.1.思路分析 发送方：商品微服务 什么时候发？ 当商品服务对商品进行写操作：增、删、改的时候，需要发送一条消息，通知其它服务。 发送什么内容？ 对商品的增删改时其它服务可能需要新的商品数据，但是如果消息内容中包含全部商品信息，数据量太大，而且并不是每个服务都需要全部的信息。因此我们只发送商品id，其它服务可以根据id查询自己需要的信息。 接收方：搜索微服务、静态页微服务 接收消息后如何处理？ 搜索微服务： 增/改：添加新的数据到索引库 删：删除索引库数据 静态页微服务： 增：创建新的静态页 删：删除原来的静态页 改：创建新的静态页并删除原来的 1.2.商品服务发送消息（ly-item-service）我们先在商品微服务ly-item-service中实现发送消息。 1.2.1.引入依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;&lt;/dependency&gt; 1.2.2.配置文件我们在application.yml中添加一些有关RabbitMQ的配置： 1234567891011121314spring: rabbitmq: host: 192.168.25.128 username: 2850105498 password: cxg200888 virtual-host: /leyou template: retry: enabled: true initial-interval: 10000ms max-interval: 30000ms multiplier: 2 exchange: ly.item.exchange publisher-confirms: true template：有关AmqpTemplate的配置 retry：失败重试 enabled：开启失败重试 initial-interval：第一次重试的间隔时长 max-interval：最长重试间隔，超过这个间隔将不再重试 multiplier：下次重试间隔的倍数，此处是2即下次重试间隔是上次的2倍 exchange：缺省的交换机名称，此处配置后，发送消息如果不指定交换机就会使用这个 publisher-confirms：生产者确认机制，确保消息会正确发送，如果发送失败会有错误回执，从而触发重试 1.2.3.改造GoodsService在GoodsService中封装一个发送消息到mq的方法： 12345678private void sendMessage(Long id, String type)&#123; // 发送消息 try &#123; this.amqpTemplate.convertAndSend("item." + type, id); &#125; catch (Exception e) &#123; logger.error("&#123;&#125;商品消息发送异常，商品id：&#123;&#125;", type, id, e); &#125;&#125; 这里没有指定交换机，因此默认发送到了配置中的：ly.item.exchange 注意：这里要把所有异常都try起来，不能让消息的发送影响到正常的业务逻辑 然后在新增的时候调用： 修改的时候调用： 1.3.搜索服务接收消息（ly-search）搜索服务接收到消息后要做的事情： 增：添加新的数据到索引库 删：删除索引库数据 改：修改索引库数据 因为索引库的新增和修改方法是合二为一的，因此我们可以将这两类消息一同处理，删除另外处理。 1.3.1.引入依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;&lt;/dependency&gt; 1.3.2.添加配置123456spring: rabbitmq: host: 192.168.25.128 username: 2850105498 password: cxg200888 virtual-host: /leyou 这里只是接收消息而不发送，所以不用配置template相关内容。 1.3.3.编写监听器 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142@Componentpublic class ItemListener &#123; @Autowired private SearchService searchService; /** * 处理insert和update的消息 * * @param spuId * @throws Exception */ @RabbitListener(bindings = @QueueBinding( value = @Queue(name = "search.item.insert.queue",durable = "true"), exchange = @Exchange(name = "ly.item.exchange",type = ExchangeTypes.TOPIC), key = &#123;"item.insert","item.update"&#125; )) public void listenInsertOrUpdate(Long spuId)&#123; if (spuId==null)&#123; return; &#125; //处理消息，对索引库进行新增和修改 searchService.createOrUpdateIndex(spuId); &#125; /** * 处理delete的消息 * * @param spuId */ @RabbitListener(bindings = @QueueBinding( value = @Queue(name = "search.item.delete.queue",durable = "true"), exchange = @Exchange(name = "ly.item.exchange",type = ExchangeTypes.TOPIC), key = &#123;"delete"&#125; )) public void listenDelete(Long spuId)&#123; if (spuId==null)&#123; return; &#125; //处理消息，对索引库进行新增和修改 searchService.deleteIndex(spuId); &#125;&#125; 1.3.4.编写创建和删除索引方法这里因为要创建和删除索引，我们需要在SearchService中拓展两个方法，创建和删除索引： 1234567891011121314151617181920/** * 处理mq消息(更新，修改) * @param spuId */ public void createOrUpdateIndex(Long spuId) &#123; //查询spu Spu spu = goodsClient.querySpuById(spuId); //构建goods Goods goods = buildGoods(spu); //存入索引库 goodsRepository.save(goods); &#125; /** * 处理mq消息(删除) * @param spuId */ public void deleteIndex(Long spuId) &#123; goodsRepository.deleteById(spuId); &#125; 创建索引的方法可以从之前导入数据的测试类中拷贝和改造。 1.4.静态页服务接收消息（ly-page）商品静态页服务接收到消息后的处理： 增：创建新的静态页 删：删除原来的静态页 改：创建新的静态页并删除原来的 不过，我们编写的创建静态页的方法也具备覆盖以前页面的功能，因此：增和改的消息可以放在一个方法中处理，删除消息放在另一个方法处理。 1.4.1.引入依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;&lt;/dependency&gt; 1.4.2.添加配置123456spring: rabbitmq: host: 192.168.25.128 username: 2850105498 password: cxg200888 virtual-host: /leyou 这里只是接收消息而不发送，所以不用配置template相关内容。 1.4.3.编写监听器 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142@Componentpublic class ItemListener &#123; @Autowired private PageService pageService; /** * 处理insert和update的消息 * * @param spuId * @throws Exception */ @RabbitListener(bindings = @QueueBinding( value = @Queue(name = "page.item.insert.queue",durable = "true"), exchange = @Exchange(name = "ly.item.exchange",type = ExchangeTypes.TOPIC), key = &#123;"item.insert","item.update"&#125; )) public void listenInsertOrUpdate(Long spuId)&#123; if (spuId==null)&#123; return; &#125; //处理消息，创建一个静态页 pageService.createHtml(spuId); &#125; /** * 处理delete的消息 * * @param spuId */ @RabbitListener(bindings = @QueueBinding( value = @Queue(name = "page.item.delete.queue",durable = "true"), exchange = @Exchange(name = "ly.item.exchange",type = ExchangeTypes.TOPIC), key = &#123;"delete"&#125; )) public void listenDelete(Long spuId)&#123; if (spuId==null)&#123; return; &#125; //处理消息，对静态页删除 pageService.deleteHtml(spuId); &#125;&#125; 1.4.4.添加删除页面方法12345678910111213141516171819202122232425262728293031323334/** * 创建静态文件 * @param spuId */public void createHtml(Long spuId)&#123; //上下文 Context context = new Context(); context.setVariables(loadModel(spuId)); //输出流 File file = new File("G:/Java-webspace/LeYou-store/leyou/ly-page/src/main/resources/templates", spuId + ".html"); //判断是否存在 if (file.exists())&#123; file.delete(); &#125; try (PrintWriter writer=new PrintWriter(file,"utf-8"))&#123; //生成html templateEngine.process("item",context,writer); &#125;catch (Exception e)&#123; log.error("[静态页服务]，生成静态页面异常！",e); &#125;&#125;/** * 删除静态页 * @param spuId */public void deleteHtml(Long spuId) &#123; File file = new File("G:/Java-webspace/LeYou-store/leyou/ly-page/src/main/resources/templates", spuId + ".html"); if (file.exists())&#123; file.delete(); &#125;&#125; 1.5.测试1.5.1.查看RabbitMQ控制台重新启动项目，并且登录RabbitMQ管理界面：http://192.168.25.128:15672 可以看到，交换机已经创建出来了： 队列也已经创建完毕： 并且队列都已经绑定到交换机： 1.5.2.修改数据试一试在后台修改商品数据的价格，分别在搜索及商品详情页查看是否统一。 2.Redis回顾完成商品详情展示，下一步自然是购物车，不过购物车之前要完成用户注册和登入业务，我们需要使用到redis技术，一起回顾下 2.1.NoSqlRedis是目前非常流行的一款NoSql数据库。 什么事NoSql 常见的NoSql产品 2.2.Redis的介绍和安装2.2.1.简介 Redis的网址： 官网： 中文网站：http://www.redis.cn/ 历史： 特性： 2.2.2.Redis与MemcacheRedis和Memcache是目前非常流行的两种NoSql数据库，都可以用于服务端缓存。两者有怎么样差异？ 实现来看 redis：单线程 Memcache：多线程 从存储方式来看： redis：支持数据持久化和主从备份，数据更安全 Memcache：数据存在内存，没有持久化功能 从功能来看： redis：除了基本的k-v结构外，支持多种其他复杂结构，事务等高级功能 Memcache：只支持基本的k-v结构 从可用性看： redis：支持主从备份，数据分片，哨兵监控 Memcache：没有分片功能，需要从客户端支持 可以看出，redis相比Memcache功能强大，只会的数据结构也比较丰富，已经不仅仅是一个缓冲服务，而是memcache的功能相对单一 2.2.3.安装参考课前资料中的《redis安装配置.md》 2.3.Redis指令通过help命令可以让我们查看到redis的指令帮助信息： 在help后面加空格,然后按tab键，会看到redis对命令分组的组名： 主要包括： @generic：通用指令 @string：字符串类型指令 @list：队列结构指令 @set：set结构指令 @sorted_set：可排序的set结构指令 @hash：hash结构指令 其中除了@generic以为的，对应了Redis中常用的5种数据类型： String：等同于java中的，Map&lt;String,String&gt; list：等同于java中的，Map&lt;String,List &gt; set： 等同于java中的，Map&lt;String,set&gt; sort_ set:：可排序的set hash： 等同于java中的: Map&lt;String,Map&lt;String,String&gt;&gt; 可见，Redis中存储数据结构都是类似java的map类型。Redis不同数据类型，只是map的值的类型不同 2.3.1.通用指令 keys 获取符合规则的键名列表 语法：keys pattern 实例：keys *（查询所有键） 这里的pattern其实是正则表达式，所以语法基本类似的 生产环境一定禁用keys： rename-command KEYS “” // 必禁命令，线上用这种查询方式绝对是不对的 rename-command FLUSHALL “” // 必禁命令，谁会清除数据呢 rename-command FLUSHDB “” // 必禁命令，谁会清除数据呢 rename-command CONFIG “” // 可以考虑重命名下 exists 判断一个键是否存在，如果存在返回整数1，否则返回0 语法：exists key 实例 select 切换库 语法：select key 实例 del DEL： 删除key，可以删除多个或一个key，返回删除个数 语法：del key，del [key … ] 实例： expire 语法 expire key seconds 作用：设置key的过期时间，超过时间后，将会自动删除该key 返回值： 如果成功设置过期时间，返回1. 如果key不存在或者不能设置时间，返回0 TTL TTL：查看一个key的过期时间 语法：TTL key 返回值： 返回剩余的过期时间 -1：永不过期 -2：已经过期，不存在 persist 语法：persist key 作用：移除给定的key的生存时间，将这个key从生存时间转换成一个不带生存时间，永不过期的key 返回值： 当生存时间移除成功，返回1 如果key不存在或key没有设置生存时间，返回0 2.3.2.字符串指令字符串结构，其实是redis中最基础的k-v结构。其键和值都是字符串，类似java的Map&lt;String,String&gt; 字符串类型是redis中最基本的数据库类型，它能存储任何形式的字符串，包括二进制数据，可以存储json化的对象，字符串数组等，一个字符串类型键允许存储的数据最大容量是512MB 常用指令： 2.3.3.hash结构命令redis的hash结构类似于java中Map&lt;String,Map&lt;String,String&gt;&gt;,键是字符串，值是另一个映射。 这里我们称键为key，字段名为hKey，字段值为hValue 常用指令： HSET、HSETNX和HGET（添加、获取） HSET 介绍： Redis Hset 命令用于为哈希表中的字段赋值 。 如果哈希表不存在，一个新的哈希表被创建并进行 HSET 操作。 如果字段已经存在于哈希表中，旧值将被覆盖。 返回值： 如果字段是哈希表中的一个新建字段，并且值设置成功，返回 1 。 如果哈希表中域字段已经存在且旧值已被新值覆盖，返回 0 实例： HGET 介绍： Hget 命令用于返回哈希表中指定字段的值。 返回值：返回给定字段的值。如果给定的字段或 key 不存在时，返回 nil 示例： HGETALL 介绍 返回值 指定key 的所有字段的名及值。返回值里，紧跟每个字段名(field name)之后是字段的值(value)，所以返回值的长度是哈希表大小的两倍 示例： HKEYS 介绍 示例 HVALS 注意：这个命令不是HVALUES，而是HVALS，是value 的缩写：val 示例： DEL Hdel 命令用于删除哈希表 key 中的一个或多个指定字段，不存在的字段将被忽略 语法： HDEL key field1 [field2 … ] 返回值：被成功删除字段的数量，不包括被忽略的字段 示例： 2.4.Redis的持久化Redis有两种持久化方案：RDB和AOF 2.4.1.RDB 触发条件 RDB是Redis的默认持久方案，当满足一定的条件时，Redis会自动将内存中的数据全部持久化到硬盘。 条件在redis.conf文件中配置，格式如下： 1save （time）（count） 当满足在time（单位是秒）时间内，至少进行了count次修改后，触发条件，进行RDB快照。 例如，默认的配置如下： 在配置文件中已经预置了3个条件： 1234save 900 1 #15分钟内有至少1个键被更改则进行快照save 300 10 #5分钟内有至少10个键被更改则进行快照save 60 10000 #1分钟内有至少10000个键被更改则进行快照以上条件之间是“或”的关系 基本原理 RDB的流程是这样： Redis使用fork函数来复制一份当前进程(父进程)的副本(子进程) 父进程继续接收并处理请求，子进程开始把内存中的数据写入硬盘中的临时文件 子进程写完后，会使用临时文件代替旧的RDB文件 2.4.2.AOF 基本原理 AOF方式默认是关闭的，需要修改配置来开启： 1appendonly yes # 把默认的no改为yes AOF持久化的策略是，把每一条服务端接收到的写命令都记录下来，每隔一定时间后，写入硬盘的AOF文件中，当服务器重启后，重新执行这些命令，即可恢复数据。 AOF文件写入的频率是可以配置的: 1234567 文件写入默认情况下会先写入到系统的缓存中，系统每30秒同步一次。才是真正的写入到硬盘，如果在这30秒服务器宕机那数据也会丢失的。Redis可以通过配置来修改同步策略: # appendfsync always每次都同步( 最安全但是最慢) appendfsync everysec每秒同步( 默认的同步策略) # appendfsync no 不主动同步，由操作系统来决定(最快但是不安全) AOF文件重写 当记录命令过多，必然会出现对同一个key的多次写操作，此时只需要记录最后一条即可， 前面的记录都毫无意义了。因此，当满足一定条件时，Redis会对AOF文件进行重写，移除对同一个key的多次操作命令，保留最后一条。默认的触发条件: 12345重写策略的参数设置:auto-aof-rewrite-percentage 100当前的AOF文件大小超过上一-次重写时的AOF文件大小的百分之多少时会再次进行重写，如果之前没有重写过，则以启动时的AOF文件大小为依据auto-aof-rewrite-min-size 64mb限制了允许重写的最小AOF文件大小。通常在AOF文件很小的时候即使其中有些冗余的命令也是可以忽略的。 2.5.SpringData Redis之前，我们使用redis都是采用的Jedis客户端，不过既然我们使用springboot，为什么不适用spring对redis封装的套件呢？ 2.5.1.Spring Data Redis官网：http://projects.spring.io/spring-data-redis/ Spring Data Redis，是Spring Data 家族的一部分。 对Jedis客户端进行了封装，与spring进行了整合。可以非常方便的来实现redis的配置和操作。 2.5.2.RedisTemplate基本操作Spring Data Redis 提供了一个工具类：RedisTemplate。里面封装了对于Redis的五种数据结构的各种操作，包括： redisTemplate.opsForValue() ：操作字符串 redisTemplate.opsForHash() ：操作hash redisTemplate.opsForList()：操作list redisTemplate.opsForSet()：操作set redisTemplate.opsForZSet()：操作zset 例如我们队字符串操作比较熟悉的有：get、set等命令，这些方法都在opsForValue( )返回对象中有： 其它一些通用命令，如del通过redisTemplate.xx()来直接调用 5种结构： String：等同于java中的，Map&lt;String,String&gt; list：等同于java中的Map&lt;String,List&lt;String&gt;&gt; set：等同于java中的Map&lt;String,Set&lt;String&gt;&gt; sort_set：可排序的set hash：等同于java中的：`Map&lt;String,Map&lt;String,String&gt;&gt; 2.5.3.StringRedisTemplateRedisTemplate在创建时，可以指定其泛型类型： K：代表key 的数据类型 V: 代表value的数据类型 注意：这里的类型不是Redis中存储的数据类型，而是Java中的数据类型，RedisTemplate会自动将Java类型转为Redis支持的数据类型：字符串、字节、二进制等等。 不过RedisTemplate默认会采用JDK自带的序列化（Serialize）来对对象进行转换。生成的数据十分庞大，因此一般我们都会指定key和value为String类型，这样就由我们自己把对象序列化为json字符串来存储即可。 因为大部分情况下，我们都会使用key和value都为String的RedisTemplate，因此Spring就默认提供了这样一个实现： 2.5.4.测试我们在项目中编写一个测试案例： 首先在项目中引入Redis启动器： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; 然后在配置文件中指定Redis地址： 123spring: redis: host: 192.168.25.128 然后就可以直接注入StringRedisTemplate对象了： 12345678910111213141516171819202122232425262728293031323334353637383940414243@RunWith(SpringRunner.class)@SpringBootTest(classes = LyUserService.class)public class RedisTest &#123; @Autowired private StringRedisTemplate redisTemplate; @Test public void testRedis() &#123; // 存储数据 this.redisTemplate.opsForValue().set("key1", "value1"); // 获取数据 String val = this.redisTemplate.opsForValue().get("key1"); System.out.println("val = " + val); &#125; @Test public void testRedis2() &#123; // 存储数据，并指定剩余生命时间,5小时 this.redisTemplate.opsForValue().set("key2", "value2", 5, TimeUnit.HOURS); &#125; //哈希 @Test public void testHash()&#123; BoundHashOperations&lt;String, Object, Object&gt; hashOps = this.redisTemplate.boundHashOps("user"); // 操作hash数据 hashOps.put("name", "jack"); hashOps.put("age", "21"); // 获取单个数据 Object name = hashOps.get("name"); System.out.println("name = " + name); // 获取所有数据 Map&lt;Object, Object&gt; map = hashOps.entries(); for (Map.Entry&lt;Object, Object&gt; me : map.entrySet()) &#123; System.out.println(me.getKey() + " : " + me.getValue()); &#125; &#125;&#125; 3.聚合数据短信服务3.1.demo注册页面上有短信发送的按钮，当用户点击发送短信，我们需要生成验证码，发送给用户。我们将使用阿里提供的阿里大于来实现短信发送。 参考课前资料的《阿里短信.md》学习demo入门 3.2.创建短信微服务因为系统中不止注册一个地方需要短信发送，因此我们将短信发送抽取为微服务：ly-sm，凡是需要的地方都可以使用。 另外，因为短信发送API调用时长的不确定性，为了提高程序的响应速度，短信发送我们都将采用异步发送方式，即： 短信服务监听MQ消息，收到消息后发送短信。 其它服务要发送短信时，通过MQ通知短信微服务。 3.2.1.创建module创建ly-sm工程 3.2.2.pom12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;leyou&lt;/artifactId&gt; &lt;groupId&gt;com.leyou.parent&lt;/groupId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.service&lt;/groupId&gt; &lt;artifactId&gt;ly-sm&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;net.sf.json-lib&lt;/groupId&gt; &lt;artifactId&gt;json-lib&lt;/artifactId&gt; &lt;version&gt;2.4&lt;/version&gt; &lt;classifier&gt;jdk15&lt;/classifier&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--读取在yml中配置的常量--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot &lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.leyou.common&lt;/groupId&gt; &lt;artifactId&gt;ly-common&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 3.2.3.编写启动类123456@SpringBootApplicationpublic class LySmsApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(LySmsApplication.class, args); &#125;&#125; 3.2.4.编写application.yml12345678910server: port: 8086spring: application: name: sms-service rabbitmq: host: 192.168.25.128 username: 2850105498 password: cxg200888 virtual-host: /leyou 3.3.编写短信工具类3.3.1.属性抽取我们首先把一些常量抽取到application.yml中： 12345ly: sms: url: http://v.juhe.cn/sms/send # 请求接口地址 accessKeySecret: d4eee3375aef4ae683e7782fc4e91f44 # 你自己的key verifyCodeTemplate: 128692 # 模板名称id 然后注入到属性类中com.leyou.sms.config： 12345678910@Data@ConfigurationProperties(prefix = "ly.sms")public class SmsProperties &#123; String accessKeySecret; String url; String verifyCodeTemplate;&#125; 3.3.2.工具类我们把阿里提供的demo进行简化和抽取，封装一个工具类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113@Slf4j@Component@EnableConfigurationProperties(SmsProperties.class)public class SmsUtis&#123; @Autowired private SmsProperties properties; public static final String DEF_CHATSET = "UTF-8"; public static final int DEF_CONN_TIMEOUT = 30000; public static final int DEF_READ_TIMEOUT = 30000; public static String userAgent = "Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/29.0.1547.66 Safari/537.36"; /** * * @param phoneNumber 号码 * @param templateCode 短信模板ID * @param templateParam 发送信息代码 */ public void mobileQuery(String phoneNumber,String templateCode,String templateParam)&#123; String result =null; String url =properties.getUrl();//请求接口地址 Map params = new HashMap();//请求参数 params.put("mobile",phoneNumber);//接受短信的用户手机号码 params.put("tpl_id",templateCode);//您申请的短信模板ID，根据实际情况修改 params.put("tpl_value","#code#="+templateParam);//您设置的模板变量，根据实际情况修改("#code#=123456") params.put("key",properties.getAccessKeySecret());//应用APPKEY(应用详细页查询) try &#123; result = net(url, params, "GET"); JSONObject object = JSONObject.fromObject(result); if(object.getInt("error_code")==0)&#123; System.out.println(object.get("result")); &#125;else&#123; //控制台输出 System.out.println("[短信服务] 发送失败，phoneNumber:" + phoneNumber + ",返回码" + object.get("error_code") + "，原因" + object.get("reason")); //日志记录 log.info("[短信服务] 发送失败，phoneNumber:" + phoneNumber + ",返回码:" + object.get("error_code") + "，原因:" + object.get("reason")); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * * @param strUrl 请求地址 * @param params 请求参数 * @param method 请求方法 * @return 网络请求字符串 * @throws Exception */ public static String net(String strUrl, Map params,String method) throws Exception &#123; HttpURLConnection conn = null; BufferedReader reader = null; String rs = null; try &#123; StringBuffer sb = new StringBuffer(); if(method==null || method.equals("GET"))&#123; strUrl = strUrl+"?"+urlencode(params); &#125; URL url = new URL(strUrl); conn = (HttpURLConnection) url.openConnection(); if(method==null || method.equals("GET"))&#123; conn.setRequestMethod("GET"); &#125;else&#123; conn.setRequestMethod("POST"); conn.setDoOutput(true); &#125; conn.setRequestProperty("User-agent", userAgent); conn.setUseCaches(false); conn.setConnectTimeout(DEF_CONN_TIMEOUT); conn.setReadTimeout(DEF_READ_TIMEOUT); conn.setInstanceFollowRedirects(false); conn.connect(); if (params!= null &amp;&amp; method.equals("POST")) &#123; try &#123; DataOutputStream out = new DataOutputStream(conn.getOutputStream()); out.writeBytes(urlencode(params)); &#125; catch (Exception e) &#123; // TODO: handle exception e.printStackTrace(); &#125; &#125; InputStream is = conn.getInputStream(); reader = new BufferedReader(new InputStreamReader(is, DEF_CHATSET)); String strRead = null; while ((strRead = reader.readLine()) != null) &#123; sb.append(strRead); &#125; rs = sb.toString(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (reader != null) &#123; reader.close(); &#125; if (conn != null) &#123; conn.disconnect(); &#125; &#125; return rs; &#125; //将map型转为请求参数型 public static String urlencode(Map&lt;String,String&gt; data) &#123; StringBuilder sb = new StringBuilder(); for (Map.Entry i : data.entrySet()) &#123; try &#123; sb.append(i.getKey()).append("=").append(URLEncoder.encode(i.getValue()+"","UTF-8")).append("&amp;"); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; &#125; return sb.toString(); &#125;&#125; 注意 根据聚合数据官方文档发送的验证码根式：#code#，所以要如上写的 3.4.编写消息监听器接下来，编写消息监听器，当接收到消息后，我们发送短信。 1234567891011121314151617181920212223242526272829@Component@Slf4jpublic class SmsListener &#123; @Autowired private SmsUtis smsUtis; @Autowired private SmsProperties smsProperties; /** * 发送短信验证码 */ @RabbitListener(bindings = @QueueBinding( value = @Queue(value = "sms.verify.code.queue", durable = "true"), exchange = @Exchange(value = "ly.sms.exchange", type = ExchangeTypes.TOPIC), key = &#123;"sms.verify.code"&#125;)) public void listtenSms(Map&lt;String,String&gt; msg)&#123; if (CollectionUtils.isEmpty(msg))&#123; return; &#125; String phone = msg.remove("phone"); if (StringUtils.isBlank(phone))&#123; return; &#125; String code=msg.get("code"); smsUtis.mobileQuery(phone, smsProperties.getVerifyCodeTemplate(), code); log.info("[短信服务] 发送验证码，手机号：&#123;&#125;",phone); &#125;&#125; 我们注意到，消息体是一个Map，里面有两个属性： phone：电话号码 code：短信验证码 3.5.启动启动项目，然后查看RabbitMQ控制台，发现交换机已经创建： 队列也已经创建： 并且绑定： 3.6.测试创建测试 12345678910111213141516@RunWith(SpringRunner.class)@SpringBootTestpublic class SmsTest &#123; @Autowired private AmqpTemplate amqpTemplate; @Test public void testSms() throws Exception &#123; HashMap&lt;Object, Object&gt; msg = new HashMap&lt;&gt;(); msg.put("phone","18860892543"); msg.put("code","200888"); amqpTemplate.convertAndSend("ly.sms.exchange","sms.verify.code",msg); Thread.sleep(10000L); &#125;&#125; 3.7.改进（短信限流）发短信的时候，在redis中记录手机号，当前系统时间减去记录时间小于60秒，短信拦截 改进工具类SmsUtis.java中的mobileQuery( )方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455@Autowiredprivate StringRedisTemplate redisTemplate;public static final String KEY_PHOME="sms_phone:";public static final String DEF_CHATSET = "UTF-8";public static final int DEF_CONN_TIMEOUT = 30000;public static final int DEF_READ_TIMEOUT = 30000;public static String userAgent = "Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/29.0.1547.66 Safari/537.36";/** * * @param phoneNumber 号码 * @param templateCode 短信模板ID * @param templateParam 发送信息代码 */public void mobileQuery(String phoneNumber,String templateCode,String templateParam)&#123; //号码用于redis中 String key=KEY_PHOME + phoneNumber; //按照手机号码限流 //读取时间 String lastTime = redisTemplate.opsForValue().get(key); if (StringUtils.isNotBlank(lastTime))&#123; Long last = Long.valueOf(lastTime); if (System.currentTimeMillis()-last&lt;60000)&#123; log.info("[短息服务] 发送短信频率过高，被拦截，手机号码：&#123;&#125;",phoneNumber); return ; &#125; &#125; String result =null; String url =properties.getUrl();//请求接口地址 Map params = new HashMap();//请求参数 params.put("mobile",phoneNumber);//接受短信的用户手机号码 params.put("tpl_id",templateCode);//您申请的短信模板ID，根据实际情况修改 params.put("tpl_value","#code#="+templateParam);//您设置的模板变量，根据实际情况修改("#code#=123456") params.put("key",properties.getAccessKeySecret());//应用APPKEY(应用详细页查询) try &#123; result = net(url, params, "GET"); JSONObject object = JSONObject.fromObject(result); if(object.getInt("error_code")==0)&#123; System.out.println(object.get("result")); /** * 发送短信成功后将手机存入redis中,String.valueOf(System.currentTimeMillis())是系统时间 */ redisTemplate.opsForValue().set(key, String.valueOf(System.currentTimeMillis()),1, TimeUnit.MILLISECONDS); log.info("[短信服务] 发送验证码，手机号：&#123;&#125;",phoneNumber); &#125;else&#123; //控制台输出 System.out.println("[短信服务] 发送失败，phoneNumber:" + phoneNumber + ",返回码" + object.get("error_code") + "，原因" + object.get("reason")); //日志记录 log.info("[短信服务] 发送失败，phoneNumber:" + phoneNumber + ",返回码:" + object.get("error_code") + "，原因:" + object.get("reason")); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;]]></content>
      <categories>
        <category>项目实战-微服务商城</category>
        <category>聚合短息</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>聚合短息</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务商城（十四）——Rabbitmq安装及介绍]]></title>
    <url>%2Fday13-rabbitmq.html</url>
    <content type="text"><![CDATA[0.学习目标 了解常见的MQ产品 了解RabbitMQ的5种消息模型 会使用Spring AMQP 利用MQ实现搜索和静态页的数据同步 1.RabbitMQ（消息队列）1.1.搜索与商品服务的问题目前我们已经完成了商品详情和搜索系统的开发。我们思考一下，是否存在问题？ 商品的原始数据保存在数据库中，增删改查都在数据库中完成。 搜索服务数据来源是索引库，如果数据库商品发生变化，索引库数据不能及时更新。 商品详情做了页面静态化，静态页面数据也不会随着数据库商品发生变化。 如果我们在后台修改了商品的价格，搜索页面和商品详情页显示的依然是旧的价格，这样显然不对。该如何解决？ 这里有两种解决方案： 方案1：每当后台对商品做增删改操作，同时要修改索引库数据及静态页面 方案2：搜索服务和商品页面服务对外提供操作接口，后台在商品增删改后，调用接口 以上两种方式都有同一个严重问题：就是代码耦合，后台服务中需要嵌入搜索和商品页面服务，违背了微服务的独立原则。 所以，我们会通过另外一种方式来解决这个问题：消息队列 1.2.消息队列（MQ）1.2.1.什么是消息队列消息队列，即MQ，Message Queue。 消息队列是典型的：生产者、消费者模型。生产者不断向消息队列中生产消息，消费者不断的从队列中获取消息。因为消息的生产和消费都是异步的，而且只关心消息的发送和接收，没有业务逻辑的侵入，这样就实现了生产者和消费者的解耦。 结合前面所说的问题： 商品服务对商品增删改以后，无需去操作索引库或静态页面，只是发送一条消息，也不关心消息被谁接收。 搜索服务和静态页面服务接收消息，分别去处理索引库和静态页面。 如果以后有其它系统也依赖商品服务的数据，同样监听消息即可，商品服务无需任何代码修改。 1.2.2.AMQP和JMSMQ是消息通信的模型，并不是具体实现。现在实现MQ的有两种主流方式：AMQP、JMS。 两者间的区别和联系： JMS是定义了统一的接口，来对消息操作进行统一；AMQP是通过规定协议来统一数据交互的格式 JMS限定了必须使用Java语言；AMQP只是协议，不规定实现方式，因此是跨语言的。 JMS规定了两种消息模型；而AMQP的消息模型更加丰富 1.2.3.常见MQ产品 ActiveMQ：基于JMS RabbitMQ：基于AMQP协议，erlang语言开发，稳定性好 RocketMQ：基于JMS，阿里巴巴产品，目前交由Apache基金会 Kafka：分布式消息系统，高吞吐量 1.2.4.RabbitMQRabbitMQ是基于AMQP的一款消息管理系统 官网： http://www.rabbitmq.com/ 官方教程：http://www.rabbitmq.com/getstarted.html 1.3.下载和安装1.3.1.下载官网下载地址：http://www.rabbitmq.com/download.html 目前最新版本是：3.7.5 我们的课程中使用的是：3.4.1版本 课前资料提供了安装包： 1.3.2.安装详见课前资料中的： 2.五种消息模型RabbitMQ提供了6种消息模型，但是第6种其实是RPC，并不是MQ，因此不予学习。那么也就剩下5种。 但是其实3、4、5这三种都属于订阅模型，只不过进行路由的方式不同。 我们通过一个demo工程来了解下RabbitMQ的工作方式： 导入工程： 导入后： 依赖： 123456789101112131415161718192021222324252627282930&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.itcast.rabbitmq&lt;/groupId&gt; &lt;artifactId&gt;itcast-rabbitmq&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;version&gt;3.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 我们抽取一个建立RabbitMQ连接的工具类，方便其他程序获取连接： 1234567891011121314151617181920212223public class ConnectionUtil &#123; /** * 建立与RabbitMQ的连接 * @return * @throws Exception */ public static Connection getConnection() throws Exception &#123; //定义连接工厂 ConnectionFactory factory = new ConnectionFactory(); //设置服务地址 factory.setHost("192.168.25.128"); //端口 factory.setPort(5672); //设置账号信息，用户名、密码、vhost factory.setVirtualHost("/leyou"); factory.setUsername("2850105498"); factory.setPassword("cxg200888"); // 通过工程获取连接 Connection connection = factory.newConnection(); return connection; &#125;&#125; 2.1.基本消息模型官方介绍： RabbitMQ是一个消息代理：它接受和转发消息。 你可以把它想象成一个邮局：当你把邮件放在邮箱里时，你可以确定邮差先生最终会把邮件发送给你的收件人。 在这个比喻中，RabbitMQ是邮政信箱，邮局和邮递员。 RabbitMQ与邮局的主要区别是它不处理纸张，而是接受，存储和转发数据消息的二进制数据块。 P（producer/ publisher）：生产者，一个发送消息的用户应用程序。 C（consumer）：消费者，消费和接收有类似的意思，消费者是一个主要用来等待接收消息的用户应用程序 queue 队列（红色区域）：rabbitmq内部类似于邮箱的一个概念。虽然消息流经rabbitmq和你的应用程序，但是它们只能存储在队列中。队列只受主机的内存和磁盘限制，实质上是一个大的消息缓冲区。许多生产者可以发送消息到一个队列，许多消费者可以尝试从一个队列接收数据。 总之： 生产者将消息发送到队列，消费者从队列中获取消息，队列是存储消息的缓冲区。 我们将用Java编写两个程序;发送单个消息的生产者，以及接收消息并将其打印出来的消费者。我们将详细介绍Java API中的一些细节，这是一个消息传递的“Hello World”。 我们将调用我们的消息发布者（发送者）Send和我们的消息消费者（接收者）Recv。发布者将连接到RabbitMQ，发送一条消息，然后退出。 2.1.1.生产者发送消息123456789101112131415161718192021222324public class Send &#123; private final static String QUEUE_NAME = "simple_queue"; public static void main(String[] argv) throws Exception &#123; // 获取到连接以及mq通道 Connection connection = ConnectionUtil.getConnection(); // 从连接中创建通道，这是完成大部分API的地方。 Channel channel = connection.createChannel(); // 声明（创建）队列，必须声明队列才能够发送消息，我们可以把消息发送到队列中。 // 声明一个队列是幂等的 - 只有当它不存在时才会被创建 channel.queueDeclare(QUEUE_NAME, false, false, false, null); // 消息内容 String message = "Hello World!"; channel.basicPublish("", QUEUE_NAME, null, message.getBytes()); System.out.println(" [x] Sent '" + message + "'"); //关闭通道和连接 channel.close(); connection.close(); &#125;&#125; 控制台： 2.1.2.管理工具中查看消息进入队列页面，可以看到新建了一个队列：simple_queue 点击队列名称，进入详情页，可以查看消息： 在控制台查看消息并不会将消息消费，所以消息还在。 2.1.3.消费者获取消息12345678910111213141516171819202122232425public class Recv &#123; private final static String QUEUE_NAME = "simple_queue"; public static void main(String[] argv) throws Exception &#123; // 获取到连接 Connection connection = ConnectionUtil.getConnection(); // 创建通道 Channel channel = connection.createChannel(); // 声明队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); // 定义队列的消费者 DefaultConsumer consumer = new DefaultConsumer(channel) &#123; // 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用 @Override public void handleDelivery(String consumerTag, Envelope envelope, BasicProperties properties, byte[] body) throws IOException &#123; // body 即消息体 String msg = new String(body); System.out.println(" [x] received : " + msg + "!"); &#125; &#125;; // 监听队列，第二个参数：是否自动进行消息确认。 channel.basicConsume(QUEUE_NAME, true, consumer); &#125;&#125; 控制台： 这个时候，队列中的消息就没了： 我们发现，消费者已经获取了消息，但是程序没有停止，一直在监听队列中是否有新的消息。一旦有新的消息进入队列，就会立即打印. 2.1.4.消息确认机制（ACK）面试通过刚才的案例可以看出，消息一旦被消费者接收，队列中的消息就会被删除。 那么问题来了：RabbitMQ怎么知道消息被接收了呢？ 如果消费者领取消息后，还没执行操作就挂掉了呢？或者抛出了异常？消息消费失败，但是RabbitMQ无从得知，这样消息就丢失了！ 因此，这就要通过消息确认机制（Acknowlege）。当消费者获取消息后，会向RabbitMQ发送回执ACK，告知消息已经被接收。不过这种回执ACK分两种情况： 自动ACK：消息一旦被接收，消费者自动发送ACK 手动ACK：消息接收后，不会发送ACK，需要手动调用 大家觉得哪种更好呢？ 这需要看消息的重要性： 如果消息不太重要，丢失也没有影响，那么自动ACK会比较方便 如果消息非常重要，不容丢失。那么最好在消费完成后手动ACK，否则接收消息后就自动ACK，RabbitMQ就会把消息从队列中删除。如果此时消费者宕机，那么消息就丢失了。 我们之前的测试都是自动ACK的，如果要手动ACK，需要改动我们的代码： 123456789101112131415161718192021222324252627public class Recv2 &#123; private final static String QUEUE_NAME = "simple_queue"; public static void main(String[] argv) throws Exception &#123; // 获取到连接 Connection connection = ConnectionUtil.getConnection(); // 创建通道 final Channel channel = connection.createChannel(); // 声明队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); // 定义队列的消费者 DefaultConsumer consumer = new DefaultConsumer(channel) &#123; // 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用 @Override public void handleDelivery(String consumerTag, Envelope envelope, BasicProperties properties, byte[] body) throws IOException &#123; // body 即消息体 String msg = new String(body); System.out.println(" [x] received : " + msg + "!"); // 手动进行ACK channel.basicAck(envelope.getDeliveryTag(), false); &#125; &#125;; // 监听队列，第二个参数false，手动进行ACK channel.basicConsume(QUEUE_NAME, false, consumer); &#125;&#125; 注意到最后一行代码： 1channel.basicConsume(QUEUE_NAME, false, consumer); 如果第二个参数为true，则会自动进行ACK；如果为false，则需要手动ACK。方法的声明： 2.1.4.1.自动ACK存在的问题修改消费者，添加异常，如下： 生产者不做任何修改，直接运行，消息发送成功： 运行消费者，程序抛出异常。但是消息依然被消费： 管理界面： 2.1.4.2.演示手动ACK修改消费者，把自动改成手动（去掉之前制造的异常） 生产者不变，再次运行： 运行消费者 但是，查看管理界面，发现： 停掉消费者的程序，发现： 这是因为虽然我们设置了手动ACK，但是代码中并没有进行消息确认！所以消息并未被真正消费掉。 当我们关掉这个消费者，消息的状态再次称为Ready 修改代码手动ACK： 执行： 消息消费成功！ 2.2.work消息模型工作队列或者竞争消费者模式 Work queues,也被称为(Task queues)，任务模型。当消息处理比较耗时的时候，可能生产消息的速度会远远大于消息的消费速度。长此以往，消息就会堆积越来越多，无法及时处理。此时就可以使用work模型:让多个消费者绑定到一个队列，共同消费队列中的消息。队列中的消息一旦消费，就会消失，因此任务是不会被重复执行的。 在第一篇教程中，我们编写了一个程序，从一个命名队列中发送并接受消息。在这里，我们将创建一个工作队列，在多个工作者之间分配耗时任务。 工作队列，又称任务队列。主要思想就是避免执行资源密集型任务时，必须等待它执行完成。相反我们稍后完成任务，我们将任务封装为消息并将其发送到队列。 在后台运行的工作进程将获取任务并最终执行作业。当你运行许多工人时，任务将在他们之间共享，但是一个消息只能被一个消费者获取。 这个概念在Web应用程序中特别有用，因为在短的HTTP请求窗口中无法处理复杂的任务。 接下来我们来模拟这个流程： ​ P：生产者：任务的发布者 ​ C1：消费者，领取任务并且完成任务，假设完成速度较快 ​ C2：消费者2：领取任务并完成任务，假设完成速度慢 面试题：避免消息堆积？ 1） 采用workqueue，多个消费者监听同一队列。 2）接收到消息以后，而是通过线程池，异步消费。 2.2.1.生产者生产者与案例1中的几乎一样： 123456789101112131415161718192021222324public class Send &#123; private final static String QUEUE_NAME = "test_work_queue"; public static void main(String[] argv) throws Exception &#123; // 获取到连接 Connection connection = ConnectionUtil.getConnection(); // 获取通道 Channel channel = connection.createChannel(); // 声明队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); // 循环发布任务 for (int i = 0; i &lt; 50; i++) &#123; // 消息内容 String message = "task .. " + i; channel.basicPublish("", QUEUE_NAME, null, message.getBytes()); System.out.println(" [x] Sent '" + message + "'"); Thread.sleep(i * 2); &#125; // 关闭通道和连接 channel.close(); connection.close(); &#125;&#125; 不过这里我们是循环发送50条消息。 2.2.2.消费者1 2.2.3.消费者2 与消费者1基本类似，就是没有设置消费耗时时间。 这里是模拟有些消费者快，有些比较慢。 接下来，两个消费者一同启动，然后发送50条消息： 可以发现，两个消费者各自消费了25条消息，而且各不相同，这就实现了任务的分发。 2.2.4.能者多劳刚才的实现有问题吗？ 消费者1比消费者2的效率要低，一次任务的耗时较长 然而两人最终消费的消息数量是一样的 消费者2大量时间处于空闲状态，消费者1一直忙碌 现在的状态属于是把任务平均分配，正确的做法应该是消费越快的人，消费的越多。 怎么实现呢？ 我们可以使用basicQos方法和prefetchCount = 1设置。 这告诉RabbitMQ一次不要向工作人员发送多于一条消息。 或者换句话说，不要向工作人员发送新消息，直到它处理并确认了前一个消息。 相反，它会将其分派给不是仍然忙碌的下一个工作人员。 12// 设置每个消费者同时只能处理一条消息channel.basicQos(1); 再次测试： 2.3.订阅模型分类在之前的模式中，我们创建了一个工作队列。 工作队列背后的假设是：每个任务只被传递给一个工作人员。 在这一部分，我们将做一些完全不同的事情 - 我们将会传递一个信息给多个消费者。 这种模式被称为“发布/订阅”。 订阅模型示意图： 解读： 1、1个生产者，多个消费者 2、每一个消费者都有自己的一个队列 3、生产者没有将消息直接发送到队列，而是发送到了交换机 4、每个队列都要绑定到交换机 5、生产者发送的消息，经过交换机到达队列，实现一个消息被多个消费者获取的目的 X（Exchanges）：交换机一方面：接收生产者发送的消息。另一方面：知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于Exchange的类型。 Exchange类型有以下几种： ​ Fanout：广播，将消息交给所有绑定到交换机的队列 ​ Direct：定向，把消息交给符合指定routing key 的队列 ​ Topic：通配符，把消息交给符合routing pattern（路由模式） 的队列 我们这里先学习 ​ Fanout：即广播模式 Exchange（交换机）只负责转发消息，不具备存储消息的能力，因此如果没有任何队列与Exchange绑定，或者没有符合路由规则的队列，那么消息会丢失！ 2.4.订阅模型-FanoutFanout，也称为广播。 流程图： 在广播模式下，消息发送流程是 这样的： 1） 可以有多个消费者 2） 每个消费者有自己的queue（队列） 3） 每个队列都要绑定到Exchange（交换机） 4） 生产者发送的消息，只能发送到交换机，交换机来决定要发给哪个队列，生产者无法决定。 5） 交换机把消息发送给绑定过的所有队列 6） 队列的消费者都能拿到消息。实现一条消息被多个消费者消费 2.4.1.生产者两个变化： 1） 声明Exchange，不再声明Queue 2） 发送消息到Exchange，不再发送到Queue 1234567891011121314151617181920212223public class Send &#123; private final static String EXCHANGE_NAME = "fanout_exchange_test"; public static void main(String[] argv) throws Exception &#123; // 获取到连接 Connection connection = ConnectionUtil.getConnection(); // 获取通道 Channel channel = connection.createChannel(); // 声明exchange，指定类型为fanout channel.exchangeDeclare(EXCHANGE_NAME, "fanout"); // 消息内容 String message = "Hello everyone"; // 发布消息到Exchange channel.basicPublish(EXCHANGE_NAME, "", null, message.getBytes()); System.out.println(" [生产者] Sent '" + message + "'"); channel.close(); connection.close(); &#125;&#125; 2.4.2.消费者112345678910111213141516171819202122232425262728293031public class Recv &#123; private final static String QUEUE_NAME = "fanout_exchange_queue_1"; private final static String EXCHANGE_NAME = "fanout_exchange_test"; public static void main(String[] argv) throws Exception &#123; // 获取到连接 Connection connection = ConnectionUtil.getConnection(); // 获取通道 Channel channel = connection.createChannel(); // 声明队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); // 绑定队列到交换机 channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, ""); // 定义队列的消费者 DefaultConsumer consumer = new DefaultConsumer(channel) &#123; // 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用 @Override public void handleDelivery(String consumerTag, Envelope envelope, BasicProperties properties, byte[] body) throws IOException &#123; // body 即消息体 String msg = new String(body); System.out.println(" [消费者1] received : " + msg + "!"); &#125; &#125;; // 监听队列，自动返回完成 channel.basicConsume(QUEUE_NAME, true, consumer); &#125;&#125; 要注意代码中：队列需要和交换机绑定 2.4.3.消费者212345678910111213141516171819202122232425262728293031public class Recv2 &#123; private final static String QUEUE_NAME = "fanout_exchange_queue_2"; private final static String EXCHANGE_NAME = "fanout_exchange_test"; public static void main(String[] argv) throws Exception &#123; // 获取到连接 Connection connection = ConnectionUtil.getConnection(); // 获取通道 Channel channel = connection.createChannel(); // 声明队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); // 绑定队列到交换机 channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, ""); // 定义队列的消费者 DefaultConsumer consumer = new DefaultConsumer(channel) &#123; // 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用 @Override public void handleDelivery(String consumerTag, Envelope envelope, BasicProperties properties, byte[] body) throws IOException &#123; // body 即消息体 String msg = new String(body); System.out.println(" [消费者2] received : " + msg + "!"); &#125; &#125;; // 监听队列，手动返回完成 channel.basicConsume(QUEUE_NAME, true, consumer); &#125;&#125; 2.4.4.测试我们运行两个消费者，然后发送1条消息： 2.5.订阅模型-Direct说明：​ 在Fanout模式中，一条消息，会被所有订阅的队列都消费。但是，在某些场景下，我们希望不同的消息被不同的队列消费。这时就要用到Direct类型的Exchange。 在Direct模型下： 队列与交换机的绑定，不能是任意绑定了，而是要指定一个RoutingKey（路由key） 消息的发送方在向Exchange发送消息时，也必须指定消息的routing key。 Exchange不 再把消息交给每一个绑定的队列，而是根据消息的Routing Key进行判断，只有队列的Routingkey与消息的Routing key完全一致，才会接收到消息 P：生产者，向Exchange发送消息，发送消息时，会指定一个routing key。 X：Exchange（交换机），接收生产者的消息，然后把消息递交给 与routing key完全匹配的队列 C1：消费者，其所在队列指定了需要routing key 为 error 的消息 C2：消费者，其所在队列指定了需要routing key 为 info、error、warning 的消息 2.5.1.生产者此处我们模拟商品的增删改，发送消息的RoutingKey分别是：insert、update、delete 1234567891011121314151617181920public class Send &#123; private final static String EXCHANGE_NAME = "direct_exchange_test"; public static void main(String[] argv) throws Exception &#123; // 获取到连接 Connection connection = ConnectionUtil.getConnection(); // 获取通道 Channel channel = connection.createChannel(); // 声明exchange，指定类型为direct channel.exchangeDeclare(EXCHANGE_NAME, "direct"); // 消息内容 String message = "商品新增了， id = 1001"; // 发送消息，并且指定routing key 为：insert ,代表新增商品 channel.basicPublish(EXCHANGE_NAME, "insert", null, message.getBytes()); System.out.println(" [商品服务：] Sent '" + message + "'"); channel.close(); connection.close(); &#125;&#125; 2.5.2.消费者1我们此处假设消费者1只接收两种类型的消息：更新商品和删除商品。 12345678910111213141516171819202122232425262728293031public class Recv &#123; private final static String QUEUE_NAME = "direct_exchange_queue_1"; private final static String EXCHANGE_NAME = "direct_exchange_test"; public static void main(String[] argv) throws Exception &#123; // 获取到连接 Connection connection = ConnectionUtil.getConnection(); // 获取通道 Channel channel = connection.createChannel(); // 声明队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); // 绑定队列到交换机，同时指定需要订阅的routing key。假设此处需要update和delete消息 channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, "update"); channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, "delete"); // 定义队列的消费者 DefaultConsumer consumer = new DefaultConsumer(channel) &#123; // 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用 @Override public void handleDelivery(String consumerTag, Envelope envelope, BasicProperties properties, byte[] body) throws IOException &#123; // body 即消息体 String msg = new String(body); System.out.println(" [消费者1] received : " + msg + "!"); &#125; &#125;; // 监听队列，自动ACK channel.basicConsume(QUEUE_NAME, true, consumer); &#125;&#125; 2.5.3.消费者2我们此处假设消费者2接收所有类型的消息：新增商品，更新商品和删除商品。 1234567891011121314151617181920212223242526272829303132public class Recv2 &#123; private final static String QUEUE_NAME = "direct_exchange_queue_2"; private final static String EXCHANGE_NAME = "direct_exchange_test"; public static void main(String[] argv) throws Exception &#123; // 获取到连接 Connection connection = ConnectionUtil.getConnection(); // 获取通道 Channel channel = connection.createChannel(); // 声明队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); // 绑定队列到交换机，同时指定需要订阅的routing key。订阅 insert、update、delete channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, "insert"); channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, "update"); channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, "delete"); // 定义队列的消费者 DefaultConsumer consumer = new DefaultConsumer(channel) &#123; // 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用 @Override public void handleDelivery(String consumerTag, Envelope envelope, BasicProperties properties, byte[] body) throws IOException &#123; // body 即消息体 String msg = new String(body); System.out.println(" [消费者2] received : " + msg + "!"); &#125; &#125;; // 监听队列，自动ACK channel.basicConsume(QUEUE_NAME, true, consumer); &#125;&#125; 2.5.4.测试我们分别发送增、删、改的RoutingKey，发现结果： 2.6.订阅模型-TopicTopic类型的Exchange与Direct相比，都是可以根据RoutingKey把消息路由到不同的队列。只不过Topic类型Exchange可以让队列在绑定Routing key 的时候使用通配符！ Routingkey 一般都是有一个或多个单词组成，多个单词之间以”.”分割，例如： item.insert 通配符规则： ​ #：匹配一个或多个词 ​ *：匹配不多不少恰好1个词 举例： ​ audit.#：能够 匹配audit.irs.corporate 或者 audit.irs ​ audit.*：只能匹配audit.irs 在这个例子中，我们将发送所有描述动物的消息。消息将使用由三个字（两个点）组成的routing key发送。路由关键字中的第一个单词将描述速度，第二个颜色和第三个种类：“..”。 我们创建了三个绑定：Q1绑定了绑定键“ .orange.”，Q2绑定了“..rabbit”和“lazy.＃”。 Q1匹配所有的橙色动物。 Q2匹配关于兔子以及懒惰动物的消息。 练习，生产者发送如下消息，会进入那个队列： quick.orange.rabbit à Q1 Q2 lazy.orange.elephant à Q1 Q2 quick.orange.fox à Q1 lazy.pink.rabbit à Q2 quick.brown.fox à 不匹配任意队列，被丢弃 quick.orange.male.rabbit à orange à 2.6.1.生产者使用topic类型的Exchange，发送消息的routing key有3种： item.isnert、item.update、item.delete： 1234567891011121314151617181920public class Send &#123; private final static String EXCHANGE_NAME = "topic_exchange_test"; public static void main(String[] argv) throws Exception &#123; // 获取到连接 Connection connection = ConnectionUtil.getConnection(); // 获取通道 Channel channel = connection.createChannel(); // 声明exchange，指定类型为topic channel.exchangeDeclare(EXCHANGE_NAME, "topic"); // 消息内容 String message = "新增商品 : id = 1001"; // 发送消息，并且指定routing key 为：insert ,代表新增商品 channel.basicPublish(EXCHANGE_NAME, "item.insert", null, message.getBytes()); System.out.println(" [商品服务：] Sent '" + message + "'"); channel.close(); connection.close(); &#125;&#125; 2.6.2.消费者1我们此处假设消费者1只接收两种类型的消息：更新商品和删除商品 12345678910111213141516171819202122232425262728293031public class Recv &#123; private final static String QUEUE_NAME = "topic_exchange_queue_1"; private final static String EXCHANGE_NAME = "topic_exchange_test"; public static void main(String[] argv) throws Exception &#123; // 获取到连接 Connection connection = ConnectionUtil.getConnection(); // 获取通道 Channel channel = connection.createChannel(); // 声明队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); // 绑定队列到交换机，同时指定需要订阅的routing key。需要 update、delete channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, "item.update"); channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, "item.delete"); // 定义队列的消费者 DefaultConsumer consumer = new DefaultConsumer(channel) &#123; // 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用 @Override public void handleDelivery(String consumerTag, Envelope envelope, BasicProperties properties, byte[] body) throws IOException &#123; // body 即消息体 String msg = new String(body); System.out.println(" [消费者1] received : " + msg + "!"); &#125; &#125;; // 监听队列，自动ACK channel.basicConsume(QUEUE_NAME, true, consumer); &#125;&#125; 2.6.3.消费者2我们此处假设消费者2接收所有类型的消息：新增商品，更新商品和删除商品。 123456789101112131415161718192021222324252627282930313233/** * 消费者2 */public class Recv2 &#123; private final static String QUEUE_NAME = "topic_exchange_queue_2"; private final static String EXCHANGE_NAME = "topic_exchange_test"; public static void main(String[] argv) throws Exception &#123; // 获取到连接 Connection connection = ConnectionUtil.getConnection(); // 获取通道 Channel channel = connection.createChannel(); // 声明队列 channel.queueDeclare(QUEUE_NAME, false, false, false, null); // 绑定队列到交换机，同时指定需要订阅的routing key。订阅 insert、update、delete channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, "item.*"); // 定义队列的消费者 DefaultConsumer consumer = new DefaultConsumer(channel) &#123; // 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用 @Override public void handleDelivery(String consumerTag, Envelope envelope, BasicProperties properties, byte[] body) throws IOException &#123; // body 即消息体 String msg = new String(body); System.out.println(" [消费者2] received : " + msg + "!"); &#125; &#125;; // 监听队列，自动ACK channel.basicConsume(QUEUE_NAME, true, consumer); &#125;&#125; 2.7.持久化如何避免消息丢失？ 1） 消费者的ACK机制。可以防止消费者丢失消息。 2） 但是，如果在消费者消费之前，MQ就 宕机了，消息就没了。 是可以将消息进行持久化呢？ 要将消息持久化，前提是：队列、Exchange都持久化 2.7.1.交换机持久化 2.7.2.队列持久化 2.7.3.消息持久化 解决消息丢失？（面试rabbitmq） ack（消息确认） 持久化 发送消息前，将消息持久化到数据库，并记录消息状态（可靠消息服务） 生产确认（publisher confirm） 幂等性（同一个接口被重复执行，其结果一致） 3.Spring AMQP3.1.简介Sprin有很多不同的项目，其中就有对AMQP的支持： Spring AMQP的页面：http://spring.io/projects/spring-amqp 注意这里一段描述： ​ Spring-amqp是对AMQP协议的抽象实现，而spring-rabbit 是对协议的具体实现，也是目前的唯一实现。底层使用的就是RabbitMQ。 2.2.依赖和配置添加AMQP的启动器： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;&lt;/dependency&gt; 在application.yml中添加RabbitMQ地址： 123456spring: rabbitmq: host: 192.168.25.128 username: 2850105498 password: cxg200888 virtual-host: /leyou 2.3.监听者在SpringAmqp中，对消息的消费者进行了封装和抽象，一个普通的JavaBean中的普通方法，只要通过简单的注解，就可以成为一个消费者。 123456789101112131415@Componentpublic class Listener &#123; @RabbitListener(bindings = @QueueBinding( value = @Queue(value = "spring.test.queue", durable = "true"), exchange = @Exchange( value = "spring.test.exchange", ignoreDeclarationExceptions = "true", type = ExchangeTypes.TOPIC ), key = &#123;"#.#"&#125;)) public void listen(String msg)&#123; System.out.println("接收到消息：" + msg); &#125;&#125; @Componet：类上的注解，注册到Spring容器 @RabbitListener：方法上的注解，声明这个方法是一个消费者方法，需要指定下面的属性： bindings：指定绑定关系，可以有多个。值是@QueueBinding的数组。@QueueBinding包含下面属性： value：这个消费者关联的队列。值是@Queue，代表一个队列 exchange：队列所绑定的交换机，值是@Exchange类型 key：队列和交换机绑定的RoutingKey 类似listen这样的方法在一个类中可以写多个，就代表多个消费者。 2.4.AmqpTemplateSpring最擅长的事情就是封装，把他人的框架进行封装和整合。 Spring为AMQP提供了统一的消息处理模板：AmqpTemplate，非常方便的发送消息，其发送方法： 红框圈起来的是比较常用的3个方法，分别是： 指定交换机、RoutingKey和消息体 指定消息 指定RoutingKey和消息，会向默认的交换机发送消息 2.5.测试代码123456789101112131415@RunWith(SpringRunner.class)@SpringBootTest(classes = Application.class)public class MqDemo &#123; @Autowired private AmqpTemplate amqpTemplate; @Test public void testSend() throws InterruptedException &#123; String msg = "hello, Spring boot amqp"; this.amqpTemplate.convertAndSend("spring.test.exchange","a.b", msg); // 等待10秒后再结束 Thread.sleep(10000); &#125;&#125; 运行后查看日志：]]></content>
      <categories>
        <category>项目实战-微服务商城</category>
        <category>Rabbitmq</category>
      </categories>
      <tags>
        <tag>Rabbitmq</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务商城（十三）——商品详情、静态化]]></title>
    <url>%2Fday13.%E5%95%86%E5%93%81%E8%AF%A6%E6%83%85%E3%80%81%E5%95%86%E5%93%81%E9%9D%99%E6%80%81%E5%8C%96.html</url>
    <content type="text"><![CDATA[0.学习目标 了解Thymeleaf的基本使用 实现商品详情页的渲染 知道页面静态化的作用 实现页面静态化功能 1.商品详情 当用户搜索到商品，肯定会点击查看，就会进入商品详情页，接下来我们完成商品详情页的展示，商品详情页在leyou-portal中对应的页面是: item.html但是不同的商品，到达item.html需 要展示的内容不同，该怎么做呢? 思路1:统一跳转到item.html页面，然后异步加载商品数据，渲染页面 思路2:将请求交给tomcat处理，在后天完成数据渲染，给不同商品生成不同页面后，返回给用户我们该选哪一种思路? 思路1: 优点:页面加载快，异步处理，用户体验好 缺点:会向后天发起多次数据请求，增加服务端压力 思路2: 优点:后台处理页面后返回，用户拿到是最终数据，不会再次向后台发起数据请求。 缺点:在后台处理页面，服务端压力过大，tomcat并发能力差​ 此处我们选择思路2，现在用tomcat来处理请求，完成服务端的页面渲染，不过后期我们对此进行优化。 以前服务端渲染我们都使用的JSP，不过在SpringBoot中已经不推 荐使用JJsp了，因此我们会使用另外的模板引擎技术: Thymeleaf 1.1.Thymeleaf在商品详情页中，我们会使用到Thymeleaf来渲染页面，所以需要先了解Thymeleaf的语法。 详见课前资料中《Thymeleaf语法入门.md》 1.2.商品详情页服务商品详情浏览量比较大，并发高，我们会独立开启一个微服务，用来展示商品详情。 1.2.1.创建module商品的详情页服务，命名为：ly-page 1.2.2.pom依赖1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;leyou&lt;/artifactId&gt; &lt;groupId&gt;com.leyou.parent&lt;/groupId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.service&lt;/groupId&gt; &lt;artifactId&gt;ly-page&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.leyou.service&lt;/groupId&gt; &lt;artifactId&gt;ly-item-interface&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 1.2.3.编写启动类12345678@SpringBootApplication@EnableDiscoveryClient@EnableFeignClientspublic class LyPageApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(LyPageApplication.class, args); &#125;&#125; 1.2.4.application.yml文件1234567891011121314151617server: port: 8084spring: application: name: page-service thymeleaf: cache: falseeureka: client: service-url: defaultZone: http://127.0.0.1:10086/eureka instance: lease-renewal-interval-in-seconds: 5 # 每隔5秒发送一次心跳 lease-expiration-duration-in-seconds: 10 # 10秒不发送就过期 prefer-ip-address: true ip-address: 127.0.0.1 instance-id: $&#123;spring.application.name&#125;.$&#123;server.port&#125; 1.2.5.页面模板我们从leyou-portal中复制item.html模板到当前项目resource目录下的templates中： 1.3.页面跳转1.3.1.修改页面跳转路径首先我们需要修改搜索结果页的商品地址，目前所有商品的地址都是：http://www.leyou.com/item.html 我们应该跳转到对应的商品的详情页才对。 那么问题来了：商品详情页是一个SKU？还是多个SKU的集合？ 通过详情页的预览，我们知道它是多个SKU的集合，即SPU。 所以，页面跳转时，我们应该携带SPU的id信息。 例如：http://www.leyou.com/item/2314123.html 这里就采用了路径占位符的方式来传递spu的id，我们打开search.html，修改其中的商品路径： 刷新页面后再看： 1.3.2.nginx反向代理接下来，我们要把这个地址指向我们刚刚创建的服务：ly-page，其端口为8084 我们在nginx.conf中添加一段逻辑： 把以/item开头的请求，代理到我们的8084端口。 1.3.3.编写跳转controller在ly-page中编写controller，接收请求，并跳转到商品详情页： 12345678910111213141516@Controller@RequestMapping("item")public class GoodsController &#123; /** * 跳转到商品详情页 * @param model * @param id * @return */ @GetMapping("&#123;id&#125;.html") public String toItemPage(Model model, @PathVariable("id")Long id)&#123; return "item"; &#125;&#125; 1.3.4.测试启动ly-page，点击搜索页面商品，看是能够正常跳转： 现在看到的依然是静态的数据。我们接下来开始页面的渲染 1.4.封装模型数据首先我们一起来分析一下，在这个页面中需要哪些数据 我们已知的条件是传递来的spu的id，我们需要根据spu的id查询到下面的数据： spu信息 spu的详情 spu下的所有sku 品牌 商品三级分类 商品规格参数、规格参数组 1.4.1.商品微服务提供接口1.4.1.1.查询spu以上所需数据中，查询spu的接口目前还没有，我们需要在商品微服务中提供这个接口： GoodsApi 1234567/** * 根据spu的id查询spu * @param id * @return */@GetMapping("spu/&#123;id&#125;")public Spu querySpuById(@PathVariable("id") Long id); GoodsController 123456789/** * 根据spu的id查询spu * @param id * @return */@GetMapping("spu/&#123;id&#125;")public ResponseEntity&lt;Spu&gt; querySpuById(@PathVariable("id")Long id)&#123; return ResponseEntity.ok(goodsService.querySpuById(id));&#125; GoodsService 123456789101112public Spu querySpuById(Long id) &#123; //查询spu Spu spu = spuMapper.selectByPrimaryKey(id); if (spu==null)&#123; throw new LyException(ExceptionEnums.SPU_NOT_FOUND); &#125; //查询sku调用上面的函数querySkuByid() spu.setSkus(querySkuByid(id)); //查询detail spu.setSpuDetail(queryDetailBySpuId(id)); return spu;&#125; 1.4.1.2.查询规格参数组我们在页面展示规格时，需要按组展示： 组内有多个参数，为了方便展示。我们提供一个接口，查询规格组，同时在规格组中持有组内的所有参数。 拓展SpecGroup类： 我们在SpecGroup中添加一个SpecParam的集合，保存该组下所有规格参数 1234567891011121314@Table(name = "tb_spec_group")public class SpecGroup &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; private Long cid; private String name; @Transient//不属于SpecGroup数据库里字段 private List&lt;SpecParam&gt; params; // 该组下的所有规格参数集合&#125; 然后提供查询接口： SpecificationAPI： 1234567/** * 根据分类cid查询规格组 * @param cid * @return */@GetMapping("spec/group")List&lt;SpecGroup&gt; queryListByCid(@RequestParam("cid")Long cid); SpecificationController 123456789/** * 根据分类cid查询规格组 * @param cid * @return */ @GetMapping("group")public ResponseEntity&lt;List&lt;SpecGroup&gt;&gt; queryListByCid(@RequestParam("cid")Long cid)&#123; return ResponseEntity.ok(specificationService.queryListByCid(cid)); &#125; SpecificationService 123456789101112131415161718192021public List&lt;SpecGroup&gt; queryListByCid(Long cid) &#123; //查询规格组 List&lt;SpecGroup&gt; specGroups = queryGroupByCid(cid); //查询当前分类下的规格参数 List&lt;SpecParam&gt; specParams = queryParamByList(null, cid, null, null); //先把规格参数变成map，map的key是规格参数组id，map的值是组下的所有参数 Map&lt;Long,List&lt;SpecParam&gt;&gt; map=new HashMap&lt;&gt;(); for (SpecParam specParam : specParams) &#123; if (!map.containsKey(specParam.getGroupId()))&#123; //这个组id在map中不存在，新增一个list map.put(specParam.getGroupId(),new ArrayList&lt;&gt;()); &#125; map.get(specParam.getGroupId()).add(specParam); &#125; //填充param到group for (SpecGroup specGroup : specGroups) &#123; specGroup.setParams(map.get(specGroup.getId())); &#125; return specGroups; &#125; 在service中，我们调用之前编写过的方法，查询规格组，和规格参数，然后封装返回。 1.4.2.创建FeignClient我们在ly-page服务中，创建FeignClient： BrandClient： 123@FeignClient("item-service")public interface BrandClient extends BrandApi &#123;&#125; CategoryClient 123@FeignClient("item-service")public interface CategoryClient extends CategoryApi &#123;&#125; GoodsClient: 123@FeignClient("item-service")public interface GoodsClient extends GoodsApi &#123;&#125; SpecificationClient： 123@FeignClient(value = "item-service")public interface SpecificationClient extends SpecificationApi&#123;&#125; 1.4.3.封装数据模型我们创建一个GoodsService，在里面来封装数据模型。 这里要查询的数据： SPU：商品 SpuDetail：商品详情 SKU集合 category：商品分类 这里值需要分类的id和name就够了，因此我们查询到以后自己需要封装数据 brand：品牌 spec：规格组 查询规格组的时候，把规格组下所有的参数也一并查出，上面提供的接口中已经实现该功能，我们直接调 sku的特有规格参数 有了规格组，为什么这里还要查询？ 因为在SpuDetail中的SpecialSpec中，是以id作为规格参数id作为key，如图： 我们就需要把id和name一一对应起来，因此需要额外查询sku的特有规格参数，然后变成一个id:name的键值对格式。也就是一个Map，方便将来根据id查找！ Service代码 123456789101112131415161718192021222324252627282930@Servicepublic class PageService &#123; @Autowired private BrandClient brandClient; @Autowired private CategoryClient categoryClient; @Autowired private SpecificationClient specificationClient; @Autowired private GoodsClient goodsClient; public Map&lt;String,Object&gt; loadModel(Long spuId) &#123; Map&lt;String,Object&gt; model=new HashMap&lt;&gt;(); //查询spu Spu spu = goodsClient.querySpuById(spuId); List&lt;Sku&gt; skus = spu.getSkus(); SpuDetail detail = spu.getSpuDetail(); Brand brand = brandClient.queryBrandById(spu.getBrandId()); List&lt;Category&gt; categories = categoryClient.queryCategoryByIds(Arrays.asList(spu.getCid1(), spu.getCid2(), spu.getCid3())); List&lt;SpecGroup&gt; specs = specificationClient.queryListByCid(spu.getCid3()); model.put("spu",spu); model.put("skus",skus); model.put("detail",detail); model.put("brand", brand); model.put("categories",categories); model.put("specs",specs); return model; &#125;&#125; 然后在controller中把数据放入model： 12345678910111213141516@Controllerpublic class PageController &#123; @Autowired private PageService pageService; @GetMapping("item/&#123;id&#125;.html") public String toItemPage(@PathVariable("id") Long spuId, Model model) &#123; //查询模型数据 Map&lt;String,Object&gt; attributes=pageService.loadModel(spuId); //准备模型属性 model.addAllAttributes(attributes); return "item"; &#125;&#125; 1.4.4.页面测试数据我们在页面中先写一段JS，把模型中的数据取出观察，看是否成功： 123456789&lt;script th:inline="javascript"&gt; const b = /*[[$&#123;params&#125;]]*/ []; const c = /*[[$&#123;categories&#125;]]*/ []; const d = /*[[$&#123;spu&#125;]]*/ &#123;&#125;; const e = /*[[$&#123;detail&#125;]]*/ &#123;&#125;; const f = /*[[$&#123;skus&#125;]]*/ []; const g = /*[[$&#123;brand&#125;]]*/ &#123;&#125;;&lt;/script&gt; 然后查看页面源码： 数据都成功查到了！ 1.5.渲染面包屑在商品展示页的顶部，有一个商品分类、品牌、标题的面包屑 其数据有3部分： 商品分类 商品品牌 spu标题 我们的模型中都有，所以直接渲染即可（页面101行开始）： 1234567891011&lt;div class="crumb-wrap"&gt; &lt;ul class="sui-breadcrumb"&gt; &lt;li th:each="category : $&#123;categories&#125;"&gt; &lt;a href="#" th:text="$&#123;categories.name&#125;"&gt;手机&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href="#" th:text="$&#123;brand.name&#125;"&gt;Apple&lt;/a&gt; &lt;/li&gt; &lt;li class="active" th:text="$&#123;spu.title&#125;"&gt;Apple iPhone 6s&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 1.6.渲染商品列表先看下整体效果： 这个部分需要渲染的数据有5块： sku图片 sku标题 副标题 sku价格 特有规格属性列表 其中，sku 的图片、标题、价格，都必须在用户选中一个具体sku后，才能渲染。而特有规格属性列表可以在spuDetail中查询到。而副标题则是在spu中，直接可以在页面渲染 因此，我们先对特有规格属性列表进行渲染。等用户选择一个sku，再通过js对其它sku属性渲染 1.6.1.副标题副标题是在spu中，所以我们直接通过Thymeleaf渲染： 在第146行左右： 1&lt;div class="news"&gt;&lt;span th:utext="$&#123;spu.subTitle&#125;"&gt;&lt;/span&gt;&lt;/div&gt; 副标题中可能会有超链接，因此这里也用th:utext来展示，效果： 1.6.2.渲染规格属性列表规格属性列表将来会有事件和动态效果。我们需要有js代码参与，不能使用Thymeleaf来渲染了。 因此，这里我们用vue，不过需要先把数据放到js对象中，方便vue使用 初始化数据我们在页面的head中，定义一个js标签，然后在里面定义变量，保存与sku相关的一些数据： 12345678910const specialSpec = JSON.parse(/*[[$&#123;detail.specialSpec&#125;]]*/ "");const genericSpec = JSON.parse(/*[[$&#123;detail.genericSpec&#125;]]*/ "");const skus = /*[[$&#123;skus&#125;]]*/ [];const specs = /*[[$&#123;specs&#125;]]*/ [];const params = &#123;&#125;;specs.forEach(group =&gt; &#123; group.params.forEach(param =&gt; &#123; params[param.id] = param.name; &#125;)&#125;); specialSpec：这是SpuDetail中唯一与Sku相关的数据 因此我们并没有保存整个spuDetail，而是只保留了这个属性，而且需要手动转为js对象。 paramMap：规格参数的id和name对，方便页面根据id获取参数名 sku：特有规格参数集合 我们来看下页面获取的数据： 通过Vue渲染我们把刚才获得的几个变量保存在Vue实例中： 然后在页面中渲染： 1234567891011121314&lt;div id="specification" class="summary-wrap clearfix"&gt; &lt;dl v-for="(v,k) in specialSpec" :key="k"&gt; &lt;dt&gt; &lt;div class="fl title"&gt; &lt;i&gt;&#123;&#123;paramMap[k]&#125;&#125;&lt;/i&gt; &lt;/div&gt; &lt;/dt&gt; &lt;dd v-for="(str,j) in v" :key="j"&gt; &lt;a href="javascript:;" class="selected"&gt; &#123;&#123;str&#125;&#125;&lt;span title="点击取消选择"&gt;&amp;nbsp;&lt;/span&gt; &lt;/a&gt; &lt;/dd&gt; &lt;/dl&gt;&lt;/div&gt; 然后刷新页面查看： 数据成功渲染了。不过我们发现所有的规格都被勾选了。这是因为现在，每一个规格都有样式：selected，我们应该只选中一个，让它的class样式为selected才对！ 那么问题来了，我们该如何确定用户选择了哪一个？ 1.6.3.规格属性的筛选分析规格参数的格式是这样的： 每一个规格项是数组中的一个元素，因此我们只要保存被选择的规格项的索引，就能判断哪个是用户选择的了！ 我们需要一个对象来保存用户选择的索引，格式如下： 12345&#123; "4":0, "12":0, "13":0&#125; 但问题是，第一次进入页面时，用户并未选择任何参数。因此索引应该有一个默认值，我们将默认值设置为0。 我们在head的script标签中，对索引对象进行初始化： 然后在vue中保存： 页面改造我们在页面中，通过判断indexes的值来判断当前规格是否被选中，并且给规格绑定点击事件，点击规格项后，修改indexes中的对应值： 1234567891011121314&lt;div id="specification" class="summary-wrap clearfix"&gt; &lt;dl v-for="(options,id) in specialSpec" :key="id"&gt; &lt;dt&gt; &lt;div class="fl title"&gt; &lt;i v-text="params[id]"&gt;&lt;/i&gt; &lt;/div&gt; &lt;/dt&gt; &lt;dd v-for="(o,i) in options" :key="i" @click="selectSku(id,i)"&gt; &lt;a href="javascript:;" :class="&#123;selected:i === indexes[id], locked:locked(id, i)&#125;"&gt; &#123;&#123;o&#125;&#125;&lt;span title="点击取消选择"&gt;&amp;nbsp;&lt;/span&gt; &lt;/a&gt; &lt;/dd&gt; &lt;/dl&gt; &lt;/div&gt; 效果： 1.6.4.确定SKU在我们设计sku数据的时候，就已经添加了一个字段：indexes： 这其实就是规格参数的索引组合。 而我们在页面中，用户点击选择规格后，就会把对应的索引保存起来： 因此，我们可以根据这个indexes来确定用户要选择的sku 我们在vue中定义一个计算属性，来计算与索引匹配的sku： 12345678910computed: &#123; sku() &#123; if (Object.values(this.indexes).includes(null)) &#123; return skus[0]; &#125; // 获取选中的规格参数的索引 const index = Object.values(this.indexes).join("_"); // 去skus集合寻找与index一致的sku return skus.find(s =&gt; s.indexes === index); &#125;, 在浏览器工具中查看： 1.6.5.渲染sku列表既然已经拿到了用户选中的sku，接下来，就可以在页面渲染数据了 图片列表商品图片是一个字符串，以,分割，页面展示比较麻烦，所以我们编写一个计算属性:images()，将图片字符串变成数组： 12345678910111213computed: &#123; sku() &#123; if (Object.values(this.indexes).includes(null)) &#123; return skus[0]; &#125; // 获取选中的规格参数的索引 const index = Object.values(this.indexes).join("_"); // 去skus集合寻找与index一致的sku return skus.find(s =&gt; s.indexes === index); &#125;, images() &#123; return this.sku.images ? this.sku.images.split(",") : []; &#125;, 页面改造： 123456789101112131415161718192021&lt;div class="zoom"&gt; &lt;!--默认第一个预览--&gt; &lt;div id="preview" class="spec-preview"&gt; &lt;span class="jqzoom"&gt; &lt;img :jqimg="images[0]" :src="images[0]" width="400px" height="400px"/&gt; &lt;/span&gt; &lt;/div&gt; &lt;!--下方的缩略图--&gt; &lt;div class="spec-scroll"&gt; &lt;a class="prev"&gt;&amp;lt;&lt;/a&gt; &lt;!--左右按钮--&gt; &lt;div class="items"&gt; &lt;ul&gt; &lt;li v-for="(image, i) in images" :key="i"&gt; &lt;img :src="image" :bimg="image" onmousemove="preview(this)" /&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;a class="next"&gt;&amp;gt;&lt;/a&gt; &lt;/div&gt;&lt;/div&gt; 完整效果 1.7.商品详情商品详情页面如下图所示： 分成上下两部分： 上部：展示的是规格属性列表 下部：展示的是商品详情 1.7.1.属性列表（作业）12345678910&lt;div id="one" class="tab-pane active" &gt;&lt;ul class="goods-intro-list unstyled" style="list-style: none;" v-for="group in specGroups" :key="group.id"&gt;&lt;!--商品的参数--&gt;&lt;li v-for="param in group.params" :key="param.id" &gt;&#123;&#123;param.name&#125;&#125; : &#123;&#123;param.value&#125;&#125;&lt;/li&gt;&lt;/ul&gt;&lt;!--商品详情--&gt;&lt;div class="intro-detail"&gt;&lt;div th:utext="$&#123;detail.description&#125;"&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt; 1.7.2.商品详情商品详情是HTML代码，我们不能使用 th:text，应该使用th:utext 在页面的第444行左右： 123&lt;!--商品详情--&gt;&lt;div class="intro-detail" th:utext="$&#123;spuDetail.description&#125;"&gt;&lt;/div&gt; 最终展示效果： 1.8.规格包装：规格包装分成两部分： 规格参数 包装列表 而且规格参数需要按照组来显示 1.8.1.规格参数最终的效果： 我们模型中有一个groups，跟这个数据结果很像： 分成8个组，组内都有params，里面是所有的参数。不过，这些参数都没有值！ 规格参数的值分为两部分： 通用规格参数：保存在SpuDetail中的genericSpec中 特有规格参数：保存在sku的ownSpec中 我们需要把这两部分值取出来，放到groups中。 把genericSpec引入到Vue实例： 因为sku是动态的，所以我们编写一个计算属性，来进行值的组合： 1234567891011121314specGroups() &#123; // 获取特有规格参数值 const ownSpec = JSON.parse(this.sku.ownSpec); specs.forEach(group =&gt; &#123; group.params.forEach(param =&gt; &#123; if (param.generic) &#123; param.value = genericSpec[param.id]; &#125; else &#123; param.value = ownSpec[param.id]; &#125; &#125;) &#125;) return specs;&#125;, 然后在页面渲染： 1234567891011&lt;div class="Ptable"&gt; &lt;div class="Ptable-item" v-for="group in specGroups" :key="group.id"&gt; &lt;h3 v-text="group.name"&gt;&lt;/h3&gt; &lt;dl&gt; &lt;span v-for="param in group.params" :key="param.id"&gt; &lt;dt v-text="param.name"&gt;&lt;/dt&gt; &lt;dd v-text="param.value + (param.unit || '')"&gt;&lt;/dd&gt; &lt;/span&gt; &lt;/dl&gt; &lt;/div&gt;&lt;/div&gt; 1.8.2.包装列表包装列表在商品详情中，我们一开始并没有赋值到Vue实例中，但是可以通过Thymeleaf来渲染 1234&lt;div class="package-list"&gt; &lt;h3&gt;包装清单&lt;/h3&gt; &lt;p th:text="$&#123;spuDetail.packingList&#125;"&gt;&lt;/p&gt;&lt;/div&gt; 最终效果： 1.9.售后服务售后服务也可以通过Thymeleaf进行渲染： 123&lt;div id="three" class="tab-pane"&gt; &lt;p th:text="$&#123;detail.afterService&#125;"&gt;售后保障&lt;/p&gt;&lt;/div&gt; 效果： 2.页面静态化2.1.简介2.1.1.问题分析现在，我们的页面是通过Thymeleaf模板引擎渲染后返回到客户端。在后台需要大量的数据查询，而后渲染得到HTML页面。会对数据库造成压力，并且请求的响应时间过长，并发能力不高。 大家能想到什么办法来解决这个问题？ 首先我们能想到的就是缓存技术，比如之前学习过的Redis。不过Redis适合数据规模比较小的情况。假如数据量比较大，例如我们的商品详情页。每个页面如果10kb，100万商品，就是10GB空间，对内存占用比较大。此时就给缓存系统带来极大压力，如果缓存崩溃，接下来倒霉的就是数据库了。 所以缓存并不是万能的，某些场景需要其它技术来解决，比如静态化。 2.1.2.什么是静态化静态化是指把动态生成的HTML页面变为静态内容保存，以后用户的请求到来，直接访问静态页面，不再经过服务的渲染。 而静态的HTML页面可以部署在nginx中，从而大大提高并发能力，减小tomcat压力。 2.1.3.如何实现静态化目前，静态化页面都是通过模板引擎来生成，而后保存到nginx服务器来部署。常用的模板引擎比如： Freemarker Velocity Thymeleaf 我们之前就使用的Thymeleaf，来渲染html返回给用户。Thymeleaf除了可以把渲染结果写入Response，也可以写到本地文件，从而实现静态化。 2.2.Thymeleaf实现静态化2.2.1.概念先说下Thymeleaf中的几个概念： Context：运行上下文 TemplateResolver：模板解析器 TemplateEngine：模板引擎 Context 上下文： 用来保存模型数据，当模板引擎渲染时，可以从Context上下文中获取数据用于渲染。 当与SpringBoot结合使用时，我们放入Model的数据就会被处理到Context，作为模板渲染的数据使用。 TemplateResolver 模板解析器：用来读取模板相关的配置，例如：模板存放的位置信息，模板文件名称，模板文件的类型等等。 当与SpringBoot结合时，TemplateResolver已经由其创建完成，并且各种配置也都有默认值，比如模板存放位置，其默认值就是：templates。比如模板文件类型，其默认值就是html。 TemplateEngine 模板引擎：用来解析模板的引擎，需要使用到上下文、模板解析器。分别从两者中获取模板中需要的数据，模板文件。然后利用内置的语法规则解析，从而输出解析后的文件。来看下模板引擎进行处理的函数： 1templateEngine.process("模板名", context, writer); 三个参数： 模板名称 上下文：里面包含模型数据 writer：输出目的地的流 在输出时，我们可以指定输出的目的地，如果目的地是Response的流，那就是网络响应。如果目的地是本地文件，那就实现静态化了。 而在SpringBoot中已经自动配置了模板引擎，因此我们不需要关心这个。现在我们做静态化，就是把输出的目的地改成本地文件即可！ 2.2.2.具体实现 Service代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253@Slf4j@Servicepublic class PageService &#123; @Autowired private BrandClient brandClient; @Autowired private CategoryClient categoryClient; @Autowired private SpecificationClient specificationClient; @Autowired private GoodsClient goodsClient; @Autowired private TemplateEngine templateEngine; public Map&lt;String,Object&gt; loadModel(Long spuId) &#123; Map&lt;String,Object&gt; model=new HashMap&lt;&gt;(); //查询spu Spu spu = goodsClient.querySpuById(spuId); //查询sku List&lt;Sku&gt; skus = spu.getSkus(); //查询商品详情 SpuDetail detail = spu.getSpuDetail(); //查询品牌 Brand brand = brandClient.queryBrandById(spu.getBrandId()); //查询商品分类 List&lt;Category&gt; categories = categoryClient.queryCategoryByIds(Arrays.asList(spu.getCid1(), spu.getCid2(), spu.getCid3())); //查询规格参数 List&lt;SpecGroup&gt; specs = specificationClient.queryListByCid(spu.getCid3()); model.put("spu",spu); model.put("skus",skus); model.put("detail",detail); model.put("brand", brand); model.put("categories",categories); model.put("specs",specs); return model; &#125; public void createHtml(Long spuId)&#123; //上下文 Context context = new Context(); context.setVariables(loadModel(spuId)); //输出流 File file = new File("G:/Java-webspace/LeYou-store/leyou/ly-page/src/main/resources/templates", spuId + ".html"); try (PrintWriter writer=new PrintWriter(file,"utf-8"))&#123; //生成html templateEngine.process("item",context,writer); &#125;catch (Exception e)&#123; log.error("[静态页服务]，生成静态页面异常！",e); &#125; &#125;&#125; 测试： 测试生成141.html 123456789101112@RunWith(SpringRunner.class)@SpringBootTestpublic class PageServiceTest &#123; @Autowired private PageService pageService; @Test public void createHtml() &#123; pageService.createHtml(141L); &#125;&#125; 2.2.3.什么时候创建静态文件我们编写好了创建静态文件的service，那么问题来了：什么时候去调用它呢 想想这样的场景： 假如大部分的商品都有了静态页面。那么用户的请求都会被nginx拦截下来，根本不会到达我们的leyou-goods-web服务。只有那些还没有页面的请求，才可能会到达这里。 因此，如果请求到达了这里，我们除了返回页面视图外，还应该创建一个静态页面，那么下次就不会再来麻烦我们了。 所以，我们在PageController中添加逻辑，去生成静态html文件： 12345678910111213@GetMapping("&#123;id&#125;.html")public String toItemPage(@PathVariable("id")Long id, Model model)&#123; // 加载所需的数据 Map&lt;String, Object&gt; map = this.goodsService.loadModel(id); // 把数据放入数据模型 model.addAllAttributes(map); // 页面静态化 pageService.createHtml(spuId); return "item";&#125; 注意：生成html 的代码不能对用户请求产生影响，所以这里我们使用额外的线程进行异步创建。 2.2.4.重启测试：访问一个商品详情，然后查看nginx目录： 2.3.nginx代理静态页面接下来，我们修改nginx，让它对商品请求进行监听，指向本地静态页面，如果本地没找到，才进行反向代理： 1234567891011121314151617181920212223server &#123; listen 80; server_name www.leyou.com; proxy_set_header X-Forwarded-Host $host; proxy_set_header X-Forwarded-Server $host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; location /item &#123; # 先找本地 root html; if (!-f $request_filename) &#123; #请求的文件不存在，就反向代理 proxy_pass http://192.168.1.104:8084; break; &#125; &#125; location / &#123; proxy_pass http://192.168.1.104:9002; proxy_connect_timeout 600; proxy_read_timeout 600; &#125;&#125; 重启测试： 发现请求速度得到了极大提升：]]></content>
      <categories>
        <category>项目实战-微服务商城</category>
      </categories>
      <tags>
        <tag>Thymeleaf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务商城（十二）——搜索过滤]]></title>
    <url>%2Fday12-%E6%90%9C%E7%B4%A2%E8%BF%87%E6%BB%A4.html</url>
    <content type="text"><![CDATA[0.学习目标 了解过滤功能的基本思路 独立实现分类和品牌展示 了解规格参数展示 实现过滤条件筛选 实现已选过滤项回显 实现取消选择过滤项 1.过滤功能分析首先看下页面要实现的效果： 整个过滤部分有3块： 顶部的导航，已经选择的过滤条件展示： 商品分类面包屑，根据用户选择的商品分类变化 其它已选择过滤参数 过滤条件展示，又包含3部分 商品分类展示 品牌展示 其它规格参数 展开或收起的过滤条件的按钮 顶部导航要展示的内容跟用户选择的过滤条件有关。 比如用户选择了某个商品分类，则面包屑中才会展示具体的分类 比如用户选择了某个品牌，列表中才会有品牌信息。 所以，这部分需要依赖第二部分：过滤条件的展示和选择。因此我们先不着急去做。 展开或收起的按钮是否显示，取决于过滤条件有多少，如果很少，那么就没必要展示。所以也是跟第二部分的过滤条件有关。 这样分析来看，我们必须先做第二部分：过滤条件展示。 2.生成分类和品牌过滤先来看分类和品牌。在我们的数据库中已经有所有的分类和品牌信息。在这个位置，是不是把所有的分类和品牌信息都展示出来呢？ 显然不是，用户搜索的条件会对商品进行过滤，而在搜索结果中，不一定包含所有的分类和品牌，直接展示出所有商品分类，让用户选择显然是不合适的。 无论是分类信息，还是品牌信息，都应该从搜索的结果商品中进行聚合得到。 2.1.扩展返回的结果原来，我们返回的结果是PageResult对象，里面只有total、totalPage、items3个属性。但是现在要对商品分类和品牌进行聚合，数据显然不够用，我们需要对返回的结果进行扩展，添加分类和品牌的数据。 那么问题来了：以什么格式返回呢？ 看页面： 分类：页面显示了分类名称，但背后肯定要保存id信息。所以至少要有id和name 品牌：页面展示的有logo，有文字，当然肯定有id，基本上是品牌的完整数据 我们新建一个类，继承PageResult，然后扩展两个新的属性：分类集合和品牌集合： 123456789101112131415161718@Data@EqualsAndHashCode(callSuper = false)public class SearchResult extends PageResult&lt;Goods&gt; &#123; private List&lt;Category&gt; categories;//分类待选项 private List&lt;Brand&gt; brands;//品牌待选项 public SearchResult()&#123; &#125; public SearchResult(Long total, Long totalPage, List&lt;Goods&gt; items, List&lt;Category&gt; categories, List&lt;Brand&gt; brands) &#123; super(total, totalPage, items); this.categories = categories; this.brands = brands; this.specs = specs; &#125;&#125; 2.2.聚合商品分类和品牌我们修改搜索的业务逻辑，对分类和品牌聚合。 因为索引库中只有id，所以我们根据id聚合，然后再根据id去查询完整数据。 所以，商品微服务需要提供一个接口：根据品牌id集合，批量查询品牌。 2.2.1.提供查询品牌接口BrandApi 123456@RequestMapping("brand")public interface BrandApi &#123; @GetMapping("list") List&lt;Brand&gt; queryBrandByIds(@RequestParam("ids") List&lt;Long&gt; ids);&#125; BrandController 1234567891011/** * 根据多个id查询品牌 * @param ids * @return */@GetMapping("list")public ResponseEntity&lt;List&lt;Brand&gt;&gt; queryBrandByIds(@RequestParam("ids") List&lt;Long&gt; ids)&#123; List&lt;Brand&gt; list = this.brandService.queryBrandByIds(ids); return ResponseEntity.ok(list);&#125; BrandService 1234public List&lt;Brand&gt; queryBrandByIds(List&lt;Long&gt; ids) &#123; return this.brandMapper.selectByIdList(ids);&#125; BrandMapper 继承通用BaseMapper，自己定义的mapper，继承了extends Mapper,IdListMapper&lt;T,Long&gt;, InsertListMapper 123public interface BrandMapper extends BaseMapper&lt;Brand&gt; &#123; &#125; 2.2.2.搜索功能改造添加BrandClient 123@FeignClient("item-service")public interface BrandClient extends BrandApi &#123;&#125; 修改SearchService： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697@Slf4j@Servicepublic class SearchService &#123; @Autowired private GoodsClient goodsClient; @Autowired private SpecificationClient specificationClient; @Autowired private CategoryClient categoryClient; @Autowired private BrandClient brandClient; @Autowired private GoodsRepository goodsRepository; @Autowired private ElasticsearchTemplate elasticsearchTemplate;public SearchResult search(SearchRequest request) &#123; int page=request.getPage()-1; int size = request.getSize(); //1、创建查询构建器 NativeSearchQueryBuilder queryBuilder = new NativeSearchQueryBuilder(); //2、结果过滤 queryBuilder.withSourceFilter(new FetchSourceFilter(new String[]&#123;"id","skus","subTitle"&#125;,null)); //3、分页 queryBuilder.withPageable(PageRequest.of(page,size)); //4、排序 String sortBy=request.getSortBy(); Boolean desc = request.getDescending(); if (StringUtils.isNotBlank(sortBy))&#123; queryBuilder.withSort(SortBuilders.fieldSort(sortBy).order(desc ? SortOrder.DESC : SortOrder.ASC)); &#125; //5、基本搜索条件 queryBuilder.withQuery(QueryBuilders.matchQuery("all",request.getKey())); //6、聚合(分类和品牌) //6.1、聚合分类 queryBuilder.addAggregation(AggregationBuilders.terms("categoryAggName").field("cid3")); //6.2、聚合品牌 queryBuilder.addAggregation(AggregationBuilders.terms("brandAggName").field("brandId")); //7、查询 AggregatedPage&lt;Goods&gt; result = elasticsearchTemplate.queryForPage(queryBuilder.build(), Goods.class); //8、解析结果 long total = result.getTotalElements();//总条数 long totalPages =(total/size)+1;//总页数 List&lt;Goods&gt; goodsList = result.getContent();//当前页结果 //9、解析聚合结果 Aggregations aggs = result.getAggregations(); //9.1、查询品牌和分类 List&lt;Brand&gt; brands=parseBrandAgg(aggs.get("brandAggName")); List&lt;Category&gt; categories=parseCategoryAgg(aggs.get("categoryAggName")); //10、返回结果 return new SearchResult(total,(long)totalPages,goodsList,categories,brands); &#125;&#125;/** * 通过ids取查询分类 * @param terms * @return */ private List&lt;Category&gt; parseCategoryAgg(LongTerms terms) &#123; try &#123; List&lt;Long&gt; ids = terms.getBuckets().stream().map(b -&gt; b.getKeyAsNumber().longValue()).collect(Collectors.toList()); List&lt;Category&gt; categories = categoryClient.queryCategoryByIds(ids); return categories; &#125;catch (Exception e)&#123; log.error("分类错误信息",e); return null; &#125; &#125; /** * 通过ids取查询品牌 * @param terms * @return */ private List&lt;Brand&gt; parseBrandAgg(LongTerms terms) &#123; try &#123; List&lt;Long&gt; ids = terms.getBuckets().stream().map(b -&gt; b.getKeyAsNumber().longValue()).collect(Collectors.toList()); List&lt;Brand&gt; brands = brandClient.queryBrandByIds(ids); return brands; &#125;catch (Exception e)&#123; log.error("品牌错误信息",e); return null; &#125; &#125; 测试： 2.3.页面渲染数据2.3.1.过滤参数数据结构来看下页面的展示效果： 虽然分类、品牌内容都不太一样，但是结构相似，都是key和value的结构。 而且页面结构也极为类似： 所以，我们可以把所有的过滤条件放入一个数组中，然后在页面利用v-for遍历一次生成。 其基本结构是这样的： 123456[ &#123; k:"过滤字段名", options:[&#123;/*过滤字段值对象*/&#125;,&#123;/*过滤字段值对象*/&#125;] &#125;] 我们先在data中定义数组：filter，等待组装过滤参数： 1234567891011data: &#123; ly, search:&#123; key: "", page: 1 &#125;, goodsList:[], // 接收搜索得到的结果 total: 0, // 总条数 totalPage: 0, // 总页数 filters:[] // 过滤参数集合&#125;, 然后在查询搜索结果的回调函数中，对过滤参数进行封装： 然后刷新页面，通过浏览器工具，查看封装的结果： 2.3.2.页面渲染数据首先看页面原来的代码： 我们注意到，虽然页面元素是一样的，但是品牌会比其它搜索条件多出一些样式，因为品牌是以图片展示。需要进行特殊处理。数据展示是一致的，我们采用v-for处理： 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!--品牌、分类--&gt;&lt;!--分类--&gt;&lt;div class="clearfix selector"&gt; &lt;div class="type-wrap" v-for="f in filters" :key="f.k" v-if="f.k !== 'brandId'"&gt; &lt;div class="fl key"&gt;&#123;&#123;f.k ==='cid3'? "分类" : f.k&#125;&#125;&lt;/div&gt; &lt;div class="fl value"&gt; &lt;ul class="type-list"&gt; &lt;li v-for="(o,i) in f.options" :key="i" @click="selectFilter(filter.k, option)"&gt; &lt;a&gt;&#123;&#123;o.name&#125;&#125;&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class="fl ext"&gt;&lt;/div&gt; &lt;/div&gt; &lt;!--品牌--&gt; &lt;div class="type-wrap logo" v-else&gt; &lt;div class="fl key brand"&gt;品牌&lt;/div&gt; &lt;div class="value logos"&gt; &lt;ul class="logo-list" v-for="(o,i) in f.options" :key="i"&gt; &lt;li v-if="o.image" @click="selectFilter(filter.k, option)"&gt; &lt;img :src="o.image"/&gt; &lt;/li&gt; &lt;li style="text-align: center" v-else @click="selectFilter(filter.k, option)"&gt; &lt;a style="line-height: 30px; font-size: 12px" href="#"&gt;&#123;&#123;o.name&#125;&#125;&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class="fl ext"&gt; &lt;a href="javascript:void(0);" class="sui-btn"&gt;多选&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="type-wrap" style="text-align: center"&gt; &lt;v-btn small flat v-show="!show" @click="show=true"&gt; 更多 &lt;!--&lt;v-icon&gt;arrow_drop_down&lt;/v-icon&gt;--&gt; &lt;/v-btn&gt; &lt;v-btn small flat v-show="show" @click="show=false"&gt; 收起 &lt;!--&lt;v-icon&gt;arrow_drop_up&lt;/v-icon&gt;--&gt; &lt;/v-btn&gt; &lt;/div&gt;&lt;/div&gt; 结果： 3.生成规格参数过滤3.1.谋而后动有四个问题需要先思考清楚： 什么时候显示规格参数过滤？ 如何知道哪些规格需要过滤？ 要过滤的参数，其可选值是如何获取的？ 规格过滤的可选值，其数据格式怎样的？ 什么情况下显示有关规格参数的过滤？ 如果用户尚未选择商品分类，或者聚合得到的分类数大于1，那么就没必要进行规格参数的聚合。因为不同分类的商品，其规格是不同的。 因此，我们在后台需要对聚合得到的商品分类数量进行判断，如果等于1，我们才继续进行规格参数的聚合。 如何知道哪些规格需要过滤？ 我们不能把数据库中的所有规格参数都拿来过滤。因为并不是所有的规格参数都可以用来过滤，参数的值是不确定的。 值的庆幸的是，我们在设计规格参数时，已经标记了某些规格可搜索，某些不可搜索。 因此，一旦商品分类确定，我们就可以根据商品分类查询到其对应的规格，从而知道哪些规格要进行搜索。 要过滤的参数，其可选值是如何获取的？ 虽然数据库中有所有的规格参数，但是不能把一切数据都用来供用户选择。 与商品分类和品牌一样，应该是从用户搜索得到的结果中聚合，得到与结果品牌的规格参数可选值。 规格过滤的可选值，其数据格式怎样的？ 我们直接看页面效果： 我们之前存储时已经将数据分段，恰好符合这里的需求 3.3.实战接下来，我们就用代码实现刚才的思路。 总结一下，应该是以下几步： 1）用户搜索得到商品，并聚合出商品分类 2）判断分类数量是否等于1，如果是则进行规格参数聚合 3）先根据分类，查找可以用来搜索的规格 4）对规格参数进行聚合 5）将规格参数聚合结果整理后返回 3.3.1.扩展返回结果返回结果中需要增加新数据，用来保存规格参数过滤条件。这里与前面的品牌和分类过滤的json结构类似： 123456[ &#123; "k":"规格参数名", "options":["规格参数值","规格参数值"] &#125;] 因此，在java中我们用List&lt;Map&lt;String, String&gt;&gt;来表示。 1234567891011121314151617public class SearchResult extends PageResult&lt;Goods&gt;&#123; private List&lt;Category&gt; categories;// 分类过滤条件 private List&lt;Brand&gt; brands; // 品牌过滤条件 private List&lt;Map&lt;String,String&gt;&gt; specs; // 规格参数过滤条件 public SearchResult(Long total, Integer totalPage, List&lt;Goods&gt; items, List&lt;Category&gt; categories, List&lt;Brand&gt; brands, List&lt;Map&lt;String,String&gt;&gt; specs) &#123; super(total, totalPage, items); this.categories = categories; this.brands = brands; this.specs = specs; &#125;&#125; 3.3.2.判断是否需要聚合首先，在聚合得到商品分类后，判断分类的个数，如果是1个则进行规格聚合： 我们将聚合的代码抽取到了一个getSpecs方法中。 3.3.3.获取需要聚合的规格参数然后，我们需要根据商品分类，查询所有可用于搜索的规格参数： 要注意的是，这里我们需要根据id查询规格，而规格参数接口需要从商品微服务提供 3.3.4.聚合规格参数因为规格参数保存时不做分词，因此其名称会自动带上一个.keyword后缀： 3.3.5.解析聚合结果 3.3.6.最终的完整代码修改SearchService.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116 public SearchResult search(SearchRequest request) &#123; int page=request.getPage()-1; int size = request.getSize(); //1、创建查询构建器 NativeSearchQueryBuilder queryBuilder = new NativeSearchQueryBuilder(); //2、结果过滤 queryBuilder.withSourceFilter(new FetchSourceFilter(new String[]&#123;"id","skus","subTitle"&#125;,null)); //3、分页 queryBuilder.withPageable(PageRequest.of(page,size)); //4、排序 String sortBy=request.getSortBy(); Boolean desc = request.getDescending(); if (StringUtils.isNotBlank(sortBy))&#123; queryBuilder.withSort(SortBuilders.fieldSort(sortBy).order(desc ? SortOrder.DESC : SortOrder.ASC)); &#125; //5、基本搜索条件,调用自己写的函数buildBasicQuery QueryBuilder basicQuery = buildBasicQuery(request); queryBuilder.withQuery(basicQuery); //6、聚合(分类和品牌) //6.1、聚合分类 queryBuilder.addAggregation(AggregationBuilders.terms("categoryAggName").field("cid3")); //6.2、聚合品牌 queryBuilder.addAggregation(AggregationBuilders.terms("brandAggName").field("brandId")); //7、查询 AggregatedPage&lt;Goods&gt; result = elasticsearchTemplate.queryForPage(queryBuilder.build(), Goods.class); //8、解析结果 long total = result.getTotalElements();//总条数 long totalPages =(total/size)+1;//总页数 List&lt;Goods&gt; goodsList = result.getContent();//当前页结果 //9、解析聚合结果 Aggregations aggs = result.getAggregations(); //9.1、查询品牌和分类 List&lt;Brand&gt; brands=parseBrandAgg(aggs.get("brandAggName")); List&lt;Category&gt; categories=parseCategoryAgg(aggs.get("categoryAggName")); //10、规格参数聚合 List&lt;Map&lt;String,Object&gt;&gt; specs=null; if (categories!=null&amp;&amp;categories.size()==1)&#123; //商品分类存在并且数量为1，可以聚合规格参数 specs=buildSpecificationAgg(categories.get(0).getId(),basicQuery); &#125; //11、返回结果 return new SearchResult(total,(long)totalPages,goodsList,categories,brands,specs); &#125; /** * 抽取基本搜索函数 * @param request * @return */ private QueryBuilder buildBasicQuery(SearchRequest request) &#123; //创建布尔查询 BoolQueryBuilder queryBuilder = QueryBuilders.boolQuery(); //查询条件 queryBuilder.must(QueryBuilders.matchQuery("all",request.getKey())); //过滤条件 Map&lt;String, String&gt; map = request.getFilter(); //map.entrySet().for for (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123; //字段名 String key = entry.getKey(); if (!"cid3".equals(key)&amp;&amp;!"brandId".equals(key))&#123; key="specs."+key+".keyword"; &#125; String value = entry.getValue(); queryBuilder.filter(QueryBuilders.termQuery(key,value)); &#125; return queryBuilder; &#125;/** * 聚合规格参数 * @param cid * @param basicQuery * @return */ private List&lt;Map&lt;String,Object&gt;&gt; buildSpecificationAgg(Long cid, QueryBuilder basicQuery) &#123; List&lt;Map&lt;String, Object&gt;&gt; specs = new ArrayList&lt;&gt;(); //1 查询需要聚合的规格参数 List&lt;SpecParam&gt; params = specificationClient.queryParamByList(null, cid, true, null); //2 聚合 //2.1 创建构建器 NativeSearchQueryBuilder queryBuilder = new NativeSearchQueryBuilder(); queryBuilder.withQuery(basicQuery); for (SpecParam param : params) &#123; String name = param.getName(); //聚合 queryBuilder.addAggregation(AggregationBuilders.terms(name).field("specs."+name+".keyword")); &#125; //3 获取结果 AggregatedPage&lt;Goods&gt; result = this.elasticsearchTemplate.queryForPage(queryBuilder.build(), Goods.class); //4 解析结果 Aggregations aggs = result.getAggregations(); for (SpecParam param : params) &#123; //规格参数名称 String name = param.getName(); //聚合结果 StringTerms terms = aggs.get(name); List&lt;String&gt; options = terms.getBuckets().stream().map(b -&gt; b.getKeyAsString()).collect(Collectors.toList()); //准备map Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put("k",name); map.put("options",options); specs.add(map); &#125; return specs; &#125; 3.3.7.测试结果 3.4.页面渲染3.4.1.渲染规格过滤条件首先把后台传递过来的specs添加到filters数组： 要注意：分类、品牌的option选项是对象，里面有name属性，而specs中的option是简单的字符串，所以需要进行封装，变为相同的结构： 最后的结果： 3.4.2.展示或收起过滤条件是不是感觉显示的太多了，我们可以通过按钮点击来展开和隐藏部分内容： 我们在data中定义变量，记录展开或隐藏的状态： 然后在按钮绑定点击事件，以改变show的取值： 在展示规格时，对show进行判断： OK！ 4.过滤条件的筛选当我们点击页面的过滤项，要做哪些事情？ 把过滤条件保存在search对象中（watch监控到search变化后就会发送到后台） 在页面顶部展示已选择的过滤项 把商品分类展示到顶部面包屑 4.1.保存过滤项4.1.1.定义属性我们把已选择的过滤项保存在search中： 要注意，在created构造函数中会对search进行初始化，所以要在构造函数中对filter进行初始化： search.filter是一个对象，结构： 123&#123; "过滤项名":"过滤项值"&#125; 4.1.2.绑定点击事件给所有的过滤项绑定点击事件： 要注意，点击事件传2个参数： k：过滤项的key option：当前过滤项对象 修改search.html下methods方法在点击事件中，保存过滤项到selectedFilter： 123456selectFilter(key, option)&#123; //将filter的属性复制到obj中 const &#123;... obj&#125;=this.search.filter; obj[key]=option; this.search.filter=obj;&#125;, 另外，这里search对象中嵌套了filter对象，请求参数格式化时需要进行特殊处理，修改common.js中的一段代码： 我们刷新页面，点击后通过浏览器功能查看search.filter的属性变化： 并且，此时浏览器地址也发生了变化： 1http://www.leyou.com/search.html?key=%E6%89%8B%E6%9C%BA&amp;page=1&amp;filter.%E5%93%81%E7%89%8C=2032&amp;filter.CPU%E5%93%81%E7%89%8C=%E6%B5%B7%E6%80%9D%EF%BC%88Hisilicon%EF%BC%89&amp;filter.CPU%E6%A0%B8%E6%95%B0=%E5%8D%81%E6%A0%B8 网络请求也正常发出： 4.2.后台添加过滤条件既然请求已经发送到了后台，那接下来我们就在后台去添加这些条件： 4.2.1.拓展请求对象我们需要在请求类：SearchRequest中添加属性，接收过滤属性。过滤属性都是键值对格式，但是key不确定，所以用一个map来接收即可。 4.2.2.添加过滤条件目前，我们的基本查询是这样的： 现在，我们要把页面传递的过滤条件也进入进去。 因此不能在使用普通的查询，而是要用到BooleanQuery，基本结构是这样的： 1234567891011GET /heima/_search&#123; "query":&#123; "bool":&#123; "must":&#123; "match": &#123; "title": "小米手机",operator:"and"&#125;&#125;, "filter":&#123; "range":&#123;"price":&#123;"gt":2000.00,"lt":3800.00&#125;&#125; &#125; &#125; &#125;&#125; 所以，我们对原来的基本查询进行改造： 因为比较复杂，我们将其封装到一个方法中： 1234567891011121314151617181920212223242526/** * 抽取基本搜索函数 * @param request * @return */private QueryBuilder buildBasicQuery(SearchRequest request) &#123; //创建布尔查询 BoolQueryBuilder queryBuilder = QueryBuilders.boolQuery(); //查询条件 queryBuilder.must(QueryBuilders.matchQuery("all",request.getKey())); //过滤条件 Map&lt;String, String&gt; map = request.getFilter(); //map.entrySet().for for (Map.Entry&lt;String, String&gt; entry : map.entrySet()) &#123; //字段名 String key = entry.getKey(); if (!"cid3".equals(key)&amp;&amp;!"brandId".equals(key))&#123; key="specs."+key+".keyword"; &#125; String value = entry.getValue(); queryBuilder.filter(QueryBuilders.termQuery(key,value)); &#125; return queryBuilder;&#125; 其它不变。 4.3.页面测试我们先不点击过滤条件，直接搜索手机： 总共184条 接下来，我们点击一个过滤条件： 得到的结果： 5.页面展示选择的过滤项(作业)5.1.商品分类面包屑当用户选择一个商品分类以后，我们应该在过滤模块的上方展示一个面包屑，把三级商品分类都显示出来。 用户选择的商品分类就存放在search.filter中，但是里面只有第三级分类的id：cid3 我们需要根据它查询出所有三级分类的id及名称 5.1.1.提供查询分类接口我们在商品微服务中提供一个根据三级分类id查询1~3级分类集合的方法： Controller 12345678910111213/** * 根据3级分类id，查询1~3级的分类 * @param id * @return */@GetMapping("all/level")public ResponseEntity&lt;List&lt;Category&gt;&gt; queryAllByCid3(@RequestParam("id") Long id)&#123; List&lt;Category&gt; list = this.categoryService.queryAllByCid3(id); if (list == null || list.size() &lt; 1) &#123; return new ResponseEntity&lt;&gt;(HttpStatus.NOT_FOUND); &#125; return ResponseEntity.ok(list);&#125; Service 123456public List&lt;Category&gt; queryAllByCid3(Long id) &#123; Category c3 = this.categoryMapper.selectByPrimaryKey(id); Category c2 = this.categoryMapper.selectByPrimaryKey(c3.getParentId()); Category c1 = this.categoryMapper.selectByPrimaryKey(c2.getParentId()); return Arrays.asList(c1,c2,c3);&#125; 测试： 5.1.2.页面展示面包屑后台提供了接口，下面的问题是，我们在哪里去查询接口？ 大家首先想到的肯定是当用户点击以后。 但是我们思考一下：用户点击以后，就会重新发起请求，页面刷新，那么你渲染的结果就没了。 因此，应该是在页面重新加载完毕后，此时因为过滤条件中加入了商品分类的条件，所以查询的结果中只有1个分类。 我们判断商品分类是否只有1个，如果是，则查询三级商品分类，添加到面包屑即可。 渲染： 刷新页面： 5.2.其它过滤项接下来，我们需要在页面展示用户已选择的过滤项，如图： 我们知道，所有已选择过滤项都保存在search.filter中，因此在页面遍历并展示即可。 但这里有个问题，filter中数据的格式： 基本有四类数据： 商品分类：这个不需要展示，分类展示在面包屑位置 品牌：这个要展示，但是其key和值不合适，我们不能显示一个id在页面。需要找到其name值 数值类型规格：这个展示的时候，需要把单位查询出来 非数值类型规格：这个直接展示其值即可 因此，我们在页面上这样处理： 1234567&lt;!--已选择过滤项--&gt;&lt;ul class="tags-choose"&gt; &lt;li class="tag" v-for="(v,k) in search.filter" v-if="k !== 'cid3'" :key="k"&gt; &#123;&#123;k === 'brandId' ? '品牌' : k&#125;&#125;:&lt;span style="color: red"&gt;&#123;&#123;getFilterValue(k,v)&#125;&#125;&lt;/span&gt;&lt;/span&gt;&lt;i class="sui-icon icon-tb-close"&gt;&lt;/i&gt;&lt;/li&gt;&lt;/ul&gt; 判断如果 k === &#39;cid3&#39;说明是商品分类，直接忽略 判断k === &#39;brandId&#39;说明是品牌，页面显示品牌，其它规格则直接显示k的值 值的处理比较复杂，我们用一个方法getFilterValue(k,v)来处理，调用时把k和v都传递 方法内部： 12345678910111213getFilterValue(k,v)&#123; // 如果没有过滤参数，我们跳过展示 if(!this.filters || this.filters.length === 0)&#123; return null; &#125; let filter = null; // 判断是否是品牌 if(k === 'brandId')&#123; // 返回品牌名称 return this.filters.find(f =&gt; f.k === 'brandId').options[0].name; &#125; return v;&#125; 然后刷新页面，即可看到效果： 5.3.隐藏已经选择的过滤项现在，我们已经实现了已选择过滤项的展示，但是你会发现一个问题： 已经选择的过滤项，在过滤列表中依然存在： 这些已经选择的过滤项，应该从列表中移除。 怎么做呢？ 你必须先知道用户选择了什么。用户选择的项保存在search.filter中： 我们可以编写一个计算属性，把filters中的 已经被选择的key过滤掉： 123456789101112computed:&#123; remainFilters()&#123; const keys = Object.keys(this.search.filter); if(this.search.filter.cid3)&#123; keys.push("cid3") &#125; if(this.search.filter.brandId)&#123; keys.push("brandId") &#125; return this.filters.filter(f =&gt; !keys.includes(f.k)); &#125;&#125; 然后页面不再直接遍历filters，而是遍历remainFilters 刷新页面： 最后发现，还剩下一堆没选过的。但是都只有一个可选项，此时再过滤没有任何意义，应该隐藏，所以，在刚才的过滤条件中，还应该添加一条：如果只剩下一个可选项，不显示 6.取消过滤项（作业）我们能够看到，每个过滤项后面都有一个小叉，当点击后，应该取消对应条件的过滤。 思路非常简单： 给小叉绑定点击事件 点击后把过滤项从search.filter中移除，页面会自动刷新，OK 绑定点击事件： 绑定点击事件时，把k传递过去，方便删除 删除过滤项 123456deleteFilter(k)&#123; //将filter的属性复制到obj中 const &#123;... obj&#125;=this.search.filter; delete obj[k]; this.search.filter=obj; &#125; 7.优化搜索系统需要优化的点： 查询规格参数部分可以添加缓存 聚合计算interval变化频率极低，所以可以设计为定时任务计算（周期为天），然后缓存起来。 elasticsearch本身有查询缓存，可以不进行优化 商品图片应该采用缩略图，减少流量，提高页面加载速度 图片采用延迟加载 图片还可以采用CDN服务器 sku信息应该在页面异步加载，而不是放到索引库]]></content>
      <categories>
        <category>项目实战-微服务商城</category>
        <category>Elasticsearch</category>
      </categories>
      <tags>
        <tag>Elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务商城（十一）——Elasticsearch安装及介绍二]]></title>
    <url>%2Fday11-elasticsearch2.html</url>
    <content type="text"><![CDATA[0.学习目标 独立编写数据导入功能 独立实现基本搜索 独立实现页面分页 独立实现结果排序 1.索引库数据导入昨天我们学习了Elasticsearch的基本应用。今天就学以致用，搭建搜索微服务，实现搜索功能。 1.1.创建搜索服务创建module： Pom文件： 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;leyou&lt;/artifactId&gt; &lt;groupId&gt;com.leyou.parent&lt;/groupId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.search&lt;/groupId&gt; &lt;artifactId&gt;leyou-search&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;!-- web --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- elasticsearch --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-elasticsearch&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- eureka --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- feign --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.leyou.service&lt;/groupId&gt; &lt;artifactId&gt;ly-item-interface&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; application.yml： 1234567891011121314151617181920server: port: 8083spring: application: name: search-service data: elasticsearch: cluster-name: elasticsearch cluster-nodes: 192.168.25.128:9300eureka: client: service-url: defaultZone: http://127.0.0.1:10086/eureka registry-fetch-interval-seconds: 5 #拉取5秒 instance: lease-renewal-interval-in-seconds: 5 # 每隔5秒发送一次心跳 lease-expiration-duration-in-seconds: 10 # 10秒不发送就过期 prefer-ip-address: true ip-address: 127.0.0.1 instance-id: $&#123;spring.application.name&#125;:$&#123;server.port&#125; 启动类： 123456789@SpringBootApplication@EnableDiscoveryClient@EnableFeignClientspublic class LySearchService &#123; public static void main(String[] args) &#123; SpringApplication.run(LySearchService.class, args); &#125;&#125; 1.2.索引库数据格式分析接下来，我们需要商品数据导入索引库，便于用户搜索。 那么问题来了，我们有SPU和SKU，到底如何保存到索引库？ 1.2.1.以结果为导向大家来看下搜索结果页： 可以看到，每一个搜索结果都有至少1个商品，当我们选择大图下方的小图，商品会跟着变化。 因此，搜索的结果是SPU，即多个SKU的集合。 既然搜索的结果是SPU，那么我们索引库中存储的应该也是SPU，但是却需要包含SKU的信息。 1.2.2.需要什么数据再来看看页面中有什么数据： 直观能看到的：图片、价格、标题、副标题属于sku的数据（用来展示的数据） 暗藏的数据：spu的id，sku的id 另外，页面还有过滤条件： 这些过滤条件也都需要存储到索引库中，包括： 商品分类、品牌、可用来搜索的规格参数等 综上所述，我们需要的数据格式有： spuId、SkuId、商品分类id、品牌id、图片、价格、商品的创建时间、sku信息集、可搜索的规格参数 1.2.3.最终的数据结构我们创建一个类，封装要保存到索引库的数据，并设置映射属性： 123456789101112131415161718@Document(indexName = "goods", type = "docs", shards = 1, replicas = 0)public class Goods &#123; @Id private Long id; // spuId @Field(type = FieldType.Text, analyzer = "ik_max_word") private String all; // 所有需要被搜索的信息，包含标题，分类，甚至品牌 @Field(type = FieldType.keyword, index = false) private String subTitle;// 卖点 private Long brandId;// 品牌id private Long cid1;// 1级分类id private Long cid2;// 2级分类id private Long cid3;// 3级分类id private Date createTime;// 创建时间 private List&lt;Long&gt; price;// 价格 @Field(type = FieldType.keyword, index = false) private String skus;// sku信息的json结构 private Map&lt;String, Object&gt; specs;// 可搜索的规格参数，key是参数名，值是参数值&#125; 一些特殊字段解释： all：用来进行全文检索的字段，里面包含标题、商品分类信息 price：价格数组，是所有sku的价格集合。方便根据价格进行筛选过滤 skus：用于页面展示的sku信息，不索引，不搜索。包含skuId、image、price、title字段 specs：所有规格参数的集合。key是参数名，值是参数值。 例如：我们在specs中存储 内存：4G,6G，颜色为红色，转为json就是： 123456&#123; "specs":&#123; "内存":[4G,6G], "颜色":"红色" &#125;&#125; 当存储到索引库时，elasticsearch会处理为两个字段： specs.内存：[4G,6G] specs.颜色：红色 另外， 对于字符串类型，还会额外存储一个字段，这个字段不会分词，用作聚合。 specs.颜色.keyword：红色 1.3.商品微服务提供接口索引库中的数据来自于数据库，我们不能直接去查询商品的数据库，因为真实开发中，每个微服务都是相互独立的，包括数据库也是一样。所以我们只能调用商品微服务提供的接口服务。 先思考我们需要的数据： SPU信息 SKU信息 SPU的详情 商品分类名称（拼接all字段） 规格参数key 品牌 再思考我们需要哪些服务： 第一：分批查询spu的服务，已经写过。 第二：根据spuId查询sku的服务，已经写过 第三：根据spuId查询SpuDetail的服务，已经写过 第四：根据商品分类id，查询商品分类名称，没写过 第五：根据商品品牌id，查询商品的品牌，没写过 因此我们需要额外提供一个查询商品分类名称的接口。 1.3.1.商品分类，品牌查询 商品分类查询 CategoryController： 123456789/** * 根据ids集合查询商品分类 * @param ids * @return */@GetMapping("list/ids")public ResponseEntity&lt;List&lt;Category&gt;&gt; queryCategoryByIds(@RequestParam("ids")List&lt;Long&gt; ids)&#123; return ResponseEntity.ok(categoryService.queryByIds(ids));&#125; CategoryService 123456789101112/** * 根据ids集合查询商品分类 * @param ids * @return */public List&lt;Category&gt; queryByIds(List&lt;Long&gt; ids)&#123; List&lt;Category&gt; list = categoryMapper.selectByIdList(ids); if (CollectionUtils.isEmpty(list))&#123; throw new LyException(ExceptionEnums.CATEGORY_NOT_FOND); &#125; return list;&#125; 测试： 品牌查询 BrandController： 123456789/** * 根据id查询品牌 * @param id * @return */ @GetMapping("&#123;id&#125;")public ResponseEntity&lt;Brand&gt; queryBrandById(@PathVariable("id")Long id)&#123; return ResponseEntity.ok(brandService.queryById(id)); &#125; BrandService 123456789101112/** * 根据id查询品牌 * @param id * @return */public Brand queryById(Long id)&#123; Brand brand = brandMapper.selectByPrimaryKey(id); if (brand==null)&#123; throw new LyException(ExceptionEnums.BRAND_NOT_FOUND); &#125; return brand;&#125; 测试： 1.3.2.编写FeignClient（远程调用别的服务）1.3.2.1.普通问题展现操作leyou-search工程 现在，我们要在搜索微服务调用商品微服务的接口。 第一步要引入商品微服务依赖：ly-item-interface。 123456&lt;!--商品微服务--&gt;&lt;dependency&gt; &lt;groupId&gt;com.leyou.service&lt;/groupId&gt; &lt;artifactId&gt;ly-item-interface&lt;/artifactId&gt; &lt;version&gt;$&#123;leyou.latest.version&#125;&lt;/version&gt;&lt;/dependency&gt; 第二步，编写GoodsFeignClient 1234567891011121314151617181920212223242526272829303132333435@FeignClient("item-service")public interface GoodsClient &#123; /** * 根据spuid查询商品详情 * @param spuId * @return */ @GetMapping("spu/detail/&#123;id&#125;") public SpuDetail queryDetailBySpuId(@PathVariable("id")Long spuId); /** * 根据spuid查询sku * @param spuId * @return */ @GetMapping("sku/list") public List&lt;Sku&gt; querySkuByid(@RequestParam("id")Long spuId); /** * 分页查询商品信息 * @param page * @param rows * @param saleable * @param key * @return */ @GetMapping("spu/page") @ResponseBody public PageResult&lt;Spu&gt; querySpuByPage( @RequestParam(value = "page", defaultValue = "1") Integer page, @RequestParam(value = "rows", defaultValue = "5") Integer rows, @RequestParam(value = "saleable", required = false) Boolean saleable, @RequestParam(value = "key", required = false) String key);&#125; 第三步，编写CategoryFeignClient 123456789101112@FeignClient("item-service")public interface CategoryClient &#123; /** * 根据ids集合查询商品分类 * 不写实现直接写接口 * @param ids * @return */ @GetMapping("category/list/ids") List&lt;Category&gt; queryCategoryByIds(@RequestParam("ids")List&lt;Long&gt; ids);&#125; 以上的这些代码直接从商品微服务中拷贝而来，完全一致。差别就是没有方法的具体实现。大家觉得这样有没有问题？ 而FeignClient代码遵循SpringMVC的风格，因此与商品微服务的Controller完全一致。这样就存在一定的问题： 代码冗余。尽管不用写实现，只是写接口，但服务调用方要写与服务controller一致的代码，有几个消费者就要写几次。 增加开发成本。调用方还得清楚知道接口的路径，才能编写正确的FeignClient。 1.3.2.2.（优化）解决方案因此，一种比较友好的实践是这样的： 我们的服务提供方不仅提供实体类，还要提供api接口声明 调用方不用字自己编写接口方法声明，直接继承提供方给的Api接口即可， 第一步：服务的提供方在ly-item-interface中提供API接口，并编写接口声明： 商品分类服务接口：CategoryAPI 12345678910public interface CategoryAPI &#123; /** * 根据ids集合查询商品分类 * 不写实现直接写接口 * @param ids * @return */ @GetMapping("category/list/ids") List&lt;Category&gt; queryCategoryByIds(@RequestParam("ids")List&lt;Long&gt; ids);&#125; 商品服务接口：GoodsAPI 12345678910111213141516171819202122232425262728293031323334public interface GoodsAPI &#123; /** * 根据spuid查询商品详情 * @param spuId * @return */ @GetMapping("spu/detail/&#123;id&#125;") public SpuDetail queryDetailBySpuId(@PathVariable("id")Long spuId); /** * 根据spuid查询sku * @param spuId * @return */ @GetMapping("sku/list") public List&lt;Sku&gt; querySkuByid(@RequestParam("id")Long spuId); /** * 分页查询商品信息 * @param page * @param rows * @param saleable * @param key * @return */ @GetMapping("spu/page") @ResponseBody public PageResult&lt;Spu&gt; querySpuByPage( @RequestParam(value = "page", defaultValue = "1") Integer page, @RequestParam(value = "rows", defaultValue = "5") Integer rows, @RequestParam(value = "saleable", required = false) Boolean saleable, @RequestParam(value = "key", required = false) String key);&#125; 品牌服务接口：BrandAPI 123456789public interface BrandAPI &#123; /** * 根据id查询品牌 * @param id * @return */ @GetMapping("brand/&#123;id&#125;") public Brand queryBrandById(@PathVariable("id")Long id);&#125; 商品详情接口：SpecificationAPI 12345678910111213141516171819public interface SpecificationAPI &#123; /** * 通过规格组的gid查询规格参数 * 通过商品分类cid查询规格参数 * required=false：表示不传值的时候给null * @param gid 规格组id * @param cid 商品分类id * @param searching 是否用于搜索关键字 * @param generic 是否是sku通用属性 * @return */ @GetMapping("spec/params") List&lt;SpecParam&gt; queryParamByList( @RequestParam(value = "gid",required = false) Long gid, @RequestParam(value = "cid",required = false)Long cid, @RequestParam(value = "searching",required = false)Boolean searching, @RequestParam(value="generic", required = false) Boolean generic );&#125; 需要引入springMVC及ly-common的依赖： 123456789101112131415161718192021222324252627&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper-core&lt;/artifactId&gt; &lt;version&gt;1.0.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.7&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;5.1.0.RC3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;5.1.0.RC3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.leyou.common&lt;/groupId&gt; &lt;artifactId&gt;ly-common&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 第二步：在调用方ly-search中编写FeignClient，但不要写方法声明了，直接继承ly-item-interface提供的api接口： 商品的FeignClient：GoodsClient 123@FeignClient(value = "item-service")public interface GoodsClient extends GoodsApi &#123;&#125; 商品分类的FeignClient：CategoryClient 123@FeignClient(value = "item-service")public interface CategoryClient extends CategoryApi &#123;&#125; 品牌的FeignClient：BrandClient 1234@FeignClient("item-service")public interface BrandClient extends BrandAPI&#123;&#125; 商品详情FeignClient：SpecificationClient 1234@FeignClient(&quot;item-service&quot;)public interface SpecificationClient extends SpecificationAPI&#123;&#125; 是不是简单多了？ 项目结构： 1.3.2.3.测试在leyou-search中引入springtest依赖： 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 创建测试类： 在接口上按快捷键：Ctrl + Shift + T 测试代码： 12345678910111213@RunWith(SpringRunner.class)@SpringBootTest(classes = LeyouSearchApplication.class)public class CategoryClientTest &#123; @Autowired private CategoryClient categoryClient; @Test public void testQueryCategories() &#123; List&lt;String&gt; names = this.categoryClient.queryNameByIds(Arrays.asList(1L, 2L, 3L)); names.forEach(System.out::println); &#125;&#125; 结果： 1.4.导入数据导入数据只做一次,以后的更新删除等操作通过消息队列来操作索引库 1.4.1.创建GoodsRepository在ly-search中创建 java代码： 12public interface GoodsRepository extends ElasticsearchRepository&lt;Goods, Long&gt; &#123;&#125; 1.4.2.创建索引我们新建一个测试类，在里面进行数据的操作： 1234567891011121314@RunWith(SpringRunner.class)@SpringBootTestpublic class GoodsRepositoryTest &#123; @Autowired private GoodsRepository goodsRepository; @Autowired private ElasticsearchTemplate elasticsearchTemplate; @Test public void testCreateIndex()&#123; elasticsearchTemplate.createIndex(Goods.class); elasticsearchTemplate.putMapping(Goods.class); &#125;&#125; 通过kibana查看： 1.4.3.导入数据导入数据其实就是查询数据，然后把查询到的Spu转变为Goods来保存，因此我们先编写一个SearchService，然后在里面定义一个方法， 把Spu转为Goods 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798/** * @version V1.0 * @ClassName:$&#123;file_name&#125; * @Description:把查询到的Spu转变为Goods来保存 * @author:cxg * @Date:$&#123;time&#125; */@Servicepublic class SearchService &#123; @Autowired private GoodsClient goodsClient; @Autowired private SpecificationClient specificationClient; @Autowired private CategoryClient categoryClient; @Autowired private BrandClient brandClient; public Goods buildGoods(Spu spu) &#123; //1.查询分类 List&lt;Category&gt; categories = categoryClient.queryCategoryByIds(Arrays.asList(spu.getCid1(), spu.getCid2(), spu.getCid3())); //1.1.获取到分类的名字(查询集合的时候这样用) List&lt;String&gt; categoryName = categories.stream().map(Category::getName).collect(Collectors.toList()); //2.查询品牌 Brand brand = brandClient.queryBrandById(spu.getBrandId()); //3.搜索字段 String all = spu.getTitle()+ StringUtils.join(categoryName," ")+brand.getName(); //4.查询sku List&lt;Sku&gt; skuList = goodsClient.querySkuByid(spu.getId()); //4.1.处理sku List&lt;Map&lt;String, Object&gt;&gt; skus = new ArrayList&lt;&gt;(); //4.2.处理价格 List&lt;Long&gt; priceList=new ArrayList&lt;&gt;(); for (Sku sku : skuList) &#123; Map&lt;String,Object&gt; map=new HashMap&lt;&gt;(); map.put("id",sku.getId()); map.put("title",sku.getTitle()); map.put("price",sku.getPrice()); map.put("images",StringUtils.substringBefore(sku.getImages(),","));//截取逗号之前的第一个 skus.add(map); priceList.add(sku.getPrice()); &#125; //5.商品规格 //5.1.查询规格参数 List&lt;SpecParam&gt; params = specificationClient.queryParamByList(null, spu.getCid3(), true, null); //6.商品详情 SpuDetail spuDetail = goodsClient.queryDetailBySpuId(spu.getId()); //6.1.获取通用规格参数（参数类型为：Map&lt;String, String&gt;） String jsonGeneric = spuDetail.getGenericSpec(); Map&lt;Long, String&gt; genericSpec = JsonUtils.toMap(jsonGeneric, Long.class, String.class); //6.2.获取特有规格参数 (参数类型为： Map&lt;String, List&lt;String&gt;&gt;这种类型) String jsonSpecial=spuDetail.getSpecialSpec(); Map&lt;Long, List&lt;String&gt;&gt; specialSpec = JsonUtils.nativeRead(jsonSpecial, new TypeReference&lt;Map&lt;Long, List&lt;String&gt;&gt;&gt;() &#123; &#125;); //6.3.规格参数，key是规格参数的名字，值是规格参数的值 Map&lt;String,Object&gt; specs=new HashMap&lt;&gt;(); for (SpecParam param : params) &#123; //规格名称 String key = param.getName(); Object value=""; //判断是否通用规格参数 if(param.getGeneric())&#123; value=genericSpec.get(param.getId()); if (param.getNumeric())&#123; //调用chooseSegment方法 value=chooseSegment(value.toString(),param); &#125; &#125; else &#123; value=specialSpec.get(param.getId()); &#125; //存入Map中 specs.put(key,value); &#125; Goods goods = new Goods(); goods.setId(spu.getId()); goods.setSubTitle(spu.getSubTitle()); goods.setBrandId(spu.getBrandId()); goods.setCid1(spu.getCid1()); goods.setCid2(spu.getCid2()); goods.setCid3(spu.getCid3()); goods.setCreateTime(spu.getCreateTime()); goods.setAll(all); // TODO 搜索字段，包含标题，分类，品牌 ，规格 goods.setPrice(priceList); // TODO 所有sku的价格集合 goods.setSkus(JsonUtils.toString(skus)); //TODO 所有sku的集合的json goods.setSpecs(specs); //TODO 所有的可搜索的规格参数 return goods; &#125; &#125; 因为过滤参数中有一类比较特殊，就是数值区间： 所以我们在存入时要进行处理： 123456789101112131415161718192021222324252627282930313233 /** * 将下面进行分段 * 0-500,500-1000,1000-1500,1500-2000,2500- * @param value * @param p * @return */private String chooseSegment(String value, SpecParam p) &#123; double val = NumberUtils.toDouble(value); String result = "其它"; // 保存数值段 for (String segment : p.getSegments().split(",")) &#123; String[] segs = segment.split("-"); // 获取数值范围 double begin = NumberUtils.toDouble(segs[0]); double end = Double.MAX_VALUE; if(segs.length == 2)&#123; end = NumberUtils.toDouble(segs[1]); &#125; // 判断是否在范围内 if(val &gt;= begin &amp;&amp; val &lt; end)&#123; if(segs.length == 1)&#123; result = segs[0] + p.getUnit() + "以上"; &#125;else if(begin == 0)&#123; result = segs[1] + p.getUnit() + "以下"; &#125;else&#123; result = segment + p.getUnit(); &#125; break; &#125; &#125; return result;&#125; 然后编写一个测试类，循环查询Spu，然后调用IndexService中的方法，把SPU变为Goods，然后写入索引库： 123456789101112131415161718192021222324252627282930@Testpublic void loadData()&#123; // 创建索引 this.elasticsearchTemplate.createIndex(Goods.class); // 配置映射 this.elasticsearchTemplate.putMapping(Goods.class); int page = 1; int rows = 100; int size = 0; do &#123; // 查询分页数据 PageResult&lt;SpuBo&gt; result = this.goodsClient.querySpuByPage(page, rows, true, null); List&lt;SpuBo&gt; spus = result.getItems(); size = spus.size(); // 创建Goods集合 List&lt;Goods&gt; goodsList = new ArrayList&lt;&gt;(); // 遍历spu for (SpuBo spu : spus) &#123; try &#123; Goods goods = this.searchService.buildGoods(spu); goodsList.add(goods); &#125; catch (Exception e) &#123; break; &#125; &#125; this.goodsRepository.saveAll(goodsList); page++; &#125; while (size == 100);&#125; 通过kibana查询， 可以看到数据成功导入： 2.实现基本搜索2.1.页面分析2.1.1.页面跳转在首页的顶部，有一个输入框： 当我们输入任何文本，点击搜索，就会跳转到搜索页search.html了： 并且将搜索关键字以请求参数携带过来： 我们打开search.html，在最下面会有提前定义好的Vue实例： 1234567891011&lt;script type="text/javascript"&gt; var vm = new Vue(&#123; el: "#searchApp", data: &#123; &#125;, components:&#123; // 加载页面顶部组件 lyTop: () =&gt; import("./js/pages/top.js") &#125; &#125;);&lt;/script&gt; 这个Vue实例中，通过import导入的方式，加载了另外一个js：top.js并作为一个局部组件。top其实是页面顶部导航组件，我们暂时不管 2.1.2.发起异步请求要想在页面加载后，就展示出搜索结果。我们应该在页面加载时，获取地址栏请求参数，并发起异步请求，查询后台数据，然后在页面渲染。 我们在data中定义一个对象，记录请求的参数： 12345data: &#123; search:&#123; key:"", // 搜索页面的关键字 &#125;&#125; 我们通过钩子函数created，在页面加载时获取请求参数，并记录下来。 12345678910111213created()&#123; // 判断是否有请求参数 if(!location.search)&#123; return; &#125; // 将请求参数转为对象 const search = ly.parse(location.search.substring(1)); // 记录在data的search对象中 this.search = search; // 发起请求，根据条件搜索 this.loadData();&#125; 然后发起请求，搜索数据。 12345678methods: &#123; loadData()&#123; // ly.http.post("/search/page", ly.stringify(this.search)).then(resp=&gt;&#123; ly.http.post("/search/page", this.search).then(resp=&gt;&#123; console.log(resp); &#125;); &#125;&#125; 我们这里使用ly是common.js中定义的工具对象。 这里使用的是post请求，这样可以携带更多参数，并且以json格式发送 在leyou-gateway中，添加允许信任域名： 并添加网关映射： 刷新页面试试： 因为后台没有提供接口，所以无法访问。没关系，接下来我们实现后台接口 2.2.后台提供搜索接口2.2.1.controller首先分析几个问题： 请求方式：Post 请求路径：/search/page，不过前面的/search应该是网关的映射路径，因此真实映射路径page，代表分页查询 请求参数：json格式，目前只有一个属性：key-搜索关键字，但是搜索结果页一定是带有分页查询的，所以将来肯定会有page属性，因此我们可以用一个对象来接收请求的json数据： 1234567891011121314151617181920212223242526272829303132public class SearchRequest &#123; private String key;// 搜索条件 private Integer page;// 当前页 private static final Integer DEFAULT_SIZE = 20;// 每页大小，不从页面接收，而是固定大小 private static final Integer DEFAULT_PAGE = 1;// 默认页 public String getKey() &#123; return key; &#125; public void setKey(String key) &#123; this.key = key; &#125; public Integer getPage() &#123; if(page == null)&#123; return DEFAULT_PAGE; &#125; // 获取页码时做一些校验，不能小于1 return Math.max(DEFAULT_PAGE, page); &#125; public void setPage(Integer page) &#123; this.page = page; &#125; public Integer getSize() &#123; return DEFAULT_SIZE; &#125;&#125; 返回结果：作为分页结果，一般都两个属性：当前页数据、总条数信息，我们可以使用之前定义的PageResult类 代码： 12345678@RestControllerpublic class SearchController &#123; @Autowired private SearchService searchService; @PostMapping("page") public ResponseEntity&lt;PageResult&lt;Goods&gt;&gt; search(@RequestBody SearchRequest request) &#123; return ResponseEntity.ok(searchService.search(request)); &#125; 2.2.2.service123456789101112131415161718192021222324252627282930public PageResult&lt;Goods&gt; search(SearchRequest request) &#123; int page=request.getPage()-1; int size = request.getSize(); //创建查询构建器 NativeSearchQueryBuilder queryBuilder = new NativeSearchQueryBuilder(); //结果过滤 queryBuilder.withSourceFilter(new FetchSourceFilter(new String[]&#123;"id","skus","subTitle"&#125;,null)); //分页 queryBuilder.withPageable(PageRequest.of(page,size)); //排序 String sortBy=request.getSortBy(); Boolean desc = request.getDescending(); if (StringUtils.isNotBlank(sortBy))&#123; queryBuilder.withSort(SortBuilders.fieldSort(sortBy).order(desc ? SortOrder.DESC : SortOrder.ASC)); &#125; //过滤 queryBuilder.withQuery(QueryBuilders.matchQuery("all",request.getKey())); //查询 Page&lt;Goods&gt; search = goodsRepository.search(queryBuilder.build()); //解析结果 long total = search.getTotalElements();//总条数 long totalPages =(total/size)+1;//总页数 List&lt;Goods&gt; goodsList = search.getContent();//当前页结果 return new PageResult&lt;&gt;(total,(long)totalPages,goodsList); &#125; 注意点：我们要设置SourceFilter，来选择要返回的结果，否则返回一堆没用的数据，影响查询效率。 2.2.3.测试刷新页面测试： 数据是查到了，但是因为我们只查询部分字段，所以结果json 数据中有很多null，这很不优雅。 解决办法很简单，在leyou-search的application.yml中添加一行配置，json处理时忽略空值： 123spring: jackson: default-property-inclusion: non_null # 配置json处理时忽略空值 结果： 2.3.页面渲染页面已经拿到了结果，接下来就要渲染样式了。在leyou-portal中的search.html中 2.3.1.保存搜索结果首先，在data中定义属性，保存搜索的结果： 在loadData的异步查询中，将结果赋值给goodsList： 2.3.2.循环展示商品在search.html的中部，有一个div，用来展示所有搜索到的商品： 可以看到，div中有一个无序列表ul，内部的每一个li就是一个商品spu了。 我们删除多余的，只保留一个li，然后利用vue的循环来展示搜索到的结果： 2.3.3.多sku展示2.3.3.1.分析接下来展示具体的商品信息，来看图： 这里我们可以发现，一个商品位置，是多个sku的信息集合。当用户鼠标选择某个sku，对应的图片、价格、标题会随之改变！ 我们先来实现sku的选择，才能去展示不同sku的数据。 可以看到，在列表中默认第一个是被选中的，那我们就需要做两件事情： 在搜索到数据时，先默认把第一个sku作为被选中的，记录下来 记录当前被选中的是哪一个sku，记录在哪里比较合适呢？显然是遍历到的goods对象自己内部，因为每一个goods都会有自己的sku信息。 2.3.3.2.初始化sku查询出的结果集skus是一个json类型的字符串，不是js对象 我们在查询成功的回调函数中，对goods进行遍历，把skus转化成对象，并添加一个selected属性保存被选中的sku： 2.3.3.3.多sku图片列表接下来，我们看看多个sku的图片列表位置： 看到又是一个无序列表，这里我们也一样删掉多余的，保留一个li，需要注意选中的项有一个样式类：selected 我们的代码： 12345678910&lt;!--展示图片有bug，什么时候出现bug？当一个sku有多个图片时--&gt;&lt;!--实际后台传的是images--&gt;&lt;img :src=&quot;goods.selected.images&quot; height=&quot;200&quot;/&gt;&lt;/a&gt;&lt;!--多sku图片列表--&gt;&lt;ul class=&quot;skus&quot;&gt; &lt;li :class=&quot;&#123;selected: sku.id == goods.selected.id&#125;&quot; v-for=&quot;sku in goods.skus&quot; :key=&quot;sku.id&quot; @mouseEnter=&quot;goods.selected=sku&quot;&gt; &lt;img :src=&quot;sku.images&quot;&gt; &lt;/li&gt;&lt;/ul&gt; 注意： class样式通过 goods.selected的id是否与当前sku的id一致来判断 绑定了鼠标事件，鼠标进入后把当前sku赋值到goods.selected 2.3.4.展示sku其它属性现在，我们已经可以通过goods.selected获取用户选中的sku，那么我们就可以在页面展示了： 刷新页面： 看起来很完美是吧！ 但其实有一些瑕疵 2.3.5.几个问题2.3.5.1.价格显示的是分首先价格显示就不正确，我们数据库中存放的是以分为单位，所以这里要格式化。 好在我们之前common.js中定义了工具类，可以帮我们转换。 改造： 结果报错： 为啥？ 因为在Vue范围内使用任何变量，都会默认去Vue实例中寻找，我们使用ly，但是Vue实例中没有这个变量。所以解决办法就是把ly记录到Vue实例： 然后刷新页面： 2.3.5.2.标题过长标题内容太长了，已经无法完全显示，怎么办？ 截取一下： 最好在加个悬停展示所有内容的效果 2.3.5.3.sku点击不切换还有一个错误比较隐蔽，不容易被发现。我们点击sku 的图片列表，发现没有任何变化。 这不科学啊，为什么？ 通过控制台观察，发现数据其实是变化了，但是Vue却没有重新渲染视图。 这是因为Vue的自动渲染是基于对象的属性变化的。比如页面使用GoodsList进行渲染，如果GoodsList变化，或者其内部的任何子对象变化，都会Vue感知，从而从新渲染页面。 然而，这一切有一个前提，那就是当你第一次渲染时，对象中有哪些属性，Vue就只监视这些属性，后来添加的属性发生改变，是不会被监视到的。 而我们的goods对象中，本身是没有selected属性的，是我们后来才添加进去的： 这段代码稍微改造一下，即可： 也就是说，我们先把selected属性初始化完毕，然后才把整个对象赋值给goodsList，这样，goodsList已初始化时就有selected属性，以后就会被正常监控了。 3.页面分页效果刚才的查询中，我们默认了查询的页码和每页大小，因此所有的分页功能都无法使用，接下来我们一起看看分页功能条该如何制作。 这里要分两步， 第一步：如何生成分页条 第二步：点击分页按钮，我们做什么 3.1.如何生成分页条先看下页面关于分页部分的代码： 3.1.1.需要的数据分页数据应该是根据总页数、当前页、总条数等信息来计算得出。 当前页：肯定是由页面来决定的，点击按钮会切换到对应的页 总页数：需要后台传递给我们 总条数：需要后台传递给我们 我们首先在data中记录下这几个值：page-当前页，total-总条数，totalPage-总页数 12345678910data: &#123; ly, search:&#123; key: "", page: 1 &#125;, goodsList:[], // 接收搜索得到的结果 total: 0, // 总条数 totalPage: 0 // 总页数&#125; 因为page是搜索条件之一，所以记录在search对象中。 要注意：我们在created钩子函数中，会读取url路径的参数，然后赋值给search。如果是第一次请求页面，page是不存在的。因此为了避免page被覆盖，我们应该这么做： 不过，这个时候我们自己的search对象中的值就可有可无了 3.1.2.后台提供数据后台返回的结果中，要包含total和totalPage，我们改造下刚才的接口： 在我们返回的PageResult对象中，其实是有totalPage字段的： 页面测试一下： OK 3.1.3.页面计算分页条首先，把后台提供的数据保存在data中： 然后看下我们要实现的效果： 这里最复杂的是中间的1~5的分页按钮，它需要动态变化。 思路分析： 最多有5个按钮，因此我们可以用v-for循环从1到5即可 但是分页条不一定是从1开始： 如果当前页值小于等于3的时候，分页条位置从1开始到5结束 如果总页数小于等于5的时候，分页条位置从1开始到5结束 如果当前页码大于3，应该从page-3开始 但是如果当前页码大于totalPage-3，应该从totalPage-5开始 所以，我们的页面这样来做： a标签中的分页数字通过index函数来计算，需要把i传递过去： 1234567891011index(i)&#123; if(this.search.page &lt;= 3 || this.totalPage &lt;= 5)&#123; // 如果当前页小于等于3或者总页数小于等于5 return i; &#125; else if(this.search.page &gt; 3) &#123; // 如果当前页大于3 return this.search.page - 3 + i; &#125; else &#123; return this.totalPage - 5 + i; &#125;&#125; 需要注意的是，如果总页数不足5页，我们就不应该遍历1~5，而是1~总页数，稍作改进： 分页条的其它部分就比较简单了： 12345678910111213141516171819202122&lt;div class=&quot;sui-pagination pagination-large&quot;&gt; &lt;ul style=&quot;width: 550px&quot;&gt; &lt;li :class=&quot;&#123;prev:true,disabled:search.page === 1&#125;&quot;&gt; &lt;a href=&quot;#&quot;&gt;«上一页&lt;/a&gt; &lt;/li&gt; &lt;li :class=&quot;&#123;active: index(i) === search.page&#125;&quot; v-for=&quot;i in Math.min(5,totalPage)&quot; :key=&quot;i&quot;&gt; &lt;a href=&quot;#&quot;&gt;&#123;&#123;index(i)&#125;&#125;&lt;/a&gt; &lt;/li&gt; &lt;li class=&quot;dotted&quot; v-show=&quot;totalPage &gt; 5&quot;&gt;&lt;span&gt;...&lt;/span&gt;&lt;/li&gt; &lt;li :class=&quot;&#123;next:true,disabled:search.page === totalPage&#125;&quot;&gt; &lt;a href=&quot;#&quot;&gt;下一页»&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;div&gt; &lt;span&gt;共&#123;&#123;totalPage&#125;&#125;页&amp;nbsp;&lt;/span&gt; &lt;span&gt; 到第 &lt;input type=&quot;text&quot; class=&quot;page-num&quot; :value=&quot;search.page&quot;&gt; 页 &lt;button class=&quot;page-confirm&quot; onclick=&quot;alert(1)&quot;&gt;确定&lt;/button&gt; &lt;/span&gt; &lt;/div&gt;&lt;/div&gt; 3.1.4.页面跳转 在methon中编写方法newPage 3.2.点击分页做什么点击分页按钮后，自然是要修改page的值 所以，我们在上一页、下一页按钮添加点击事件，对page进行修改，在数字按钮上绑定点击事件，点击直接修改page： 12345678910prevPage()&#123; if(this.search.page &gt; 1)&#123; this.search.page-- &#125;&#125;,nextPage()&#123; if(this.search.page &lt; this.totalPage)&#123; this.search.page++ &#125;&#125; 当page发生变化，我们应该去后台重新查询数据。 不过，如果我们直接发起ajax请求，那么浏览器的地址栏中是不会有变化的，没有记录下分页信息。如果用户刷新页面，那么就会回到第一页。 这样不太友好，我们应该把搜索条件记录在地址栏的查询参数中。 因此，我们监听search的变化，然后把search的过滤字段拼接在url路径后： 123456789watch:&#123; search:&#123; deep:true, handler(val)&#123; // 把search对象变成请求参数，拼接在url路径 window.location.href = "http://www.leyou.com/search.html?" + ly.stringify(val); &#125; &#125;&#125;, 刷新页面测试，然后就出现重大bug：页面无限刷新！为什么？ 因为Vue实例初始化的钩子函数中，我们读取请求参数，赋值给search的时候，也触发了watch监视！也就是说，每次页面创建完成，都会触发watch，然后就会去修改window.location路径，然后页面被刷新，再次触发created钩子，又触发watch，周而复始，无限循环。 所以，我们需要在watch中进行监控，如果发现是第一次初始化，则不继续向下执行。 那么问题是，如何判断是不是第一次？ 第一次初始化时，search中的key值肯定是空的，所以，我们这么做： 12345678910111213watch:&#123; search:&#123; deep:true, handler(val,old)&#123; if(!old || !old.key)&#123; // 如果旧的search值为空，或者search中的key为空，证明是第一次 return; &#125; // 把search对象变成请求参数，拼接在url路径 window.location.href = "http://www.leyou.com/search.html?" + ly.stringify(val); &#125; &#125;&#125; 再次刷新，OK了！ 3.3.页面顶部分页条在页面商品列表的顶部，也有一个分页条： 我们把这一部分，也加上点击事件： 4.排序(作业)4.1.页面搜索排序条件在搜索商品列表的顶部，有这么一部分内容： 这是用来做排序的，默认按照综合排序。点击新品，应该按照商品创建时间排序，点击价格应该按照价格排序。因为我们没有统计销量和评价，这里咱们以新品和价格为例，进行讲解，做法是想通的。 排序需要知道两个内容： 排序的字段 排序的方式 因此，我们首先在search中记录这两个信息，因为created钩子函数会对search进行覆盖，因此我们在钩子函数中对这两个信息进行初始化即可： 然后，在页面上给按钮绑定点击事件，修改sortBy和descending的值： 1234567891011121314151617181920212223&lt;!--排序字段--&gt;&lt;ul class=&quot;sui-nav&quot;&gt; &lt;li :class=&quot;&#123;active:!search.sortBy&#125;&quot; @click=&quot;search.sortBy=&apos;&apos;&quot;&gt; &lt;a href=&quot;#&quot;&gt;综合&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;销量&lt;/a&gt; &lt;/li&gt; &lt;li @click=&quot;search.sortBy=&apos;createTime&apos;&quot; :class=&quot;&#123;active: search.sortBy===&apos;createTime&apos;&#125;&quot;&gt; &lt;a href=&quot;#&quot;&gt;新品&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;评价&lt;/a&gt; &lt;/li&gt; &lt;li @click=&quot;search.sortBy=&apos;price&apos;; search.descending = !search.descending&quot; :class=&quot;&#123;active: search.sortBy===&apos;price&apos;&#125;&quot;&gt; &lt;a href=&quot;#&quot;&gt; 价格 &lt;v-icon v-show=&quot;search.descending&quot;&gt;arrow_drop_down&lt;/v-icon&gt; &lt;v-icon v-show=&quot;!search.descending&quot;&gt;arrow_drop_up&lt;/v-icon&gt; &lt;/a&gt; &lt;/li&gt;&lt;/ul&gt; 可以看到，页面请求参数中已经有了排序字段了： 4.2.后台添加排序逻辑接下来，后台需要接收请求参数中的排序信息，然后在搜索中加入排序的逻辑。 现在，我们的请求参数对象SearchRequest中，只有page、key两个字段。需要进行扩展： 然后在搜索业务逻辑中，添加排序条件： 注意，因为我们存储在索引库中的的价格是一个数组，因此在按照价格排序时，会进行智能处理： 如果是价格降序，则会把数组中的最大值拿来排序 如果是价格升序，则会把数组中的最小值拿来排序 修改search.html中的searchFromServer方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748searchFromServer() &#123; ly.http.post("/search/page",this.search).then((resp) =&gt; &#123; resp.data.items.forEach(goods =&gt; &#123; let max = 0; let min = 0; //转换skus:把字符串转变为对象 goods.skus = JSON.parse(goods.skus); //添加默认选中项,如果按价格排序则选出skus中价格最低的或者最高的，否则选skus中的第一个 if (this.search.sortBy === "price")&#123; if (this.search.descending === true)&#123; //降序，则skus中价格选最高的 goods.skus.forEach(sku =&gt; &#123; if (sku.price &gt; max)&#123; max = sku.price; &#125; &#125;); goods.skus.forEach(sku =&gt; &#123; if (sku.price === max)&#123; goods.selected = sku; &#125; &#125;); &#125; else &#123; //升序，则skus中价格选最低的 min = goods.skus[0].price; goods.skus.forEach(sku =&gt; &#123; if (sku.price &lt; min)&#123; min = sku.price; &#125; &#125;); goods.skus.forEach(sku =&gt; &#123; if (sku.price === min)&#123; goods.selected = sku; &#125; &#125;); &#125; &#125; else &#123; goods.selected = goods.skus[0]; &#125; &#125;); this.goodsList = resp.data.items; this.total = resp.data.total; this.totalPage = resp.data.totalPage; &#125;); &#125;]]></content>
      <categories>
        <category>项目实战-微服务商城</category>
        <category>Elasticsearch</category>
      </categories>
      <tags>
        <tag>Elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务商城（十一）——Elasticsearch安装及介绍一]]></title>
    <url>%2Fday10-elasticsearch.html</url>
    <content type="text"><![CDATA[独立安装Elasticsearch 会使用Rest的API操作索引 会使用Rest的API查询数据 会使用Rest的API聚合数据 掌握Spring Data Elasticsearch使用 1.Elasticsearch介绍和安装用户访问我们的首页，一般都会直接搜索来寻找自己想要购买的商品。 而商品的数量非常多，而且分类繁杂。如果能正确的显示出用户想要的商品，并进行合理的过滤，尽快促成交易，是搜索系统要研究的核心。 面对这样复杂的搜索业务和数据量，使用传统数据库搜索就显得力不从心，一般我们都会使用全文检索技术，比如之前大家学习过的Solr。 不过今天，我们要讲的是另一个全文检索技术：Elasticsearch。 1.1.简介1.1.1.ElasticElastic官网：https://www.elastic.co/cn/ Elastic有一条完整的产品线及解决方案：Elasticsearch、Kibana、Logstash等，前面说的三个就是大家常说的ELK技术栈。 1.1.2.ElasticsearchElasticsearch官网：https://www.elastic.co/cn/products/elasticsearch 如上所述，Elasticsearch具备以下特点： 分布式，无需人工搭建集群（solr就需要人为配置，使用Zookeeper作为注册中心） Restful风格，一切API都遵循Rest原则，容易上手 近实时搜索，数据更新在Elasticsearch中几乎是完全同步的。 1.1.3.版本目前Elasticsearch最新的版本是6.3.1，我们就使用6.3.0 需要虚拟机JDK1.8及以上 1.2.安装和配置为了模拟真实场景，我们将在linux下安装Elasticsearch。 1.2.1.新建一个用户leyou出于安全考虑，elasticsearch默认不允许以root账号运行。 创建用户： 1useradd leyou 设置密码： 1passwd leyou 设置权限： 123将ElasticSearch的权限改成leyou的[root@localhost leyou]# chown leyou:leyou elasticsearch/ -R 切换用户： 1su - leyou 1.2.2.上传安装包,并解压我们将安装包上传到：/home/leyou目录 解压缩： 1tar -zxvf elasticsearch-6.3.0.tar.gz 我们把目录重命名： 1mv elasticsearch-6.3.0/ elasticsearch 进入，查看目录结构： 1.2.3.修改配置我们进入config目录：cd config 需要修改的配置文件有两个： jvm.options Elasticsearch基于Lucene的，而Lucene底层是java实现，因此我们需要配置jvm参数。 编辑jvm.options： 1vim jvm.options 默认配置如下： 12-Xms1g-Xmx1g 内存占用太多了，我们调小一些： 12-Xms512m-Xmx512m elasticsearch.yml 1vim elasticsearch.yml 修改数据和日志目录： 12path.data: /home/leyou/elasticsearch/data # 数据目录位置path.logs: /home/leyou/elasticsearch/logs # 日志目录位置 我们把data和logs目录修改指向了elasticsearch的安装目录。但是这两个目录并不存在，因此我们需要创建出来。 进入elasticsearch的根目录，然后创建： 12mkdir datamkdir logs 修改绑定的ip： 1network.host: 0.0.0.0 # 绑定到0.0.0.0，允许任何ip来访问 默认只允许本机访问，修改为0.0.0.0后则可以远程访问 目前我们是做的单机安装，如果要做集群，只需要在这个配置文件中添加其它节点信息即可。 elasticsearch.yml的其它可配置信息： 属性名 说明 cluster.name 配置elasticsearch的集群名称，默认是elasticsearch。建议修改成一个有意义的名称。 node.name 节点名，es会默认随机指定一个名字，建议指定一个有意义的名称，方便管理 path.conf 设置配置文件的存储路径，tar或zip包安装默认在es根目录下的config文件夹，rpm安装默认在/etc/ elasticsearch path.data 设置索引数据的存储路径，默认是es根目录下的data文件夹，可以设置多个存储路径，用逗号隔开 path.logs 设置日志文件的存储路径，默认是es根目录下的logs文件夹 path.plugins 设置插件的存放路径，默认是es根目录下的plugins文件夹 bootstrap.memory_lock 设置为true可以锁住ES使用的内存，避免内存进行swap network.host 设置bind_host和publish_host，设置为0.0.0.0允许外网访问 http.port 设置对外服务的http端口，默认为9200。 transport.tcp.port 集群结点之间通信端口 discovery.zen.ping.timeout 设置ES自动发现节点连接超时的时间，默认为3秒，如果网络延迟高可设置大些 discovery.zen.minimum_master_nodes 主结点数量的最少值 ,此值的公式为：(master_eligible_nodes / 2) + 1 ，比如：有3个符合要求的主结点，那么这里要设置为2 1.3.运行进入elasticsearch/bin目录，可以看到下面的执行文件： 然后输入命令： 1./elasticsearch 发现报错了，启动失败： 1.3.1.错误1：内核过低 我们使用的是centos6，其linux内核版本为2.6。而Elasticsearch的插件要求至少3.5以上版本。不过没关系，我们禁用这个插件即可。 修改elasticsearch.yml文件，在最下面添加如下配置： 1bootstrap.system_call_filter: false 然后重启 1.3.2.错误2：文件权限不足再次启动，又出错了： 1[1]: max file descriptors [4096] for elasticsearch process likely too low, increase to at least [65536] 我们用的是leyou用户，而不是root，所以文件权限不足。 首先用root用户登录。 然后修改配置文件: 1vim /etc/security/limits.conf 添加下面的内容： 1234567* soft nofile 65536* hard nofile 131072* soft nproc 4096* hard nproc 4096 1.3.3.错误3：线程数不够刚才报错中，还有一行： 1[1]: max number of threads [1024] for user [leyou] is too low, increase to at least [4096] 这是线程数不够。 继续修改配置： 1vim /etc/security/limits.d/90-nproc.conf 修改下面的内容： 1* soft nproc 1024 改为： 1* soft nproc 4096 1.3.4.错误4：进程虚拟内存1[3]: max virtual memory areas vm.max_map_count [65530] likely too low, increase to at least [262144] vm.max_map_count：限制一个进程可以拥有的VMA(虚拟内存区域)的数量，继续修改配置文件， ： 1vim /etc/sysctl.conf 添加下面内容： 1vm.max_map_count=655360 然后执行命令： 1sysctl -p 1.3.5.重启终端窗口所有错误修改完毕，一定要重启你的 Xshell终端，否则配置无效。 1.3.6.启动再次启动，终于成功了！ 123切换用户，然后进入安装目录，启动elasticsearch服务cd /home/leyou/elasticsearch/bin./elasticsearch 可以看到绑定了两个端口: 9300：集群节点间通讯接口 9200：客户端访问接口 我们在浏览器中访问：http://192.168.25.128:9200 1.4.安装kibana1.4.1.什么是Kibana？ Kibana是一个基于Node.js的Elasticsearch索引库数据统计工具，可以利用Elasticsearch的聚合功能，生成各种图表，如柱形图，线状图，饼图等。 而且还提供了操作Elasticsearch索引数据的控制台，并且提供了一定的API提示，非常有利于我们学习Elasticsearch的语法。 1.4.2.安装因为Kibana依赖于node，我们的虚拟机没有安装node，而window中安装过。所以我们选择在window下使用kibana。 最新版本与elasticsearch保持一致，也是6.3.0 解压到特定目录即可C:\Program Files (x86)\Apache Software Foundation\kibana 1.4.3.配置运行 配置 进入安装目录下的config目录，修改kibana.yml文件： 修改elasticsearch服务器的地址： 1elasticsearch.url: &quot;http://192.168.25.128:9200&quot; 运行 进入安装目录下的bin目录： 双击运行： 发现kibana的监听端口是5601 我们访问：http://127.0.0.1:5601 1.4.4.控制台选择左侧的DevTools菜单，即可进入控制台页面： 在页面右侧，我们就可以输入请求，访问Elasticsearch了。 1.5.安装ik分词器Lucene的IK分词器早在2012年已经没有维护了，现在我们要使用的是在其基础上维护升级的版本，并且开发为ElasticSearch的集成插件了，与Elasticsearch一起维护升级，版本也保持一致，最新版本：6.3.0 1.5.1.安装上传课前资料中的zip包，解压到Elasticsearch目录的plugins目录中： 使用unzip命令解压并且改名为ik-analyzer： 1unzip elasticsearch-analysis-ik-6.3.0.zip -d ik-analyzer 设置成leyou权限 1[root@localhost plugins]# chown leyou:leyou ik-analyzer/ -R 然后重启elasticsearch： 1.5.2.测试大家先不管语法，我们先测试一波。 在kibana控制台输入下面的请求： 12345POST _analyze&#123; &quot;analyzer&quot;: &quot;ik_max_word&quot;, &quot;text&quot;: &quot;我是中国人&quot;&#125; 运行得到结果： 123456789101112131415161718192021222324252627282930313233343536373839&#123; &quot;tokens&quot;: [ &#123; &quot;token&quot;: &quot;我&quot;, &quot;start_offset&quot;: 0, &quot;end_offset&quot;: 1, &quot;type&quot;: &quot;CN_CHAR&quot;, &quot;position&quot;: 0 &#125;, &#123; &quot;token&quot;: &quot;是&quot;, &quot;start_offset&quot;: 1, &quot;end_offset&quot;: 2, &quot;type&quot;: &quot;CN_CHAR&quot;, &quot;position&quot;: 1 &#125;, &#123; &quot;token&quot;: &quot;中国人&quot;, &quot;start_offset&quot;: 2, &quot;end_offset&quot;: 5, &quot;type&quot;: &quot;CN_WORD&quot;, &quot;position&quot;: 2 &#125;, &#123; &quot;token&quot;: &quot;中国&quot;, &quot;start_offset&quot;: 2, &quot;end_offset&quot;: 4, &quot;type&quot;: &quot;CN_WORD&quot;, &quot;position&quot;: 3 &#125;, &#123; &quot;token&quot;: &quot;国人&quot;, &quot;start_offset&quot;: 3, &quot;end_offset&quot;: 5, &quot;type&quot;: &quot;CN_WORD&quot;, &quot;position&quot;: 4 &#125; ]&#125; 1.7.APIElasticsearch提供了Rest风格的API，即http请求接口，而且也提供了各种语言的客户端API 1.7.1.Rest风格API文档地址：https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html 1.7.2.客户端APIElasticsearch支持的客户端非常多：https://www.elastic.co/guide/en/elasticsearch/client/index.html 点击Java Rest Client后，你会发现又有两个： Low Level Rest Client是低级别封装，提供一些基础功能，但更灵活 High Level Rest Client，是在Low Level Rest Client基础上进行的高级别封装，功能更丰富和完善，而且API会变的简单 1.7.3.如何学习建议先学习Rest风格API，了解发起请求的底层实现，请求体格式等。 2.操作索引2.1.基本概念Elasticsearch也是基于Lucene的全文检索库，本质也是存储数据，很多概念与MySQL类似的。 对比关系： ElasticSearch————————————–Mysql 索引（indices）——————————–Databases 数据库 ​ 类型（type）—————————–Table 数据表 ​ 文档（Document）—————-Row 行 ​ 字段（Field）——————-Columns 列 详细说明： 概念 说明 索引库（indices) indices是index的复数，代表许多的索引， 类型（type） 类型是模拟mysql中的table概念，一个索引库下可以有不同类型的索引，比如商品索引，订单索引，其数据格式不同。不过这会导致索引库混乱，因此未来版本中会移除这个概念 文档（document） 存入索引库原始的数据。比如每一条商品信息，就是一个文档 字段（field） 文档中的属性 映射配置（mappings） 字段的数据类型、属性、是否索引、是否存储等特性 是不是与Lucene和solr中的概念类似。 另外，在SolrCloud中，有一些集群相关的概念，在Elasticsearch也有类似的： 索引集（Indices，index的复数）：逻辑上的完整索引 分片（shard）：数据拆分后的各个部分 副本（replica）：每个分片的复制 要注意的是：Elasticsearch本身就是分布式的，因此即便你只有一个节点，Elasticsearch默认也会对你的数据进行分片和副本操作，当你向集群添加新数据时，数据也会在新加入的节点中进行平衡。 2.2.创建索引2.2.1.语法Elasticsearch采用Rest风格API，因此其API就是一次http请求，你可以用任何工具发起http请求 创建索引的请求格式： 请求方式：PUT 请求路径：/索引库名 请求参数：json格式： 123456&#123; "settings": &#123; "number_of_shards": 3, "number_of_replicas": 2 &#125;&#125; settings：索引库的设置 number_of_shards：分片数量 number_of_replicas：副本数量 2.2.2.测试我们先用RestClient来试试 响应： 可以看到索引创建成功了。 2.2.3.使用kibana创建kibana的控制台，可以对http请求进行简化，示例： 相当于是省去了elasticsearch的服务器地址 而且还有语法提示，非常舒服。 2.3.查看索引设置 语法 Get请求可以帮我们查看索引信息，格式： 1GET /索引库名 或者，我们可以使用*来查询所有索引库配置： 2.4.删除索引删除索引使用DELETE请求 语法 1DELETE /索引库名 示例 再次查看heima2： 当然，我们也可以用HEAD请求，查看索引是否存在： 2.5.映射配置索引有了，接下来肯定是添加数据。但是，在添加数据之前必须定义映射。 什么是映射？ ​ 映射是定义文档的过程，文档包含哪些字段，这些字段是否保存，是否索引，是否分词等 只有配置清楚，Elasticsearch才会帮我们进行索引库的创建（不一定） 2.5.1.创建映射字段 语法 请求方式依然是PUT 1234567891011PUT /索引库名/_mapping/类型名称&#123; &quot;properties&quot;: &#123; &quot;字段名&quot;: &#123; &quot;type&quot;: &quot;类型&quot;, &quot;index&quot;: true， &quot;store&quot;: true， &quot;analyzer&quot;: &quot;分词器&quot; &#125; &#125;&#125; 类型名称：就是前面将的type的概念，类似于数据库中的不同表字段名：任意填写 ，可以指定许多属性，例如： type：类型，可以是text、long、short、date、integer、object等 index：是否索引，默认为true store：是否存储，默认为false analyzer：分词器，这里的ik_max_word即使用ik分词器 示例 发起请求： 12345678910111213141516PUT /heima/_mapping/goods&#123; "properties": &#123; "title": &#123; "type": "text", "analyzer": "ik_max_word" &#125;, "images": &#123; "type": "keyword", "index": "false" &#125;, "price": &#123; "type": "float" &#125; &#125;&#125; 响应结果： 123&#123; &quot;acknowledged&quot;: true&#125; 2.5.2.查看映射关系 语法： 1GET /索引库名/_mapping 示例： 1GET /heima/_mapping 响应： 123456789101112131415161718192021&#123; "heima": &#123; "mappings": &#123; "goods": &#123; "properties": &#123; "images": &#123; "type": "keyword", "index": false &#125;, "price": &#123; "type": "float" &#125;, "title": &#123; "type": "text", "analyzer": "ik_max_word" &#125; &#125; &#125; &#125; &#125;&#125; 2.5.3.字段属性详解2.5.3.1.typeElasticsearch中支持的数据类型非常丰富： 我们说几个关键的： String类型，又分两种： text：可分词，不可参与聚合 keyword：不可分词，数据会作为完整字段进行匹配，可以参与聚合 Numerical：数值类型，分两类 基本数据类型：long、interger、short、byte、double、float、half_float 浮点数的高精度类型：scaled_float 需要指定一个精度因子，比如10或100。elasticsearch会把真实值乘以这个因子后存储，取出时再还原。 Date：日期类型 elasticsearch可以对日期格式化为字符串存储，但是建议我们存储为毫秒值，存储为long，节省空间。 存的是对象： {girl:{name=”rose”,age:21}} 会处理成两个字段：girl.name和girl.age 2.5.3.2.indexindex影响字段的索引情况。 true：字段会被索引，则可以用来进行搜索。默认值就是true false：字段不会被索引，不能用来搜索 index的默认值就是true，也就是说你不进行任何配置，所有字段都会被索引。 但是有些字段是我们不希望被索引的，比如商品的图片信息，就需要手动设置index为false。 2.5.3.3.store是否将数据进行额外存储。 在学习lucene和solr时，我们知道如果一个字段的store设置为false，那么在文档列表中就不会有这个字段的值，用户的搜索结果中不会显示出来。 但是在Elasticsearch中，即便store设置为false，也可以搜索到结果。 原因是Elasticsearch在创建文档索引时，会将文档中的原始数据备份，保存到一个叫做_source的属性中。而且我们可以通过过滤_source来选择哪些要显示，哪些不显示。 而如果设置store为true，就会在_source以外额外存储一份数据，多余，因此一般我们都会将store设置为false，事实上，store的默认值就是false。 2.5.3.4.boost激励因子，这个与lucene中一样 其它的不再一一讲解，用的不多，大家参考官方文档： 2.6.新增数据2.6.1.随机生成id通过POST请求，可以向一个已经存在的索引库中添加数据。 语法： 1234POST /索引库名/类型名&#123; &quot;key&quot;:&quot;value&quot;&#125; 示例： 1234567891011121314//默认idPOST /heima/goods/&#123; "title":"小米手机", "images":"http://image.leyou.com/12479122.jpg", "price":2699.00&#125;//自定义idPOST /heima/goods/1&#123; "title":"小米手机2", "images":"http://image.leyou.com/12479122.jpg", "price":2666.00&#125; 响应： 1234567891011121314&#123; "_index": "heima", "_type": "goods", "_id": "r9c1KGMBIhaxtY5rlRKv", "_version": 1, "result": "created", "_shards": &#123; "total": 3, "successful": 1, "failed": 0 &#125;, "_seq_no": 0, "_primary_term": 2&#125; 通过kibana查看数据： 1234GET /heima/_search&#123; "query": &#123;"match_all": &#123;&#125;&#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738&#123; "took": 194, "timed_out": false, "_shards": &#123; "total": 5, "successful": 5, "skipped": 0, "failed": 0 &#125;, "hits": &#123; "total": 2, "max_score": 1, "hits": [ &#123; "_index": "heima", "_type": "goods", "_id": "HA7CpmcB-AoaT0cuqrW4", "_score": 1, "_source": &#123; "title": "小米手机", "images": "http://image.leyou.com/12479122.jpg", "price": 2699 &#125; &#125;, &#123; "_index": "heima", "_type": "goods", "_id": "1", "_score": 1, "_source": &#123; "title": "1小米手机", "images": "http://image.leyou.com/12479122.jpg", "price": 12699 &#125; &#125; ] &#125;&#125; _source：源文档信息，所有的数据都在里面。 _id：这条文档的唯一标示，与文档自己的id字段没有关联 2.6.2.自定义id如果我们想要自己新增的时候指定id，可以这么做： 1234POST /索引库名/类型/id值&#123; ...&#125; 示例： 123456POST /heima/goods/2&#123; "title":"大米手机", "images":"http://image.leyou.com/12479122.jpg", "price":2899.00&#125; 得到的数据： 1234567891011&#123; "_index": "heima", "_type": "goods", "_id": "2", "_score": 1, "_source": &#123; "title": "大米手机", "images": "http://image.leyou.com/12479122.jpg", "price": 2899 &#125;&#125; 2.6.3.智能判断在学习Solr时我们发现，我们在新增数据时，只能使用提前配置好映射属性的字段，否则就会报错。 不过在Elasticsearch中并没有这样的规定。 事实上Elasticsearch非常智能，你不需要给索引库设置任何mapping映射，它也可以根据你输入的数据来判断类型，动态添加数据映射。 测试一下： 123456789POST /heima/goods/3&#123; "title":"超米手机", "images":"http://image.leyou.com/12479122.jpg", "price":2899.00, "stock": 200, "saleable":true， &#125; 我们额外添加了stock库存，和saleable是否上架两个字段。 来看结果： 1234567891011121314&#123; "_index": "heima", "_type": "goods", "_id": "3", "_version": 1, "_score": 1, "_source": &#123; "title": "超米手机", "images": "http://image.leyou.com/12479122.jpg", "price": 2899, "stock": 200, "saleable": true &#125;&#125; 在看下索引库的映射关系: 123456789101112131415161718192021222324252627&#123; "heima": &#123; "mappings": &#123; "goods": &#123; "properties": &#123; "images": &#123; "type": "keyword", "index": false &#125;, "price": &#123; "type": "float" &#125;, "saleable": &#123; "type": "boolean" &#125;, "stock": &#123; "type": "long" &#125;, "title": &#123; "type": "text", "analyzer": "ik_max_word" &#125; &#125; &#125; &#125; &#125;&#125; stock和saleable都被成功映射了。 如果存储的是string类型的数据，ES无智能判断，他会存入两个字符，例如： 存入一个那么字段，智能形成两个字段： name：text类型 name.keyword：keyword类型 2.7.修改数据把刚才新增的请求方式改为PUT，就是修改了。不过修改必须指定id， id对应文档存在，则修改 id对应文档不存在，则新增 比如，我们把id为3的数据进行修改： 12345678PUT /heima/goods/3&#123; "title":"超大米手机", "images":"http://image.leyou.com/12479122.jpg", "price":3899.00, "stock": 100, "saleable":true&#125; 结果： 1234567891011121314151617181920212223242526272829&#123; "took": 17, "timed_out": false, "_shards": &#123; "total": 9, "successful": 9, "skipped": 0, "failed": 0 &#125;, "hits": &#123; "total": 1, "max_score": 1, "hits": [ &#123; "_index": "heima", "_type": "goods", "_id": "3", "_score": 1, "_source": &#123; "title": "超大米手机", "images": "http://image.leyou.com/12479122.jpg", "price": 3899, "stock": 100, "saleable": true &#125; &#125; ] &#125;&#125; 2.8.删除数据删除使用DELETE请求，同样，需要根据id进行删除： 语法 1DELETE /索引库名/类型名/id值 示例： 3.查询我们从4块来讲查询： 基本查询 _source过滤 结果过滤 高级查询 排序 3.1.基本查询： 基本语法 12345678GET /索引库名/_search&#123; "query":&#123; "查询类型":&#123; "查询条件":"查询条件值" &#125; &#125;&#125; 这里的query代表一个查询对象，里面可以有不同的查询属性 查询类型： 例如：match_all， match，term ， range 等等 查询条件：查询条件会根据类型的不同，写法也有差异，后面详细讲解 3.1.1 查询所有（match_all) 示例： 123456GET /heima/_search&#123; "query":&#123; "match_all": &#123;&#125;//很多搜索类型 &#125;&#125; query：代表查询对象 match_all：代表查询所有 结果： 1234567891011121314151617181920212223242526272829303132333435363738&#123; "took": 2, "timed_out": false, "_shards": &#123; "total": 3, "successful": 3, "skipped": 0, "failed": 0 &#125;, "hits": &#123; "total": 2, "max_score": 1, "hits": [ &#123; "_index": "heima", "_type": "goods", "_id": "2", "_score": 1, "_source": &#123; "title": "大米手机", "images": "http://image.leyou.com/12479122.jpg", "price": 2899 &#125; &#125;, &#123; "_index": "heima", "_type": "goods", "_id": "r9c1KGMBIhaxtY5rlRKv", "_score": 1, "_source": &#123; "title": "小米手机", "images": "http://image.leyou.com/12479122.jpg", "price": 2699 &#125; &#125; ] &#125;&#125; took：查询花费时间，单位是毫秒 time_out：是否超时 _shards：分片信息 hits：搜索结果总览对象 total：搜索到的总条数 max_score：所有结果中文档得分的最高分 hits：搜索结果的文档对象数组，每个元素是一条搜索到的文档信息 _index：索引库 _type：文档类型 _id：文档id _score：文档得分 _source：文档的源数据 例子： 3.1.2 匹配查询（match）我们先加入一条数据，便于测试： 123456PUT /heima/goods/3&#123; "title":"小米电视4A", "images":"http://image.leyou.com/12479122.jpg", "price":3899.00&#125; 现在，索引库中有2部手机，1台电视： or关系 match类型查询，会把查询条件进行分词，然后进行查询,多个词条之间是or的关系 12345678GET /heima/_search&#123; "query":&#123; "match":&#123; "title":"小米电视" &#125; &#125;&#125; 结果： 12345678910111213141516171819202122232425262728"hits": &#123; "total": 2, "max_score": 0.6931472, "hits": [ &#123; "_index": "heima", "_type": "goods", "_id": "tmUBomQB_mwm6wH_EC1-", "_score": 0.6931472, "_source": &#123; "title": "小米手机", "images": "http://image.leyou.com/12479122.jpg", "price": 2699 &#125; &#125;, &#123; "_index": "heima", "_type": "goods", "_id": "3", "_score": 0.5753642, "_source": &#123; "title": "小米电视4A", "images": "http://image.leyou.com/12479122.jpg", "price": 3899 &#125; &#125; ]&#125; 在上面的案例中，不仅会查询到电视，而且与小米相关的都会查询到，多个词之间是or的关系。 and关系 某些情况下，我们需要更精确查找，我们希望这个关系变成and，可以这样做： 1234567891011GET /heima/_search&#123; "query":&#123; "match": &#123; "title": &#123; "query": "小米电视", "operator": "and" &#125; &#125; &#125;&#125; 结果： 123456789101112131415161718192021222324252627&#123; "took": 2, "timed_out": false, "_shards": &#123; "total": 3, "successful": 3, "skipped": 0, "failed": 0 &#125;, "hits": &#123; "total": 1, "max_score": 0.5753642, "hits": [ &#123; "_index": "heima", "_type": "goods", "_id": "3", "_score": 0.5753642, "_source": &#123; "title": "小米电视4A", "images": "http://image.leyou.com/12479122.jpg", "price": 3899 &#125; &#125; ] &#125;&#125; 本例中，只有同时包含小米和电视的词条才会被搜索到。 or和and之间？ 在 or 与 and 间二选一有点过于非黑即白。 如果用户给定的条件分词后有 5 个查询词项，想查找只包含其中 4 个词的文档，该如何处理？将 operator 操作符参数设置成 and 只会将此文档排除。 有时候这正是我们期望的，但在全文搜索的大多数应用场景下，我们既想包含那些可能相关的文档，同时又排除那些不太相关的。换句话说，我们想要处于中间某种结果。 match 查询支持 minimum_should_match 最小匹配参数， 这让我们可以指定必须匹配的词项数用来表示一个文档是否相关。我们可以将其设置为某个具体数字，更常用的做法是将其设置为一个百分数，因为我们无法控制用户搜索时输入的单词数量： 1234567891011GET /heima/_search&#123; "query":&#123; "match":&#123; "title":&#123; "query":"小米曲面电视", "minimum_should_match": "75%" &#125; &#125; &#125;&#125; 本例中，搜索语句可以分为3个词，如果使用and关系，需要同时满足3个词才会被搜索到。这里我们采用最小品牌数：75%，那么也就是说只要匹配到总词条数量的75%即可，这里3*75% 约等于2。所以只要包含2个词条就算满足条件了。 结果： 3.1.3 多字段查询（multi_match）multi_match与match类似，不同的是它可以在多个字段中查询 123456789GET /heima/_search&#123; "query":&#123; "multi_match": &#123; "query": "小米", "fields": [ "title", "subTitle" ] &#125; &#125;&#125; 本例中，我们会在title字段和subtitle字段中查询小米这个词 3.1.4 词条匹配(term)term 查询被用于精确值 匹配，这些精确值可能是数字、时间、布尔或者那些未分词的字符串 12345678GET /heima/_search&#123; "query":&#123; "term":&#123; "price":2699.00 &#125; &#125;&#125; 结果： 123456789101112131415161718192021222324252627&#123; "took": 2, "timed_out": false, "_shards": &#123; "total": 3, "successful": 3, "skipped": 0, "failed": 0 &#125;, "hits": &#123; "total": 1, "max_score": 1, "hits": [ &#123; "_index": "heima", "_type": "goods", "_id": "r9c1KGMBIhaxtY5rlRKv", "_score": 1, "_source": &#123; "title": "小米手机", "images": "http://image.leyou.com/12479122.jpg", "price": 2699 &#125; &#125; ] &#125;&#125; 3.1.5 多词条精确匹配(terms)terms 查询和 term 查询一样，但它允许你指定多值进行匹配。如果这个字段包含了指定值中的任何一个值，那么这个文档满足条件： 12345678GET /heima/_search&#123; "query":&#123; "terms":&#123; "price":[2699.00,2899.00,3899.00] &#125; &#125;&#125; 结果： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&#123; "took": 4, "timed_out": false, "_shards": &#123; "total": 3, "successful": 3, "skipped": 0, "failed": 0 &#125;, "hits": &#123; "total": 3, "max_score": 1, "hits": [ &#123; "_index": "heima", "_type": "goods", "_id": "2", "_score": 1, "_source": &#123; "title": "大米手机", "images": "http://image.leyou.com/12479122.jpg", "price": 2899 &#125; &#125;, &#123; "_index": "heima", "_type": "goods", "_id": "r9c1KGMBIhaxtY5rlRKv", "_score": 1, "_source": &#123; "title": "小米手机", "images": "http://image.leyou.com/12479122.jpg", "price": 2699 &#125; &#125;, &#123; "_index": "heima", "_type": "goods", "_id": "3", "_score": 1, "_source": &#123; "title": "小米电视4A", "images": "http://image.leyou.com/12479122.jpg", "price": 3899 &#125; &#125; ] &#125;&#125; 3.2.结果过滤（指定返回结果）默认情况下，elasticsearch在搜索的结果中，会把文档中保存在_source的所有字段都返回。 如果我们只想获取其中的部分字段，我们可以添加_source的过滤 3.2.1.直接指定字段示例： 123456789GET /heima/_search&#123; "_source": ["title","price"], "query": &#123; "term": &#123; "price": 2699 &#125; &#125;&#125; 返回的结果： 1234567891011121314151617181920212223242526&#123; "took": 12, "timed_out": false, "_shards": &#123; "total": 3, "successful": 3, "skipped": 0, "failed": 0 &#125;, "hits": &#123; "total": 1, "max_score": 1, "hits": [ &#123; "_index": "heima", "_type": "goods", "_id": "r9c1KGMBIhaxtY5rlRKv", "_score": 1, "_source": &#123; "price": 2699, "title": "小米手机" &#125; &#125; ] &#125;&#125; 3.2.2.指定includes和excludes我们也可以通过： includes：来指定想要显示的字段 excludes：来指定不想要显示的字段 二者都是可选的。 示例： 1234567891011GET /heima/_search&#123; "_source": &#123; "includes":["title","price"] &#125;, "query": &#123; "term": &#123; "price": 2699 &#125; &#125;&#125; 与下面的结果将是一样的： 1234567891011GET /heima/_search&#123; "_source": &#123; "excludes": ["images"] &#125;, "query": &#123; "term": &#123; "price": 2699 &#125; &#125;&#125; 3.3 高级查询3.3.1 布尔组合（bool)bool把各种其它查询通过must（与）、must_not（非）、should（或）的方式进行组合 12345678910GET /heima/_search&#123; "query":&#123; "bool":&#123; "must": &#123; "match": &#123; "title": "大米" &#125;&#125;, "must_not": &#123; "match": &#123; "title": "电视" &#125;&#125;, "should": &#123; "match": &#123; "title": "手机" &#125;&#125; &#125; &#125;&#125; 结果： 123456789101112131415161718192021222324252627&#123; "took": 10, "timed_out": false, "_shards": &#123; "total": 3, "successful": 3, "skipped": 0, "failed": 0 &#125;, "hits": &#123; "total": 1, "max_score": 0.5753642, "hits": [ &#123; "_index": "heima", "_type": "goods", "_id": "2", "_score": 0.5753642, "_source": &#123; "title": "大米手机", "images": "http://image.leyou.com/12479122.jpg", "price": 2899 &#125; &#125; ] &#125;&#125; 3.3.2 范围查询(range)range 查询找出那些落在指定区间内的数字或者时间 1234567891011GET /heima/_search&#123; "query":&#123; "range": &#123; "price": &#123; "gte": 1000.0, "lt": 2800.00 &#125; &#125; &#125;&#125; range查询允许以下字符： 操作符 说明 gt 大于 gte 大于等于 lt 小于 lte 小于等于 3.3.3 模糊查询(fuzzy)我们新增一个商品： 123456POST /heima/goods/4&#123; "title":"apple手机", "images":"http://image.leyou.com/12479122.jpg", "price":6899.00&#125; fuzzy 查询是 term 查询的模糊等价。它允许用户搜索词条与实际词条的拼写出现偏差，但是偏差的编辑距离不得超过2： 12345678GET /heima/_search&#123; "query": &#123; "fuzzy": &#123; "title": "appla" &#125; &#125;&#125; 上面的查询，也能查询到apple手机 我们可以通过fuzziness来指定允许的编辑距离： 1234567891011GET /heima/_search&#123; "query": &#123; "fuzzy": &#123; "title": &#123; "value":"appla", "fuzziness":1 &#125; &#125; &#125;&#125; 3.4 过滤(filter) 条件查询中进行过滤 所有的查询都会影响到文档的评分及排名。如果我们需要在查询结果中进行过滤，并且不希望过滤条件影响评分，那么就不要把过滤条件作为查询条件来用。而是使用filter方式： 1234567891011GET /heima/_search&#123; "query":&#123; "bool":&#123; "must":&#123; "match": &#123; "title": "小米手机" &#125;&#125;, "filter":&#123; "range":&#123;"price":&#123;"gt":2000.00,"lt":3800.00&#125;&#125; &#125; &#125; &#125;&#125; 注意：filter中还可以再次进行bool组合条件过滤。 无查询条件，直接过滤 如果一次查询只有过滤，没有查询条件，不希望进行评分，我们可以使用constant_score取代只有 filter 语句的 bool 查询。在性能上是完全相同的，但对于提高查询简洁性和清晰度有很大帮助。 123456789GET /heima/_search&#123; "query":&#123; "constant_score": &#123; "filter": &#123; "range":&#123;"price":&#123;"gt":2000.00,"lt":3000.00&#125;&#125; &#125; &#125;&#125; 3.5 排序3.4.1 单字段排序sort 可以让我们按照不同的字段进行排序，并且通过order指定排序的方式 123456789101112131415GET /heima/_search&#123; "query": &#123; "match": &#123; "title": "小米手机" &#125; &#125;, "sort": [ &#123; "price": &#123; "order": "desc" &#125; &#125; ]&#125; 3.4.2 多字段排序假定我们想要结合使用 price和 _score（得分） 进行查询，并且匹配的结果首先按照价格排序，然后按照相关性得分排序： 123456789101112131415GET /goods/_search&#123; "query":&#123; "bool":&#123; "must":&#123; "match": &#123; "title": "小米手机" &#125;&#125;, "filter":&#123; "range":&#123;"price":&#123;"gt":200000,"lt":300000&#125;&#125; &#125; &#125; &#125;, "sort": [ &#123; "price": &#123; "order": "desc" &#125;&#125;, &#123; "_score": &#123; "order": "desc" &#125;&#125; ]&#125; 4. 聚合aggregations聚合可以让我们极其方便的实现对数据的统计、分析。例如： 什么品牌的手机最受欢迎？ 这些手机的平均价格、最高价格、最低价格？ 这些手机每月的销售情况如何？ 实现这些统计功能的比数据库的sql要方便的多，而且查询速度非常快，可以实现实时搜索效果。 4.1 基本概念Elasticsearch中的聚合，包含多种类型，最常用的两种，一个叫桶，一个叫度量： 桶（bucket） 桶的作用，是按照某种方式对数据进行分组，每一组数据在ES中称为一个桶，例如我们根据国籍对人划分，可以得到中国桶、英国桶，日本桶……或者我们按照年龄段对人进行划分：0~10,10~20,20~30,30~40等。 Elasticsearch中提供的划分桶的方式有很多： Date Histogram Aggregation：根据日期阶梯分组，例如给定阶梯为周，会自动每周分为一组 Histogram Aggregation：根据数值阶梯分组，与日期类似 Terms Aggregation：根据词条内容分组，词条内容完全匹配的为一组 Range Aggregation：数值和日期的范围分组，指定开始和结束，然后按段分组 …… 综上所述，我们发现bucket aggregations 只负责对数据进行分组，并不进行计算，因此往往bucket中往往会嵌套另一种聚合：metrics aggregations即度量 度量（metrics） 分组完成以后，我们一般会对组中的数据进行聚合运算，例如求平均值、最大、最小、求和等，这些在ES中称为度量 比较常用的一些度量聚合方式： Avg Aggregation：求平均值 Max Aggregation：求最大值 Min Aggregation：求最小值 Percentiles Aggregation：求百分比 Stats Aggregation：同时返回avg、max、min、sum、count等 Sum Aggregation：求和 Top hits Aggregation：求前几 Value Count Aggregation：求总数 …… 为了测试聚合，我们先批量导入一些数据 创建索引库： 12345678910111213141516171819PUT /cars&#123; "settings": &#123; "number_of_shards": 1, "number_of_replicas": 0 &#125;, "mappings": &#123; "transactions": &#123; "properties": &#123; "color": &#123; "type": "keyword" &#125;, "make": &#123; "type": "keyword" &#125; &#125; &#125; &#125;&#125; 注意：在ES中，需要进行聚合、排序、过滤的字段其处理方式比较特殊，因此不能被分词。这里我们将color和make这两个文字类型的字段设置为keyword类型，这个类型不会被分词，将来就可以参与聚合 导入数据 1234567891011121314151617POST /cars/transactions/_bulk&#123; "index": &#123;&#125;&#125;&#123; "price" : 10000, "color" : "red", "make" : "honda", "sold" : "2014-10-28" &#125;&#123; "index": &#123;&#125;&#125;&#123; "price" : 20000, "color" : "red", "make" : "honda", "sold" : "2014-11-05" &#125;&#123; "index": &#123;&#125;&#125;&#123; "price" : 30000, "color" : "green", "make" : "ford", "sold" : "2014-05-18" &#125;&#123; "index": &#123;&#125;&#125;&#123; "price" : 15000, "color" : "blue", "make" : "toyota", "sold" : "2014-07-02" &#125;&#123; "index": &#123;&#125;&#125;&#123; "price" : 12000, "color" : "green", "make" : "toyota", "sold" : "2014-08-19" &#125;&#123; "index": &#123;&#125;&#125;&#123; "price" : 20000, "color" : "red", "make" : "honda", "sold" : "2014-11-05" &#125;&#123; "index": &#123;&#125;&#125;&#123; "price" : 80000, "color" : "red", "make" : "bmw", "sold" : "2014-01-01" &#125;&#123; "index": &#123;&#125;&#125;&#123; "price" : 25000, "color" : "blue", "make" : "ford", "sold" : "2014-02-12" &#125; 4.2 聚合为桶首先，我们按照 汽车的颜色color来划分桶 1234567891011GET /cars/_search&#123; "size" : 0, "aggs" : &#123; "popular_colors" : &#123; "terms" : &#123; "field" : "color" &#125; &#125; &#125;&#125; size： 查询条数，这里设置为0，因为我们不关心搜索到的数据，只关心聚合结果，提高效率 aggs：声明这是一个聚合查询，是aggregations的缩写 popular_colors：给这次聚合起一个名字，任意。 terms：划分桶的方式，这里是根据词条划分 field：划分桶的字段 结果： 1234567891011121314151617181920212223242526272829303132333435&#123; "took": 1, "timed_out": false, "_shards": &#123; "total": 1, "successful": 1, "skipped": 0, "failed": 0 &#125;, "hits": &#123; "total": 8, "max_score": 0, "hits": [] &#125;, "aggregations": &#123; "popular_colors": &#123; "doc_count_error_upper_bound": 0, "sum_other_doc_count": 0, "buckets": [ &#123; "key": "red", "doc_count": 4 &#125;, &#123; "key": "blue", "doc_count": 2 &#125;, &#123; "key": "green", "doc_count": 2 &#125; ] &#125; &#125;&#125; hits：查询结果为空，因为我们设置了size为0 aggregations：聚合的结果 popular_colors：我们定义的聚合名称 buckets：查找到的桶，每个不同的color字段值都会形成一个桶 key：这个桶对应的color字段的值 doc_count：这个桶中的文档数量 通过聚合的结果我们发现，目前红色的小车比较畅销！ 4.3 桶内度量前面的例子告诉我们每个桶里面的文档数量，这很有用。 但通常，我们的应用需要提供更复杂的文档度量。 例如，每种颜色汽车的平均价格是多少？ 因此，我们需要告诉Elasticsearch使用哪个字段，使用何种度量方式进行运算，这些信息要嵌套在桶内，度量的运算会基于桶内的文档进行 现在，我们为刚刚的聚合结果添加 求价格平均值的度量： 123456789101112131415161718GET /cars/_search&#123; "size" : 0, "aggs" : &#123; "popular_colors" : &#123; "terms" : &#123; "field" : "color" &#125;, "aggs":&#123; "avg_price": &#123; "avg": &#123; "field": "price" &#125; &#125; &#125; &#125; &#125;&#125; aggs：我们在上一个aggs(popular_colors)中添加新的aggs。可见度量也是一个聚合,度量是在桶内的聚合 avg_price：聚合的名称 avg：度量的类型，这里是求平均值 field：度量运算的字段 结果： 12345678910111213141516171819202122232425262728293031... "aggregations": &#123; "popular_colors": &#123; "doc_count_error_upper_bound": 0, "sum_other_doc_count": 0, "buckets": [ &#123; "key": "red", "doc_count": 4, "avg_price": &#123; "value": 32500 &#125; &#125;, &#123; "key": "blue", "doc_count": 2, "avg_price": &#123; "value": 20000 &#125; &#125;, &#123; "key": "green", "doc_count": 2, "avg_price": &#123; "value": 21000 &#125; &#125; ] &#125; &#125;... 可以看到每个桶中都有自己的avg_price字段，这是度量聚合的结果 4.4 桶内嵌套桶刚刚的案例中，我们在桶内嵌套度量运算。事实上桶不仅可以嵌套运算， 还可以再嵌套其它桶。也就是说在每个分组中，再分更多组。 比如：我们想统计每种颜色的汽车中，分别属于哪个制造商，按照make字段再进行分桶 1234567891011121314151617181920212223GET /cars/_search&#123; "size" : 0, "aggs" : &#123; "popular_colors" : &#123; "terms" : &#123; "field" : "color" &#125;, "aggs":&#123; "avg_price": &#123; "avg": &#123; "field": "price" &#125; &#125;, "maker":&#123; "terms":&#123; "field":"make" &#125; &#125; &#125; &#125; &#125;&#125; 原来的color桶和avg计算我们不变 maker：在嵌套的aggs下新添一个桶，叫做maker terms：桶的划分类型依然是词条 filed：这里根据make字段进行划分 部分结果： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374...&#123;"aggregations": &#123; "popular_colors": &#123; "doc_count_error_upper_bound": 0, "sum_other_doc_count": 0, "buckets": [ &#123; "key": "red", "doc_count": 4, "maker": &#123; "doc_count_error_upper_bound": 0, "sum_other_doc_count": 0, "buckets": [ &#123; "key": "honda", "doc_count": 3 &#125;, &#123; "key": "bmw", "doc_count": 1 &#125; ] &#125;, "avg_price": &#123; "value": 32500 &#125; &#125;, &#123; "key": "blue", "doc_count": 2, "maker": &#123; "doc_count_error_upper_bound": 0, "sum_other_doc_count": 0, "buckets": [ &#123; "key": "ford", "doc_count": 1 &#125;, &#123; "key": "toyota", "doc_count": 1 &#125; ] &#125;, "avg_price": &#123; "value": 20000 &#125; &#125;, &#123; "key": "green", "doc_count": 2, "maker": &#123; "doc_count_error_upper_bound": 0, "sum_other_doc_count": 0, "buckets": [ &#123; "key": "ford", "doc_count": 1 &#125;, &#123; "key": "toyota", "doc_count": 1 &#125; ] &#125;, "avg_price": &#123; "value": 21000 &#125; &#125; ] &#125; &#125;&#125;... 我们可以看到，新的聚合maker被嵌套在原来每一个color的桶中。 每个颜色下面都根据 make字段进行了分组 我们能读取到的信息： 红色车共有4辆 红色车的平均售价是 $32，500 美元。 其中3辆是 Honda 本田制造，1辆是 BMW 宝马制造。 4.5.划分桶的其它方式前面讲了，划分桶的方式有很多，例如： Date Histogram Aggregation：根据日期阶梯分组，例如给定阶梯为周，会自动每周分为一组 Histogram Aggregation：根据数值阶梯分组，与日期类似 Terms Aggregation：根据词条内容分组，词条内容完全匹配的为一组 Range Aggregation：数值和日期的范围分组，指定开始和结束，然后按段分组 刚刚的案例中，我们采用的是Terms Aggregation，即根据词条划分桶。 接下来，我们再学习几个比较实用的： 4.5.1.阶梯分桶Histogram 原理： histogram是把数值类型的字段，按照一定的阶梯大小进行分组。你需要指定一个阶梯值（interval）来划分阶梯大小。 举例： 比如你有价格字段，如果你设定interval的值为200，那么阶梯就会是这样的： 0，200，400，600，… 上面列出的是每个阶梯的key，也是区间的启点。 如果一件商品的价格是450，会落入哪个阶梯区间呢？计算公式如下： 1bucket_key = Math.floor((value - offset) / interval) * interval + offset value：就是当前数据的值，本例中是450 offset：起始偏移量，默认为0 interval：阶梯间隔，比如200 因此你得到的key = Math.floor((450 - 0) / 200) * 200 + 0 = 400 操作一下： 比如，我们对汽车的价格进行分组，指定间隔interval为5000： 123456789101112GET /cars/_search&#123; "size":0, "aggs":&#123; "price":&#123; "histogram": &#123; "field": "price", "interval": 5000 &#125; &#125; &#125;&#125; 结果： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&#123; "took": 21, "timed_out": false, "_shards": &#123; "total": 5, "successful": 5, "skipped": 0, "failed": 0 &#125;, "hits": &#123; "total": 8, "max_score": 0, "hits": [] &#125;, "aggregations": &#123; "price": &#123; "buckets": [ &#123; "key": 10000, "doc_count": 2 &#125;, &#123; "key": 15000, "doc_count": 1 &#125;, &#123; "key": 20000, "doc_count": 2 &#125;, &#123; "key": 25000, "doc_count": 1 &#125;, &#123; "key": 30000, "doc_count": 1 &#125;, &#123; "key": 35000, "doc_count": 0 &#125;, &#123; "key": 40000, "doc_count": 0 &#125;, &#123; "key": 45000, "doc_count": 0 &#125;, &#123; "key": 50000, "doc_count": 0 &#125;, &#123; "key": 55000, "doc_count": 0 &#125;, &#123; "key": 60000, "doc_count": 0 &#125;, &#123; "key": 65000, "doc_count": 0 &#125;, &#123; "key": 70000, "doc_count": 0 &#125;, &#123; "key": 75000, "doc_count": 0 &#125;, &#123; "key": 80000, "doc_count": 1 &#125; ] &#125; &#125;&#125; 你会发现，中间有大量的文档数量为0 的桶，看起来很丑。 我们可以增加一个参数min_doc_count为1，来约束最少文档数量为1，这样文档数量为0的桶会被过滤 示例： 12345678910111213GET /cars/_search&#123; "size":0, "aggs":&#123; "price":&#123; "histogram": &#123; "field": "price", "interval": 5000, "min_doc_count": 1 &#125; &#125; &#125;&#125; 结果： 123456789101112131415161718192021222324252627282930313233343536373839404142434445&#123; "took": 15, "timed_out": false, "_shards": &#123; "total": 5, "successful": 5, "skipped": 0, "failed": 0 &#125;, "hits": &#123; "total": 8, "max_score": 0, "hits": [] &#125;, "aggregations": &#123; "price": &#123; "buckets": [ &#123; "key": 10000, "doc_count": 2 &#125;, &#123; "key": 15000, "doc_count": 1 &#125;, &#123; "key": 20000, "doc_count": 2 &#125;, &#123; "key": 25000, "doc_count": 1 &#125;, &#123; "key": 30000, "doc_count": 1 &#125;, &#123; "key": 80000, "doc_count": 1 &#125; ] &#125; &#125;&#125; 完美，！ 如果你用kibana将结果变为柱形图，会更好看： 4.5.2.范围分桶range范围分桶与阶梯分桶类似，也是把数字按照阶段进行分组，只不过range方式需要你自己指定每一组的起始和结束大小。 5.Spring Data ElasticsearchElasticsearch提供的Java客户端有一些不太方便的地方： 很多地方需要拼接Json字符串，在java中拼接字符串有多恐怖你应该懂的 需要自己把对象序列化为json存储 查询到结果也需要自己反序列化为对象 因此，我们这里就不讲解原生的Elasticsearch客户端API了。 而是学习Spring提供的套件：Spring Data Elasticsearch。 5.1.简介Spring Data Elasticsearch是Spring Data项目下的一个子模块。 查看 Spring Data的官网：http://projects.spring.io/spring-data/ Spring Data的使命是为数据访问提供熟悉且一致的基于Spring的编程模型，同时仍保留底层数据存储的特殊特性。 它使得使用数据访问技术，关系数据库和非关系数据库，map-reduce框架和基于云的数据服务变得容易。这是一个总括项目，其中包含许多特定于给定数据库的子项目。这些令人兴奋的技术项目背后，是由许多公司和开发人员合作开发的。 Spring Data 的使命是给各种数据访问提供统一的编程接口，不管是关系型数据库（如MySQL），还是非关系数据库（如Redis），或者类似Elasticsearch这样的索引数据库。从而简化开发人员的代码，提高开发效率。 包含很多不同数据操作的模块： Spring Data Elasticsearch的页面：https://projects.spring.io/spring-data-elasticsearch/ 特征： 支持Spring的基于@Configuration的java配置方式，或者XML配置方式 提供了用于操作ES的便捷工具类ElasticsearchTemplate。包括实现文档到POJO之间的自动智能映射。 利用Spring的数据转换服务实现的功能丰富的对象映射 基于注解的元数据映射方式，而且可扩展以支持更多不同的数据格式 根据持久层接口自动生成对应实现方法，无需人工编写基本操作代码（类似mybatis，根据接口自动得到实现）。当然，也支持人工定制查询 5.2.创建Demo工程我们新建一个demo，学习Elasticsearch pom依赖： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.demo&lt;/groupId&gt; &lt;artifactId&gt;elasticsearch&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;elasticsearch&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.4.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-elasticsearch&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; application.yml文件配置： 12345spring: data: elasticsearch: cluster-name: elasticsearch cluster-nodes: 192.168.25.128:9300 5.3.实体类及注解首先我们准备好实体类： 12345678public class Item &#123; Long id; String title; //标题 String category;// 分类 String brand; // 品牌 Double price; // 价格 String images; // 图片地址&#125; 映射 Spring Data通过注解来声明字段的映射属性，有下面的三个注解： @Document 作用在类，标记实体类为文档对象，一般有两个属性 indexName：对应索引库名称 type：对应在索引库中的类型 shards：分片数量，默认5 replicas：副本数量，默认1 @Id 作用在成员变量，标记一个字段作为id主键 @Field 作用在成员变量，标记为文档的字段，并指定字段映射属性： type：字段类型，取值是枚举：FieldType index：是否索引，布尔类型，默认是true store：是否存储，布尔类型，默认是false analyzer：分词器名称 示例： 123456789101112131415161718@Data@Document(indexName = "heima3",type = "item",shards = 1)public class Item &#123; @Id @Field(type = FieldType.Long) Long id; @Field(type = FieldType.Text,analyzer = "ik_smart") String title; //标题 @Field(type = FieldType.Keyword) String category;// 分类 @Field(type = FieldType.Keyword) String brand; // 品牌 @Field(type = FieldType.Double) Double price; // 价格 @Field(type = FieldType.Keyword,index = false) String images; // 图片地址&#125; 5.4.Template索引操作5.4.1.创建索引和映射 创建索引 ElasticsearchTemplate中提供了创建索引的API： 可以根据类的信息自动生成，也可以手动指定indexName和Settings 映射 映射相关的API： 可以根据类的字节码信息（注解配置）来生成映射，或者手动编写映射 我们这里采用类的字节码信息创建索引并映射： 123456789101112131415@RunWith(SpringRunner.class)@SpringBootTest(classes = ItcastElasticsearchApplication.class)public class IndexTest &#123; @Autowired private ElasticsearchTemplate elasticsearchTemplate; @Test public void testCreate()&#123; // 创建索引，会根据Item类的@Document注解信息来创建 elasticsearchTemplate.createIndex(Item.class); // 配置映射，会根据Item类中的id、Field等字段来自动完成映射 elasticsearchTemplate.putMapping(Item.class); &#125;&#125; 结果： 123456789101112131415161718192021222324252627282930313233343536373839404142434445GET heima3/_mapping&#123; "item": &#123; "aliases": &#123;&#125;, "mappings": &#123; "docs": &#123; "properties": &#123; "brand": &#123; "type": "keyword" &#125;, "category": &#123; "type": "keyword" &#125;, "images": &#123; "type": "keyword", "index": false &#125;, "price": &#123; "type": "double" &#125;, "title": &#123; "type": "text", "analyzer": "ik_max_word" &#125; &#125; &#125; &#125;, "settings": &#123; "index": &#123; "refresh_interval": "1s", "number_of_shards": "1", "provided_name": "item", "creation_date": "1525405022589", "store": &#123; "type": "fs" &#125;, "number_of_replicas": "0", "uuid": "4sE9SAw3Sqq1aAPz5F6OEg", "version": &#123; "created": "6020499" &#125; &#125; &#125; &#125;&#125; 5.3.2.删除索引删除索引的API： 可以根据类名或索引名删除。 示例： 1234@Testpublic void deleteIndex() &#123; esTemplate.deleteIndex("heima");&#125; 结果： 5.5.Repository文档操作（重要）Spring Data 的强大之处，就在于你不用写任何DAO处理，自动根据方法名或类的信息进行CRUD操作。只要你定义一个接口，然后继承Repository提供的一些子接口，就能具备各种基本的CRUD功能。 我们只需要定义接口，然后继承它就OK了。 源码如下： 来看下Repository的继承关系： 我们看到有一个ElasticsearchRepository接口： 只要我们继承ElasticsearchRepositor&lt;T,ID&gt;就可以使用ElasticSearch T：实体类 ID：id数据类型 在es-test中的repository中创建 12public interface ItemRepository extends ElasticsearchRepository&lt;Item,Long&gt; &#123;&#125; 5.5.1.新增文档123456789@Autowiredprivate ItemRepository itemRepository;@Testpublic void index() &#123; Item item = new Item(1L, "小米手机7", " 手机", "小米", 3499.00, "http://image.leyou.com/13123.jpg"); itemRepository.save(item);&#125; 去页面查询看看： 1GET /item/_search 结果： 123456789101112131415161718192021222324252627282930&#123; "took": 14, "timed_out": false, "_shards": &#123; "total": 1, "successful": 1, "skipped": 0, "failed": 0 &#125;, "hits": &#123; "total": 1, "max_score": 1, "hits": [ &#123; "_index": "item", "_type": "docs", "_id": "1", "_score": 1, "_source": &#123; "id": 1, "title": "小米手机7", "category": " 手机", "brand": "小米", "price": 3499, "images": "http://image.leyou.com/13123.jpg" &#125; &#125; ] &#125;&#125; 5.5.2.批量新增代码： 12345678@Testpublic void indexList() &#123; List&lt;Item&gt; list = new ArrayList&lt;&gt;(); list.add(new Item(2L, "坚果手机R1", " 手机", "锤子", 3699.00, "http://image.leyou.com/123.jpg")); list.add(new Item(3L, "华为META10", " 手机", "华为", 4499.00, "http://image.leyou.com/3.jpg")); // 接收对象集合，实现批量新增 itemRepository.saveAll(list);&#125; 再次去页面查询： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&#123; "took": 5, "timed_out": false, "_shards": &#123; "total": 1, "successful": 1, "skipped": 0, "failed": 0 &#125;, "hits": &#123; "total": 3, "max_score": 1, "hits": [ &#123; "_index": "item", "_type": "docs", "_id": "2", "_score": 1, "_source": &#123; "id": 2, "title": "坚果手机R1", "category": " 手机", "brand": "锤子", "price": 3699, "images": "http://image.leyou.com/13123.jpg" &#125; &#125;, &#123; "_index": "item", "_type": "docs", "_id": "3", "_score": 1, "_source": &#123; "id": 3, "title": "华为META10", "category": " 手机", "brand": "华为", "price": 4499, "images": "http://image.leyou.com/13123.jpg" &#125; &#125;, &#123; "_index": "item", "_type": "docs", "_id": "1", "_score": 1, "_source": &#123; "id": 1, "title": "小米手机7", "category": " 手机", "brand": "小米", "price": 3499, "images": "http://image.leyou.com/13123.jpg" &#125; &#125; ] &#125;&#125; 5.5.3.修改文档修改和新增是同一个接口，区分的依据就是id，这一点跟我们在页面发起PUT请求是类似的。 5.5.4.基本查询ElasticsearchRepository提供了一些基本的查询方法： 我们来试试查询所有： 123456@Testpublic void testFind()&#123; // 查询全部，并安装价格降序排序 Iterable&lt;Item&gt; items = this.itemRepository.findAll(Sort.by(Sort.Direction.DESC, "price")); items.forEach(item-&gt; System.out.println(item));&#125; 结果： 5.5.5.自定义方法Spring Data 的另一个强大功能，是根据方法名称自动实现功能。 比如：你的方法名叫做：findByTitle，那么它就知道你是根据title查询，然后自动帮你完成，无需写实现类。 当然，方法名称要符合一定的约定： Keyword Sample Elasticsearch Query String And findByNameAndPrice {&quot;bool&quot; : {&quot;must&quot; : [ {&quot;field&quot; : {&quot;name&quot; : &quot;?&quot;}}, {&quot;field&quot; : {&quot;price&quot; : &quot;?&quot;}} ]}} Or findByNameOrPrice {&quot;bool&quot; : {&quot;should&quot; : [ {&quot;field&quot; : {&quot;name&quot; : &quot;?&quot;}}, {&quot;field&quot; : {&quot;price&quot; : &quot;?&quot;}} ]}} Is findByName {&quot;bool&quot; : {&quot;must&quot; : {&quot;field&quot; : {&quot;name&quot; : &quot;?&quot;}}}} Not findByNameNot {&quot;bool&quot; : {&quot;must_not&quot; : {&quot;field&quot; : {&quot;name&quot; : &quot;?&quot;}}}} Between findByPriceBetween {&quot;bool&quot; : {&quot;must&quot; : {&quot;range&quot; : {&quot;price&quot; : {&quot;from&quot; : ?,&quot;to&quot; : ?,&quot;include_lower&quot; : true,&quot;include_upper&quot; : true}}}}} LessThanEqual findByPriceLessThan {&quot;bool&quot; : {&quot;must&quot; : {&quot;range&quot; : {&quot;price&quot; : {&quot;from&quot; : null,&quot;to&quot; : ?,&quot;include_lower&quot; : true,&quot;include_upper&quot; : true}}}}} GreaterThanEqual findByPriceGreaterThan {&quot;bool&quot; : {&quot;must&quot; : {&quot;range&quot; : {&quot;price&quot; : {&quot;from&quot; : ?,&quot;to&quot; : null,&quot;include_lower&quot; : true,&quot;include_upper&quot; : true}}}}} Before findByPriceBefore {&quot;bool&quot; : {&quot;must&quot; : {&quot;range&quot; : {&quot;price&quot; : {&quot;from&quot; : null,&quot;to&quot; : ?,&quot;include_lower&quot; : true,&quot;include_upper&quot; : true}}}}} After findByPriceAfter {&quot;bool&quot; : {&quot;must&quot; : {&quot;range&quot; : {&quot;price&quot; : {&quot;from&quot; : ?,&quot;to&quot; : null,&quot;include_lower&quot; : true,&quot;include_upper&quot; : true}}}}} Like findByNameLike {&quot;bool&quot; : {&quot;must&quot; : {&quot;field&quot; : {&quot;name&quot; : {&quot;query&quot; : &quot;?*&quot;,&quot;analyze_wildcard&quot; : true}}}}} StartingWith findByNameStartingWith {&quot;bool&quot; : {&quot;must&quot; : {&quot;field&quot; : {&quot;name&quot; : {&quot;query&quot; : &quot;?*&quot;,&quot;analyze_wildcard&quot; : true}}}}} EndingWith findByNameEndingWith {&quot;bool&quot; : {&quot;must&quot; : {&quot;field&quot; : {&quot;name&quot; : {&quot;query&quot; : &quot;*?&quot;,&quot;analyze_wildcard&quot; : true}}}}} Contains/Containing findByNameContaining {&quot;bool&quot; : {&quot;must&quot; : {&quot;field&quot; : {&quot;name&quot; : {&quot;query&quot; : &quot;**?**&quot;,&quot;analyze_wildcard&quot; : true}}}}} In findByNameIn(Collection&lt;String&gt;names) {&quot;bool&quot; : {&quot;must&quot; : {&quot;bool&quot; : {&quot;should&quot; : [ {&quot;field&quot; : {&quot;name&quot; : &quot;?&quot;}}, {&quot;field&quot; : {&quot;name&quot; : &quot;?&quot;}} ]}}}} NotIn findByNameNotIn(Collection&lt;String&gt;names) {&quot;bool&quot; : {&quot;must_not&quot; : {&quot;bool&quot; : {&quot;should&quot; : {&quot;field&quot; : {&quot;name&quot; : &quot;?&quot;}}}}}} Near findByStoreNear Not Supported Yet ! True findByAvailableTrue {&quot;bool&quot; : {&quot;must&quot; : {&quot;field&quot; : {&quot;available&quot; : true}}}} False findByAvailableFalse {&quot;bool&quot; : {&quot;must&quot; : {&quot;field&quot; : {&quot;available&quot; : false}}}} OrderBy findByAvailableTrueOrderByNameDesc {&quot;sort&quot; : [{ &quot;name&quot; : {&quot;order&quot; : &quot;desc&quot;} }],&quot;bool&quot; : {&quot;must&quot; : {&quot;field&quot; : {&quot;available&quot; : true}}}} 例如，我们来按照价格区间查询，定义这样的一个方法： 12345678910public interface ItemRepository extends ElasticsearchRepository&lt;Item,Long&gt; &#123; /** * 根据价格区间查询 * @param price1 * @param price2 * @return */ List&lt;Item&gt; findByPriceBetween(double price1, double price2);&#125; 然后添加一些测试数据： 1234567891011@Testpublic void indexList() &#123; List&lt;Item&gt; list = new ArrayList&lt;&gt;(); list.add(new Item(1L, "小米手机7", "手机", "小米", 3299.00, "http://image.leyou.com/13123.jpg")); list.add(new Item(2L, "坚果手机R1", "手机", "锤子", 3699.00, "http://image.leyou.com/13123.jpg")); list.add(new Item(3L, "华为META10", "手机", "华为", 4499.00, "http://image.leyou.com/13123.jpg")); list.add(new Item(4L, "小米Mix2S", "手机", "小米", 4299.00, "http://image.leyou.com/13123.jpg")); list.add(new Item(5L, "荣耀V10", "手机", "华为", 2799.00, "http://image.leyou.com/13123.jpg")); // 接收对象集合，实现批量新增 itemRepository.saveAll(list);&#125; 不需要写实现类，然后我们直接去运行： 1234567@Testpublic void queryByPriceBetween()&#123; List&lt;Item&gt; list = this.itemRepository.findByPriceBetween(2000.00, 3500.00); for (Item item : list) &#123; System.out.println("item = " + item); &#125;&#125; 结果： 虽然基本查询和自定义方法已经很强大了，但是如果是复杂查询（模糊、通配符、词条查询等）就显得力不从心了。此时，我们只能使用原生查询。 5.6.高级查询5.6.1.基本查询先看看基本玩法 12345678@Testpublic void testQuery()&#123; // 词条查询 MatchQueryBuilder queryBuilder = QueryBuilders.matchQuery("title", "小米"); // 执行查询 Iterable&lt;Item&gt; items = this.itemRepository.search(queryBuilder); items.forEach(System.out::println);&#125; Repository的search方法需要QueryBuilder参数，elasticSearch为我们提供了一个对象QueryBuilders： QueryBuilders提供了大量的静态方法，用于生成各种不同类型的查询对象，例如：词条、模糊、通配符等QueryBuilder对象。 结果： elasticsearch提供很多可用的查询方式，但是不够灵活。如果想玩过滤或者聚合查询等就很难了。 5.6.2.自定义查询先来看最基本的match query： 123456789101112131415@Testpublic void testNativeQuery()&#123; // 构建查询条件 NativeSearchQueryBuilder queryBuilder = new NativeSearchQueryBuilder(); // 添加基本的分词查询 queryBuilder.withQuery(QueryBuilders.matchQuery("title", "小米")); // 执行搜索，获取结果 Page&lt;Item&gt; items = this.itemRepository.search(queryBuilder.build()); // 打印总条数 long total=items.getTotalElements(); System.out.println("total="+total) for(Item item:items)&#123; System.out.println(item); &#125;&#125; NativeSearchQueryBuilder：Spring提供的一个查询条件构建器，帮助构建json格式的请求体 Page&lt;item&gt;：默认是分页查询，因此返回的是一个分页的结果对象，包含属性： totalElements：总条数 totalPages：总页数 Iterator：迭代器，本身实现了Iterator接口，因此可直接迭代得到当前页的数据 其它属性： 结果： 5.6.4.分页查询利用NativeSearchQueryBuilder可以方便的实现分页： 12345678910111213141516171819202122232425@Testpublic void testNativeQuery()&#123; // 构建查询条件 NativeSearchQueryBuilder queryBuilder = new NativeSearchQueryBuilder(); // 添加基本的分词查询（过滤） queryBuilder.withQuery(QueryBuilders.termQuery("category", "手机")); // 初始化分页参数 int page = 0;//从0开始 int size = 3; // 设置分页参数 queryBuilder.withPageable(PageRequest.of(page, size)); // 执行搜索，获取结果 Page&lt;Item&gt; items = this.itemRepository.search(queryBuilder.build()); // 打印总条数 System.out.println(items.getTotalElements()); // 打印总页数 System.out.println(items.getTotalPages()); // 每页大小 System.out.println(items.getSize()); // 当前页 System.out.println(items.getNumber()); items.forEach(System.out::println);&#125; 结果： 可以发现，Elasticsearch中的分页是从第0页开始。 5.6.5.排序排序也通用通过NativeSearchQueryBuilder完成： 12345678910111213141516@Testpublic void testSort()&#123; // 构建查询条件 NativeSearchQueryBuilder queryBuilder = new NativeSearchQueryBuilder(); // 添加基本的分词查询 queryBuilder.withQuery(QueryBuilders.termQuery("category", "手机")); // 排序 queryBuilder.withSort(SortBuilders.fieldSort("price").order(SortOrder.DESC)); // 执行搜索，获取结果 Page&lt;Item&gt; items = this.itemRepository.search(queryBuilder.build()); // 打印总条数 System.out.println(items.getTotalElements()); items.forEach(System.out::println);&#125; 结果： 5.7.聚合5.7.1.聚合为桶桶就是分组，比如这里我们按照品牌brand进行分组： 12345678910111213141516171819202122232425262728293031@Test public void testAgg()&#123; NativeSearchQueryBuilder queryBuilder = new NativeSearchQueryBuilder(); // 不查询任何结果 queryBuilder.withSourceFilter(new FetchSourceFilter(new String[]&#123;""&#125;, null)); // 1、添加一个新的聚合，聚合类型为terms，聚合名称为popularBrand，聚合字段为brand queryBuilder.addAggregation(AggregationBuilders.terms("popularBrand").field("brand")); // 2、查询,需要把结果强转为AggregatedPage类型 //AggregatedPage&lt;Item&gt; aggPage = (AggregatedPage&lt;Item&gt;) this.itemRepository.search(queryBuilder.build()); AggregatedPage&lt;Item&gt; aggPage = elasticsearchTemplate.queryForPage(queryBuilder.build(), Item.class); // 3、解析 // 3.1、从结果中取出名为brands的那个聚合， // 因为是利用String类型字段来进行的term聚合，所以结果要强转为StringTerm类型 Aggregations aggs = aggPage.getAggregations(); StringTerms terms = aggs.get("popularBrand"); // 3.2、获取桶 List&lt;StringTerms.Bucket&gt; buckets = terms.getBuckets(); // 3.3、遍历 for (StringTerms.Bucket bucket : buckets) &#123; // 3.4、获取桶中的key，即品牌名称 System.out.println("key = "+bucket.getKeyAsString()); // 3.5、获取桶中的文档数量 System.out.println("docCount = "+bucket.getDocCount()); &#125; &#125; 显示的结果： 关键API： AggregationBuilders：聚合的构建工厂类。所有聚合都由这个类来构建，看看他的静态方法： AggregatedPage：聚合查询的结果类。它是Page&lt;T&gt;的子接口： AggregatedPage在Page功能的基础上，拓展了与聚合相关的功能，它其实就是对聚合结果的一种封装，大家可以对照聚合结果的JSON结构来看。 而返回的结果都是Aggregation类型对象，不过根据字段类型不同，又有不同的子类表示 我们看下页面的查询的JSON结果与Java类的对照关系： 5.7.2.嵌套聚合，求平均值代码： 1234567891011121314151617181920212223242526272829@Testpublic void testSubAgg()&#123; NativeSearchQueryBuilder queryBuilder = new NativeSearchQueryBuilder(); // 不查询任何结果 queryBuilder.withSourceFilter(new FetchSourceFilter(new String[]&#123;""&#125;, null)); // 1、添加一个新的聚合，聚合类型为terms，聚合名称为brands，聚合字段为brand queryBuilder.addAggregation( AggregationBuilders.terms("brands").field("brand") .subAggregation(AggregationBuilders.avg("priceAvg").field("price")) // 在品牌聚合桶内进行嵌套聚合，求平均值 ); // 2、查询,需要把结果强转为AggregatedPage类型 AggregatedPage&lt;Item&gt; aggPage = (AggregatedPage&lt;Item&gt;) this.itemRepository.search(queryBuilder.build()); // 3、解析 // 3.1、从结果中取出名为brands的那个聚合， // 因为是利用String类型字段来进行的term聚合，所以结果要强转为StringTerm类型 StringTerms agg = (StringTerms) aggPage.getAggregation("brands"); // 3.2、获取桶 List&lt;StringTerms.Bucket&gt; buckets = agg.getBuckets(); // 3.3、遍历 for (StringTerms.Bucket bucket : buckets) &#123; // 3.4、获取桶中的key，即品牌名称 3.5、获取桶中的文档数量 System.out.println(bucket.getKeyAsString() + "，共" + bucket.getDocCount() + "台"); // 3.6.获取子聚合结果： InternalAvg avg = (InternalAvg) bucket.getAggregations().asMap().get("priceAvg"); System.out.println("平均售价：" + avg.getValue()); &#125;&#125; 结果：]]></content>
      <categories>
        <category>项目实战-微服务商城</category>
        <category>Elasticsearch</category>
      </categories>
      <tags>
        <tag>Elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务商城（十）——商品管理二]]></title>
    <url>%2Fday09-%E5%95%86%E5%93%81%E7%AE%A1%E7%90%86.html</url>
    <content type="text"><![CDATA[独立实现商品新增后台 独立实现商品编辑后台 独立搭建前台系统页面 1.商品新增1.1.页面预览当我们点击新增商品按钮： 就会出现一个弹窗： 里面把商品的数据分为了4部分来填写： 基本信息：主要是一些简单的文本数据，包含了SPU和SpuDetail的部分数据，如 商品分类：是SPU中的cid1，cid2，cid3属性 品牌：是spu中的brandId属性 标题：是spu中的title属性 子标题：是spu中的subTitle属性 售后服务：是SpuDetail中的afterService属性 包装列表：是SpuDetail中的packingList属性 商品描述：是SpuDetail中的description属性，数据较多，所以单独放一个页面 规格参数：商品规格信息，对应SpuDetail中的genericSpec属性 SKU属性：spu下的所有Sku信息 对应到页面中的四个stepper-content： 1.2.弹窗事件弹窗是一个独立组件： 并且在Goods组件中已经引用它： 并且在GoodsForm.vue页面中渲染： 在新增商品按钮的点击事件中，改变这个dialog的show属性： 1.3.基本数据我们先来看下基本数据： 1.3.1.商品分类商品分类信息查询我们之前已经做过，所以这里的级联选框已经实现完成： 刷新页面，可以看到请求已经发出： 效果： 1.3.2.品牌选择1.3.2.1页面品牌也是一个下拉选框，不过其选项是不确定的，只有当用户选择了商品分类，才会把这个分类下的所有品牌展示出来。 所以页面编写了watch函数，监控商品分类的变化，每当商品分类值有变化，就会发起请求，查询品牌列表： 选择商品分类后，可以看到请求发起： 接下来，我们只要编写后台接口，根据商品分类id，查询对应品牌即可。 1.2.2.2后台接口页面需要去后台查询品牌信息，我们自然需要提供： 请求方式：GET 请求路径：/brand/cid/{cid} 请求参数：cid 响应数据：List 涉及的表：tb_brand，tb_category_brand BrandController 12345678910/** * 根据商品分类cid查询品牌分类 * 涉及tb_brand，tb_category_brand表 * @param cid * @return */ @GetMapping("cid/&#123;cid&#125;")public ResponseEntity&lt;List&lt;Brand&gt;&gt; queryBrandByCid(@PathVariable("cid")Long cid)&#123; return ResponseEntity.ok(brandService.queryBrandByCid(cid)); &#125; BrandService 在BrandService中 12345678910111213/** * 根据商品分类cid查询品牌分类 * 涉及tb_brand，tb_category_brand表 * @param cid * @return */public List&lt;Brand&gt; queryBrandByCid(Long cid) &#123; List&lt;Brand&gt; brands = brandMapper.queryBrandByCid(cid); if (CollectionUtils.isEmpty(brands))&#123; throw new LyException(ExceptionEnums.BRAND_NOT_FOUND); &#125; return brands;&#125; BrandMapper 根据分类查询品牌有中间表，需要自己编写Sql： 12@Select("SELECT * FROM tb_brand WHERE id IN (SELECT brand_id FROM tb_category_brand WHERE category_id = #&#123;cid&#125;)") List&lt;Brand&gt; queryBrandByCid(@Param("cid")Long cid); 效果： 1.3.3.其它文本框GoodsForm.vue剩余的几个属性：标题、子标题等都是普通文本框，我们直接填写即可，没有需要特别注意的。 1.4.商品描述商品描述信息比较复杂，而且图文并茂，甚至包括视频。 这样的内容，一般都会使用富文本编辑器。 1.4.1.什么是富文本编辑器百度百科： 通俗来说：富文本，就是比较丰富的文本编辑器。普通的框只能输入文字，而富文本还能给文字加颜色样式等。 富文本编辑器有很多，例如：KindEditor、Ueditor。但并不原生支持vue 但是我们今天要说的，是一款支持Vue的富文本编辑器：vue-quill-editor 1.4.2.Vue-Quill-EditorGitHub的主页：https://github.com/surmon-china/vue-quill-editor Vue-Quill-Editor是一个基于Quill的富文本编辑器：Quill的官网 1.4.3.使用指南使用非常简单： 第一步：安装，使用npm命令： 1npm install vue-quill-editor --save 第二步：加载，在js中引入： 全局引入： 123456import Vue from 'vue'import VueQuillEditor from 'vue-quill-editor'const options = &#123;&#125;; /* &#123; default global options &#125; */Vue.use(VueQuillEditor, options); // options可选 局部引入： 1234567891011import 'quill/dist/quill.core.css'import 'quill/dist/quill.snow.css'import 'quill/dist/quill.bubble.css'import &#123;quillEditor&#125; from 'vue-quill-editor'var vm = new Vue(&#123; components:&#123; quillEditor &#125;&#125;) 我们这里采用局部引用： 第三步：页面使用： 1&lt;quill-editor v-model="goods.spuDetail.description" :options="editorOption"/&gt; 1.4.4.自定义的富文本编辑器不过这个组件有个小问题，就是图片上传的无法直接上传到后台，因此我们对其进行了封装，支持了图片的上传。 使用也非常简单： 在GoodsForm.vue中 1234&lt;!--2、商品描述--&gt;&lt;v-stepper-content step="2"&gt; &lt;v-editor v-model="goods.spuDetail.description" upload-url="/upload/image"/&gt;&lt;/v-stepper-content&gt; upload-url：是图片上传的路径 v-model：双向绑定，将富文本编辑器的内容绑定到goods.spuDetail.description 1.4.5.效果 1.5.商品规格参数规格参数的查询我们之前也已经编写过接口，因为商品规格参数也是与商品分类绑定，所以需要在商品分类变化后去查询，我们也是通过watch监控来实现： 可以看到这里是根据商品分类id查询规格参数：SpecParam。我们之前写过一个根据gid（分组id）来查询规格参数的接口，我们接下来完成根据分类id查询规格参数。 改造查询规格参数接口 修改SpecificationController中的queryParamByGid( )改成queryParamByList( ) 我们在原来的根据 gid（规格组id)查询规格参数的接口上，添加一个参数：cid，即商品分类id。 等一下， 考虑到以后可能还会根据是否搜索、是否为通用属性等条件过滤，我们多添加generic、searching 过滤条件： 12345678910111213141516171819/** * 通过规格组的gid查询规格参数 * 通过商品分类cid查询规格参数 * required=false：表示不传值的时候给null * @param gid 规格组id * @param cid 商品分类id * @param searching 是否用于搜索关键字 * @param generic 是否是sku通用属性 * @return */ @GetMapping("params") public ResponseEntity&lt;List&lt;SpecParam&gt;&gt; queryParamByList( @RequestParam(value = "gid",required = false) Long gid, @RequestParam(value = "cid",required = false)Long cid, @RequestParam(value = "searching",required = false)Boolean searching, @RequestParam(value="generic", required = false) Boolean generic ) &#123; return ResponseEntity.ok(specificationService.queryParamByList(gid,cid,searching,generic)); &#125; 改造service： 修改SpecificationService 12345678910111213141516171819202122/** * 通过规格组的gid查询规格参数 * 通过商品分类cid查询规格参数 * required=false：表示不传值的时候给null * @param gid 规格组id * @param cid 商品分类id * @param searching 是否用于搜索关键字 * @param generic 是否是sku通用属性 * @return */ public List&lt;SpecParam&gt; queryParamByList(Long gid,Long cid,Boolean searching,Boolean generic) &#123; SpecParam param = new SpecParam(); param.setGroupId(gid); param.setCid(cid); param.setSearching(searching); param.setGeneric(generic); List&lt;SpecParam&gt; list = specParamMapper.select(param); if (CollectionUtils.isEmpty(list))&#123; throw new LyException(ExceptionEnums.SPEC_PARAM_NOT_FOUND); &#125; return list; &#125; 如果param中有属性为null，则不会吧属性作为查询条件，因此该方法具备通用性，即可根据gid查询，也可根据cid查询。 测试： 刷新页面测试： 1.6.SKU信息Sku属性是SPU下的每个商品的不同特征，如图： 当我们填写一些属性后，会在页面下方生成一个sku表格，大家可以计算下会生成多少个不同属性的Sku呢？ 当你选择了上图中的这些选项时： 颜色共2种：迷夜黑，勃艮第红，绚丽蓝 内存共2种：4GB，6GB 机身存储1种：64GB，128GB 此时会产生多少种SKU呢？ 应该是 3 2 2 = 12种，这其实就是在求笛卡尔积。 我们会在页面下方生成一个sku的表格： 1.7.页面表单提交在sku列表的下方，有一个提交按钮： 并且绑定了点击事件： 点击后会组织数据并向后台提交： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465submit() &#123; // 表单校验。 if(!this.$refs.basic.validate)&#123; this.$message.error("请先完成表单内容！"); &#125; // 先处理goods，用结构表达式接收,除了categories外，都接收到goodsParams中 const &#123; categories: [&#123; id: cid1 &#125;, &#123; id: cid2 &#125;, &#123; id: cid3 &#125;], ...goodsParams &#125; = this.goods; // 处理规格参数 const specs = &#123;&#125;; this.specs.forEach((&#123; id,v &#125;) =&gt; &#123; specs[id] = v; &#125;); // 处理特有规格参数模板 const specTemplate = &#123;&#125;; this.specialSpecs.forEach((&#123; id, options &#125;) =&gt; &#123; specTemplate[id] = options; &#125;); // 处理sku const skus = this.skus .filter(s =&gt; s.enable) .map((&#123; price, stock, enable, images, indexes, ...rest &#125;) =&gt; &#123; // 标题，在spu的title基础上，拼接特有规格属性值 const title = goodsParams.title + " " + Object.values(rest).map(v =&gt; v.v).join(" "); const obj = &#123;&#125;; Object.values(rest).forEach(v =&gt; &#123; obj[v.id] = v.v; &#125;); return &#123; price: this.$format(price), // 价格需要格式化 stock, indexes, enable, title, // 基本属性 images: images ? images.join(",") : '', // 图片 ownSpec: JSON.stringify(obj) // 特有规格参数 &#125;; &#125;); Object.assign(goodsParams, &#123; cid1, cid2, cid3, // 商品分类 skus // sku列表 &#125;); goodsParams.spuDetail.genericSpec = JSON.stringify(specs); goodsParams.spuDetail.specialSpec = JSON.stringify(specTemplate); // 提交到后台 this.$http(&#123; method: this.isEdit ? "put" : "post", url: "/item/goods", data: goodsParams &#125;) .then(() =&gt; &#123; // 成功，关闭窗口 this.$emit("close"); // 提示成功 this.$message.success("保存成功了"); &#125;) .catch(() =&gt; &#123; this.$message.error("保存失败！"); &#125;);&#125; 点击提交，查看控制台提交的数据格式： 整体是一个json格式数据，包含Spu表所有数据： brandId：品牌id cid1、cid2、cid3：商品分类id subTitle：副标题 title：标题 spuDetail：是一个json对象，代表商品详情表数据 afterService：售后服务 description：商品描述 packingList：包装列表 specialSpec：sku规格属性模板 genericSpec：通用规格参数 skus：spu下的所有sku数组，元素是每个sku对象： title：标题 images：图片 price：价格 stock：库存 ownSpec：特有规格参数 indexes：特有规格参数的下标 1.8.后台实现1.8.1.实体类SPU和SpuDetail实体类已经添加过，添加Sku和Stock对象： Sku 123456789101112131415161718@Data@Table(name = "tb_sku")public class Sku &#123; @Id @KeySql(useGeneratedKeys = true) private Long id; private Long spuId; private String title; private String images; private Long price; private String ownSpec;// 商品特殊规格的键值对 private String indexes;// 商品特殊规格的下标 private Boolean enable;// 是否有效，逻辑删除用 private Date createTime;// 创建时间 private Date lastUpdateTime;// 最后修改时间 @Transient private Integer stock;// 库存&#125; 注意：这里保存了一个库存字段，在数据库中是另外一张表保存的，方便查询。 Stock 123456789@Data@Table(name = "tb_stock")public class Stock &#123; @Id private Long skuId; private Integer seckillStock;// 秒杀可用库存 private Integer seckillTotal;// 已秒杀数量 private Integer stock;// 正常库存&#125; 1.8.2.GoodsController请求方式：POST 请求路径：/goods 请求参数：Spu的json格式的对象，spu中包含spuDetail和Sku集合。这里我们该怎么接收？我们之前定义了一个Spu对象，作为业务对象。这里也可以用它，不过需要再扩展spuDetail和skus字段： 123456789101112131415@Table(name = "tb_spu")@Datapublic class Spu &#123; //新添加的skus、spuDetail @Transient private List&lt;Sku&gt; skus; @Transient SpuDetail spuDetail;// 商品详情 // 省略getter和setter&#125; 返回类型：无 代码： 1234567891011/** * 新增商品信息 * 涉及表：tb_spu，tb_sku，tb_stock，tb_spu_detail * @param spu * @return */@PostMapping("goods")public ResponseEntity&lt;Void&gt; saveGoods(@RequestBody Spu spu)&#123; goodsService.saveGoods(spu); return ResponseEntity.status(HttpStatus.OK).build();&#125; 注意：通过@RequestBody注解来接收Json请求 1.8.3.GoodsService这里的逻辑比较复杂，我们除了要对SPU新增以外，还要对SpuDetail、Sku、Stock进行保存 1234567891011121314151617181920212223public void saveGoods(Spu spu) &#123; //新增spu spu.setCreateTime(new Date()); spu.setLastUpdateTime(spu.getCreateTime()); spu.setSaleable(true); spu.setValid(true); int insert = spuMapper.insert(spu); if (insert!=1)&#123; throw new LyException(ExceptionEnums.BRAND_NOT_FOUND); &#125; //新增detail SpuDetail spuDetail = spu.getSpuDetail(); spuDetail.setSpuId(spu.getId()); int insert1 = spuDetailMapper.insert(spuDetail); if (insert1!=1)&#123; throw new LyException(ExceptionEnums.SPU_ADD_ERROR); &#125; //抽离出来的新增sku和stock方法 AddSkuAndStock(spu); &#125; AddSkuAndStock() 123456789101112131415161718192021//新增sku和stockprivate void saveSkuAndStock(Spu spu) &#123; //新增sku List&lt;Stock&gt; stockList=new ArrayList&lt;&gt;(); List&lt;Sku&gt; skus = spu.getSkus(); for (Sku sku : skus) &#123; sku.setCreateTime(new Date()); sku.setLastUpdateTime(sku.getCreateTime()); sku.setSpuId(spu.getId()); int insert2 = skuMapper.insert(sku); if (insert2!=1)&#123; throw new LyException(ExceptionEnums.SKU_ADD_ERROR); &#125; Stock stock = new Stock(); stock.setSkuId(sku.getId()); stock.setStock(sku.getStock()); stockMapper.insert(stock); &#125;&#125; 在ly-common中的vo创建BaseMapper 自定义的mapper，IdListMapper&lt;T,Long&gt;,InsertListMapper&lt;T&gt;批量处理 T：表示要实现的pojo 123@RegisterMapperpublic interface BaseMapper&lt;T&gt; extends Mapper&lt;T&gt;,IdListMapper&lt;T,Long&gt;,InsertListMapper&lt;T&gt; &#123;&#125; 1.8.4.Mapper12public interface SkuMapper extends BaseMapper&lt;Sku&gt; &#123;&#125; StockMapper继承自定义的BaseMapper 12public interface StockMapper extends BaseMapper&lt;Stock&gt; &#123;&#125; 2.商品修改2.1.编辑按钮点击事件在商品详情页，每一个商品后面，都会有一个编辑按钮： 点击这个按钮，就会打开一个商品编辑窗口，我们看下它所绑定的点击事件： 对应的方法： 可以看到这里发起了两个请求，在查询商品详情和sku信息。 因为在商品列表页面，只有spu的基本信息：id、标题、品牌、商品分类等。比较复杂的商品详情（spuDetail)和sku信息都没有，编辑页面要回显数据，就需要查询这些内容。 因此，接下来我们就编写后台接口，提供查询服务接口。 2.2.查询SpuDetail接口 GoodsController 需要分析的内容： 请求方式：GET 请求路径：/spu/detail/{id} 请求参数：id，应该是spu的id 返回结果：SpuDetail对象 12345678910/** * 根据spuid查询商品详情(回显) * @param spuId * @return */@GetMapping("spu/detail/&#123;id&#125;")public ResponseEntity&lt;SpuDetail&gt; queryDetailBySpuId(@PathVariable("id")Long spuId)&#123; return ResponseEntity.ok(goodsService.queryDetailBySpuId(spuId));&#125; GoodsService 1234567public SpuDetail queryDetailBySpuId(Long spuId) &#123; SpuDetail spuDetail = spuDetailMapper.selectByPrimaryKey(spuId); if (spuDetail==null)&#123; throw new LyException(ExceptionEnums.SPU_DETAIL_NOT_FOUND); &#125; return spuDetail; &#125; 测试 2.3.查询sku 分析 请求方式：Get 请求路径：/sku/list 请求参数：id，应该是spu的id 返回结果：sku的集合 GoodsController 123456789/** * 根据spuid查询sku(回显) * @param spuId * @return */@GetMapping("sku/list")public ResponseEntity&lt;List&lt;Sku&gt;&gt; querySkuByid(@RequestParam("id")Long spuId)&#123; return ResponseEntity.ok(goodsService.querySkuByid(spuId));&#125; GoodsService 需要注意的是，为了页面回显方便，我们一并把sku的库存stock也查询出来 12345678910public List&lt;Sku&gt; querySkuByid(Long spuId) &#123; Sku sku = new Sku(); sku.setSpuId(spuId); List&lt;Sku&gt; skuLists = skuMapper.select(sku); for (Sku skuList : skuLists) &#123; Stock stock = stockMapper.selectByPrimaryKey(skuList.getId()); sku.setStock(stock.getStock()); &#125; return skuLists;&#125; 测试： 2.4.页面回显随便点击一个编辑按钮，发现数据回显完成： 2.5.页面提交这里的保存按钮与新增其实是同一个，因此提交的逻辑也是一样的，这里不再赘述。 随便修改点数据，然后点击保存，可以看到浏览器已经发出请求： 2.6.后台实现接下来，我们编写后台，实现修改商品接口。 2.6.1.Controller 请求方式：PUT 请求路径：/ 请求参数：Spu对象 返回结果：无 1234567891011/** * 修改商品信息 * 涉及表：tb_spu，tb_sku，tb_stock，tb_spu_detail * @param spu * @return */@PutMapping("goods")public ResponseEntity&lt;Void&gt; uploadGoods(@RequestBody Spu spu)&#123; goodsService.uploadGoods(spu); return ResponseEntity.status(HttpStatus.NO_CONTENT).build();&#125; 2.6.2.Servicespu数据可以修改，但是SKU数据无法修改，因为有可能之前存在的SKU现在已经不存在了，或者以前的sku属性都不存在了。比如以前内存有4G，现在没了。 因此这里直接删除以前的SKU，然后新增即可。 代码： 12345678910111213141516171819202122232425262728293031@Transactional public void uploadGoods(Spu spu) &#123; if (spu.getId()==null)&#123; throw new LyException(ExceptionEnums.SPU_ID_NOT_NULL); &#125; //查询sku Sku sku = new Sku(); sku.setSpuId(spu.getId()); List&lt;Sku&gt; skuList = skuMapper.select(sku); if (!CollectionUtils.isEmpty(skuList)) &#123; //删除sku skuMapper.delete(sku); //获取sku的id集合 List&lt;Long&gt; ids = skuList.stream().map(Sku::getId).collect(Collectors.toList()); //删除stock stockMapper.deleteByIdList(ids); &#125; // 更新spu spu.setLastUpdateTime(new Date()); spu.setCreateTime(null); spu.setValid(null); spu.setSaleable(null); int count = spuMapper.updateByPrimaryKeySelective(spu); if(count!=1)&#123; throw new LyException(ExceptionEnums.GOODS_UPDATE_ERROR); &#125; //修改detail spuDetailMapper.updateByPrimaryKeySelective(spu.getSpuDetail()); //新增sku和stock saveSkuAndStock(spu); &#125; 2.6.3.mapper与以前一样。 2.7.商品删除 前端分析： 查看==Goods.vue== 点击删除deleteGood事件 后台 controller 在==GoodsController== 分析： 请求方式：PUT 请求路径：/spec/delete 请求参数：spuId 返回值：void 123456789101112/** * 通过spuId删除 * 涉及表：tb_spu，tb_sku，tb_stock，tb_spu_detail * @param spuId * @return */@ResponseBody@PutMapping("spu/delete/&#123;id&#125;")public ResponseEntity&lt;Void&gt; deleteGood(@PathVariable("id")Long spuId)&#123; goodsService.deleteGood(spuId); return ResponseEntity.status(HttpStatus.OK).build();&#125; service 在==GoodsService== 123456789101112131415161718192021222324252627282930313233343536@Transactionalpublic void deleteGood(Long spuId) &#123; //查询sku Sku sku = new Sku(); sku.setSpuId(spuId); //查询到skuList List&lt;Sku&gt; skuList = skuMapper.select(sku); //判断skuList是否存在 if (!CollectionUtils.isEmpty(skuList))&#123; //删除sku skuMapper.delete(sku); &#125; //得到sku的ids集合 List&lt;Long&gt; ids = skuList.stream().map(Sku::getId).collect(Collectors.toList()); //查询库存stocks List&lt;Stock&gt; stocks = stockMapper.selectByIdList(ids); //判断是否存在 if (!CollectionUtils.isEmpty(stocks)) &#123; //删除stocks stockMapper.deleteByIdList(ids); &#125; //查询商品详情 SpuDetail spuDetail = spuDetailMapper.selectByPrimaryKey(spuId); if (spuDetail!=null) &#123; //删除商品详情 spuDetailMapper.deleteByPrimaryKey(spuId); &#125; //查询spu Spu spu = spuMapper.selectByPrimaryKey(spuId); if (spu!=null) &#123; //删除spu spuMapper.deleteByPrimaryKey(spuId); &#125;&#125; 2.8.商品的上架下架 前端分析： 查看==Goods.vue== 上架 GoodsController 分析： 请求方式：PUT 请求路径：/spec/up/{id} 请求参数：spuId 返回值：void 12345678910/** * 商品上架 * @param spuId * @return */ @PutMapping("spu/up/&#123;id&#125;") public ResponseEntity&lt;Void&gt; upGood(@PathVariable("id")Long spuId)&#123; goodsService.upGood(spuId); return ResponseEntity.status(HttpStatus.OK).build(); &#125; GoodService 123456 public void upGood(Long spuId) &#123; Spu spu = new Spu(); spu.setSaleable(true); spu.setId(spuId); spuMapper.updateByPrimaryKeySelective(spu);&#125; 下架 前端分析： 查看==SpecParam.vue== 后台 GoodController 分析： 请求方式：POST 请求路径：spu/down/{id} 请求参数：spuId 返回值：void 12345678910/** * 商品下架 * @param spuId * @return */@PostMapping("spu/down/&#123;id&#125;")public ResponseEntity&lt;Void&gt; downGood(@PathVariable("id")Long spuId)&#123; goodsService.downGood(spuId); return ResponseEntity.status(HttpStatus.OK).build();&#125; GoodService 123456public void downGood(Long spuId) &#123; Spu spu = new Spu(); spu.setSaleable(false); spu.setId(spuId); spuMapper.updateByPrimaryKeySelective(spu);&#125; 3.搭建前台系统后台系统的内容暂时告一段落，有了商品，接下来我们就要在页面展示商品，给用户提供浏览和购买的入口，那就是我们的门户系统。 门户系统面向的是用户，安全性很重要，而且搜索引擎对于单页应用并不友好。因此我们的门户系统不再采用与后台系统类似的SPA（单页应用）。 依然是前后端分离，不过前端的页面会使用独立的html，在每个页面中使用vue来做页面渲染。 3.1.静态资源webpack打包多页应用配置比较繁琐，项目结构也相对复杂。这里为了简化开发（毕竟我们不是专业的前端人员），我们不再使用webpack，而是直接编写原生的静态HTML。 3.1.1.导入工程3.1.2.导入静态资源将课前资料中的leyou-portal解压，并复制到这个项目下 解压缩： 项目结构： 3.2.live-server没有webpack，我们就无法使用webpack-dev-server运行这个项目，实现热部署。 所以，这里我们使用另外一种热部署方式：live-server， 3.2.1.简介地址；https://www.npmjs.com/package/live-server 这是一款带有热加载功能的小型开发服务器。用它来展示你的HTML / JavaScript / CSS，但不能用于部署最终的网站。 3.2.2.安装和运行参数安装，使用npm命令即可，这里建议全局安装，以后任意位置可用 1npm install -g live-server 运行时，直接输入命令： 1live-server 另外，你可以在运行命令后，跟上一些参数以配置： --port=NUMBER - 选择要使用的端口，默认值：PORT env var或8080 --host=ADDRESS - 选择要绑定的主机地址，默认值：IP env var或0.0.0.0（“任意地址”） --no-browser - 禁止自动Web浏览器启动 --browser=BROWSER - 指定使用浏览器而不是系统默认值 --quiet | -q - 禁止记录 --verbose | -V - 更多日志记录（记录所有请求，显示所有侦听的IPv4接口等） --open=PATH - 启动浏览器到PATH而不是服务器root --watch=PATH - 用逗号分隔的路径来专门监视变化（默认值：观看所有内容） --ignore=PATH- 要忽略的逗号分隔的路径字符串（anymatch -compatible definition） --ignorePattern=RGXP-文件的正则表达式忽略（即.*\.jade）（不推荐使用赞成--ignore） --middleware=PATH - 导出要添加的中间件功能的.js文件的路径; 可以是没有路径的名称，也可以是引用middleware文件夹中捆绑的中间件的扩展名 --entry-file=PATH - 提供此文件（服务器根目录）代替丢失的文件（对单页应用程序有用） --mount=ROUTE:PATH - 在定义的路线下提供路径内容（可能有多个定义） --spa - 将请求从/ abc转换为/＃/ abc（方便单页应用） --wait=MILLISECONDS - （默认100ms）等待所有更改，然后重新加载 --htpasswd=PATH - 启用期待位于PATH的htpasswd文件的http-auth --cors - 为任何来源启用CORS（反映请求源，支持凭证的请求） --https=PATH - 到HTTPS配置模块的路径 --proxy=ROUTE:URL - 代理ROUTE到URL的所有请求 --help | -h - 显示简洁的使用提示并退出 --version | -v - 显示版本并退出 3.2.3.测试我们进入leyou-portal目录，输入命令： 1live-server --port=9002 3.3.域名访问现在我们访问只能通过：http://127.0.0.1:9002 我们希望用域名访问：http://www.leyou.com 第一步，修改hosts文件，添加一行配置： 1192.168.25.153 www.leyou.com 第二步，修改nginx配置，将www.leyou.com反向代理到192.168.25.153:9002 123456789101112131415161718192021 server&#123; listen 9002; server_name www.leyou.com; location /&#123; proxy_pass http://192.168.1.104:9002; &#125; &#125; server &#123; listen 80; server_name www.leyou.com; proxy_set_header X-Forwarded-Host $host; proxy_set_header X-Forwarded-Server $host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; location / &#123;proxy_pass http://192.168.1.104:9002;proxy_connect_timeout 600;proxy_read_timeout 600; &#125; &#125; 重新加载nginx配置：nginx -s reload 3.4.common.js为了方便后续的开发，我们在前台系统中定义了一些工具，放在了common.js中： 部分代码截图： 首先对axios进行了一些全局配置，请求超时时间，请求的基础路径，是否允许跨域操作cookie等 定义了对象 ly ，也叫leyou，包含了下面的属性： getUrlParam(key)：获取url路径中的参数 http：axios对象的别名。以后发起ajax请求，可以用ly.http.get() store：localstorage便捷操作，后面用到再详细说明 formatPrice：格式化价格，如果传入的是字符串，则扩大100被并转为数字，如果传入是数字，则缩小100倍并转为字符串 formatDate(val, pattern)：对日期对象val按照指定的pattern模板进行格式化 stringify：将对象转为参数字符串 parse：将参数字符串变为js对象]]></content>
      <categories>
        <category>项目实战-微服务商城</category>
      </categories>
      <tags>
        <tag>FastDFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务商城（十）——商品管理一]]></title>
    <url>%2Fday08-%E5%95%86%E5%93%81%E7%AE%A1%E7%90%86.html</url>
    <content type="text"><![CDATA[商品规格都在ly-item中操作 了解商品规格数据结构设计思路 实现商品规格查询 了解SPU和SKU数据结构设计思路 实现商品查询 了解商品新增的页面实现 独立编写商品新增后台功能 1.商品规格数据结构商品中都有属性，不同商品，属性往往不同，这一部分数据很重要，我们一起看看： 1.1.规格属性内容我们看下京东中商品的规格属性： 一款华为手机属性： 一款空调的属性： 我们发现，不同商品的属性名称竟然不同，假如我们要把属性放入一张表去保存，表字段该如何设计别着急，我们在看另一个手机属性： 三星手机： 我们发现，虽然不同商品，规格不同，但是同一分类的商品，比如都是手机，其规格是一致，但是值不一样，也就是说，商品的规格参数应该是与分类绑定。每一个分类都有统一的规格参数模板，但不同商品其参数值可能不同。 因此： 规格参数的名称（key）与值（value）应该分开来保存 一个分类，对应一套规格参数模板，只有规格参数key，没有值 一个分类对应多个商品，每个商品的规格值不同，每个商品对应一套规格的值 1.2.横表和竖表值我们暂且不管，新增商品时，在来填写规格参数值，我们考虑规格参数模板（key）该如何设计 来看下规格参数的结构： 规格数据首先要分组，组内再有不同的规格参数 不同分类，其分组名称不同 不同分类，组内属性也不同 这样就意味着:有多少分类，就有多少分组，至少有数千数据，组内属性也是一样，数量更多。如果按照传统设计，我们会以规格参数作为数据库字段名，如品牌、型号等都是字段，那么表的字段会无限多。这样的表称为横表。一条信息，描述所有数据。例如: id 品牌 型号 入网型号 上市时间 上市月份 机身颜色 机身长度 1 华为 P20 LLD_AL20 2018 2 红 190 我们不这么做，我们一条信息，只描述一条规格属性，也就是把规格参数作为字段的值，而非字段本身，这样设计称为竖表设计例如： id 分类id 参数名称 1 1 品牌 2 1 型号 3 1 入网型号 4 1 上市时间 5 1 上市月份 6 1 机身颜色 7 1 机身长度 不过，规格和规格组也要单独保存，都采用竖表设计。所以我们有两张表: 规格组: tb_ spec group 一个商品分类下有多个规格组 规格参数: tb_ spec_ param 一个规格组下，有多个规格参数 1.3.规格参数表1.3.1.规格组 规格参数分组tb_spec_group： 1234567CREATE TABLE `tb_spec_group` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &apos;主键&apos;, `cid` bigint(20) NOT NULL COMMENT &apos;商品分类id，一个分类下有多个规格组&apos;, `name` varchar(50) NOT NULL COMMENT &apos;规格组的名称&apos;, PRIMARY KEY (`id`), KEY `key_category` (`cid`)) ENGINE=InnoDB AUTO_INCREMENT=14 DEFAULT CHARSET=utf8 COMMENT=&apos;规格参数的分组表，每个商品分类下有多个规格参数组&apos; 规格组有3个字段 id：主键 cid：商品分类id，一个分类下有多个模板 name ：该规格组的名称 1.3.2.规格参数表1234567891011121314CREATE TABLE tb_spec_param ( `id` BIGINT(20) NOT NULL AUTO_INCREMENT COMMENT &apos;主键&apos;, `cid` BIGINT(20) NOT NULL COMMENT &apos;商品分类id&apos;, `group_id` BIGINT(20) NOT NULL , `name` VARCHAR(255) NOT NULL COMMENT &apos;参数名&apos;,`numeric` TINYINT(1) NOT NULL COMMENT &apos;是否为数字类型参数,true或false&apos;, `unit` VARCHAR(255) DEFAULT &apos;&apos; COMMENT &apos;数字类型参数单位,非数字类型可以为空&apos;, `generic` TINYINT(1) NOT NULL COMMENT &apos;是否为sku通用属性,true或false&apos;, `searching` TINYINT(1) NOT NULL COMMENT &apos;是否用于搜索过滤,true或false&apos;, `segments` VARCHAR(1000) DEFAULT &apos;&apos; COMMENT &apos;数值类型参数,如果需要搜索,则添加分段间隔值,如cpu频率间隔&apos;, PRIMARY KEY (`id`), KEY `key_group` (`group_id`), KEY `key_category` (`cid`)) ENGINE=INNODB AUTO_INCREMENT=24 DEFAULT CHARSET=utf8 COMMENT=&apos;规格参数组下的参数名&apos;; 1.3.2.1数值类型基本信息中由机身长度，宽度，厚度 我们有两个字段来描述： numberic：是否为数值类型 true：数字类型 false：不是数值类型 unit：参数的单位 ###1.3.2.2.打开一个搜索页，我们来看看过滤的条件： 你会发现，过滤条件中的屏幕尺寸、运行内存、网路、机身内存、电池容量、CPU核数等，在规格参数中都能找到： 也就是说，规格参数中的数据，将来会有一部分作为搜索条件来使用。我们可以在设计时，将这部分属性标记出来，将来做搜索的时候，作为过滤条件。 与搜索相关的两个字段： searching：标记是否用作过滤 true：用于过滤搜索 false：不用与过滤 segments：某些数值类型的参数，在搜索时需要按区间来划分，这里提前确定好划分区间 比如电池容量，0-2000mAh，2000mAh-3000mAh ， 3000mAh-4000mAh 乐优商城是一个全品类的电商网站，因此商品的种类多，没一件商品，其属性又有差别，为了更准确描述商品及细分差别，抽象出来两个概念，spu和sku： 1.3.2.3.通用属性 有一个generic属性，代表通用属性，我们在商品数据结构时在聊 2.商品规格参数管理2.1.页面实现页面比较复杂，这里就不带着大家去实现完整页面效果了，我们一起分析一下即可。 2.1.1.整体布局打开规格参数页面，看到如下内容： 点击手机后会去查表tb_spec_group中商品分类号为76的 因为规格是跟商品分类绑定的，因此首先会展现商品分类树，并且提示你要选择商品分类，才能看到规格参数的模板。一起了解下页面的实现： 这里使用v-layout来完成页面布局，并且添加了row属性，代表接下来的内容是行布局 可以看出页面分成3个部分： &lt;v-flex xs3&gt;：左侧，内部又分两部分：商品分类树和标题 v-card-title：标题部分，这里是提示信息，告诉用户要先选择分类，才能看到模板 v-tree：这里用到的是我们之前讲过的树组件，展示商品分类树，不过现在是假数据。 &lt;v-flex xs9 class=&quot;px-1&gt;&quot;： 右侧，内部是规格参数展示 2.1.2.右侧规格当我们点击一个分类时，最终要达到的效果 可以看到右侧分为上下两部分： 上部分：面包屑，显示当前选中分类 下部分：table，显示规格参数信息 可以看到右侧并不是我们熟悉的v-data-table，而是一个spec-group组件和spec-param组件，这是我们自定义的独立组件 在SpecGroup中定义了表格： 2.2规格组的查询2.2.1.规格组和规格参数的切换当我们点击规格参数组，表格中的数据会变为该组下的规格参数“ 两者怎么切换时如何实现的呢？ 我们看到spec-group和spec-pram中，通过v-show来控制显示，对应属性：showGroup showGroup为true，则展示分组；false，则展示组内参数 2.2.2.树节点的点击事件当我们点击树节点时，要将v-dialog打开，因此必须绑定一个点击事件： 我们来看下handleClick方法： 点击事件发生时，发生了两件事： 记录当前选中的节点，选中的就是商品分类 showGroup被置为true，则规格组就会显示 同时，我们把选中的节点（商品分类）的id传递给SpecGroup组件 2.2.3.页面查询规格组来看下SpecGroup.vue中实现： 我们查看页面控制台，可以看到请求已发 2.2.4.后端代码(规格组查询)在ly-item-interface中添加实体类： 实体类 123456789@Table(name = "tb_spec_group")@Datapublic class SpecGroup &#123; @Id @KeySql(useGeneratedKeys=true) private Long id; private Long cid; private String name;&#125; mapper 12public interface SpecGroupMapper extends Mapper&lt;SpecGroup&gt; &#123;&#125; controller 先分析下需要的东西，在页面的ajax请求中可以看出： 请求方式：查询，肯定是get 请求路径：/spec/groups/{cid} ，这里通过路径占位符传递商品分类的id 请求参数：商品分类id 返回结果：页面是直接把resp.data赋值给了specifications： 那么我们返回的应该是规格参数的字符串 代码： 1234567891011121314151617@RestController@RequestMapping("spec")public class SpecificationController &#123; @Autowired private SpecificationService specificationService; /** * 根据分类id查询规格组 * @param cid * @return */ @GetMapping("groups/&#123;cid&#125;") public ResponseEntity&lt;List&lt;SpecGroup&gt;&gt; queryGroupByCid(@PathVariable("cid")Long cid)&#123; return ResponseEntity.ok(specificationService.queryGroupByCid(cid)); &#125;&#125; service: 1234567891011121314151617@Servicepublic class SpecificationService &#123; @Autowired private SpecGroupMapper specGroupMapper; public List&lt;SpecGroup&gt; queryGroupByCid(Long cid) &#123; //查询条件 SpecGroup group = new SpecGroup(); group.setCid(cid); //查询 List&lt;SpecGroup&gt; list = specGroupMapper.select(group); if (CollectionUtils.isEmpty(list))&#123; //没查到 throw new LyException(ExceptionEnums.SPEC_GROUP_NOT_FOUND); &#125; return list; &#125;&#125; 页面访问测试： 查询的是tb_spec_group表 我们访问：http://api.leyou.com/api/item/spec/groups/76 然后在后台系统中测试： 2.3.规格组的增、删、改增删改的作业就留给大家去完成了。页面中接口都已定义，你要做的就是实现后台接口。 2.3.1.规格组的添加前端SpecGroup.vue： 注意： 我们在这里使用$qs.stringify来转换 JS的Object与QueryString，如此就可以将数据传输给后台 结果形如：name=jack&amp;age=21进行 ##controller： 在SpecificationController 12345678910/** * 新增规格组 * @param specGroup * @return */@PutMapping("group")public ResponseEntity&lt;Void&gt; addGroup(SpecGroup specGroup)&#123; specificationService.addGroup(specGroup); return ResponseEntity.status(HttpStatus.OK).build();&#125; ##service： 在SpecificationService 12345678/** * 新增规格组 * @param specGroup * @return */public void addGroup(SpecGroup specGroup) &#123; specGroupMapper.insert(specGroup);&#125; 2.3.2规格组的删除前端SpecGroup.vue controller 在SpecificationController 12345678910/** * 根据id删除规格组 * @param id * @return */@DeleteMapping("group/&#123;id&#125;")public ResponseEntity&lt;Void&gt; deleteGroup(@PathVariable("id")Long id)&#123; specificationService.deleteGroup(id); return ResponseEntity.status(HttpStatus.OK).build();&#125; service 在SpecificationService 123456789101112/** * 根据id删除规格组 * @param id */ public void deleteGroup(Long id) &#123; SpecGroup group = new SpecGroup(); group.setId(id); int delete = specGroupMapper.delete(group); if (delete!=1)&#123; throw new LyException(ExceptionEnums.SPEC_GROUP_DELETE_ERROR); &#125; &#125; 2.3.3规格组的修改前端SpecGroup.vue controller 在SpecificationController 1234567891011 /** * 修改规格组 * * @param specGroup * @return */@PutMapping("group")public ResponseEntity&lt;Void&gt; editGroup(SpecGroup specGroup) &#123; specificationService.editGroup(specGroup); return ResponseEntity.status(HttpStatus.OK).build();&#125; service 在SpecificationService 1234567891011/** * 修改规格组 * @param specGroup */ public void editGroup(SpecGroup specGroup) &#123; int update = specGroupMapper.updateByPrimaryKeySelective(specGroup); if (update!=1)&#123; throw new LyException(ExceptionEnums.SPEC_GROUP_UPLOAD_ERROR); &#125; &#125; 2.4.规格参数查询2.4.1.表格切换当我们点击规格组名称时，会切换到规格参数显示，在规格组中绑定了点击事件 前端页面 我们看下事件处理： 可以看到这里是使用了父子通信，子组件触发了select事件： 在看看父组件的事件绑定Specification.vue： selectGroup( ) 的方法处理： 这里我们记录选中的分组，并且标记设置为false，这样规格组就不显示，而是显示：SpecParam 并且我们把group也传递到spec-param组件中 2.4.2.页面查询规格参数我们来看==SpecParam.vue== 可以查看到控制台发起的请求： 2.4.3.后台实现 实体类 1234567891011121314151617@Data@Table(name = "tb_spec_param")public class SpecParam &#123; @Id @KeySql(useGeneratedKeys = true) private Long id; private Long cid; private Long groupId; private String name; @Column(name = "`numeric`") private Boolean numeric; private String unit; private Boolean generic; private Boolean searching; private String segments;&#125; @Column(name = “numeric“)，是将numeric变成字符串，==numeric==在sql是数据类型 controller 在==SpecificationController== 分析： 请求方式：GET 请求路径：/spec/params?gid= ( http://api.leyou.com/api/item/spec/params?gid=1) 请求参数：规格组gid ，规格分组cid 返回值：List 123456789/** * 通过规格组的gid查询规格参数 * @param gid * @return */@GetMapping("params")public ResponseEntity&lt;List&lt;SpecParam&gt;&gt; queryParamByGid(@RequestParam("gid")Long gid)&#123; return ResponseEntity.ok(specificationService.queryParamByGid(gid));&#125; service 在==SpecParamService== 123456789101112131415 /** * 通过规格组的gid查询规格参数 * @param gid * @return */ public List&lt;SpecParam&gt; queryParamByGid(Long gid) &#123; SpecParam param = new SpecParam(); param.setGroupId(gid); List&lt;SpecParam&gt; list = specParamMapper.select(param); if (CollectionUtils.isEmpty(list))&#123; throw new LyException(ExceptionEnums.SPEC_PARAM_NOT_FOUND); &#125; return list; &#125;&#125; mapper 12public interface SpecParamMapper extends Mapper&lt;SpecParam&gt; &#123;&#125; 2.5.规格参数添加，修改，删除2.5.1.规格参数的添加 前端分析： 查看==SpecParam.vue== 点击事件addParam()： 数据填写后提交事件save( ) ： 点击addParam事件：isEdi=false，restful：post 填写数据后，点击保存 通过==$qs.stringify==方法将数据转换成name=jack&amp;age=21………，这样就将数据传输给后台 controller 在==SpecificationController== 分析： 请求方式：POST 请求路径：/spec/param ( http://api.leyou.com/api/item/spec/param) 请求参数： 返回值：void 12345678910/** * 添加规格参数 * @param specParam * @return */ @PostMapping("param") public ResponseEntity&lt;Void&gt; addParam(SpecParam specParam)&#123; specificationService.addParam(specParam); return ResponseEntity.status(HttpStatus.OK).build(); &#125; service 在==SpecificationService== 1234567891011/** * 添加规格参数 * @param specParam * @return */public void addParam(SpecParam specParam) &#123; int insert = specParamMapper.insert(specParam); if (insert!=1)&#123; throw new LyException(ExceptionEnums.SPEC_PARAM_ADD_ERROR); &#125;&#125; 2.5.2.规格参数的修改 前端分析： 查看==SpecParam.vue== 点击修改editParam触发事件： this.param=param将数据回显this.isEdit = true传递到save事件后restful：put save事件 后台 controller 在==SpecificationController== 分析： 请求方式：PUT 请求路径：/spec/param (http://api.leyou.com/api/item/spec/param) 传递参数：specParam 返回值： 12345678910/** * 规格参数修改 * @param specParam * @return */@PutMapping("param")public ResponseEntity&lt;Void&gt; editParam(SpecParam specParam)&#123; specificationService.editParam(specParam); return ResponseEntity.status(HttpStatus.OK).build();&#125; service 在==SpecificationService== 1234567891011 /** * 规格参数修改 * @param specParam * @return */public void editParam(SpecParam specParam) &#123; int update = specParamMapper.updateByPrimaryKeySelective(specParam); if (update!=1)&#123; throw new LyException(ExceptionEnums.SPEC_PARAM_UPLOAD_ERROR); &#125;&#125; 2.5.3.规格参数的删除 前端分析： 查看==SpecParam.vue== 后台 controller 在==SpecificationController== 分析： 请求方式：DELETE 请求路径：/spec/param/{id} ( http://api.leyou.com/api/item/spec/param/id) 请求参数：id 返回值：void 12345678910/** * 根据id删除规格参数 * @param id * @return */@DeleteMapping("param")public ResponseEntity&lt;Void&gt; deleteParam(@PathVariable("id")Long id)&#123; specificationService.deleteParam(id); return ResponseEntity.status(HttpStatus.OK).build();&#125; service 在==SpecificationService== 12345678910111213 /** * 根据id删除规格参数 * @param id * @return */public void deleteParam(Long id) &#123; SpecParam param = new SpecParam(); param.setId(id); int delete = specParamMapper.delete(param); if (delete!=1)&#123; throw new LyException(ExceptionEnums.SPEC_PARAM_DELETE_ERROR); &#125;&#125; 3.SPU和SKU数据结构规格确定以后，就可以添加商品了,先看下数据库表 3.1.什么事SPU和SKUSPU：Standard Product Unit （标准产品单位） ，一组具有共同属性的商品集 SKU：Stock Keeping Unit（库存量单位），SPU商品集因具体特性不同而细分的每个商品 以图为例来看： 本页的 华为Mate10 就是一个商品集（SPU） 因为颜色、内存等不同，而细分出不同的Mate10，如亮黑色128G版。（SKU） 可以看出： SPU是一个抽象的商品集概念，为了方便后台的管理。 SKU才是具体要销售的商品，每一个SKU的价格、库存可能会不一样，用户购买的是SKU而不是SPU 3.2.数据库设计分析3.2.1.思考分析弄清楚了SPU和SKU的概念区分，接下来我们一起思考一下该如何设计数据库表。 首先来看SPU，大家一起思考下SPU应该有哪些字段来描述？ 123456789id:主键title：标题description：描述specification：规格packaging_list：包装after_service：售后服务comment：评价category_id：商品分类brand_id：品牌 似乎并不复杂，但是大家仔细思考一下，商品的规格字段你如何填写？ 不同商品的规格不一定相同，数据库中要如何保存？ 再看下SKU，大家觉得应该有什么字段？ 12345678id：主键spu_id：关联的spuprice：价格images：图片stock：库存颜色？内存？硬盘？ 碰到难题了，不同的商品分类，可能属性是不一样的，比如手机有内存，衣服有尺码，我们是全品类的电商网站，这些不同的商品的不同属性，如何设计到一张表中？ 另外，我们之前说过商品的规格字段分为key和value保存，key已经设计完成，那么值要在商品中保存，你如何填写？ 商品规格参数已经与分类绑定，但是值不一定相同，数据库中如何保存？ 也就是说，现在的问题有两个： 规格参数值如何保存 sku的属性是动态变化的 3.2.2.SKU的特有属性SPU中会有一些特殊属性，用来区分不同的SKU，我们称为SKU特有属性。如华为META10的颜色、内存属性。 不同种类的商品，一个手机，一个衣服，其SKU属性不相同。 同一种类的商品，比如都是衣服，SKU属性基本是一样的，都是颜色、尺码等。 这样说起来，似乎SKU的特有属性也是与分类相关的？事实上，仔细观察你会发现，SKU的特有属性是商品规格参数的一部分： 也就是说，我们没必要单独对SKU的特有属性进行设计，它可以看做是规格参数中的一部分。这样规格参数中的属性可以标记成两部分： 所有sku共享的规格属性（称为全局属性），我们记录在spu表中 每个sku不同的规格属性（称为特有属性），我们记录到sku表中 回一下之前 我们设计的tb_spec_param表，是不是有一个字段，名为generic，标记通用和特有属性，就是为了这里使用。 3.3.SPU表3.3.1.表结构1234567891011121314CREATE TABLE `tb_spu` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &apos;spu id&apos;, `name` varchar(128) NOT NULL DEFAULT &apos;&apos; COMMENT &apos;商品名称&apos;, `sub_title` varchar(256) DEFAULT &apos;&apos; COMMENT &apos;子标题&apos;, `cid1` bigint(20) NOT NULL COMMENT &apos;1级类目id&apos;, `cid2` bigint(20) NOT NULL COMMENT &apos;2级类目id&apos;, `cid3` bigint(20) NOT NULL COMMENT &apos;3级类目id&apos;, `brand_id` bigint(20) NOT NULL COMMENT &apos;商品所属品牌id&apos;, `saleable` tinyint(1) NOT NULL DEFAULT &apos;1&apos; COMMENT &apos;是否上架，0下架，1上架&apos;, `valid` tinyint(1) NOT NULL DEFAULT &apos;1&apos; COMMENT &apos;是否有效，0已删除，1有效&apos;, `create_time` datetime DEFAULT NULL COMMENT &apos;添加时间&apos;, `last_update_time` datetime DEFAULT NULL COMMENT &apos;最后修改时间&apos;, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=195 DEFAULT CHARSET=utf8 COMMENT=&apos;spu表，该表描述的是一个抽象性的商品，比如 iphone8&apos; 与我们前面分析的基本类似，但是似乎少了一些字段，比如商品描述。 我们做了表的垂直拆分，将SPU的详情放到了另一张表：tb_spu_detail 123456789CREATE TABLE `tb_spu_detail` ( `spu_id` bigint(20) NOT NULL, `description` text COMMENT &apos;商品描述信息&apos;, `generic_spec` varchar(2048) NOT NULL DEFAULT &apos;&apos; COMMENT &apos;通用规格参数数据&apos;, `special_spec` varchar(1024) NOT NULL COMMENT &apos;特有规格参数及可选值信息，json格式&apos;, `packing_list` varchar(1024) DEFAULT &apos;&apos; COMMENT &apos;包装清单&apos;, `after_service` varchar(1024) DEFAULT &apos;&apos; COMMENT &apos;售后服务&apos;, PRIMARY KEY (`spu_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 这张表中的数据都比较大，为了不影响主表的查询效率我们拆分出这张表。 需要注意的是这两个字段：geneirc_spec和special_spec。 3.3.2.SPU中的规格参数前面讲过规格参数与商品分类绑定，一个分类下的所有SPU具有类似的规格参数。SPU下的SKU可能会有不同的规格参数，因此我们计划是这样： SPU中保存全局的规格参数信息。 SKU中保存特有规格参数。 3.3.2.1.generic_spec字段首先是generice_spec，其中保存全部规格参数信息的值，使用json格式 整体来看： json结构，其中都是键值对： key：对应的规格组spec_param的id value：对应规格参数的值 3.3.2.3.special_spec字段我们说spu中只保存通用规格参数，那么为什么有多出了一个special_spec字段？ 以手机为例，品牌、操作系统等肯定是全局属性，内存、颜色等肯定是特有属性。 当你确定了一个SPU，比如小米的：红米4X 全局属性举例： 12品牌：小米型号：红米4X 特有属性举例： 123颜色：[香槟金, 樱花粉, 磨砂黑]内存：[2G, 3G]机身存储：[16GB, 32GB] 颜色、内存、机身存储，作为sku特有属性，key虽然一样，但是spu下的每一个sku，其值都不一样，所以值会有很多，形成数组。 我们在spu中，会把特有属性的所有值记录下来，形成一个数组： 里面又有哪些内容？ 看数据格式： 也是json结构： key：规格参数id value：spu属性的数组 那么问题来了：特有规格参数应该在sku中记录才对，为什么在spu中也要记录一份？ 因为我们有时候需要把所有规格参数查询出来，而不是只查询一个sku中属性。比如，商品详情页展示可选的规格参数： 刚好符合我们的结构，这样页面渲染就非常方便。 3.2.SKU表3.2.1.表结构1234567891011121314CREATE TABLE `tb_sku` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &apos;sku id&apos;, `spu_id` bigint(20) NOT NULL COMMENT &apos;spu id&apos;, `title` varchar(256) NOT NULL COMMENT &apos;商品标题&apos;, `images` varchar(1024) DEFAULT &apos;&apos; COMMENT &apos;商品的图片，多个图片以‘,’分割&apos;, `price` bigint(15) NOT NULL DEFAULT &apos;0&apos; COMMENT &apos;销售价格，单位为分&apos;, `indexes` varchar(32) DEFAULT &apos;&apos; COMMENT &apos;特有规格属性在spu属性模板中的对应下标组合（索引）&apos;, `own_spec` varchar(1024) DEFAULT &apos;&apos; COMMENT &apos;sku的特有规格参数键值对，json格式，反序列化时请使用linkedHashMap，保证有序&apos;, `enable` tinyint(1) NOT NULL DEFAULT &apos;1&apos; COMMENT &apos;是否有效，0无效，1有效&apos;, `create_time` datetime NOT NULL COMMENT &apos;添加时间&apos;, `last_update_time` datetime NOT NULL COMMENT &apos;最后修改时间&apos;, PRIMARY KEY (`id`), KEY `key_spu_id` (`spu_id`) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=27359021729 DEFAULT CHARSET=utf8 COMMENT=&apos;sku表,该表表示具体的商品实体,如黑色的 64g的iphone 8&apos; 还有一张表，代表库存（读写很高）： 1234567CREATE TABLE `tb_stock` ( `sku_id` bigint(20) NOT NULL COMMENT &apos;库存对应的商品sku id&apos;, `seckill_stock` int(9) DEFAULT &apos;0&apos; COMMENT &apos;可秒杀库存&apos;, `seckill_total` int(9) DEFAULT &apos;0&apos; COMMENT &apos;秒杀总数量&apos;, `stock` int(9) NOT NULL COMMENT &apos;库存数量&apos;, PRIMARY KEY (`sku_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&apos;库存表，代表库存，秒杀库存等信息&apos; 问题：为什么要将库存独立一张表？ 因为库存字段写频率较高，而SKU的其它字段以读为主，因此我们将两张表分离，读写不会干扰。 特别需要注意的是sku表中的indexes字段和own_spec字段。sku中应该保存特有规格参数的值，就在这两个字段中。 3.2.2.sku中的特有规格参数3.2.2.1.indexes字段在SPU表中，已经对特有规格参数及可选项进行了保存，结构如下： 123456789101112131415&#123; "机身颜色": [ "香槟金", "樱花粉", "磨砂黑" ], "内存": [ "2GB", "3GB" ], "机身存储": [ "16GB", "32GB" ]&#125; 这些特有属性如果排列组合，会产生12个不同的SKU，而不同的SKU，其属性就是上面备选项中的一个。 比如： 红米4X，香槟金，2GB内存，16GB存储 红米4X，磨砂黑，2GB内存，32GB存储 你会发现，每一个属性值，对应于SPUoptions数组的一个选项，如果我们记录下角标，就是这样： 红米4X，0,0,0 红米4X，2,0,1 既然如此，我们是不是可以将不同角标串联起来，作为SPU下不同SKU的标示。这就是我们的indexes字段。 这个设计在商品详情页会特别有用： 当用户点击选中一个特有属性，你就能根据 角标快速定位到sku。 3.2.2.2.own_spec字段看结构： 1&#123;"机身颜色":"香槟金","内存":"2GB","机身存储":"16GB"&#125; 保存的是特有属性的键值对。 SPU中保存的是可选项，但不确定具体的值，而SKU中的保存的就是具体的键值对了。 这样，在页面展示规格参数信息时，就可以根据key来获取值，用于显示。 3.3.导入图片信息现在商品表中虽然有数据，但是所有的图片信息都是无法访问的，我们需要把图片导入到虚拟机： 首先，把课前资料提供的数据上传到虚拟机下：/leyou/static目录： 然后，使用命令解压缩： 1unzip images.zip 修改Nginx配置，使nginx反向代理这些图片地址： 1vim /opt/nginx/config/nginx.conf 修改成如下配置： 12345678910111213141516171819server &#123; listen 80; server_name image.leyou.com; # 监听域名中带有group的，交给FastDFS模块处理 location ~/group([0-9])/ &#123; ngx_fastdfs_module; &#125; # 将其它图片代理指向本地的/leyou/static目录 location / &#123; root /leyou/static/; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125;&#125; 4.商品查询4.1.效果预览接下来，我们实现商品管理的页面，先看下我们要实现的效果： 可以看出整体是一个table，然后有新增按钮。是不是跟昨天写品牌管理很像？ 模板代码在分别在Goods.vue ——从0开始（可看前端自己写步骤）接下来，我们自己来实现一下，新建两个组件：MyGoods.vue和MyGoodsForm.vue 内容先随意： 1234567891011121314151617181920&lt;template&gt; &lt;v-card&gt; MyGoods &lt;/v-card&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: &quot;my-goods&quot;, data() &#123; return &#123; &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 然后修改menu.js,新建一个菜单： 修改router/index.js，添加一个路由： 预览一下： —–页面实现（可看前端自己写步骤）1.页面基本表格商品列表页与品牌列表页几乎一样，我们可以直接去复制一份过来，然后进行一些修改。 首先，字段不一样，商品列表也展示的SPU信息，包含以下字段： 1234id：title：标题cname：商品分类名称bname：品牌名称 完整代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142&lt;template&gt; &lt;v-card&gt; &lt;v-card-title&gt; &lt;v-btn color="primary" @click="addGoods"&gt;新增商品&lt;/v-btn&gt; &lt;!--搜索框，与search属性关联--&gt; &lt;v-spacer/&gt; &lt;v-text-field label="输入关键字搜索" v-model.lazy="search" append-icon="search" hide-details/&gt; &lt;/v-card-title&gt; &lt;v-divider/&gt; &lt;v-data-table :headers="headers" :items="goodsList" :search="search" :pagination.sync="pagination" :total-items="totalGoods" :loading="loading" class="elevation-1" &gt; &lt;template slot="items" slot-scope="props"&gt; &lt;td&gt;&#123;&#123; props.item.id &#125;&#125;&lt;/td&gt; &lt;td class="text-xs-center"&gt;&#123;&#123; props.item.title &#125;&#125;&lt;/td&gt; &lt;td class="text-xs-center"&gt;&#123;&#123;props.item.cname&#125;&#125;&lt;/td&gt; &lt;td class="text-xs-center"&gt;&#123;&#123; props.item.bname &#125;&#125;&lt;/td&gt; &lt;td class="justify-center layout"&gt; &lt;v-btn color="info" @click="editGoods(props.item)"&gt;编辑&lt;/v-btn&gt; &lt;v-btn color="warning"&gt;删除&lt;/v-btn&gt; &lt;v-btn &gt;下架&lt;/v-btn&gt; &lt;/td&gt; &lt;/template&gt; &lt;/v-data-table&gt; &lt;!--弹出的对话框--&gt; &lt;v-dialog max-width="500" v-model="show" persistent&gt; &lt;v-card&gt; &lt;!--对话框的标题--&gt; &lt;v-toolbar dense dark color="primary"&gt; &lt;v-toolbar-title&gt;&#123;&#123;isEdit ? '修改' : '新增'&#125;&#125;商品&lt;/v-toolbar-title&gt; &lt;v-spacer/&gt; &lt;!--关闭窗口的按钮--&gt; &lt;v-btn icon @click="closeWindow"&gt;&lt;v-icon&gt;close&lt;/v-icon&gt;&lt;/v-btn&gt; &lt;/v-toolbar&gt; &lt;!--对话框的内容，表单--&gt; &lt;v-card-text class="px-5"&gt; &lt;my-goods-form :oldGoods="oldGoods" /&gt; &lt;/v-card-text&gt; &lt;/v-card&gt; &lt;/v-dialog&gt; &lt;/v-card&gt;&lt;/template&gt;&lt;script&gt; // 导入自定义的表单组件 import MyGoodsForm from './MyGoodsForm' export default &#123; name: "my-goods", data() &#123; return &#123; search: '', // 搜索过滤字段 totalGoods: 0, // 总条数 goodsList: [], // 当前页品牌数据 loading: true, // 是否在加载中 pagination: &#123;&#125;, // 分页信息 headers: [ &#123;text: 'id', align: 'center', value: 'id'&#125;, &#123;text: '标题', align: 'center', sortable: false, value: 'title'&#125;, &#123;text: '商品分类', align: 'center', sortable: false, value: 'cname'&#125;, &#123;text: '品牌', align: 'center', value: 'bname', sortable: false,&#125;, &#123;text: '操作', align: 'center', sortable: false&#125; ], show: false,// 控制对话框的显示 oldGoods: &#123;&#125;, // 即将被编辑的商品信息 isEdit: false, // 是否是编辑 &#125; &#125;, mounted() &#123; // 渲染后执行 // 查询数据 this.getDataFromServer(); &#125;, watch: &#123; pagination: &#123; // 监视pagination属性的变化 deep: true, // deep为true，会监视pagination的属性及属性中的对象属性变化 handler() &#123; // 变化后的回调函数，这里我们再次调用getDataFromServer即可 this.getDataFromServer(); &#125; &#125;, search: &#123; // 监视搜索字段 handler() &#123; this.getDataFromServer(); &#125; &#125; &#125;, methods: &#123; getDataFromServer() &#123; // 从服务的加载数的方法。 // 发起请求 this.$http.get("/item/spu/page", &#123; params: &#123; key: this.search, // 搜索条件 page: this.pagination.page,// 当前页 rows: this.pagination.rowsPerPage,// 每页大小 sortBy: this.pagination.sortBy,// 排序字段 desc: this.pagination.descending// 是否降序 &#125; &#125;).then(resp =&gt; &#123; // 这里使用箭头函数 this.goodsList = resp.data.items; this.totalGoods = resp.data.total; // 完成赋值后，把加载状态赋值为false this.loading = false; &#125;) &#125;, addGoods() &#123; // 修改标记 this.isEdit = false; // 控制弹窗可见： this.show = true; // 把oldBrand变为null this.oldBrand = null; &#125;, editGoods(oldGoods)&#123; // 修改标记 this.isEdit = true; // 控制弹窗可见： this.show = true; // 获取要编辑的brand this.oldGoods = oldGoods; &#125;, closeWindow()&#123; // 重新加载数据 this.getDataFromServer(); // 关闭窗口 this.show = false; &#125; &#125;, components:&#123; MyGoodsForm &#125; &#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 主要的改动点： 页面的v-data-table中的属性绑定修改。items指向goodsList，totalItems指向totalGoods 页面渲染的字段名修改：字段改成商品的SPU字段：id、title，cname(商品分类名称),bname（品牌名称） data属性修改了以下属性： goodsList：当前页商品数据 totalGoods：商品总数 headers：头信息，需要修改头显示名称 oldGoods：准备要修改的商品 加载数据的函数：getDataFromServer，请求的路径进行了修改，另外去除了跟排序相关的查询。SPU查询不排序 新增商品的事件函数：清除了一些数据查询接口，只保留弹窗 查看效果： 因为没有编写查询功能，表格一直处于loading状态。 接下来看弹窗： 2.上下架状态按钮另外，似乎页面少了对上下架商品的过滤，在原始效果图中是有的： 这在Vuetify中是一组按钮，我们查看帮助文档： 查看实例得到以下信息： v-btn：一个按钮 v-btn-toggle：按钮组，内部可以有多个按钮，点击切换，有以下属性： multiple：是否支持多选，默认是false value：选中的按钮的值，如果是多选，结果是一个数组；单选，结果是点击的v-btn中的value值，因此按钮组的每个btn都需要指定value属性 改造页面： 首先在data中定义一个属性，记录按钮的值。 1234filter:&#123; saleable: false, // 上架还是下架 search: '', // 搜索过滤字段&#125; 这里我们的做法是定义一个filter属性，内部在定义search来关联过滤字段，saleable来关联上下架情况。 这样watch就必须监听filter，而不是只监听search了： 123456filter: &#123;// 监视搜索字段 handler() &#123; this.getDataFromServer(); &#125;, deep:true&#125; 另外，页面中与search有关的所有字段都需要修改成filter.search: 12&lt;!--搜索框，与search属性关联--&gt;&lt;v-text-field label="输入关键字搜索" v-model.lazy="filter.search" append-icon="search" hide-details/&gt; 然后，在页面中添加按钮组： 1234567891011121314 &lt;v-flex xs3&gt; 状态： &lt;v-btn-toggle v-model="filter.saleable"&gt; &lt;v-btn flat&gt; 全部 &lt;/v-btn&gt; &lt;v-btn flat :value="true"&gt; 上架 &lt;/v-btn&gt; &lt;v-btn flat :value="false"&gt; 下架 &lt;/v-btn&gt; &lt;/v-btn-toggle&gt;&lt;/v-flex&gt; 最后，不要忘了在查询时，将saleable携带上： 12345678910111213141516getDataFromServer() &#123; // 从服务的加载数的方法。 // 发起请求 this.$http.get("/item/spu/page", &#123; params: &#123; key: this.filter.search, // 搜索条件 saleable: this.filter.saleable, // 上下架 page: this.pagination.page,// 当前页 rows: this.pagination.rowsPerPage,// 每页大小 &#125; &#125;).then(resp =&gt; &#123; // 这里使用箭头函数 this.goodsList = resp.data.items; this.totalGoods = resp.data.total; // 完成赋值后，把加载状态赋值为false this.loading = false; &#125;)&#125; 4.2.页面请求先看完整页面结构： 并且在Vue实例挂载时就会发起查询 查询商品数据的请求： ​ 4.4.后台提供接口页面已经准备好，接下来在后台提供分页查询SPU的功能： 4.4.1.实体类 SPU 123456789101112131415161718@Table(name = "tb_spu")@Datapublic class Spu &#123; @Id @KeySql(useGeneratedKeys = true) private Long id; private Long brandId; private Long cid1;// 1级类目 private Long cid2;// 2级类目 private Long cid3;// 3级类目 private String title;// 标题 private String subTitle;// 子标题 private Boolean saleable;// 是否上架 private Boolean valid;// 是否有效，逻辑删除用 private Date createTime;// 创建时间 private Date lastUpdateTime;// 最后修改时间 // 省略getter和setter&#125; SPU详情 123456789101112@Data@Table(name="tb_spu_detail")public class SpuDetail &#123; @Id private Long spuId;// 对应的SPU的id private String description;// 商品描述 private String specialSpec;// 商品特殊规格的名称及可选值模板 private String genericSpec;// 商品的全局规格属性 private String packingList;// 包装清单 private String afterService;// 售后服务 // 省略getter和setter&#125; 4.4.2.controller先分析： 请求方式：GET 请求路径：/spu/page 请求参数： page：当前页 rows：每页大小 key：过滤条件 saleable：上架或下架 返回结果：商品SPU的分页信息PageResult&lt;Spu&gt; 。 要注意，页面展示的是商品分类和品牌名称，而数据库中保存的是id，怎么办？ 我们可以拓展cname和bname属性，写到ly-item-interface 12345678910111213141516171819202122232425262728293031@Table(name = "tb_spu")@Datapublic class Spu &#123; @Id @KeySql(useGeneratedKeys = true) private Long id; private Long brandId; private Long cid1;// 1级类目 private Long cid2;// 2级类目 private Long cid3;// 3级类目 private String title;// 标题 private String subTitle;// 子标题 private Boolean saleable;// 是否上架 //返回字段的时候忽略lastUpdateTime @JsonIgnore private Boolean valid;// 是否有效，逻辑删除用 private Date createTime;// 创建时间 //返回字段的时候忽略lastUpdateTime @JsonIgnore private Date lastUpdateTime;// 最后修改时间 @Transient//不是数据库字段的 private String bname; @Transient//不是数据库字段的 private String cname; // 省略getter和setter &#125; 编写controller代码： 我们把与商品相关的一切业务接口都放到一起，起名为GoodsController，业务层也是这样 12345678910111213141516/** * 分页查询 * @param page * @param rows * @param saleable * @param key * @return */@GetMapping("page")public ResponseEntity&lt;PageResult&lt;Spu&gt;&gt; querySpuByPage( @RequestParam(value = "page", defaultValue = "1") Integer page, @RequestParam(value = "rows", defaultValue = "5") Integer rows, @RequestParam(value = "saleable", required = false) Boolean saleable, @RequestParam(value = "key", required = false) String key)&#123; return ResponseEntity.ok(goodsService.querySpuByPage(page,rows,saleable,key));&#125; 4.4.3.service所有商品相关的业务（包括SPU和SKU）放到一个业务下：GoodsService。 1234567891011121314151617181920212223242526272829public PageResult&lt;Spu&gt; querySpuByPage(Integer page, Integer rows, Boolean saleable, String key) &#123; //1.分页 PageHelper.startPage(page,rows); //2.过滤 Example example = new Example(Spu.class); Example.Criteria criteria = example.createCriteria(); //3.搜索过滤字段 if (StringUtils.isNotBlank(key))&#123; criteria.andLike("title","%"+key+"%"); &#125; //4.上下架过滤 if (saleable!=null)&#123; criteria.andEqualTo("saleable",saleable); &#125; //5.默认排序 example.setOrderByClause("last_update_time DESC"); //6.查询 List&lt;Spu&gt; spus = spuMapper.selectByExample(example); //7.判断 if (CollectionUtils.isEmpty(spus))&#123; throw new LyException(ExceptionEnums.GOODS_NOT_FOUND); &#125; //8.解析分类和品牌的名称(方法抽离) loadCategoryAndBrandName(spus); //9.解析分页结果 PageInfo&lt;Spu&gt; info = new PageInfo&lt;&gt;(spus); return new PageResult&lt;&gt;(info.getTotal(),spus);&#125; loadCategoryAndBrandName方法 在GoodsService中添加loadCategoryAndBrandName方法，用于查询商品分类和商品的品牌： 12345678910111213141516//解析分类和品牌的名称 private void loadCategoryAndBrandName(List&lt;Spu&gt; spus) &#123; for (Spu spu : spus) &#123; //1.处理分类名称 List&lt;String&gt; cname = categoryService.queryByIds(Arrays.asList( spu.getCid1(), spu.getCid2(), spu.getCid3())) .stream().map(Category::getName).collect(Collectors.toList()); //1.1集合拼成字符串，通过“/”分隔 spu.setCname(StringUtils.join(cname,"/")); //2.处理品牌 String bname = brandService.queryById(spu.getBrandId()).getName(); spu.setBname(bname); &#125; &#125; .stream().map(Category::getName).collect(Collectors.toList());得到catgory的name输出流 queryByIds()方法 查询商品分类名称，在CategoryService中添加 selectByIdList是查询id的集合，必须在CategoryMapper中扩展IdListMapper 123456789101112/** * 根据ids集合查询商品分类 * @param ids * @return */public List&lt;Category&gt; queryByIds(List&lt;Long&gt; ids)&#123; List&lt;Category&gt; list = categoryMapper.selectByIdList(ids); if (CollectionUtils.isEmpty(list))&#123; throw new LyException(ExceptionEnums.CATEGORY_NOT_FOND); &#125; return list;&#125; 修改CategoryMapper 12345//IdListMapper&lt;T,PK&gt; T:要查询的pojo，PK:是什么数据类型public interface CategoryMapper extends Mapper&lt;Category&gt;,IdListMapper&lt;Category,Long&gt;&#123; @Select("SELECT * FROM tb_category WHERE id IN (SELECT category_id FROM tb_category_brand WHERE brand_id = #&#123;bid&#125;)") List&lt;Category&gt; queryCategoryListByBid(@Param("bid")Long bid);&#125; 4.4.4.mapper12public interface SpuMapper extends Mapper&lt;Spu&gt; &#123;&#125; 4.5.测试刷新页面，查看效果： 基本与预览的效果一致，OK！]]></content>
      <categories>
        <category>项目实战-微服务商城</category>
      </categories>
      <tags>
        <tag>FastDFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务商城（九）——品牌管理]]></title>
    <url>%2Fday07-%E5%93%81%E7%89%8C%E7%AE%A1%E7%90%86.html</url>
    <content type="text"><![CDATA[0.学习目标 独立实现品牌新增 实现图片上传 了解FastDFS的安装 使用FastDFS客户端实现上传 1.品牌的新增（自己看）昨天我们完成了品牌的查询，接下来就是新增功能。 1.1.页面实现1.1.1.初步编写弹窗当我们点击新增按钮，应该出现一个弹窗，然后在弹窗中出现一个表格，我们就可以填写品牌信息了。 我们查看Vuetify官网，弹窗是如何实现： 另外，我们可以通过文档看到对话框的一些属性： value：控制窗口的可见性，true可见，false，不可见 max-width：控制对话框最大宽度 scrollable ：是否可滚动，要配合v-card来使用，默认是false persistent ：点击弹窗以外的地方不会关闭弹窗，默认是false 现在，我们来使用一下。 首先，我们在data中定义一个show属性，来控制对话框的显示状态： 然后，在页面添加一个v-dialog 12345678910111213&lt;!--弹出的对话框--&gt;&lt;v-dialog max-width="500" v-model="show" persistent&gt; &lt;v-card&gt; &lt;!--对话框的标题--&gt; &lt;v-toolbar dense dark color="primary"&gt; &lt;v-toolbar-title&gt;新增品牌&lt;/v-toolbar-title&gt; &lt;/v-toolbar&gt; &lt;!--对话框的内容，表单--&gt; &lt;v-card-text class="px-5"&gt; 我是表单 &lt;/v-card-text&gt; &lt;/v-card&gt;&lt;/v-dialog&gt; 说明： 我们给dialog指定了3个属性，分别是 max-width：限制宽度 v-model：value值双向绑定到show变量，用来控制窗口显示 persisitent：控制窗口不会被意外关闭 因为可滚动需要配合v-card使用，因此我们在对话框中加入了一个v-card 在v-card的头部添加了一个 v-toolbar，作为窗口的头部，并且写了标题为：新增品牌 dense：紧凑显示 dark：黑暗主题 color：颜色，primary就是整个网站的主色调，蓝色 在v-card的内容部分，暂时空置，等会写表单 class=“px-5&quot;：vuetify的内置样式，含义是padding的x轴设置为5，这样表单内容会缩进一些，而不是顶着边框 基本语法：{property}{direction}-{size} property：属性，有两种padding和margin p：对应padding m：对应margin direction：只padding和margin的作用方向， t - 对应margin-top或者padding-top属性 b - 对应margin-bottom or padding-bottom l - 对应margin-left or padding-left r - 对应margin-right or padding-right x - 同时对应*-left和*-right属性 y - 同时对应*-top和*-bottom属性 size：控制空间大小，基于$spacer进行倍增，$spacer默认是16px 0：将margin或padding的大小设置为0 1 - 将margin或者padding属性设置为$spacer * .25 2 - 将margin或者padding属性设置为$spacer * .5 3 - 将margin或者padding属性设置为$spacer 4 - 将margin或者padding属性设置为$spacer * 1.5 5 - 将margin或者padding属性设置为$spacer * 3 1.1.2.实现弹窗的可见和关闭 窗口可见 接下来，我们要在点击新增品牌按钮时，将窗口显示，因此要给新增按钮绑定事件。 1&lt;v-btn color="primary" @click="addBrand"&gt;新增品牌&lt;/v-btn&gt; 然后定义一个addBrand方法： 1234addBrand()&#123; // 控制弹窗可见： this.show = true;&#125; 效果： 窗口关闭 现在，悲剧发生了，因为我们设置了persistent属性，窗口无法被关闭了。除非把show属性设置为false 因此我们需要给窗口添加一个关闭按钮： 1234567&lt;!--对话框的标题--&gt;&lt;v-toolbar dense dark color="primary"&gt; &lt;v-toolbar-title&gt;新增品牌&lt;/v-toolbar-title&gt; &lt;v-spacer/&gt; &lt;!--关闭窗口的按钮--&gt; &lt;v-btn icon @click="closeWindow"&gt;&lt;v-icon&gt;close&lt;/v-icon&gt;&lt;/v-btn&gt;&lt;/v-toolbar&gt; 并且，我们还给按钮绑定了点击事件，回调函数为closeWindow。 接下来，编写closeWindow函数： 1234closeWindow()&#123; // 关闭窗口 this.show = false;&#125; 效果： 1.1.3.新增品牌的表单页接下来就是写表单了。我们有两种选择： 直接在dialog对话框中编写表单代码 另外编写一个组件，组件内写表单代码。然后在对话框引用组件 选第几种？ 我们选第二种方案，优点： 表单代码独立组件，可拔插，方便后期的维护。 代码分离，可读性更好。 我们新建一个MyBrandForm.vue组件： 将MyBrandForm引入到MyBrand中，这里使用局部组件的语法： 先导入自定义组件： 12// 导入自定义的表单组件import MyBrandForm from './MyBrandForm' 然后通过components属性来指定局部组件： 123components:&#123; MyBrandForm&#125; 然后在页面中引用： 页面效果： 1.1.4.编写表单1.1.4.1.表单查看文档，找到关于表单的部分： v-form，表单组件，内部可以有许多输入项。v-form有下面的属性： value：true，代表表单验证通过；false，代表表单验证失败 v-form提供了两个方法： reset：重置表单数据 validate：校验整个表单数据，前提是你写好了校验规则。返回Boolean表示校验成功或失败 我们在data中定义一个valid属性，跟表单的value进行双向绑定，观察表单是否通过校验，同时把等会要跟表单关联的品牌brand对象声明出来： 1234567891011121314export default &#123; name: "my-brand-form", data() &#123; return &#123; valid:false, // 表单校验结果标记 brand:&#123; name:'', // 品牌名称 letter:'', // 品牌首字母 image:'',// 品牌logo categories:[], // 品牌所属的商品分类数组 &#125; &#125; &#125;&#125; 然后，在页面先写一个表单： 123&lt;v-form v-model="valid"&gt;&lt;/v-form&gt; 1.1.4.2.文本框我们的品牌总共需要这些字段： 名称 首字母 商品分类，有很多个 LOGO 表单项主要包括文本框、密码框、多选框、单选框、文本域、下拉选框、文件上传等。思考下我们的品牌需要哪些？ 文本框：品牌名称、品牌首字母都属于文本框 文件上传：品牌需要图片，这个是文件上传框 下拉选框：商品分类提前已经定义好，这里需要通过下拉选框展示，提供给用户选择。 先看文本框，昨天已经用过的，叫做v-text-field： 查看文档，v-text-field有以下关键属性： append-icon：文本框后追加图标，需要填写图标名称。无默认值 clearable：是否添加一个清空图标，点击会清空文本框。默认是false color：颜色 counter：是否添加一个文本计数器，在角落显示文本长度，指定true或允许的组大长度。无默认值 dark：是否应用黑暗色调，默认是false disable：是否禁用，默认是false flat：是否移除默认的动画效果，默认是false full-width：指定宽度为全屏，默认是false hide-details：是否因此错误提示，默认是false hint：输入框的提示文本 label：输入框的标签 multi-line：是否转为文本域，默认是false。文本框和文本域可以自由切换 placeholder：输入框占位符文本，focus后消失 required：是否为必填项，如果是，会在label后加*，不具备校验功能。默认是false rows：文本域的行数，multi-line为true时才有效 rules：指定校验规则及错误提示信息，数组结构。默认[] single-line：是否单行文本显示，默认是false suffix：显示后缀 接下来，我们先添加两个字段：品牌名称、品牌的首字母，校验规则暂时不写： 1234&lt;v-form v-model="valid"&gt; &lt;v-text-field v-model="brand.name" label="请输入品牌名称" required /&gt; &lt;v-text-field v-model="brand.letter" label="请输入品牌首字母" required /&gt;&lt;/v-form&gt; 千万不要忘了通过v-model把表单项与brand的属性关联起来。 效果： 1.1.4.3.级联下拉选框接下来就是商品分类了，按照刚才的分析，商品分类应该是下拉选框。 但是大家仔细思考，商品分类包含三级。在展示的时候，应该是先由用户选中1级，才显示2级；选择了2级，才显示3级。形成一个多级分类的三级联动效果。 这个时候，就不是普通的下拉选框，而是三级联动的下拉选框！ 这样的选框，在Vuetify中并没有提供（它提供的是基本的下拉框）。因此我已经给大家编写了一个无限级联动的下拉选框，能够满足我们的需求。 具体请参考课前资料的《自定义组件用法指南.md》 我们在代码中使用： 123456&lt;v-cascader url="/item/category/list" multiple required v-model="brand.categories" label="请选择商品分类"/&gt; url：加载商品分类选项的接口路径 multiple：是否多选，这里设置为true，因为一个品牌可能有多个分类 requried：是否是必须的，这里为true，会在提示上加*，提醒用户 v-model：关联我们brand对象的categories属性 label：文字说明 效果： data中获取的结果： 1.1.4.4.文件上传项在Vuetify中，也没有文件上传的组件。 还好，我已经给大家写好了一个文件上传的组件： 详细用法，参考《自定义组件使用指南.md》 我们添加上传的组件： 1234567891011121314&lt;v-layout row&gt; &lt;v-flex xs3&gt; &lt;span style="font-size: 16px; color: #444"&gt;品牌LOGO：&lt;/span&gt; &lt;/v-flex&gt; &lt;v-flex&gt; &lt;v-upload v-model="brand.image" url="/upload" :multiple="false" :pic-width="250" :pic-height="90" /&gt; &lt;/v-flex&gt;&lt;/v-layout&gt; 注意： 文件上传组件本身没有提供文字提示。因此我们需要自己添加一段文字说明 我们要实现文字和图片组件左右放置，因此这里使用了v-layout布局组件： layout添加了row属性，代表这是一行，如果是column，代表是多行 layout下面有v-flex组件，是这一行的单元，我们有2个单元 &lt;v-flex xs3&gt; ：显示文字说明，xs3是响应式布局，代表占12格中的3格 剩下的部分就是图片上传组件了 v-upload：图片上传组件，包含以下属性： v-model：将上传的结果绑定到brand的image属性 url：上传的路径，我们先随便写一个。 multiple：是否运行多图片上传，这里是false。因为品牌LOGO只有一个 pic-width和pic-height：可以控制l图片上传后展示的宽高 最终结果： 1.1.4.5.按钮上面已经把所有的表单项写完。最后就差提交和清空的按钮了。 在表单的最下面添加两个按钮： 12345&lt;v-layout class="my-4" row&gt; &lt;v-spacer/&gt; &lt;v-btn @click="submit" color="primary"&gt;提交&lt;/v-btn&gt; &lt;v-btn @click="clear" &gt;重置&lt;/v-btn&gt;&lt;/v-layout&gt; 通过layout来进行布局，my-4增大上下边距 v-spacer占用一定空间，将按钮都排挤到页面右侧 两个按钮分别绑定了submit和clear事件 我们先将方法定义出来： 12345678methods:&#123; submit()&#123; // 提交表单 &#125;, clear()&#123; // 重置表单 &#125;&#125; 重置表单相对简单，因为v-form组件已经提供了reset方法，用来清空表单数据。只要我们拿到表单组件对象，就可以调用方法了。 我们可以通过$refs内置对象来获取表单组件。 首先，在表单上定义ref属性： 然后，在页面查看this.$refs属性： 看到this.$refs中只有一个属性，就是myBrandForm 我们在clear中来获取表单对象并调用reset方法： 123456789101112methods:&#123; submit()&#123; // 提交表单 console.log(this); &#125;, clear()&#123; // 重置表单 this.$refs.myBrandForm.reset(); // 需要手动清空商品分类 this.categories = []; &#125;&#125; 要注意的是，这里我们还手动把this.categories清空了，因为我写的级联选择组件并没有跟表单结合起来。需要手动清空。 1.1.5.表单校验1.1.5.1.校验规则Vuetify的表单校验，是通过rules属性来指定的： 校验规则的写法： 说明： 规则是一个数组 数组中的元素是一个函数，该函数接收表单项的值作为参数，函数返回值两种情况： 返回true，代表成功， 返回错误提示信息，代表失败 1.1.5.2.项目中代码我们有四个字段： name：做非空校验和长度校验，长度必须大于1 letter：首字母，校验长度为1，非空。 image：图片，不做校验，图片可以为空 categories：非空校验，自定义组件已经帮我们完成，不用写了 首先，我们定义规则： 12345678nameRules:[ v =&gt; !!v || "品牌名称不能为空", v =&gt; v.length &gt; 1 || "品牌名称至少2位"],letterRules:[ v =&gt; !!v || "首字母不能为空", v =&gt; /^[A-Z]&#123;1&#125;$/.test(v) || "品牌字母只能是A~Z的大写字母"] 然后，在页面标签中指定： 12&lt;v-text-field v-model="brand.name" label="请输入品牌名称" required :rules="nameRules" /&gt;&lt;v-text-field v-model="brand.letter" label="请输入品牌首字母" required :rules="letterRules" /&gt; 效果： 1.1.6.表单提交在submit方法中添加表单提交的逻辑： 1234567891011121314151617181920submit() &#123; // 1、表单校验 if (this.$refs.myBrandForm.validate()) &#123; // 2、定义一个请求参数对象，通过解构表达式来获取brand中的属性 const &#123;categories ,letter ,...params&#125; = this.brand; // 3、数据库中只要保存分类的id即可，因此我们对categories的值进行处理,只保留id，并转为字符串 params.cids = categories.map(c =&gt; c.id).join(","); // 4、将字母都处理为大写 params.letter = letter.toUpperCase(); // 5、将数据提交到后台 this.$http.post('/item/brand', params) .then(() =&gt; &#123; // 6、弹出提示 this.$message.success("保存成功！"); &#125;) .catch(() =&gt; &#123; this.$message.error("保存失败！"); &#125;); &#125;&#125; 1、通过this.$refs.myBrandForm选中表单，然后调用表单的validate方法，进行表单校验。返回boolean值，true代表校验通过 2、通过解构表达式来获取brand中的值，categories和letter需要处理，单独获取。其它的存入params对象中 3、品牌和商品分类的中间表只保存两者的id，而brand.categories中保存的数对象数组，里面有id和name属性，因此这里通过数组的map功能转为id数组，然后通过join方法拼接为字符串 4、首字母都处理为大写保存 5、发起请求 6、弹窗提示成功还是失败，这里用到的是我们的自定义组件功能message组件： 这个插件把$message对象绑定到了Vue的原型上，因此我们可以通过this.$message来直接调用。 包含以下常用方法： info、error、success、warning等，弹出一个带有提示信息的窗口，色调与为普通（灰）、错误（红色）、成功（绿色）和警告（黄色）。使用方法：this.$message.info(“msg”) confirm：确认框。用法：this.$message.confirm(&quot;确认框的提示信息&quot;)，返回一个Promise 1.2.后台实现新增1.2.1.controller还是一样，先分析四个内容： 请求方式：刚才看到了是POST 请求路径：/brand 请求参数：brand对象，外加商品分类的id数组cids 返回值：无 代码： 12345678910/** * 新增品牌 * @param brand * @return */@PostMappingpublic ResponseEntity&lt;Void&gt; saveBrand(Brand brand, @RequestParam("cids") List&lt;Long&gt; cids) &#123; this.brandService.saveBrand(brand, cids); return new ResponseEntity&lt;&gt;(HttpStatus.CREATED);&#125; 1.2.2.Service这里要注意，我们不仅要新增品牌，还要维护品牌和商品分类的中间表。 123456789@Transactionalpublic void saveBrand(Brand brand, List&lt;Long&gt; cids) &#123; // 新增品牌信息 this.brandMapper.insertSelective(brand); // 新增品牌和分类中间表 for (Long cid : cids) &#123; this.brandMapper.insertCategoryBrand(cid, brand.getId()); &#125;&#125; 这里调用了brandMapper中的一个自定义方法，来实现中间表的数据新增 1.2.3.Mapper通用Mapper只能处理单表，也就是Brand的数据，因此我们手动编写一个方法及sql，实现中间表的新增： 12345678910public interface BrandMapper extends Mapper&lt;Brand&gt; &#123; /** * 新增商品分类和品牌中间表数据 * @param cid 商品分类id * @param bid 品牌id * @return */ @Insert("INSERT INTO tb_category_brand (category_id, brand_id) VALUES (#&#123;cid&#125;,#&#123;bid&#125;)") int insertCategoryBrand(@Param("cid") Long cid, @Param("bid") Long bid);&#125; 1.3.请求参数格式错误1.3.1.原因分析我们填写表单并提交，发现报错了： 查看控制台的请求详情： 发现请求的数据格式是JSON格式。 原因分析： axios处理请求体的原则会根据请求数据的格式来定： 如果请求体是对象：会转为json发送 如果请求体是String：会作为普通表单请求发送，但需要我们自己保证String的格式是键值对。 如：name=jack&amp;age=12 1.3.2.QS工具（数据传输给后台方法重要）QS是一个第三方库，我们可以用npm install qs --save来安装。不过我们在项目中已经集成了，大家无需安装： 这个工具的名字：QS，即Query String，请求参数字符串。 什么是请求参数字符串？例如： name=jack&amp;age=21 QS工具可以便捷的实现 JS的Object与QueryString的转换。 在我们的项目中，将QS注入到了Vue的原型对象中，我们可以通过this.$qs来获取这个工具： 我们将this.$qs对象打印到控制台： 123created()&#123; console.log(this.$qs);&#125; 发现其中有3个方法： 这里我们要使用的方法是stringify，它可以把Object转为QueryString。 测试一下，使用浏览器工具，把qs对象保存为一个临时变量： 然后调用stringify方法： 成功将person对象变成了 name=jack&amp;age=21的字符串了 1.3.3.解决问题修改页面，对参数处理后发送： 然后再次发起请求： 发现请求成功： 参数格式： 数据库： 1.4.新增完成后关闭窗口我们发现有一个问题：新增不管成功还是失败，窗口都一致在这里，不会关闭。 这样很不友好，我们希望如果新增失败，窗口保持；但是新增成功，窗口关闭才对。 因此，我们需要在新增的ajax请求完成以后，关闭窗口 但问题在于，控制窗口是否显示的标记在父组件：MyBrand.vue中。子组件如何才能操作父组件的属性？或者告诉父组件该关闭窗口了？ 之前我们讲过一个父子组件的通信，有印象吗？ 第一步，在父组件中定义一个函数，用来关闭窗口，不过之前已经定义过了，我们优化一下，关闭的同时重新加载数据： 123456closeWindow()&#123; // 关闭窗口 this.show = false; // 重新加载数据 this.getDataFromServer();&#125; 第二步，父组件在使用子组件时，绑定事件，关联到这个函数： 1234&lt;!--对话框的内容，表单--&gt;&lt;v-card-text class="px-5"&gt; &lt;my-brand-form @close="closeWindow"/&gt;&lt;/v-card-text&gt; 第三步，子组件通过this.$emit调用父组件的函数： 测试一下 2.实现图片上传刚才的新增实现中，我们并没有上传图片，接下来我们一起完成图片上传逻辑。 文件的上传并不只是在品牌管理中有需求，以后的其它服务也可能需要，因此我们创建一个独立的微服务，专门处理各种上传。 2.1.搭建项目2.1.1.创建module 2.1.2.依赖我们需要EurekaClient和web依赖： 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;leyou&lt;/artifactId&gt; &lt;groupId&gt;com.leyou.parent&lt;/groupId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.service&lt;/groupId&gt; &lt;artifactId&gt;ly-upload&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--ly-common依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;com.leyou.common&lt;/groupId&gt; &lt;artifactId&gt;ly-common&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;!--FastDFS依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.tobato&lt;/groupId&gt; &lt;artifactId&gt;fastdfs-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 2.1.3.编写配置12345678910111213141516171819server: port: 8082spring: application: name: upload-service servlet: multipart: max-file-size: 5MB # 限制文件上传的大小# Eurekaeureka: client: service-url: defaultZone: http://127.0.0.1:10086/eureka instance: lease-renewal-interval-in-seconds: 5 # 每隔5秒发送一次心跳 lease-expiration-duration-in-seconds: 10 # 10秒不发送就过期 prefer-ip-address: true ip-address: 127.0.0.1 instance-id: $&#123;spring.application.name&#125;:$&#123;server.port&#125; 需要注意的是，我们应该添加了限制文件大小的配置 2.1.4.启动类1234567@SpringBootApplication@EnableDiscoveryClientpublic class LyUploadService &#123; public static void main(String[] args) &#123; SpringApplication.run(LyUploadService.class, args); &#125;&#125; 结构： 2.2.编写上传功能2.2.1.controller编写controller需要知道4个内容： 请求方式：上传肯定是POST 请求路径：/upload/image 请求参数：文件，参数名是file，SpringMVC会封装为一个接口：MultipleFile 返回结果：上传成功后得到的文件的url路径 代码如下： 12345678910111213141516@RestController@RequestMapping("upload")public class UploadController &#123; @Autowired private UploadService uploadService; /** * 上传图片功能 * @param file * @return */ @PostMapping("image") public ResponseEntity&lt;String&gt; uploadImage(@RequestParam("file")MultipartFile file)&#123; return ResponseEntity.ok(uploadService.uploadImage(file)); &#125;&#125; 2.2.2.service（图片在本地存储）在上传文件过程中，我们需要对上传的内容进行校验： 校验文件大小 校验文件的媒体类型 校验文件的内容 文件大小在Spring的配置文件中设置，因此已经会被校验，我们不用管。 具体代码： 1234567891011121314151617181920212223242526272829303132333435363738394041@Servicepublic class UploadService &#123; private static final Logger logger = LoggerFactory.getLogger(UploadController.class); // 支持的文件类型 private static final List&lt;String&gt; suffixes = Arrays.asList("image/png", "image/jpeg"); public String upload(MultipartFile file) &#123; try &#123; // 1、图片信息校验 // 1)校验文件类型 String type = file.getContentType(); if (!suffixes.contains(type)) &#123; logger.info("上传失败，文件类型不匹配：&#123;&#125;", type); return null; &#125; // 2)校验图片内容 BufferedImage image = ImageIO.read(file.getInputStream()); if (image == null) &#123; logger.info("上传失败，文件内容不符合要求"); return null; &#125; // 2、保存图片 // 2.1、生成保存目录 File dir = new File("D:\\heima\\upload"); if (!dir.exists()) &#123; dir.mkdirs(); &#125; // 2.2、保存图片 file.transferTo(new File(dir, file.getOriginalFilename())); // 2.3、拼接图片地址 String url = "http://image.leyou.com/upload/" + file.getOriginalFilename(); return url; &#125; catch (Exception e) &#123; return null; &#125; &#125;&#125; 这里有一个问题：为什么图片地址需要使用另外的url？ 图片不能保存在服务器内部，这样会对服务器产生额外的加载负担 一般静态资源都应该使用独立域名，这样访问静态资源时不会携带一些不必要的cookie，减小请求的数据量 2.2.3.测试上传我们通过RestClient工具来测试： 结果： 去目录下查看： 上传成功！ ###2.2.4.忽略路由前缀 zuul的路由功能中，会忽略路由匹配的路径前缀，不过我们的Controller中由/upload路径，此时如果通过网关访问，我们的地址应该是：http://api.leyou.com/api/upload/upload/image，这是因为路由匹配的前/upload在请求转发时会自动忽略。 123456789zuul: prefix: /api # 添加路由前缀 routes: item-service: /item/** #将商品微服务映射到/item/** upload-service: #将上传微服务映射到/upload/** #忽略/upload/** path: /upload/** serviceId: upload-service strip-prefix: false 这样，路由前缀也会作为地址一部分转发到微服务，那么我们可以这样访问 http://api.leyou.com/api/upload/image 2.2.5.绕过网关缓存默认情况下，所有的请求经过zuul网关的代理，默认会通过springMVC预先对请求进行处理，缓存。普通请求并不会有什么影响，但是对于文件上传，造成不必要的网络负担，在高并发时，可能导致网络阻塞，Zuul网关不可用。这样我们的整个系统就瘫痪了。 所以，我们上传文件的请求就不经过网关来处理了。 2.2.5.1.Nginx的rewrite指令现在，我们修改页面的访问路径： 123456&lt;v-upload v-model="brand.image" url="/upload/image" :multiple="false" :pic-width="250" :pic-height="90" /&gt; 查看页面的请求路径： 可以看到这个地址不对，依然是去找Zuul网关，因为我们的系统全局配置了URL地址。怎么办？ 有同学会想：修改页面请求地址不就好了。 注意：原则上，我们是不能把除了网关以外的服务对外暴露的，不安全。 既然不能修改页面请求，那么就只能在Nginx反向代理上做文章了。 我们修改nginx配置，将以/api/upload开头的请求拦截下来，转交到真实的服务地址: 123location /api/upload &#123; rewrite "^/(.*)$" /zuul/$1;&#125; 这样写大家觉得对不对呢？ 显然是不对的，因为ip和端口虽然对了，但是路径没变，依然是：http://127.0.0.1:8002/api/upload/image 前面多了一个/api Nginx提供了rewrite指令，用于对地址进行重写，语法规则： 1rewrite &quot;用来匹配路径的正则&quot; 重写后的路径 [指令]; 我们的案例： 12345678910111213141516171819server &#123; listen 80; server_name api.leyou.com; proxy_set_header X-Forwarded-Host $host; proxy_set_header X-Forwarded-Server $host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; # 上传路径的映射 location /api/upload &#123; rewrite "^/(.*)$" /zuul/$1; &#125; location / &#123; proxy_pass http://192.168.1.101:10010; proxy_connect_timeout 600; proxy_read_timeout 600; &#125; &#125; 首先，我们映射路径是/api/upload，而下面一个映射路径是 / ，根据最长路径匹配原则，/api/upload优先级更高。也就是说，凡是以/api/upload开头的路径，都会被第一个配置处理 proxy_pass：反向代理，这次我们代理到8082端口，也就是upload-service服务 rewrite &quot;^/(.*)$&quot; /zuul/$1，路径重写： &quot;^/(.*)$&quot;：匹配路径的正则表达式，用了分组语法，把/api/以后的所有部分当做1组 /zuul/$1：重写的目标路径，这里用$1引用前面正则表达式匹配到的分组（组编号从1开始），即/api/后面的所有。这样新的路径就是除去/api/以外的所有，就达到了去除/api前缀的目的 2.2.6.之前上传的缺陷先思考一下，之前上传的功能，有没有什么问题？ 上传本身没有任何问题，问题出在保存文件的方式，我们是保存在服务器机器，就会有下面的问题： 单机器存储，存储能力有限 无法进行水平扩展，因为多台机器的文件无法共享,会出现访问不到的情况 数据没有备份，有单点故障风险 并发能力差 这个时候，最好使用分布式文件存储来代替本地文件存储。 3.FastDFS3.1.什么是分布式文件系统分布式文件系统（Distributed File System）是指文件系统管理的物理存储资源不一定直接连接在本地节点上，而是通过计算机网络与节点相连。 通俗来讲： 传统文件系统管理的文件就存储在本机。 分布式文件系统管理的文件存储在很多机器，这些机器通过网络连接，要被统一管理。无论是上传或者访问文件，都需要通过管理中心来访问 3.2.什么是FastDFSFastDFS是由淘宝的余庆先生所开发的一个轻量级、高性能的开源分布式文件系统。用纯C语言开发，功能丰富： 文件存储 文件同步 文件访问（上传、下载） 存取负载均衡 在线扩容 适合有大容量存储需求的应用或系统。同类的分布式文件系统有谷歌的GFS、HDFS（Hadoop）、TFS（淘宝）等。 3.3.FastDFS的架构3.3.1.架构图先上图： FastDFS两个主要的角色：Tracker Server 和 Storage Server 。 Tracker Server：跟踪服务器，主要负责调度storage节点与client通信，在访问上起负载均衡的作用，和记录storage节点的运行状态，是连接client和storage节点的枢纽。 Storage Server：存储服务器，保存文件和文件的meta data（元数据），每个storage server会启动一个单独的线程主动向Tracker cluster中每个tracker server报告其状态信息，包括磁盘使用情况，文件同步情况及文件上传下载次数统计等信息 Group：文件组，多台Storage Server的集群。上传一个文件到同组内的一台机器上后，FastDFS会将该文件即时同步到同组内的其它所有机器上，起到备份的作用。不同组的服务器，保存的数据不同，而且相互独立，不进行通信。 Tracker Cluster：跟踪服务器的集群，有一组Tracker Server（跟踪服务器）组成。 Storage Cluster ：存储集群，有多个Group组成。 3.3.2.上传和下载流程 上传 Client通过Tracker server查找可用的Storage server。 Tracker server向Client返回一台可用的Storage server的IP地址和端口号。 Client直接通过Tracker server返回的IP地址和端口与其中一台Storage server建立连接并进行文件上传。 上传完成，Storage server返回Client一个文件ID，文件上传结束。 下载 Client通过Tracker server查找要下载文件所在的的Storage server。 Tracker server向Client返回包含指定文件的某个Storage server的IP地址和端口号。 Client直接通过Tracker server返回的IP地址和端口与其中一台Storage server建立连接并指定要下载文件。 下载文件成功。 3.4.安装和使用参考课前资料的：《centos安装FastDFS.md》 3.5.java客户端余庆先生提供了一个Java客户端，但是作为一个C程序员，写的java代码可想而知。而且已经很久不维护了。 这里推荐一个开源的FastDFS客户端，支持最新的SpringBoot2.0。 配置使用极为简单，支持连接池，支持自动生成缩略图，狂拽酷炫吊炸天啊，有木有。 地址：tobato/FastDFS_client 3.5.1.引入依赖在父工程中，我们已经管理了依赖，版本为： 1&lt;fastDFS.client.version&gt;1.26.2&lt;/fastDFS.client.version&gt; 因此，这里我们直接引入坐标即可： 1234&lt;dependency&gt; &lt;groupId&gt;com.github.tobato&lt;/groupId&gt; &lt;artifactId&gt;fastdfs-client&lt;/artifactId&gt;&lt;/dependency&gt; 3.5.2.引入配置类纯java配置： 123456@Configuration@Import(FdfsClientConfig.class)// 解决jmx重复注册bean的问题@EnableMBeanExport(registration = RegistrationPolicy.IGNORE_EXISTING)public class FastClientImporter &#123;&#125; 3.5.3.编写FastDFS属性12345678fdfs: so-timeout: 1501 connect-timeout: 601 thumb-image: # 缩略图 width: 60 height: 60 tracker-list: # tracker地址 - 192.168.25.128:22122 #fdfs虚拟机ip地址 3.5.4.测试12345678910111213141516171819202122232425262728293031323334353637@RunWith(SpringRunner.class)@SpringBootTestpublic class FdfsTest &#123; @Autowired private FastFileStorageClient storageClient; @Autowired private ThumbImageConfig thumbImageConfig; @Test public void testUpload() throws FileNotFoundException &#123; File file = new File("G:/Java-webspace/LeYou-store/image/athor.jpg"); // 上传并且生成缩略图 StorePath storePath = this.storageClient.uploadFile( new FileInputStream(file), file.length(), "jpg", null); // 带分组的路径 System.out.println(storePath.getFullPath()); // 不带分组的路径 System.out.println(storePath.getPath()); &#125; @Test public void testUploadAndCreateThumb() throws FileNotFoundException &#123; File file = new File("G:/Java-webspace/LeYou-store/image/athor.jpg"); // 上传并且生成缩略图 StorePath storePath = this.storageClient.uploadImageAndCrtThumbImage( new FileInputStream(file), file.length(), "jpg", null); // 带分组的路径 System.out.println(storePath.getFullPath()); // 不带分组的路径 System.out.println(storePath.getPath()); // 获取缩略图路径 String path = thumbImageConfig.getThumbImagePath(storePath.getPath()); System.out.println(path); &#125;&#125; 结果： 123group1/M00/00/00/wKg4ZVro5eCAZEMVABfYcN8vzII630.pngM00/00/00/wKg4ZVro5eCAZEMVABfYcN8vzII630.pngM00/00/00/wKg4ZVro5eCAZEMVABfYcN8vzII630_60x60.png 访问第一个路径： 访问最后一个路径（缩略图路径），注意加组名： 3.5.5.改造上传逻辑定义错误信息在ly-common中 1234567891011121314@Getter@NoArgsConstructor@AllArgsConstructorpublic enum ExceptionEnums &#123; PRICE_CANNOT_BE_NULL(400, "价格不能为空"), CATEGORY_NOT_FOND(404,"没查询到"), BRAND_NOT_FOUND(500,"品牌查不到或者不存在"), BRAND_SAVE_ERROR(500,"新增品牌失败" ), UPLOAD_FILE_ERROR(500,"文件上传失败"), Invalid_file_type(500,"无效文件类型" ), ; private int code; private String msg;&#125; 修改ly-upload的UploadService 123456789101112131415161718192021222324252627282930313233@Service@Slf4jpublic class UploadService &#123; @Autowired private FastFileStorageClient fileStorageClient; //定义文件类型 private static final List&lt;String&gt; ALLOW_TYPES = Arrays.asList("image/png", "image/jpeg","image/bmp"); public String uploadImage(MultipartFile file) &#123; try &#123; //校验文件类型 String contentType=file.getContentType();//获取文件类型 if (!ALLOW_TYPES.contains(contentType))&#123; throw new LyException(ExceptionEnums.Invalid_file_type); &#125; //校验文件内容 BufferedImage image = ImageIO.read(file.getInputStream()); if (image==null)&#123; throw new LyException(ExceptionEnums.Invalid_file_type); &#125; // 2、将图片上传到FastDFS // 2.1、获取文件后缀名 String extension = StringUtils.substringAfterLast(file.getOriginalFilename(), "."); StorePath storePath = fileStorageClient.uploadFile(file.getInputStream(), file.getSize(), extension, null); //返回路径 return "http://image.leyou.com/" + storePath.getFullPath(); &#125; catch (IOException e) &#123; log.error("上传文件失败",e); throw new LyException(ExceptionEnums.UPLOAD_FILE_ERROR); &#125; &#125;&#125; 只需要把原来保存文件的逻辑去掉，然后上传到FastDFS即可。 3.5.6.测试通过RestClient测试： 3.6.页面测试上传发现上传成功： 不过，当我们访问页面时： 这是因为我们图片是上传到虚拟机的，ip为：192.168.25.128 因此，我们需要将image.leyou.com映射到192.168.25.128 修改我们的hosts： 再次上传： 3.7添加nginx图片上传大小在nginx的nginx.conf配置文件下添加到http{。。。。。。}的#access_log logs/access.log main;下 1client_max_body_size:10m 3.8.将图片导入到虚拟机中 将images.zip上传到虚拟机/leyou/static中 修改nginx.conf 4.修改品牌（作业）修改的难点在于回显。 当我们点击编辑按钮，希望弹出窗口的同时，看到原来的数据： 4.1.点击编辑出现弹窗这个比较简单，修改show属性为true即可实现，我们绑定一个点击事件： 1&lt;v-btn color="info" @click="editBrand"&gt;编辑&lt;/v-btn&gt; 然后编写事件，改变show 的状态： 如果仅仅是这样，编辑按钮与新增按钮将没有任何区别，关键在于，如何回显呢？ 4.2.回显数据回显数据，就是把当前点击的品牌数据传递到子组件（MyBrandForm）。而父组件给子组件传递数据，通过props属性。 第一步：在编辑时获取当前选中的品牌信息，并且记录到data中 先在data中定义属性，用来接收用来编辑的brand数据： 我们在页面触发编辑事件时，把当前的brand传递给editBrand方法： 1&lt;v-btn color="info" @click="editBrand(props.item)"&gt;编辑&lt;/v-btn&gt; 然后在editBrand中接收数据，赋值给oldBrand： 123456editBrand(oldBrand)&#123; // 控制弹窗可见： this.show = true; // 获取要编辑的brand this.oldBrand = oldBrand;&#125;, 第二步：把获取的brand数据 传递给子组件 1234&lt;!--对话框的内容，表单--&gt;&lt;v-card-text class="px-5"&gt; &lt;my-brand-form @close="closeWindow" :oldBrand="oldBrand"/&gt;&lt;/v-card-text&gt; 第三步：在子组件中通过props接收要编辑的brand数据，Vue会自动完成回显 接收数据： 通过watch函数监控oldBrand的变化，把值copy到本地的brand： 12345678910111213141516171819watch: &#123; oldBrand: &#123;// 监控oldBrand的变化 handler(val) &#123; if(val)&#123; // 注意不要直接复制，否则这边的修改会影响到父组件的数据，copy属性即可 this.brand = Object.deepCopy(val) &#125;else&#123; // 为空，初始化brand this.brand = &#123; name: '', letter: '', image: '', categories: [], &#125; &#125; &#125;, deep: true &#125;&#125; Object.deepCopy 自定义的对对象进行深度复制的方法。 需要判断监听到的是否为空，如果为空，应该进行初始化 测试：发现数据回显了，除了商品分类以外： 4.3.商品分类回显为什么商品分类没有回显？ 因为品牌中并没有商品分类数据。我们需要在进入编辑页面之前，查询商品分类信息： 4.3.1.后台提供接口 controller 在CategoryController中添加 12345678910/** * 根据品牌id查询商品分类 * @param bid * @return */@GetMapping("bid/&#123;bid&#125;")public ResponseEntity&lt;List&lt;Category&gt;&gt; editCategoryListByBid(@PathVariable("bid")Long bid)&#123; return ResponseEntity.ok(categoryService.editCategoryListByBid(bid));&#125; Service 123456789101112/** * 根据品牌id查询商品分类 * @param bid * @return */public List&lt;Category&gt; editCategoryListByBid(Long bid) &#123; List&lt;Category&gt; list = categoryMapper.queryCategoryListByBid(bid); if (CollectionUtils.isEmpty(list))&#123; throw new LyException(ExceptionEnums.CATEGORY_NOT_FOND); &#125; return list;&#125; mapper 因为需要通过中间表进行子查询，所以这里要手写Sql： 1234public interface CategoryMapper extends Mapper&lt;Category&gt;&#123; @Select("SELECT * FROM tb_category WHERE id IN (SELECT category_id FROM tb_category_brand WHERE brand_id = #&#123;bid&#125;)") List&lt;Category&gt; queryCategoryListByBid(@Param("bid")Long bid);&#125; 4.3.2.前台查询分类并渲染我们在编辑页面打开之前，先把数据查询完毕： 123456789101112editBrand(oldBrand)&#123; // 根据品牌信息查询商品分类 this.$http.get("/item/category/bid/" + oldBrand.id) .then((&#123;data&#125;) =&gt; &#123; // 控制弹窗可见： this.show = true; // 获取要编辑的brand this.oldBrand = oldBrand // 回显商品分类 this.oldBrand.categories = data; &#125;)&#125; 再次测试：数据成功回显了 4.3.3.新增窗口数据干扰但是，此时却产生了新问题：新增窗口竟然也有数据？ 原因： ​ 如果之前打开过编辑，那么在父组件中记录的oldBrand会保留。下次再打开窗口，如果是编辑窗口到没问题，但是新增的话，就会再次显示上次打开的品牌信息了。 解决： ​ 新增窗口打开前，把数据置空。 123456addBrand() &#123; // 控制弹窗可见： this.show = true; // 把oldBrand变为null this.oldBrand = null;&#125; 4.3.4.提交表单时判断是新增还是修改新增和修改是同一个页面，我们该如何判断？ 父组件中点击按钮弹出新增或修改的窗口，因此父组件非常清楚接下来是新增还是修改。 因此，最简单的方案就是，在父组件中定义变量，记录新增或修改状态，当弹出页面时，把这个状态也传递给子组件。 第一步：在父组件中记录状态： 第二步：在新增和修改前，更改状态： 第三步：传递给子组件 第四步，子组件接收标记： 标题的动态化： 表单提交动态： axios除了除了get和post外，还有一个通用的请求方式： 1234567891011121314// 将数据提交到后台// this.$http.post('/item/brand', this.$qs.stringify(params))this.$http(&#123; method: this.isEdit ? 'put' : 'post', // 动态判断是POST还是PUT url: '/item/brand', data: this.$qs.stringify(this.brand)&#125;).then(() =&gt; &#123; // 关闭窗口 this.$emit("close"); this.$message.success("保存成功！");&#125;) .catch(() =&gt; &#123; this.$message.error("保存失败！");&#125;); 4.4.品牌修改后台 ##controller 在BrandController 12345678910/** * 更新品牌 * @param brand * @return */@PutMappingpublic ResponseEntity&lt;Void&gt; editBrand(Brand brand)&#123; brandService.editBrand(brand); return ResponseEntity.status(HttpStatus.OK).build();&#125; service 在BrandService 1234567891011/** * 更新品牌 * @param brand * @return */public void editBrand(Brand brand) &#123; int update = brandMapper.updateByPrimaryKeySelective(brand); if (update!=1)&#123; throw new LyException(ExceptionEnums.BRAND_UPLOAD_ERROR); &#125;&#125; 5.删除品牌5.1前端在中Brand.vue 在表格中添加 12345678&lt;td class=&quot;justify-center layout px-0&quot;&gt; &lt;v-btn icon @click=&quot;editBrand(props.item)&quot;&gt; &lt;i class=&quot;el-icon-edit&quot;/&gt; &lt;/v-btn&gt; &lt;v-btn icon @click=&quot;deleteBrand(props.item)&quot;&gt; &lt;i class=&quot;el-icon-delete&quot;/&gt; &lt;/v-btn&gt; &lt;/td&gt; js如下 1234567891011121314//删除单个 deleteBrand(oldBrand)&#123; this.$message.confirm("此操作将永久删除"+oldBrand.id+"品牌, 是否继续?").then(() =&gt; &#123; // 发起删除请求 this.$http.delete("/item/brand/bid/" + oldBrand.id) .then(() =&gt; &#123; // 删除成功，重新加载数据 this.$message.success("删除成功！"); this.getDataFromServer(); &#125;) &#125;).catch(() =&gt; &#123; this.$message.info("删除已取消！"); &#125;); &#125; 5.2.controller12345678910/** * 根据id删除品牌信息 * @param bid * @return */ @DeleteMapping("bid/&#123;bid&#125;") public ResponseEntity&lt;Void&gt; delete(@PathVariable("bid")Long bid)&#123; brandService.delete(bid); return ResponseEntity.status(HttpStatus.OK).build(); &#125; 5.3.service1234public void delete(Long bid) &#123; brandMapper.deleteByPrimaryKey(bid); brandMapper.deleteByBid(bid);&#125; 5.3.mapper12@Delete("delete from tb_category_brand where brand_id=#&#123;bid&#125;")void deleteByBid(@Param("bid")Long bid);]]></content>
      <categories>
        <category>项目实战-微服务商城</category>
      </categories>
      <tags>
        <tag>FastDFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务商城（八）——搭建管理系统页面]]></title>
    <url>%2Fday06-%E6%90%AD%E5%BB%BA%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E9%A1%B5%E9%9D%A2.html</url>
    <content type="text"><![CDATA[0.学习目标 使用资料搭建后台系统 会使用nginx进行反向代理 实现商品分类查询功能 掌握cors解决跨域 实现品牌查询功能 1.使用域名访问本地项目1.1.统一环境我们现在访问页面使用的是：http://localhost:9001 有没有什么问题？ 实际开发中，会有不同的环境： 开发环境：自己的电脑 测试环境：提供给测试人员使用的环境 预发布环境：数据是和生成环境的数据一致，运行最新的项目代码进去测试 生产环境：项目最终发布上线的环境 如果不同环境使用不同的ip去访问，可能会出现一些问题。为了保证所有环境的一致，我们会在各种环境下都使用域名来访问。 我们将使用以下域名： 主域名是：www.leyou.com， 管理系统域名：manage.leyou.com 网关域名：api.leyou.com … 但是最终，我们希望这些域名指向的还是我们本机的某个端口。 那么，当我们在浏览器输入一个域名时，浏览器是如何找到对应服务的ip和端口的呢？ 1.2.域名解析一个域名一定会被解析为一个或多个ip。这一般会包含两步： 本地域名解析 浏览器会首先在本机的hosts文件中查找域名映射的IP地址，如果查找到就返回IP ，没找到则进行域名服务器解析，一般本地解析都会失败，因为默认这个文件是空的。 Windows下的hosts文件地址：C:/Windows/System32/drivers/etc/hosts Linux下的hosts文件所在路径： /etc/hosts 样式： 1234# My hosts127.0.0.1 localhost0.0.0.0 account.jetbrains.com127.0.0.1 www.xmind.net 域名服务器解析 本地解析失败，才会进行域名服务器解析，域名服务器就是网络中的一台计算机，里面记录了所有注册备案的域名和ip映射关系，一般只要域名是正确的，并且备案通过，一定能找到。 1.3.解决域名解析问题我们不可能去购买一个域名，因此我们可以伪造本地的hosts文件，实现对域名的解析。修改本地的host为： 12127.0.0.1 api.leyou.com127.0.0.1 manage.leyou.com 这样就实现了域名的关系映射了。 每次在C盘寻找hosts文件并修改是非常麻烦的，给大家推荐一个快捷修改host的工具，在课前资料中可以找到： 效果： 我们添加了两个映射关系： 127.0.0.1 api.leyou.com ：我们的网关Zuul 127.0.0.1 manage.leyou.com：我们的后台系统地址 现在，ping一下域名试试是否畅通： OK！ 1.4.nginx解决端口问题虽然域名解决了，但是现在如果我们要访问，还得自己加上端口：http://manage.leyou.com:9001。 这就不够优雅了。我们希望的是直接域名访问：http://manage.leyou.com。这种情况下端口默认是80，如何才能把请求转移到9001端口呢？ 这里就要用到反向代理工具：Nginx 1.4.1.什么是Nginx NIO：not-blocking-io 非阻塞IO BIO：blocking-IO 阻塞IO nginx可以作为web服务器，但更多的时候，我们把它作为网关，因为它具备网关必备的功能： 反向代理 负载均衡 动态路由 请求过滤 1.4.2.nginx作为web服务器Web服务器分2类： web应用服务器，如： tomcat resin jetty web服务器，如： Apache 服务器 Nginx IIS 区分：web服务器不能解析jsp等页面，只能处理js、css、html等静态资源。并发：web服务器的并发能力远高于web应用服务器。 Nginx + tomcat 1.4.3.nginx作为反向代理什么是反向代理？ 代理：通过客户机的配置，实现让一台服务器代理客户机，客户的所有请求都交给代理服务器处理。 反向代理：用一台服务器，代理真实服务器，用户访问时，不再是访问真实服务器，而是代理服务器。 nginx可以当做反向代理服务器来使用： 我们需要提前在nginx中配置好反向代理的规则，不同的请求，交给不同的真实服务器处理 当请求到达nginx，nginx会根据已经定义的规则进行请求的转发，从而实现路由功能 利用反向代理，就可以解决我们前面所说的端口问题，如图 1.5虚拟机安装nginx###1.5.1安装nginx 创建一个leyou文件 1[root@localhost home]# mkdir leyou 将资料目录FastDFS下的nginx复制到leyou目录下 1[root@localhost ~]# cp nginx-1.10.0.tar.gz /home/leyou 解压nginx： 1[root@localhost leyou]# tar -xvf nginx-1.10.0.tar.gz 改名字： 1[root@localhost leyou]# mv nginx-1.10.0 nginx 配置nginx 123[root@localhost leyou]#cd nginx//安装[root@localhost nginx]# ./configure --prefix=/opt/nginx --sbin-path=/usr/bin/nginx 指定安装目录为：/opt/nginx 目录下 编译安装 1[root@localhost nginx]# make &amp;&amp; make install 启动： 1[root@localhost nginx]# nginx 停止和重新加载 在存放nginx的目录下/home/leyou/nginx操作 停止 ：[root@localhost nginx]# nginx -s stop 重新加载：[root@localhost nginx]# nginx -s reload ###1.5.2反向代理配置 这里我们安装的nginx在 ” /opt/nginx “目录下 修改/opt/nginx/conf目下的nginx.conf 示例： nginx中的每个server就是一个反向代理配置，可以有多个server 完整配置： 1234567891011121314151617181920212223242526272829303132333435363738394041424344#user nobody;worker_processes 1;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; # gzip on; server &#123; listen 80; server_name manage.leyou.com; proxy_set_header X-Forwarded-Host $host; proxy_set_header X-Forwarded-Server $host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; location / &#123; proxy_pass http://192.168.1.106:9001;//本地电脑开发的ip地址 proxy_connect_timeout 600; proxy_read_timeout 600; &#125; &#125; server &#123; listen 80; server_name api.leyou.com; proxy_set_header X-Forwarded-Host $host; proxy_set_header X-Forwarded-Server $host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; location / &#123; proxy_pass http://192.168.1.106:10010; proxy_connect_timeout 600; proxy_read_timeout 600; &#125; &#125;&#125; 默认我们的前端项目绑定的host是：localhost ，因此只能在本机访问，要通过虚拟机访问，就是必须修改host绑定地址。 修改leyou-manage-web下的config的index.jsp ###1.5.3测试使用域名访问 使用软件：SwitchHosts 结果 流程： 浏览器准备发起请求，访问http://mamage.leyou.com，但需要进行域名解析 优先进行本地域名解析，因为我们修改了hosts，所以解析成功，得到地址：192.168.25.153 请求被发往解析得到的ip，并且默认使用80端口：http://192.168.2.153:80 本机的nginx一直监听80端口，因此捕获这个请求 nginx中配置了反向代理规则，将manage.leyou.com代理到192.168.1.103:9001，因此请求被转发 后台系统的webpack server监听的端口是9001，得到请求并处理，完成后将响应返回到nginx nginx将得到的结果返回到浏览器 2.实现商品分类查询商城的核心自然是商品，而商品多了以后，肯定要进行分类，并且不同的商品会有不同的品牌信息，其关系如图所示： 一个商品分类下有很多商品 一个商品分类下有很多品牌 而一个品牌，可能属于不同的分类 一个品牌下也会有很多商品 因此，我们需要依次去完成：商品分类、品牌、商品的开发。 2.1.导入数据首先导入课前资料提供的sql： 我们先看商品分类表： 123456789CREATE TABLE `tb_category` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &apos;类目id&apos;, `name` varchar(20) NOT NULL COMMENT &apos;类目名称&apos;, `parent_id` bigint(20) NOT NULL COMMENT &apos;父类目id,顶级类目填0&apos;, `is_parent` tinyint(1) NOT NULL COMMENT &apos;是否为父节点，0为否，1为是&apos;, `sort` int(4) NOT NULL COMMENT &apos;排序指数，越小越靠前&apos;, PRIMARY KEY (`id`), KEY `key_parent_id` (`parent_id`) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=1424 DEFAULT CHARSET=utf8 COMMENT=&apos;商品类目表，类目和商品(spu)是一对多关系，类目与品牌是多对多关系&apos;; 因为商品分类会有层级关系，因此这里我们加入了parent_id字段，对本表中的其它分类进行自关联。 2.2.页面实现2.2.1.页面分析首先我们看下要实现的效果： 商品分类之间是会有层级关系的，采用树结构去展示是最直观的方式。 一起来看页面，对应的是/pages/item/Category.vue： 页面模板： 123456789101112&lt;v-card&gt; &lt;v-flex xs12 sm10&gt; &lt;v-tree url="/item/category/list" :treeData="treeData" :isEdit="isEdit" @handleAdd="handleAdd" @handleEdit="handleEdit" @handleDelete="handleDelete" @handleClick="handleClick" /&gt; &lt;/v-flex&gt;&lt;/v-card&gt; v-card：卡片，是vuetify中提供的组件，提供一个悬浮效果的面板，一般用来展示一组数据。 v-flex：布局容器，用来控制响应式布局。与BootStrap的栅格系统类似，整个屏幕被分为12格。我们可以控制所占的格数来控制宽度： 本例中，我们用sm10控制在小屏幕及以上时，显示宽度为10格 v-tree：树组件。Vuetify并没有提供树组件，这个是我们自己编写的自定义组件： 里面涉及一些vue的高级用法，大家暂时不要关注其源码，会用即可。 2.2.2.树组件的用法也可参考课前资料中的：《自定义Vue组件的用法.md》 这里我贴出树组件的用法指南。 属性列表： 属性名称 说明 数据类型 默认值 url 用来加载数据的地址，即延迟加载 String - isEdit 是否开启树的编辑功能 boolean false treeData 整颗树数据，这样就不用远程加载了 Array - 这里推荐使用url进行延迟加载，每当点击父节点时，就会发起请求，根据父节点id查询子节点信息。 当有treeData属性时，就不会触发url加载 远程请求返回的结果格式： 12345678910111213141516[ &#123; "id": 74, "name": "手机", "parentId": 0, "isParent": true, "sort": 2 &#125;, &#123; "id": 75, "name": "家用电器", "parentId": 0, "isParent": true, "sort": 3 &#125;] 事件： 事件名称 说明 回调参数 handleAdd 新增节点时触发，isEdit为true时有效 新增节点node对象，包含属性：name、parentId和sort handleEdit 当某个节点被编辑后触发，isEdit为true时有效 被编辑节点的id和name handleDelete 当删除节点时触发，isEdit为true时有效 被删除节点的id handleClick 点击某节点时触发 被点击节点的node对象,包含全部信息 完整node的信息 回调函数中返回完整的node节点会包含以下数据： 12345678&#123; "id": 76, // 节点id "name": "手机", // 节点名称 "parentId": 75, // 父节点id "isParent": false, // 是否是父节点 "sort": 1, // 顺序 "path": ["手机", "手机通讯", "手机"] // 所有父节点的名称数组&#125; 2.3.实现功能2.3.1.url异步请求给大家的页面中，treeData是假数据，我们删除数据treeData属性，只保留url看看会发生什么： 1234567&lt;v-tree url="/item/category/list" :isEdit="isEdit" @handleAdd="handleAdd" @handleEdit="handleEdit" @handleDelete="handleDelete" @handleClick="handleClick" /&gt; 刷新页面，可以看到： 页面中的树没有了，并且发起了一条请求：http://localhost/api/item/category/list?pid=0 大家可能会觉得很奇怪，我们明明是使用的相对路径，讲道理发起的请求地址应该是： http://manage.leyou.com/item/category/list 但实际却是： http://localhost/api/item/category/list?pid=0 这是因为，我们有一个全局的配置文件，对所有的请求路径进行了约定： 路径是localhost，并且默认加上了/api的前缀，这恰好与我们的网关设置匹配，我们只需要把地址改成网关的地址即可,因为我们使用了nginx反向代理，这里可以写域名： 再次查看页面，发现地址已经变成了正确的地址了： 接下来，我们要做的事情就是编写后台接口，返回对应的数据即可。 2.3.2.实体类在ly-item-interface中添加category实体类： 123456789101112@Table(name="tb_category")public class Category &#123; @Id @KeySql(userGeneratedKey) private Long id; private String name; private Long parentId; private Boolean isParent; private Integer sort; // getter和setter略 // 注意isParent的get和set方法&#125; 需要注意的是，这里要用到jpa的注解，因此我们在ly-item-iterface中添加jpa依赖 12345&lt;dependency&gt; &lt;groupId&gt;javax.persistence&lt;/groupId&gt; &lt;artifactId&gt;persistence-api&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt;&lt;/dependency&gt; 结构： 2.3.3.controller编写一个controller一般需要知道四个内容： 请求方式：决定我们用GetMapping还是PostMapping 请求路径：决定映射路径 请求参数：决定方法的参数 返回值结果：决定方法的返回值 在刚才页面发起的请求中，我们就能得到绝大多数信息： 请求方式：Get 请求路径：/api/item/category/list。其中/api是网关前缀，/item是网关的路由映射，真实的路径应该是/category/list 请求参数：pid=0，根据tree组件的说明，应该是父节点的id，第一次查询为0，那就是查询一级类目 返回结果：？？ 根据前面tree组件的用法我们知道，返回的应该是json数组： 12345678910111213141516[ &#123; "id": 74, "name": "手机", "parentId": 0, "isParent": true, "sort": 2 &#125;, &#123; "id": 75, "name": "家用电器", "parentId": 0, "isParent": true, "sort": 3 &#125;] 对应的java类型可以是List集合，里面的元素就是类目对象了。 在ly-item-service中的web中创建 controller代码： 123456789101112131415161718@RestController@RequestMapping("category")public class CategoryController &#123; @Autowired private CategoryService categoryService; /** * 根据父节点查询商品分类 * ResponseEntity&lt;List&lt;Category&gt;&gt;：是restful风格 * @param pid * @return */ @GetMapping("list") public ResponseEntity&lt;List&lt;Category&gt;&gt; queryCategoryListByPid(@RequestParam("pid")Long pid)&#123; return ResponseEntity.ok(categoryService.queryCategoryListByPid(pid)); &#125;&#125; 2.3.4.service在ly-item-service中的service中创建 一般service层我们会定义接口和实现类，不过这里我们就偷懒一下，直接写实现类了： 12345678910111213141516171819202122@Servicepublic class CategoryService &#123; @Autowired private CategoryMapper categoryMapper; /** * 根据父节点查询商品分类 * ResponseEntity&lt;List&lt;Category&gt;&gt;：是restful风格 * @param pid * @return */ public List&lt;Category&gt; queryCategoryListByPid(Long pid) &#123; //查询条件，mapper会把对象中的非空属性作为查询条件 Category category = new Category(); category.setParentId(pid); List&lt;Category&gt; list = categoryMapper.select(category); if(CollectionUtils.isEmpty(list))&#123; //自定义的错误返回 throw new LyException(ExceptionEnums.CATEGORY_NOT_FOND); &#125; return list; &#125;&#125; 2.3.5.mapper在ly-item-service中的mapper中添加 我们使用通用mapper来简化开发： 12public interface CategoryMapper extends Mapper&lt;Category&gt; &#123;&#125; 要注意，我们并没有在mapper接口上声明@Mapper注解，那么mybatis如何才能找到接口呢？ 我们在启动类上添加一个扫描包功能： 在ly-item-service中LyItemService.java添加： 12345678@SpringBootApplication@EnableDiscoveryClient@MapperScan("com.leyou.item.mapper") // 扫描mapper包public class LyItemService &#123; public static void main(String[] args) &#123; SpringApplication.run(LyItemService.class, args); &#125;&#125; 2.3.6.启动并测试我们不经过网关，直接访问： 然后试试网关是否畅通： 一切OK！ 然后刷新页面查看： 发现报错了！ 浏览器直接访问没事，但是这里却报错，什么原因？ 2.4.跨域问题2.4.1.什么是跨域跨域是指跨域名的访问，以下情况都属于跨域： 跨域原因说明 示例 域名不同 www.jd.com 与 www.taobao.com 域名相同，端口不同 www.jd.com:8080 与 www.jd.com:8081 二级域名不同 item.jd.com 与 miaosha.jd.com 如果域名和端口都相同，但是请求路径不同，不属于跨域，如： www.jd.com/item www.jd.com/goods 而我们刚才是从manage.leyou.com去访问api.leyou.com，这属于二级域名不同，跨域了。 2.4.2.为什么有跨域问题？跨域不一定会有跨域问题。 因为跨域问题是浏览器对于ajax请求的一种安全限制：一个页面发起的ajax请求，只能是于当前页同域名的路径，这能有效的阻止跨站攻击。 因此：跨域问题 是针对ajax的一种限制。 但是这却给我们的开发带来了不变，而且在实际生成环境中，肯定会有很多台服务器之间交互，地址和端口都可能不同，怎么办？ 2.4.3.解决跨域问题的方案目前比较常用的跨域解决方案有3种： Jsonp 最早的解决方案，利用script标签可以跨域的原理实现。 限制： 需要服务的支持 只能发起GET请求 nginx反向代理 思路是：利用nginx反向代理把跨域为不跨域，支持各种请求方式 缺点：需要在nginx进行额外配置，语义不清晰 CORS 规范化的跨域请求解决方案，安全可靠。 优势： 在服务端进行控制是否允许跨域，可自定义规则 支持各种请求方式 缺点： 会产生额外的请求 我们这里会采用cors的跨域方案。 2.5.cors解决跨域2.5.1.什么是corsCORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。 它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。 CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。 浏览器端： 目前，所有浏览器都支持该功能（IE10以下不行）。整个CORS通信过程，都是浏览器自动完成，不需要用户参与。 服务端： CORS通信与AJAX没有任何差别，因此你不需要改变以前的业务逻辑。只不过，浏览器会在请求中携带一些头信息，我们需要以此判断是否运行其跨域，然后在响应头中加入一些信息即可。这一般通过过滤器完成即可。 2.5.2.原理有点复杂浏览器会将ajax请求分为两类，其处理方案略有差异：简单请求、特殊请求。 简单请求只要同时满足以下两大条件，就属于简单请求。： （1) 请求方法是以下三种方法之一： HEAD GET POST （2）HTTP的头信息不超出以下几种字段： Accept Accept-Language Content-Language Last-Event-ID Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain 当浏览器发现发现的ajax请求是简单请求时，会在请求头中携带一个字段：Origin. Origin中会指出当前请求属于哪个域（协议+域名+端口）。服务会根据这个值决定是否允许其跨域。 如果服务器允许跨域，需要在返回的响应头中携带下面信息： 123Access-Control-Allow-Origin: http://manage.leyou.comAccess-Control-Allow-Credentials: trueContent-Type: text/html; charset=utf-8 Access-Control-Allow-Origin：可接受的域，是一个具体域名或者*，代表任意 Access-Control-Allow-Credentials：是否允许携带cookie，默认情况下，cors不会携带cookie，除非这个值是true 注意： 如果跨域请求要想操作cookie，需要满足3个条件： 服务的响应头中需要携带Access-Control-Allow-Credentials并且为true。 浏览器发起ajax需要指定withCredentials 为true 响应头中的Access-Control-Allow-Origin一定不能为*，必须是指定的域名 特殊请求不符合简单请求的条件，会被浏览器判定为特殊请求,，例如请求方式为PUT。 预检请求 特殊请求会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）。 浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。 一个“预检”请求的样板： 12345678OPTIONS /cors HTTP/1.1Origin: http://manage.leyou.comAccess-Control-Request-Method: PUTAccess-Control-Request-Headers: X-Custom-HeaderHost: api.leyou.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0... 与简单请求相比，除了Origin以外，多了两个头： Access-Control-Request-Method：接下来会用到的请求方式，比如PUT Access-Control-Request-Headers：会额外用到的头信息 预检请求的响应 服务的收到预检请求，如果许可跨域，会发出响应： 1234567891011121314HTTP/1.1 200 OKDate: Mon, 01 Dec 2008 01:15:39 GMTServer: Apache/2.0.61 (Unix)Access-Control-Allow-Origin: http://manage.leyou.comAccess-Control-Allow-Credentials: trueAccess-Control-Allow-Methods: GET, POST, PUTAccess-Control-Allow-Headers: X-Custom-HeaderAccess-Control-Max-Age: 1728000Content-Type: text/html; charset=utf-8Content-Encoding: gzipContent-Length: 0Keep-Alive: timeout=2, max=100Connection: Keep-AliveContent-Type: text/plain 除了Access-Control-Allow-Origin和Access-Control-Allow-Credentials以外，这里又额外多出3个头： Access-Control-Allow-Methods：允许访问的方式 Access-Control-Allow-Headers：允许携带的头 Access-Control-Max-Age：本次许可的有效时长，单位是秒，过期之前的ajax请求就无需再次进行预检了 如果浏览器得到上述响应，则认定为可以跨域，后续就跟简单请求的处理是一样的了。 2.5.3.实现非常简单虽然原理比较复杂，但是前面说过： 浏览器端都有浏览器自动完成，我们无需操心 服务端可以通过拦截器统一实现，不必每次都去进行跨域判定的编写。 事实上，SpringMVC已经帮我们写好了CORS的跨域过滤器：CorsFilter ,内部已经实现了刚才所讲的判定逻辑，我们直接用就好了。 在ly-gateway中编写一个配置类，并且注册CorsFilter： 1234567891011121314151617181920212223242526272829303132333435import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.cors.CorsConfiguration;import org.springframework.web.cors.UrlBasedCorsConfigurationSource;import org.springframework.web.filter.CorsFilter;@Configurationpublic class GlobalCorsConfig &#123; @Bean public CorsFilter corsFilter() &#123; //1.添加CORS配置信息 CorsConfiguration config = new CorsConfiguration(); //1) 允许的域,不要写*，否则cookie就无法使用了 config.addAllowedOrigin("http://manage.leyou.com"); //2) 是否发送Cookie信息 config.setAllowCredentials(true); //3) 允许的请求方式 config.addAllowedMethod("OPTIONS"); config.addAllowedMethod("HEAD"); config.addAllowedMethod("GET"); config.addAllowedMethod("PUT"); config.addAllowedMethod("POST"); config.addAllowedMethod("DELETE"); config.addAllowedMethod("PATCH"); // 4）允许的头信息 config.addAllowedHeader("*"); //2.添加映射路径，我们拦截一切请求 UrlBasedCorsConfigurationSource configSource = new UrlBasedCorsConfigurationSource(); configSource.registerCorsConfiguration("/**", config); //3.返回新的CorsFilter. return new CorsFilter(configSource); &#125;&#125; 结构： 4.5.4.重启测试： 访问正常： 页面也OK了： 分类的增删改功能暂时就不做了，页面已经预留好了事件接口，有兴趣的同学可以完成一下。 3.品牌的查询（结合3.1-3.7一起看，先修改前端后修改后端）商品分类完成以后，自然轮到了品牌功能了。 先看看我们要实现的效果： 接下来，我们从0开始，实现下从前端到后端的完整开发。 3.1.从0开始为了方便看到效果，我们新建一个MyBrand.vue（注意先停掉服务器），从0开始搭建。 内容初始化一下： 123456789101112131415&lt;template&gt; &lt;span&gt; hello &lt;/span&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: &quot;my-brand&quot; &#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 改变router新的index.js，将路由地址指向MyBrand.vue 打开服务器，再次查看页面： 干干净净了。 3.2.品牌查询页面3.2.1.data-tables组件大家看到这个原型页面肯定能看出，其主体就是一个table。我们去Vuetify查看有关table的文档： 仔细阅读，发现v-data-table中有以下核心属性： dark：是否使用黑暗色彩主题，默认是false expand：表格的行是否可以展开，默认是false headers：定义表头的数组，数组的每个元素就是一个表头信息对象，结构： 12345678&#123; text: string, // 表头的显示文本 value: string, // 表头对应的每行数据的key align: 'left' | 'center' | 'right', // 位置 sortable: boolean, // 是否可排序 class: string[] | string,// 样式 width: string,// 宽度&#125; items：表格的数据的数组，数组的每个元素是一行数据的对象，对象的key要与表头的value一致 loading：是否显示加载数据的进度条，默认是false no-data-text：当没有查询到数据时显示的提示信息，string类型，无默认值 pagination.sync：包含分页和排序信息的对象，将其与vue实例中的属性关联，表格的分页或排序按钮被触发时，会自动将最新的分页和排序信息更新。对象结构： 123456&#123; page: 1, // 当前页 rowsPerPage: 5, // 每页大小 sortBy: '', // 排序字段 descending:false, // 是否降序&#125; total-items：分页的总条数信息，number类型，无默认值 select-all ：是否显示每一行的复选框，Boolean类型，无默认值 value：当表格可选的时候，返回选中的行 我们向下翻，找找有没有看起来牛逼的案例。 找到这样一条： 其它的案例都是由Vuetify帮我们对查询到的当前页数据进行排序和分页，这显然不是我们想要的。我们希望能在服务端完成对整体品牌数据的排序和分页，而这个案例恰好合适。 点击按钮，我们直接查看源码，然后直接复制到MyBrand.vue中 模板： 12345678910111213141516171819202122&lt;template&gt; &lt;div&gt; &lt;v-data-table :headers=&quot;headers&quot; :items=&quot;desserts&quot; :search=&quot;search&quot; :pagination.sync=&quot;pagination&quot; :total-items=&quot;totalDesserts&quot; :loading=&quot;loading&quot; class=&quot;elevation-1&quot; &gt; &lt;template slot=&quot;items&quot; slot-scope=&quot;props&quot;&gt; &lt;td&gt;&#123;&#123; props.item.name &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-right&quot;&gt;&#123;&#123; props.item.calories &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-right&quot;&gt;&#123;&#123; props.item.fat &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-right&quot;&gt;&#123;&#123; props.item.carbs &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-right&quot;&gt;&#123;&#123; props.item.protein &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-right&quot;&gt;&#123;&#123; props.item.iron &#125;&#125;&lt;/td&gt; &lt;/template&gt; &lt;/v-data-table&gt; &lt;/div&gt;&lt;/template&gt; 3.2.2.分析接下来，就分析一下案例中每一部分是什么意思，搞清楚了，我们也可以自己玩了。 先看模板中table上的一些属性： 12345678910&lt;v-data-table :headers=&quot;headers&quot; :items=&quot;desserts&quot; :search=&quot;search&quot; :pagination.sync=&quot;pagination&quot; :total-items=&quot;totalDesserts&quot; :loading=&quot;loading&quot; class=&quot;elevation-1&quot; &gt;&lt;/v-data-table&gt; headers：表头信息，是一个数组 items：要在表格中展示的数据，数组结构，每一个元素是一行 search：搜索过滤字段，用不到，暂时不管 pagination.sync：分页信息，包含了当前页，每页大小，排序字段，排序方式等。加上.sync代表服务端排序，当用户点击分页条时，该对象的值会跟着变化。监控这个值，并在这个值变化时去服务端查询，即可实现页面数据动态加载了。 total-items：总条数 loading：boolean类型，true：代表数据正在加载，会有进度条。false：数据加载完毕。 另外，在v-data-tables中，我们还看到另一段代码： 12345678&lt;template slot=&quot;items&quot; slot-scope=&quot;props&quot;&gt; &lt;td&gt;&#123;&#123; props.item.name &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-right&quot;&gt;&#123;&#123; props.item.calories &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-right&quot;&gt;&#123;&#123; props.item.fat &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-right&quot;&gt;&#123;&#123; props.item.carbs &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-right&quot;&gt;&#123;&#123; props.item.protein &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-right&quot;&gt;&#123;&#123; props.item.iron &#125;&#125;&lt;/td&gt;&lt;/template&gt; 这段就是在渲染每一行的数据。Vue会自动遍历上面传递的items属性，并把得到的对象传递给这段template中的props.item属性。我们从中得到数据，渲染在页面即可。 我们需要做的事情，主要有两件： 给items和totalItems赋值 当pagination变化时，重新获取数据，再次给items和totalItems赋值 3.2.3.初步实现我们先弄点假品牌数据： 1234567891011121314151617181920212223242526272829303132[ &#123; "id": 2032, "name": "OPPO", "image": "http://img10.360buyimg.com/popshop/jfs/t2119/133/2264148064/4303/b8ab3755/56b2f385N8e4eb051.jpg", "letter": "O" &#125;, &#123; "id": 2033, "name": "飞利浦（PHILIPS）", "image": "http://img12.360buyimg.com/popshop/jfs/t18361/122/1318410299/1870/36fe70c9/5ac43a4dNa44a0ce0.jpg", "letter": "F" &#125;, &#123; "id": 2034, "name": "华为（HUAWEI）", "image": "http://img10.360buyimg.com/popshop/jfs/t5662/36/8888655583/7806/1c629c01/598033b4Nd6055897.jpg", "letter": "H" &#125;, &#123; "id": 2036, "name": "酷派（Coolpad）", "image": "http://img10.360buyimg.com/popshop/jfs/t2521/347/883897149/3732/91c917ec/5670cf96Ncffa2ae6.jpg", "letter": "K" &#125;, &#123; "id": 2037, "name": "魅族（MEIZU）", "image": "http://img13.360buyimg.com/popshop/jfs/t3511/131/31887105/4943/48f83fa9/57fdf4b8N6e95624d.jpg", "letter": "M" &#125;] 品牌中有id,name,image,letter字段。 修改模板123456789101112131415161718192021&lt;div&gt; &lt;v-data-table :headers=&quot;headers&quot; :items=&quot;brands&quot; :search=&quot;search&quot; :pagination.sync=&quot;pagination&quot; :total-items=&quot;totalBrands&quot; :loading=&quot;loading&quot; class=&quot;elevation-1&quot; &gt; &lt;template slot=&quot;items&quot; slot-scope=&quot;props&quot;&gt; &lt;td&gt;&#123;&#123; props.item.id &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.name &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt; &lt;img v-if=&quot;props.item.image&quot; :src=&quot;props.item.image&quot; width=&quot;130&quot; height=&quot;40&quot;&gt; &lt;span v-else&gt;无&lt;/span&gt; &lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.letter &#125;&#125;&lt;/td&gt; &lt;/template&gt; &lt;/v-data-table&gt;&lt;/div&gt; 我们修改了以下部分： items：指向一个brands变量，等下在js代码中定义 total-items：指向了totalBrands变量，等下在js代码中定义 template模板中，渲染了四个字段： id： name image，注意，我们不是以文本渲染，而是赋值到一个img标签的src属性中，并且做了非空判断 letter 编写数据接下来编写要用到的数据： 1234567891011121314151617&#123; data() &#123; return &#123; search: '', // 搜索过滤字段 totalBrands: 0, // 总条数 brands: [], // 当前页品牌数据 loading: true, // 是否在加载中 pagination: &#123;&#125;, // 分页信息 headers: [ // 头信息 &#123;text: 'id', align: 'center', value: 'id'&#125;, &#123;text: '名称', align: 'center', sortable: false, value: 'name'&#125;, &#123;text: 'LOGO', align: 'center', sortable: false, value: 'image'&#125;, &#123;text: '首字母', align: 'center', value: 'letter', sortable: true,&#125; ] &#125; &#125;&#125; 编写函数，初始化数据接下来就是对brands和totalBrands完成赋值动作了。 我们编写一个函数来完成赋值，提高复用性： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950methods:&#123; getDataFromServer()&#123; // 从服务的加载数据的方法。 // 伪造假数据 const brands = [ &#123; "id": 2032, "name": "OPPO", "image": "http://img10.360buyimg.com/popshop/jfs/t2119/133/2264148064/4303/b8ab3755/56b2f385N8e4eb051.jpg", "letter": "O", "categories": null &#125;, &#123; "id": 2033, "name": "飞利浦（PHILIPS）", "image": "http://img12.360buyimg.com/popshop/jfs/t18361/122/1318410299/1870/36fe70c9/5ac43a4dNa44a0ce0.jpg", "letter": "F", "categories": null &#125;, &#123; "id": 2034, "name": "华为（HUAWEI）", "image": "http://img10.360buyimg.com/popshop/jfs/t5662/36/8888655583/7806/1c629c01/598033b4Nd6055897.jpg", "letter": "H", "categories": null &#125;, &#123; "id": 2036, "name": "酷派（Coolpad）", "image": "http://img10.360buyimg.com/popshop/jfs/t2521/347/883897149/3732/91c917ec/5670cf96Ncffa2ae6.jpg", "letter": "K", "categories": null &#125;, &#123; "id": 2037, "name": "魅族（MEIZU）", "image": "http://img13.360buyimg.com/popshop/jfs/t3511/131/31887105/4943/48f83fa9/57fdf4b8N6e95624d.jpg", "letter": "M", "categories": null &#125; ]; // 模拟延迟一段时间，随后进行赋值 setTimeout(() =&gt; &#123; // 然后赋值给brands this.brands = brands; this.totalBrands = brands.length; // 完成赋值后，把加载状态赋值为false this.loading = false; &#125;,400) &#125;&#125; 然后使用钩子函数，在Vue实例初始化完毕后调用这个方法，这里使用mounted（渲染后）函数： 1234mounted()&#123; // 渲染后执行 // 查询数据 this.getDataFromServer();&#125; 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899&lt;template&gt; &lt;div&gt; &lt;v-data-table :headers=&quot;headers&quot; :items=&quot;brands&quot; :search=&quot;search&quot; :pagination.sync=&quot;pagination&quot; :total-items=&quot;totalBrands&quot; :loading=&quot;loading&quot; class=&quot;elevation-1&quot; &gt; &lt;template slot=&quot;items&quot; slot-scope=&quot;props&quot;&gt; &lt;td&gt;&#123;&#123; props.item.id &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.name &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&lt;img :src=&quot;props.item.image&quot;&gt;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.letter &#125;&#125;&lt;/td&gt; &lt;/template&gt; &lt;/v-data-table&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: &quot;my-brand&quot;, data() &#123; return &#123; search: &apos;&apos;, // 搜索过滤字段 totalBrands: 0, // 总条数 brands: [], // 当前页品牌数据 loading: true, // 是否在加载中 pagination: &#123;&#125;, // 分页信息 headers: [ &#123;text: &apos;id&apos;, align: &apos;center&apos;, value: &apos;id&apos;&#125;, &#123;text: &apos;名称&apos;, align: &apos;center&apos;, sortable: false, value: &apos;name&apos;&#125;, &#123;text: &apos;LOGO&apos;, align: &apos;center&apos;, sortable: false, value: &apos;image&apos;&#125;, &#123;text: &apos;首字母&apos;, align: &apos;center&apos;, value: &apos;letter&apos;, sortable: true,&#125; ] &#125; &#125;, mounted()&#123; // 渲染后执行 // 查询数据 this.getDataFromServer(); &#125;, methods:&#123; getDataFromServer()&#123; // 从服务的加载数的方法。 // 伪造假数据 const brands = [ &#123; &quot;id&quot;: 2032, &quot;name&quot;: &quot;OPPO&quot;, &quot;image&quot;: &quot;http://img10.360buyimg.com/popshop/jfs/t2119/133/2264148064/4303/b8ab3755/56b2f385N8e4eb051.jpg&quot;, &quot;letter&quot;: &quot;O&quot;, &quot;categories&quot;: null &#125;, &#123; &quot;id&quot;: 2033, &quot;name&quot;: &quot;飞利浦（PHILIPS）&quot;, &quot;image&quot;: &quot;http://img12.360buyimg.com/popshop/jfs/t18361/122/1318410299/1870/36fe70c9/5ac43a4dNa44a0ce0.jpg&quot;, &quot;letter&quot;: &quot;F&quot;, &quot;categories&quot;: null &#125;, &#123; &quot;id&quot;: 2034, &quot;name&quot;: &quot;华为（HUAWEI）&quot;, &quot;image&quot;: &quot;http://img10.360buyimg.com/popshop/jfs/t5662/36/8888655583/7806/1c629c01/598033b4Nd6055897.jpg&quot;, &quot;letter&quot;: &quot;H&quot;, &quot;categories&quot;: null &#125;, &#123; &quot;id&quot;: 2036, &quot;name&quot;: &quot;酷派（Coolpad）&quot;, &quot;image&quot;: &quot;http://img10.360buyimg.com/popshop/jfs/t2521/347/883897149/3732/91c917ec/5670cf96Ncffa2ae6.jpg&quot;, &quot;letter&quot;: &quot;K&quot;, &quot;categories&quot;: null &#125;, &#123; &quot;id&quot;: 2037, &quot;name&quot;: &quot;魅族（MEIZU）&quot;, &quot;image&quot;: &quot;http://img13.360buyimg.com/popshop/jfs/t3511/131/31887105/4943/48f83fa9/57fdf4b8N6e95624d.jpg&quot;, &quot;letter&quot;: &quot;M&quot;, &quot;categories&quot;: null &#125; ]; // 模拟延迟一段时间，随后进行赋值 setTimeout(() =&gt; &#123; // 然后赋值给brands this.brands = brands; this.totalBrands = brands.length; // 完成赋值后，把加载状态赋值为false this.loading = false; &#125;,400) &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 刷新页面查看： 3.2.4.优化页面编辑和删除按钮我们将来要对品牌进行增删改，需要给每一行数据添加 修改删除的按钮，一般放到改行的最后一列： 其实就是多了一列，只是这一列没有数据，而是两个按钮而已。 我们先在头（headers）中添加一列： 1234567headers: [ &#123;text: 'id', align: 'center', value: 'id'&#125;, &#123;text: '名称', align: 'center', sortable: false, value: 'name'&#125;, &#123;text: 'LOGO', align: 'center', sortable: false, value: 'image'&#125;, &#123;text: '首字母', align: 'center', value: 'letter', sortable: true,&#125;, &#123;text: '操作', align: 'center', value: 'id', sortable: false&#125;] 然后在模板中添加按钮： 123456789&lt;template slot=&quot;items&quot; slot-scope=&quot;props&quot;&gt; &lt;td&gt;&#123;&#123; props.item.id &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.name &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&lt;img :src=&quot;props.item.image&quot;&gt;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.letter &#125;&#125;&lt;/td&gt; &lt;td class=&quot;justify-center&quot;&gt; 编辑/删除 &lt;/td&gt;&lt;/template&gt; 因为不知道按钮怎么写，先放个普通文本看看： 然后在官方文档中找到按钮的用法： 修改我们的模板： 12345678910&lt;template slot=&quot;items&quot; slot-scope=&quot;props&quot;&gt; &lt;td&gt;&#123;&#123; props.item.id &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.name &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&lt;img :src=&quot;props.item.image&quot;&gt;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.letter &#125;&#125;&lt;/td&gt; &lt;td class=&quot;justify-center layout&quot;&gt; &lt;v-btn color=&quot;info&quot;&gt;编辑&lt;/v-btn&gt; &lt;v-btn color=&quot;warning&quot;&gt;删除&lt;/v-btn&gt; &lt;/td&gt;&lt;/template&gt; 新增按钮因为新增根某个品牌无关，是独立的，因此我们可以放到表格的外面： 效果： 布局v-layout、v-flex1234567891011121314151617181920212223242526&lt;div&gt; &lt;v-layout class=&quot;px-2&quot;&gt; &lt;v-flex xs2&gt; &lt;v-btn color=&quot;info&quot; &gt;新增品牌&lt;/v-btn&gt; &lt;/v-flex&gt; &lt;/v-layout&gt; &lt;v-data-table :headers=&quot;headers&quot; :items=&quot;brands&quot; :search=&quot;search&quot; :pagination.sync=&quot;pagination&quot; :total-items=&quot;totalBrands&quot; :loading=&quot;loading&quot; class=&quot;elevation-1&quot; &gt; &lt;template slot=&quot;items&quot; slot-scope=&quot;props&quot;&gt; &lt;td&gt;&#123;&#123; props.item.id &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.name &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&lt;img :src=&quot;props.item.image&quot;&gt;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.letter &#125;&#125;&lt;/td&gt; &lt;td class=&quot;justify-center layout&quot;&gt; &lt;v-btn color=&quot;info&quot;&gt;编辑&lt;/v-btn&gt; &lt;v-btn color=&quot;warning&quot;&gt;删除&lt;/v-btn&gt; &lt;/td&gt; &lt;/template&gt; &lt;/v-data-table&gt; 效果： 添加搜索框我们还可以在卡片头部添加一个搜索框，其实就是一个文本输入框。 查看官网中，文本框的用法： name：字段名，表单中会用到 label：提示文字 value：值。可以用v-model代替，实现双向绑定 修改模板，添加输入框： 123&lt;v-flex xs4&gt; &lt;v-text-field label="输入关键字搜索" v-model="key" append-icon="search" hide-details /&gt;&lt;/v-flex&gt; 效果： 发现输入框变的超级长！！！ 这个时候，我们可以使用Vuetify提供的一个空间隔离工具： 修改代码： 12345678910&lt;v-layout class="px-2"&gt; &lt;v-flex xs2&gt; &lt;v-btn color="info" &gt;新增品牌&lt;/v-btn&gt; &lt;/v-flex&gt; &lt;!--撑开一个空间--&gt; &lt;v-spacer/&gt; &lt;v-flex xs4&gt; &lt;v-text-field label="输入关键字搜索" v-model="key" append-icon="search" hide-details /&gt; &lt;/v-flex&gt;&lt;/v-layout&gt; 给搜索框添加搜索图标查看textfiled的文档，发现： 通过append-icon属性可以为 输入框添加后置图标，所有可用图标名称可以到 material-icons官网去查看。 修改我们的代码： 1&lt;v-text-field label="输入关键字搜索" v-model="search" append-icon="search"/&gt; 把文本框变紧凑搜索框看起来高度比较高，页面不够紧凑。这其实是因为默认在文本框下面预留有错误提示空间。通过下面的属性可以取消提示： 修改代码： 1&lt;v-text-field label="输入关键字搜索" v-model="search" append-icon="search" hide-details/&gt; 效果： 几乎已经达到了原来一样的效果了吧！ 3.3.异步查询工具axios异步查询数据，自然是通过ajax查询，大家首先想起的肯定是jQuery。但jQuery与MVVM的思想不吻合，而且ajax只是jQuery的一小部分。因此不可能为了发起ajax请求而去引用这么大的一个库。 3.3.1.axios入门Vue官方推荐的ajax请求框架叫做：axios，看下demo： axios的Get请求语法： 123456789101112131415axios.get("/item/category/list?pid=0") // 请求路径和请求参数拼接 .then(function(resp)&#123; // 成功回调函数 &#125;) .catch(function()&#123; // 失败回调函数 &#125;)// 参数较多时，可以通过params来传递参数axios.get("/item/category/list", &#123; params:&#123; pid:0 &#125; &#125;) .then(function(resp)&#123;&#125;)// 成功时的回调 .catch(function(error)&#123;&#125;)// 失败时的回调 axios的POST请求语法： 比如新增一个用户 123456axios.post("/user",&#123; name:"Jack", age:21 &#125;) .then(function(resp)&#123;&#125;) .catch(function(error)&#123;&#125;) 注意，POST请求传参，不需要像GET请求那样定义一个对象，在对象的params参数中传参。post()方法的第二个参数对象，就是将来要传递的参数 PUT和DELETE请求与POST请求类似 3.3.2.axios的全局配置而在我们的项目中，已经引入了axios，并且进行了简单的封装，在src下的http.js中： http.js中对axios进行了一些默认配置： 12345678import Vue from 'vue'import axios from 'axios'import config from './config'// config中定义的基础路径是：http://api.leyou.com/apiaxios.defaults.baseURL = config.api; // 设置axios的基础请求路径axios.defaults.timeout = 2000; // 设置axios的请求时间Vue.prototype.$http = axios;// 将axios赋值给Vue原型的$http属性，这样所有vue实例都可使用该对象 http.js中导入了config的配置，还记得吗？ http.js对axios进行了全局配置：baseURL=config.api，即http://api.leyou.com/api。因此以后所有用axios发起的请求，都会以这个地址作为前缀。 通过Vue.property.$http = axios，将axios赋值给了 Vue原型中的$http。这样以后所有的Vue实例都可以访问到$http，也就是访问到了axios了。 3.3.3.测试一下：我们在组件MyBrand.vue的loadBrands()方法，通过$http发起get请求，测试查询品牌的接口，看是否能获取到数据： 网络监视： 控制台结果： 可以看到，在请求成功的返回结果response中，有一个data属性，里面就是真正的响应数据。 响应结果中与我们设计的一致，包含3个内容： total：总条数，目前是165 items：当前页数据 totalPage：总页数，我们没有返回 3.4.异步加载品牌数据虽然已经通过ajax请求获取了品牌数据，但是刚才的请求没有携带任何参数，这样显然不对。我们后端接口需要5个参数： page：当前页，int rows：每页大小，int sortBy：排序字段，String desc：是否为降序，boolean key：搜索关键词，String 而页面中分页信息应该是在pagination对象中，我们通过浏览器工具，查看pagination中有哪些属性： 分别是： descending：是否是降序，对应请求参数的desc page：当前页，对应参数的page rowsPerpage：每页大小，对应参数中的rows sortBy：排序字段，对应参数的sortBy 缺少一个搜索关键词，这个应该是通过v-model与输入框绑定的属性：search。这样，所有参数就都有了。 另外，不要忘了把查询的结果赋值给brands和totalBrands属性，Vuetify会帮我们渲染页面。 接下来，我们在loadBrands()方法中完善请求参数： 12345678910111213141516// 发起请求this.$http.get("/item/brand/page",&#123; params:&#123; key: this.search, // 搜索条件 page: this.pagination.page,// 当前页 rows: this.pagination.rowsPerPage,// 每页大小 sortBy: this.pagination.sortBy,// 排序字段 desc: this.pagination.descending// 是否降序 &#125; &#125;).then(resp =&gt; &#123; // 这里使用箭头函数 // 将得到的数据赋值给本地属性 this.brands = resp.data.items; this.totalBrands = resp.data.total; // 完成赋值后，把加载状态赋值为false this.loading = false; &#125;) 查看网络请求： 效果： 3.5.完成分页和过滤3.5.1.分页现在我们实现了页面加载时的第一次查询，你会发现你点击分页或搜索不会发起新的请求，怎么办？ 虽然点击分页，不会发起请求，但是通过浏览器工具查看，会发现pagination对象的属性一直在变化： 我们可以利用Vue的监视功能：watch，当pagination发生改变时，会调用我们的回调函数，我们在回调函数中进行数据的查询即可！ 具体实现： 成功实现分页功能： 3.5.2.过滤分页实现了，过滤也很好实现了。过滤字段对应的是key属性，我们只要监视这个属性即可: 查看网络请求： 页面结果： 3.6.前端完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102&lt;template&gt; &lt;div&gt; &lt;v-layout class=&quot;px-2&quot;&gt; &lt;v-flex xs2&gt; &lt;v-btn color=&quot;info&quot; &gt;新增品牌&lt;/v-btn&gt; &lt;/v-flex&gt; &lt;!--撑开一个空间--&gt; &lt;v-spacer/&gt; &lt;v-flex xs4&gt; &lt;v-text-field label=&quot;输入关键字搜索&quot; v-model=&quot;key&quot; append-icon=&quot;search&quot; hide-details /&gt; &lt;/v-flex&gt; &lt;/v-layout&gt; &lt;!--v-data-table表格，pagination：分页信息，total-items：查出来总数 ,loading：进度条--&gt; &lt;v-data-table :headers=&quot;headers&quot; :items=&quot;brands&quot; :pagination.sync=&quot;pagination&quot; :total-items=&quot;totalBrands&quot; :loading=&quot;loading&quot; class=&quot;elevation-1&quot; &gt; &lt;template slot=&quot;items&quot; slot-scope=&quot;props&quot;&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.id &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.name &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&lt;img v-if=&quot;props.item.image&quot; :src=&quot;props.item.image&quot; width=&quot;130&quot; height=&quot;40&quot;&gt;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt;&#123;&#123; props.item.letter &#125;&#125;&lt;/td&gt; &lt;td class=&quot;text-xs-center&quot;&gt; &lt;v-btn color=&quot;warning&quot;&gt;删除&lt;/v-btn&gt; &lt;v-btn color=&quot;info&quot;&gt;修改&lt;/v-btn&gt; &lt;/td&gt; &lt;/template&gt; &lt;/v-data-table&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: &quot;Mybrand.vue&quot;, data()&#123; return&#123; headers:[ &#123;text: &apos;品牌id&apos;,value: &apos;id&apos;,align: &apos;center&apos;,sortable: true&#125;, &#123;text: &apos;品牌名称&apos;,value: &apos;name&apos;,align: &apos;center&apos;,sortable: false&#125;, &#123;text: &apos;品牌LOGO&apos;,value: &apos;image&apos;,align: &apos;center&apos;,sortable: false&#125;, &#123;text: &apos;品牌首字母&apos;,value: &apos;letter&apos;,align: &apos;center&apos;,sortable: true&#125;, &#123;text: &apos;操作&apos;,value: &apos;id&apos;,align: &apos;center&apos;,sortable: false&#125;, ], brands:[], //当前页品牌数 pagination:&#123;&#125;, //分页信息 totalBrands:0, //查询出来的总数据条数 loading:false, //是否加载 key:&quot;&quot;, //搜索关键字 &#125; &#125;, //1、立马加载 created()&#123; this.totalBrands=15; //去后台查询品牌 this.loadBrands(); &#125;, //2、监控,数据变化后就立马加载 watch:&#123; //监控搜索关键词 key:&#123; handler() &#123; this.loadBrands(); this.pagination.page=1; &#125; &#125;, pagination:&#123; deep:true,//深度监控 handler()&#123; this.loadBrands(); &#125; &#125; &#125;, //3、与后台数据交互 methods:&#123; loadBrands()&#123; this.loading=true; this.$http.get(&quot;/item/brand/page&quot;,&#123; params:&#123; key:this.key,//搜索条件 page:this.pagination.page,//当前页 row:this.pagination.rowsPerPage,//每页大小 sortBy:this.pagination.sortBy,//排序字段 desc:this.pagination.descending,//是否降序 &#125; &#125;).then(resp =&gt; &#123; this.brands=resp.data.items; this.totalBrands=resp.data.total; this.loading=false; &#125;) &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 3.7.后台提供查询接口前台页面已经准备好，接下来就是后台提供数据接口了。 3.7.1.数据库表1234567CREATE TABLE `tb_brand` ( `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT &apos;品牌id&apos;, `name` varchar(50) NOT NULL COMMENT &apos;品牌名称&apos;, `image` varchar(200) DEFAULT &apos;&apos; COMMENT &apos;品牌图片地址&apos;, `letter` char(1) DEFAULT &apos;&apos; COMMENT &apos;品牌的首字母&apos;, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=325400 DEFAULT CHARSET=utf8 COMMENT=&apos;品牌表，一个品牌下有多个商品（spu），一对多关系&apos;; 简单的四个字段，不多解释。 这里需要注意的是，品牌和商品分类之间是多对多关系。因此我们有一张中间表，来维护两者间关系： 12345CREATE TABLE `tb_category_brand` ( `category_id` bigint(20) NOT NULL COMMENT &apos;商品类目id&apos;, `brand_id` bigint(20) NOT NULL COMMENT &apos;品牌id&apos;, PRIMARY KEY (`category_id`,`brand_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&apos;商品分类和品牌的中间表，两者是多对多关系&apos;; 但是，你可能会发现，这张表中并没有设置外键约束，似乎与数据库的设计范式不符。为什么这么做？ 外键会严重影响数据库读写的效率 数据删除时会比较麻烦 在电商行业，性能是非常重要的。我们宁可在代码中通过逻辑来维护表关系，也不设置外键。 3.7.2.实体类在ly-item-interface中创建Brand类 1234567891011@Table(name = "tb_brand")@Datapublic class Brand &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; private String name;// 品牌名称 private String image;// 品牌图片 private Character letter; // getter setter 略&#125; 3.7.3.mapperly-item-service的mapper中创建 通用mapper来简化开发： 12public interface BrandMapper extends Mapper&lt;Brand&gt; &#123;&#125; 3.7.4.controllerly-item-service的web中创建 编写controller先思考四个问题，这次没有前端代码，需要我们自己来设定 请求方式：查询，肯定是Get 请求路径：分页查询，/brand/page 请求参数：根据我们刚才编写的页面，有分页功能，有排序功能，有搜索过滤功能，因此至少要有5个参数： page：当前页，int rows：每页大小，int sortBy：排序字段，String desc：是否为降序，boolean key：搜索关键词，String 响应结果：分页结果一般至少需要两个数据 total：总条数 items：当前页数据 totalPage：有些还需要总页数 这里我们封装一个类，来表示分页结果： 1234567891011121314151617181920@Datapublic class PageResult&lt;T&gt; &#123; private Long total;// 总条数 private Long totalPage;// 总页数 private List&lt;T&gt; items;// 当前页数据 public PageResult() &#123; &#125; public PageResult(Long total, List&lt;T&gt; items) &#123; this.total = total; this.items = items; &#125; public PageResult(Long total, Long totalPage, List&lt;T&gt; items) &#123; this.total = total; this.totalPage = totalPage; this.items = items; &#125;&#125; 另外，这个PageResult以后可能在其它项目中也有需求，因此我们将其抽取到ly-common中，提高复用性： 接下来，我们编写Controller 12345678910111213141516171819202122232425262728@RestController@RequestMapping("brand")public class BrandController &#123; @Autowired private BrandService brandService; /** * * @param page 当前页 * @param rows 每页显示多少数据 * @param sortBy 是否排序 * @param desc 是否降序 * @param key 搜索条件 * @return */ @GetMapping("page") public ResponseEntity&lt;PageResult&lt;Brand&gt;&gt; queryBrandByPage( @RequestParam(value = "page", defaultValue = "1") Integer page, @RequestParam(value = "rows", defaultValue = "5") Integer rows, @RequestParam(value = "sortBy", required = false) String sortBy, @RequestParam(value = "desc", defaultValue = "false") Boolean desc, @RequestParam(value = "key", required = false) String key )&#123; PageResult&lt;Brand&gt; brandPageResult = brandService.queryBrandByPage(page, rows, sortBy, desc, key); return ResponseEntity.ok(brandPageResult); &#125;&#125; 3.7.5.Service123456789101112131415161718192021222324252627282930313233public class BrandService &#123; @Autowired private BrandMapper brandMapper; public PageResult&lt;Brand&gt; queryBrandByPage(Integer page, Integer rows, String sortBy, boolean desc, String key) &#123; //分页 PageHelper.startPage(page,rows); //过滤(搜索) /** * SQL语句 * where name like %x% or letter==x * order by desc */ Example example = new Example(Brand.class); if(StringUtils.isNotBlank(key))&#123; example.createCriteria().orLike("name","%"+key+"%").orEqualTo("letter",key.toUpperCase());//key.toUpperCase()变成大写 &#125; //排序 if(StringUtils.isNotBlank(sortBy))&#123; String orderByClause=sortBy+(desc ? " DESC":" ASC"); example.setOrderByClause(orderByClause); &#125; //查询 List&lt;Brand&gt; list = brandMapper.selectByExample(example); if (CollectionUtils.isEmpty(list))&#123; throw new LyException(ExceptionEnums.BRAND_NOT_FOUND); &#125; //解析分页结果 PageInfo&lt;Brand&gt; info = new PageInfo&lt;&gt;(list); return new PageResult&lt;&gt;(info.getTotal(),list); &#125;&#125; 3.7.6.测试通过浏览器访问试试：http://api.leyou.com/api/item/brand/page 接下来，去页面请求数据并渲染]]></content>
      <categories>
        <category>项目实战-微服务商城</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[微服务商城（七）——商城项目搭建]]></title>
    <url>%2Fday05-%E4%B9%90%E4%BC%98%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA.html</url>
    <content type="text"><![CDATA[0.学习目标 了解电商行业 了解乐优商城项目结构 能独立搭建项目基本框架 能参考使用ES6的新语法 1.了解电商行业学习电商项目，自然要先了解这个行业，所以我们首先来聊聊电商行业 1.1.项目分类主要从需求方、盈利模式、技术侧重点这三个方面来看它们的不同 1.1.1.传统项目各种企业里面用的管理系统（ERP、HR、OA、CRM、物流管理系统。。。。。。。） 需求方：公司、企业内部 盈利模式：项目本身卖钱 技术侧重点：业务功能 1.1.2.互联网项目门户网站、电商网站：baidu.com、qq.com、taobao.com、jd.com …… 需求方：广大用户群体 盈利模式：虚拟币、增值服务、广告收益…… 技术侧重点：网站性能、业务功能 而我们今天要聊的就是互联网项目中的重要角色：电商 1.2.电商行业的发展1.2.1.钱景近年来，中国的电子商务快速发展，交易额连创新高，电子商务在各领域的应用不断拓展和深化、相关服务业蓬勃发展、支撑体系不断健全完善、创新的动力和能力不断增强。电子商务正在与实体经济深度融合，进入规模性发展阶段，对经济社会生活的影响不断增大，正成为我国经济发展的新引擎。 中国电子商务研究中心数据显示，截止到 2012 年底，中国电子商务市场交易规模达 7.85万亿人民币，同比增长 30.83%。其中，B2B 电子商务交易额达 6.25 万亿，同比增长 27%。而 2011 年全年，中国电子商务市场交易额达 6 万亿人民币，同比增长 33%，占 GDP 比重上升到 13%；2012 年，电子商务占 GDP 的比重已经高达 15%。 ![1525686041466](assets/1525686041466.png) 1.2.2.数据来看看双十一的成交数据： 2016双11开场30分钟，创造每秒交易峰值17.5万笔，每秒支付峰值12万笔的新纪录。菜鸟单日物流订单量超过4.67亿，创历史新高。 1.2.3.技术特点从上面的数据我们不仅要看到钱，更要看到背后的技术实力。正是得益于电商行业的高强度并发压力，促使了BAT等巨头们的技术进步。电商行业有些什么特点呢？ 技术范围广 技术新 高并发（分布式、静态化技术、缓存技术、异步并发、池化、队列） 高可用（集群、负载均衡、限流、降级、熔断） 数据量大 业务复杂 数据安全 1.3.常见电商模式电商行业的一些常见模式： B2C：商家对个人，如：亚马逊、当当等 C2C平台：个人对个人，如：咸鱼、拍拍网、ebay B2B平台：商家对商家，如：阿里巴巴、八方资源网等 O2O：线上和线下结合，如：饿了么、电影票、团购等 P2P：在线金融，贷款，如：网贷之家、人人聚财等。 B2C平台：天猫、京东、一号店等 1.4.一些专业术语 SaaS：软件即服务 SOA：面向服务 RPC：远程过程调用 RMI：远程方法调用 PV：(page view)，即页面浏览量； 用户每1次对网站中的每个网页访问均被记录1次。用户对同一页面的多次访问，访问量累计 UV：(unique visitor)，独立访客 指访问某个站点或点击某条新闻的不同IP地址的人数。在同一天内，uv只记录第一次进入网站的具有独立IP的访问者，在同一天内再次访问该网站则不计数。 PV与带宽： 计算带宽大小需要关注两个指标：峰值流量和页面的平均大小。 计算公式是：网站带宽= ( PV 平均页面大小（单位MB） 8 )/统计时间（换算到秒） 为什么要乘以8？ 网站大小为单位是字节(Byte)，而计算带宽的单位是bit，1Byte=8bit 这个计算的是平均带宽，高峰期还需要扩大一定倍数 PV、QPS、并发 QPS：每秒处理的请求数量。8000/s 比如你的程序处理一个请求平均需要0.1S，那么1秒就可以处理10个请求。QPS自然就是10，多线程情况下，这个数字可能就会有所增加。 由PV和QPS如何需要部署的服务器数量？ 根据二八原则，80%的请求集中在20%的时间来计算峰值压力： （每日PV 80%） / （3600s 24 20%） 每个页面的请求数 = 每个页面每秒的请求数量 然后除以服务器的QPS值，即可计算得出需要部署的服务器数量 1.5.项目开发流程项目经理：管人 产品经理：设计需求原型 测试： 前端：大前端。node 后端： 移动端： 项目开发流程图： ​ 公司现状： ​ 2.乐优商城介绍2.1.项目介绍 乐优商城是一个全品类的电商购物网站（B2C）。 用户可以在线购买商品、加入购物车、下单、秒杀商品 可以品论已购买商品 管理员可以在后台管理商品的上下架、促销活动 管理员可以监控商品销售状况 客服可以在后台处理退款操作 希望未来3到5年可以支持千万用户的使用 2.2.系统架构2.2.1.架构图乐优商城架构缩略图，大图请参考课前资料： 2.2.2.系统架构解读整个乐优商城可以分为两部分：后台管理系统、前台门户系统。 后台管理： 后台系统主要包含以下功能： 商品管理，包括商品分类、品牌、商品规格等信息的管理 销售管理，包括订单统计、订单退款处理、促销活动生成等 用户管理，包括用户控制、冻结、解锁等 权限管理，整个网站的权限控制，采用JWT鉴权方案，对用户及API进行权限控制 统计，各种数据的统计分析展示 后台系统会采用前后端分离开发，而且整个后台管理系统会使用Vue.js框架搭建出单页应用（SPA）。 预览图： 前台门户 前台门户面向的是客户，包含与客户交互的一切功能。例如： 搜索商品 加入购物车 下单 评价商品等等 前台系统我们会使用Thymeleaf模板引擎技术来完成页面开发。出于SEO优化的考虑，我们将不采用单页应用。 无论是前台还是后台系统，都共享相同的微服务集群，包括： 商品微服务：商品及商品分类、品牌、库存等的服务 搜索微服务：实现搜索功能 订单微服务：实现订单相关 购物车微服务：实现购物车相关功能 用户中心：用户的登录注册等功能 短信服务：完成各种短息的发送任务 授权服务：完成对用户的授权、鉴权等功能 Eureka注册中心 Zuul网关服务 Spring Cloud Config配置中心 … 3.商城管理系统前端页面我们的后台管理系统采用前后端分离开发，而且整个后台管理系统会使用Vue.js框架搭建出单页应用SPA 3.1.什么事SPA SPA，Single Page Application，即单页应用。整个后台管理系统只会出现一个HTML页面，剩下的一切页面的内容都是通过Vue组件来实现的。 这些Vue组件其实就是许多的JS文件。不过前端除了js，还有css、image、font等，甚至前端还开发出各种不同类型的扩展语言，这么多东西在打包、构建的过程中，人工来操作非常麻烦，因此就会有一些工具来帮助搭建前端项目，如：webpack、vue-cli 3.2.webpack####3.2.1.介绍 Webpack 是一个前端资源的打包工具，它可以将js、image、css等资源当成一个模块进行打包。 中文官方网站：https://www.webpackjs.com/ 官网给出的解释： 本质上，webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。 为什么需要打包？ 将许多碎小文件打包成一个整体，减少单页面内的衍生请求次数，提高网站效率。 将ES6的高级语法进行转换编译，以兼容老版本的浏览器。 将代码打包的同时进行混淆，提高代码的安全性。 ####3.2.2.四个核心概念 学习Webpack，你需要先理解四个核心概念： 入口(entry) webpack打包的起点，可以有一个或多个，一般是js文件。webpack会从启点文件开始，寻找启点直接或间接依赖的其它所有的依赖，包括JS、CSS、图片资源等，作为将来打包的原始数据 输出(output) 出口一般包含两个属性：path和filename。用来告诉webpack打包的目标文件夹，以及文件的名称。目的地也可以有多个。 加载器（loader） webpack本身只识别Js文件，如果要加载非JS文件，必须指定一些额外的加载器（loader），例如css-loader。然后将这些文件转为webpack能处理的有效模块，最后利用webpack的打包能力去处理。 插件(plugins) 插件可以扩展webpack的功能，让webpack不仅仅是完成打包，甚至各种更复杂的功能，或者是对打包功能进行优化、压缩，提高效率。 3.3.vue-cli3.3.1.介绍和安装在开发中，需要打包的东西不止是js、css、html。还有更多的东西要处理，这些插件和加载器如果我们一一去添加就会比较麻烦。 幸好，vue官方提供了一个快速搭建vue项目的脚手架：vue-cli 使用它能快速的构建一个web工程模板。 官网：https://github.com/vuejs/vue-cli cmd安装命令：npm install -g vue-cli 3.3.2.快速上手新建一个model idea中切换Terminal 用vue-cli命令，快速搭建一个webpack的项目：vue init webpack 3.3.3项目结构安装好的项目结构： 入口文件：main.js ####3.3.4单文件组件 需要注意的是，我们看到有一类后缀名为.vue的文件，我们称为单文件组件 每一个.vue文件，就是一个独立的vue组件。类似于我们刚才写的login.js和register.js 只不过，我们在js中编写 html模板和样式非常的不友好，而且没有语法提示和高亮。 而单文件组件中包含三部分内容： template：模板，支持html语法高亮和提示 script：js脚本，这里编写的就是vue的组件对象，还可以有data(){}等 style：样式，支持CSS语法高亮和提示 每个组件都有自己独立的html、JS、CSS，互不干扰，真正做到可独立复用。 ####3.3.5.运行 看看生成的package.json： 可以看到这引入了非常多的依赖，绝大多数都是开发期依赖，比如大量的加载器。 运行时依赖只有vue和vue-router 脚本有三个： dev：使用了webpack-dev-server命令，开发时热部署使用 start：使用了npm run dev命令，与上面的dev效果完全一样，当脚本名为“start”时，可以省略“run”。 build：等同于webpack的打包功能，会打包到dist目录下。 我们执行npm run dev 或者 npm start 都可以启动项目： 页面： ###3.4.Vuetify框架 3.4.1.为什么要学习UI框架Vue虽然会帮我们进行视图的渲染，但样式还是由我们自己来完成。这显然不是我们的强项，因此后端开发人员一般都喜欢使用一些现成的UI组件，拿来即用，常见的例如： BootStrap LayUI EasyUI ZUI 然而这些UI组件的基因天生与Vue不合，因为他们更多的是利用DOM操作，借助于jQuery实现，而不是MVVM的思想。 而目前与Vue吻合的UI框架也非常的多，国内比较知名的如： element-ui：饿了么出品 i-view：某公司出品 然而我们都不用，我们今天推荐的是一款国外的框架：Vuetify 官方网站：https://vuetifyjs.com/zh-Hans/ 3.4.2.为什么是Vuetify有中国的为什么还要用外国的？原因如下： Vuetify几乎不需要任何CSS代码，而element-ui许多布局样式需要我们来编写 Vuetify从底层构建起来的语义化组件。简单易学，容易记住。 Vuetify基于Material Design（谷歌推出的多平台设计规范），更加美观，动画效果酷炫，且风格统一 这是官网的说明： 缺陷： 目前官网虽然有中文文档，但因为翻译问题，几乎不太能看。 3.4.3.怎么用？基于官方网站的文档进行学习： 我们重点关注UI components即可，里面有大量的UI组件，我们要用的时候再查看，不用现在学习，先看下有什么： 以后用到什么组件，就来查询即可。 4.搭建基础服务4.1.技术选型前端技术： 基础的HTML、CSS、JavaScript（基于ES6标准） JQuery Vue.js 2.0以及基于Vue的框架：Vuetify 前端构建工具：WebPack 前端安装包工具：NPM Vue脚手架：Vue-cli Vue路由：vue-router ajax框架：axios 基于Vue的富文本框架：quill-editor 后端技术： 基础的SpringMVC、Spring 5.0和MyBatis3 Spring Boot 2.0.4版本 Spring Cloud 最新版 Finchley.RC1 Redis-4.0 RabbitMQ-3.4 Elasticsearch-5.6.8 nginx-1.10.2： FastDFS - 5.0.8 MyCat Thymeleaf JWT 4.2.开发环境为了保证开发环境的统一，希望每个人都按照我的环境来配置： IDE：我们使用Idea 2017.3 版本 JDK：统一使用JDK1.8 项目构建：maven3.3.9以上版本即可 版本控制工具：git idea大家可以在我的课前资料中找到。另外，使用帮助大家可以参考课前资料的《idea使用指南.md》 4.3.域名我们在开发的过程中，为了保证以后的生产、测试环境统一。尽量都采用域名来访问项目。 一级域名：www.leyou.com 二级域名：manage.leyou.com , api.leyou.com 我们可以通过switchhost工具来修改自己的host对应的地址，只要把这些域名指向127.0.0.1，那么跟你用localhost的效果是完全一样的。 switchhost可以去课前资料寻找。 4.4.创建父工程创建统一的父工程：leyou，用来管理依赖及其版本，注意是创建project，而不是moudle 填写项目信息： 注意： 父工程不需要代码，只是管理依赖，因此我们不选择任何SpringCloud的依赖 跳过依赖选择。 然后将pom文件修改成我这个样子： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.parent&lt;/groupId&gt; &lt;artifactId&gt;leyou&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;name&gt;leyou&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.1.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-cloud.version&gt;Finchley.RC1&lt;/spring-cloud.version&gt; &lt;mapper.starter.version&gt;2.0.2&lt;/mapper.starter.version&gt; &lt;mysql.version&gt;5.1.32&lt;/mysql.version&gt; &lt;pageHelper.starter.version&gt;1.2.3&lt;/pageHelper.starter.version&gt; &lt;leyou.latest.version&gt;1.0.0-SNAPSHOT&lt;/leyou.latest.version&gt; &lt;fastDFS.client.version&gt;1.26.1-RELEASE&lt;/fastDFS.client.version&gt; &lt;/properties&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- springCloud --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 通用Mapper启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;mapper.starter.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 分页助手启动器 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;$&#123;pageHelper.starter.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mysql驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;$&#123;mysql.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--FastDFS客户端--&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.tobato&lt;/groupId&gt; &lt;artifactId&gt;fastdfs-client&lt;/artifactId&gt; &lt;version&gt;$&#123;fastDFS.client.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.16.22&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.apache.commons/commons-lang3 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;version&gt;3.4&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;spring-milestones&lt;/id&gt; &lt;name&gt;Spring Milestones&lt;/name&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt;&lt;/project&gt; 可以发现，我们在父工程中引入了SpringCloud等很多以后需要用到的依赖，以后创建的子工程就不需要自己引入了。 最后，删除自动生成的LeyouApplication启动类、测试类以及application.properties文件，我们不需要。 4.5.创建EurekaServer4.5.1.创建工程这个大家应该比较熟悉了。 我们的注册中心，起名为：ly-registry 这次我们就不Spring使用提供的脚手架了。直接创建maven项目，自然会继承父类的依赖： 选择新建module： ​ 选择maven安装，但是不要选择骨架： 然后填写项目坐标，我们的项目名称为ly-registry: 选择安装目录，因为是聚合项目，目录应该是在父工程leyou的下面： 4.5.2.添加依赖添加EurekaServer的依赖： 1234567891011121314151617181920212223&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;leyou&lt;/artifactId&gt; &lt;groupId&gt;com.leyou.parent&lt;/groupId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;relativePath&gt;../leyou/pom.xml&lt;/relativePath&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.common&lt;/groupId&gt; &lt;artifactId&gt;ly-registry&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 4.5.3.编写启动类1234567@SpringBootApplication@EnableEurekaServerpublic class LyRegistry &#123; public static void main(String[] args) &#123; SpringApplication.run(LyRegistry.class, args); &#125;&#125; 4.5.4.配置文件1234567891011121314server: port: 10086spring: application: name: ly-registryeureka: client: fetch-registry: false register-with-eureka: false service-url: defaultZone: http://127.0.0.1:$&#123;server.port&#125;/eureka server: enable-self-preservation: false # 关闭自我保护 eviction-interval-timer-in-ms: 5000 # 每隔5秒进行一次服务列表清理 4.5.5.项目的结构：目前，整个项目的结构如图： 4.6.创建Zuul网关4.6.1.创建工程与上面类似，选择maven方式创建Module，然后填写项目名称，我们命名为：ly-api-gateway 填写保存的目录： 4.6.2.添加依赖这里我们需要添加Zuul和EurekaClient的依赖： 12345678910111213141516171819202122232425&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;leyou&lt;/artifactId&gt; &lt;groupId&gt;com.leyou.parent&lt;/groupId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.common&lt;/groupId&gt; &lt;artifactId&gt;ly-gateway&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-zuul&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 4.6.3.编写启动类12345678@SpringBootApplication@EnableDiscoveryClient@EnableZuulProxypublic class LyApiGateway &#123; public static void main(String[] args) &#123; SpringApplication.run(LyApiGateway.class, args); &#125;&#125; 4.6.4.配置文件123456789101112131415161718192021222324server: port: 10010spring: application: name: api-gatewayeureka: client: service-url: defaultZone: http://127.0.0.1:10086/eureka zuul: prefix: /api # 添加路由前缀ribbon: ConnectTimeout: 1000 # 连接超时时间(ms) ReadTimeout: 3500 # 通信超时时间(ms) MaxAutoRetriesNextServer: 0 # 同一服务不同实例的重试次数 MaxAutoRetries: 0 # 同一实例的重试次数hystrix: command: default: execution: isolation: thread: timeoutInMillisecond: 5000 # 熔断超时时长：5000ms 4.6.5.项目结构目前，leyou下有两个子模块： ly-registry：服务的注册中心（EurekaServer） ly-gateway：服务网关（Zuul） 目前，服务的结构如图所示： ![1525709241440](assets/1525709241440.png) 截止到这里，我们已经把基础服务搭建完毕，为了便于开发，统一配置中心（ConfigServer）我们留待以后添加。 4.7.创建商品微服务既然是一个全品类的电商购物平台，那么核心自然就是商品。因此我们要搭建的第一个服务，就是商品微服务。其中会包含对于商品相关的一系列内容的管理，包括： 商品分类管理 品牌管理 商品规格参数管理 商品管理 库存管理 我们先完成项目的搭建： 4.7.1.微服务的结构因为与商品的品类相关，我们的工程命名为ly-item. 需要注意的是，我们的ly-item是一个微服务，那么将来肯定会有其它系统需要来调用服务中提供的接口，因此肯定也会使用到接口中关联的实体类。 因此这里我们需要使用聚合工程，将要提供的接口及相关实体类放到独立子工程中，以后别人引用的时候，只需要知道坐标即可。 我们会在ly-item中创建两个子工程： ly-item-interface：主要是对外暴露的接口及相关实体类 ly-item-service：所有业务逻辑及内部使用接口 调用关系如图所示： 4.7.2.创建父工程ly-item依然是使用maven构建： 保存的位置： 不需要任何依赖，我们可以把项目打包方式设置为pom 1234567891011121314151617&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;leyou&lt;/artifactId&gt; &lt;groupId&gt;com.leyou.parent&lt;/groupId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.service&lt;/groupId&gt; &lt;artifactId&gt;ly-item&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;!-- 打包方式为pom --&gt; &lt;packaging&gt;pom&lt;/packaging&gt;&lt;/project&gt; 4.7.3.创建ly-item-interface在ly-item工程上点击右键，选择new &gt; module: 依然是使用maven构建，注意父工程是ly-item： 注意：接下来填写的目录结构需要自己手动完成，保存到ly-item下的ly-item-interface目录中： 点击Finish完成。 此时的项目结构： ​ 4.7.4.创建ly-item-service与ly-item-interface类似，我们选择在ly-item上右键，新建module，然后填写项目信息： 填写存储位置，是在/ly-item/ly-item-service目录 点击Finish完成。 4.7.5.整个微服务结构如图所示： ​ 我们打开ly-item的pom查看，会发现ly-item-interface和ly-item-service都已经称为module了： ​ 4.7.6.添加依赖接下来我们给ly-item-service中添加依赖： 思考一下我们需要什么？ Eureka客户端 web启动器 mybatis启动器 通用mapper启动器 分页助手启动器 连接池，我们用默认的Hykira mysql驱动 千万不能忘了，我们自己也需要ly-item-interface中的实体类 这些依赖，我们在顶级父工程：leyou中已经添加好了。所以直接引入即可： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;ly-item&lt;/artifactId&gt; &lt;groupId&gt;com.leyou.service&lt;/groupId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.service&lt;/groupId&gt; &lt;artifactId&gt;ly-item-service&lt;/artifactId&gt; &lt;dependencies&gt; &lt;!--web启动器--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--Eureka客户端--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--分页助手--&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--mysql驱动--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--通用mapper--&gt; &lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.leyou.service&lt;/groupId&gt; &lt;artifactId&gt;ly-item-interface&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 整个结构： 4.7.7.编写启动和配置在整个ly-item工程中，只有ly-item-service是需要启动的。因此在其中编写启动类即可： 1234567@SpringBootApplication@EnableDiscoveryClientpublic class LyItemApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(LyItemApplication.class, args); &#125;&#125; 然后是全局属性文件： 12345678910111213141516171819server: port: 8081spring: application: name: item-service datasource: url: jdbc:mysql://localhost:3306/heima username: root password: cxg200888 hikari: maximum-pool-size: 30 minimum-idle: 10eureka: client: service-url: defaultZone: http://127.0.0.1:10086/eureka instance: prefer-ip-address: true ip-address: 127.0.0.1 4.8.添加商品微服务的路由规则既然商品微服务已经创建，接下来肯定要添加路由规则到Zuul中，我们不使用默认的路由规则。 在ly-gateway中修改配置文件： 12345zuul: prefix: /api # 添加路由前缀 retryable: true routes: item-service: /item/** # 将商品微服务映射到/item/** 4.9.启动测试我们分别启动：ly-registry，ly-api-gateway，ly-item-service 查看Eureka面板： 4.10.测试路由规则为了测试路由规则是否畅通，我们是不是需要在item-service中编写一个controller接口呢？ 其实不需要，Spring提供了一个依赖：actuator 只要我们添加了actuator的依赖，它就会为我们生成一系列的访问接口： /info /health /refresh … 添加依赖： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt; 重启后访问Eureka控制台： 鼠标悬停在item-service上，会显示一个地址： 这就是actuator提供的接口，我们点击访问： 因为我们没有添加信息，所以是一个空的json，但是可以肯定的是：我们能够访问到item-service了。 接下来我们通过路由访问试试，根据路由规则，我们需要访问的地址是： http://127.0.0.1:10010/api/item/actuator/info 4.11.通用工具模块有些工具或通用的约定内容，我们希望各个服务共享，因此需要创建一个工具模块：ly-common 使用maven来构建module： 位置信息： 结构： 目前还不需要编码。 4.11.1导入工具类 JsonUtils.java 包括四个方法： toString：把一个对象序列化为string类型，包含一个参数 Object obj：原始java对象 toList：把一个json反序列化为List类型，需要指定一个集合中的元素，包含两个参数 String json：要反序列化的json字符串 Class eClass：集合中元素类型 toMap：把一个json反序列化为Map类型，需要指定集合中key和value类型，包含三个参数： String json：要反序列化的json字符串 Class kClass：集合中key的类型 Class vClass：集合中value的类型 nativeRead：把json字符串反序列化，当反序列化的结果比较复杂时。通过这个方法转换，参数： String json：要反序列化的json字符串 TypeReference type：在传递时，需要传递TypeReference的匿名内部类，把要返回的类型写在TypeReference中的泛型，则返回的就是泛型中类型 例如： 123List&lt;User&gt; users=JsonUtils.nativeRead(json, new TypeReference&lt;List&lt;User&gt;&gt;()&#123; &#125;); 4.11.2添加依赖12345678910111213141516171819202122232425262728293031&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;leyou&lt;/artifactId&gt; &lt;groupId&gt;com.leyou.parent&lt;/groupId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.common&lt;/groupId&gt; &lt;artifactId&gt;ly-common&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-core&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--日志--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--引入json--&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.7&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 5.通用异常处理5.1.场景预设###5.1.1场景 我们预设这样一个场景，加入我们做新增商品，需要接受下面的参数: 12price:价格name:名称 然后对数据做简单的校验： 价格不能为空 新增时，自动形成id，然后随商品对象一起返回 5.1.2代码在ly-item-interface pojo： 123456@Datapublic class Item &#123; private Integer id; private String name; private Long price;&#125; 在ly-item-service中 service： 123456789@Servicepublic class ItemService &#123; public Item saveItem(Item item)&#123; //随机生成id int id=new Random().nextInt(100); item.setId(id); return item; &#125;&#125; 在ly-item-service中 controller： 123456789101112131415@Controller@RequestMapping("item")public class ItemController &#123; @Autowired private ItemService itemService; @PostMapping @ResponseBody public ResponseEntity&lt;Item&gt; saveItem(Item item) &#123; if (item.getPrice()==null)&#123; throw new RuntimeException("价格不能为空"); &#125; return ResponseEntity.status(HttpStatus.CREATED).body(itemService.saveItem(item)); &#125;&#125; 在ly-common中定义异常处理工具类 123456789//扫描启动类@ControllerAdvicepublic class CommonExceptionHander &#123; //拦截ly-item-service的ItemController的RuntimeException()方法 @ExceptionHandler(RuntimeException.class) public ResponseEntity&lt;String&gt; handleException(RuntimeException e)&#123; return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(e.getMessage()); &#125;&#125; ###5.1.3测试如下 5.1.4自定义异常将上述代码优化 在ly-common中定义通用异常拦截 CommonExceptionHander 12345678910@ControllerAdvicepublic class CommonExceptionHander &#123; //拦截ly-item-service的ItemController的RuntimeException()方法 @ExceptionHandler(RuntimeException.class) public ResponseEntity&lt;ExceptionResult&gt; handleException(LyException e)&#123; return ResponseEntity.status(e.getExceptionEnums().getCode()) .body(new ExceptionResult(e.getExceptionEnums())); &#125;&#125; 异常对象：ExceptionEnums 123456789@Getter@NoArgsConstructor@AllArgsConstructorpublic enum ExceptionEnums &#123; PRICE_CANNOT_BE_NULL(400,"价格不能为空"); ; private int code; private String msg;&#125; 自定义异常方法 1234567@NoArgsConstructor@AllArgsConstructor@Getterpublic class LyException extends RuntimeException &#123; private ExceptionEnums exceptionEnums;&#125; 通用异常结果： 1234567891011@Datapublic class ExceptionResult &#123; private int status; private String message; private Long timestamp; public ExceptionResult(ExceptionEnums em)&#123; this.status=em.getCode(); this.message=em.getMsg(); this.timestamp=System.currentTimeMillis(); &#125;&#125; 修改ly-item-service 1234567891011121314151617&gt; @Controller&gt; @RequestMapping("item")&gt; public class ItemController &#123;&gt; @Autowired&gt; private ItemService itemService;&gt; @PostMapping&gt; @ResponseBody&gt; public ResponseEntity&lt;Item&gt; saveItem(Item item) &#123;&gt; if (item.getPrice()==null)&#123;&gt; //修改地方：调用ExceptionEnums.PRICE_CANNOT_BE_NULL&gt; throw new LyException(ExceptionEnums.PRICE_CANNOT_BE_NULL);&gt; &#125;&gt; return ResponseEntity.status(HttpStatus.CREATED).body(itemService.saveItem(item));&gt; &#125;&gt; &gt; &#125;&gt;]]></content>
      <categories>
        <category>项目实战-微服务商城</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[微服务商城（六）——商城前台搭建]]></title>
    <url>%2F%E5%89%8D%E5%8F%B0%E6%90%AD%E5%BB%BA.html</url>
    <content type="text"><![CDATA[0.学习目标 使用资料搭建后台系统 会使用nginx进行反向代理 实现商品分类查询功能 掌握cors解决跨域 实现品牌查询功能 1.搭建后台管理前端1.1.导入已有资源后台项目相对复杂，为了有利于教学，我们不再从0搭建项目，而是直接使用课前资料中给大家准备好的源码： 我们解压缩，放到工作目录中： 然后在Intellij idea中导入新的工程： 选中我们的工程： 这正是一个用vue-cli构建的webpack工程，是不是与昨天的一样： 1.2.安装依赖你应该注意到，这里并没有node_modules文件夹，方便给大家下发，已经把依赖都删除了。不过package.json中依然定义了我们所需的一切依赖： 我们只需要打开终端，进入项目目录，输入：npm install命令，即可安装这些依赖。 大概需要几分钟。 如果安装过程出现以下问题： 建议删除node_modules目录，重新安装。 1.3.运行一下看看输入命令：npm run dev 发现默认的端口是9001。访问：http://localhost:9001 会自动进行跳转：]]></content>
      <categories>
        <category>项目实战-微服务商城</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[微服务商城（五）——Vue入门学习二]]></title>
    <url>%2Fday04-vue%E5%85%A5%E9%97%A82%EF%BC%88vue-router%EF%BC%8Cwebpck%EF%BC%8Cvue-cli%EF%BC%8Cvue-router%EF%BC%89.html</url>
    <content type="text"><![CDATA[7.路由vue-router7.1.场景模拟现在我们来实现这样一个功能： 一个页面，包含登录和注册，点击不同按钮，实现登录和注册页切换： 7.1.1.编写父组件为了让接下来的功能比较清晰，我们先新建一个文件夹：src 然后新建一个HTML文件，作为入口：index.html 然后编写页面的基本结构： 1234567891011121314&lt;div id="app"&gt; &lt;span&gt;登录&lt;/span&gt; &lt;span&gt;注册&lt;/span&gt; &lt;hr/&gt; &lt;div&gt; 登录页/注册页 &lt;/div&gt;&lt;/div&gt;&lt;script src="node_modules/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; var vm = new Vue(&#123; el:"#app" &#125;)&lt;/script&gt; 样式： 7.1.2.编写登录及注册组件接下来我们来实现登录组件，以前我们都是写在一个文件中，但是为了复用性，开发中都会把组件放入独立的JS文件中，我们新建一个user目录以及login.js及register.js： 编写组件，这里我们只写模板，不写功能。 login.js内容如下： 123456789const loginForm = &#123; template:'\ &lt;div&gt;\ &lt;h2&gt;登录页&lt;/h2&gt; \ 用户名：&lt;input type="text"&gt;&lt;br/&gt;\ 密码：&lt;input type="password"&gt;&lt;br/&gt;\ &lt;/div&gt;\ '&#125; register.js内容： 12345678910const registerForm = &#123; template:'\ &lt;div&gt;\ &lt;h2&gt;注册页&lt;/h2&gt; \ 用&amp;ensp;户&amp;ensp;名：&lt;input type="text"&gt;&lt;br/&gt;\ 密&amp;emsp;&amp;emsp;码：&lt;input type="password"&gt;&lt;br/&gt;\ 确认密码：&lt;input type="password"&gt;&lt;br/&gt;\ &lt;/div&gt;\ '&#125; 7.1.3.在父组件中引用123456789101112131415161718192021222324252627&lt;div id="app"&gt; &lt;span&gt;登录&lt;/span&gt; &lt;span&gt;注册&lt;/span&gt; &lt;hr/&gt; &lt;div&gt; &lt;!--&lt;loginForm&gt;&lt;/loginForm&gt;--&gt; &lt;!-- 疑问：为什么不采用上面的写法？ 由于html是大小写不敏感的，如果采用上面的写法，则被认为是&lt;loginform&gt;&lt;/loginform&gt; 所以，如果是驼峰形式的组件，需要把驼峰转化为“-”的形式 --&gt; &lt;login-form&gt;&lt;/login-form&gt; &lt;register-form&gt;&lt;/register-form&gt; &lt;/div&gt;&lt;/div&gt;&lt;script src="../node_modules/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;script src="user/login.js"&gt;&lt;/script&gt;&lt;script src="user/register.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; var vm = new Vue(&#123; el: "#app", components: &#123; loginForm, registerForm &#125; &#125;)&lt;/script&gt; 效果： 7.1.5.问题我们期待的是，当点击登录或注册按钮，分别显示登录页或注册页，而不是一起显示。 但是，如何才能动态加载组件，实现组件切换呢？ 虽然使用原生的Html5和JS也能实现，但是官方推荐我们使用vue-router模块。 7.2.vue-router简介和安装使用vue-router和vue可以非常方便的实现 复杂单页应用的动态路由功能。 官网：https://router.vuejs.org/zh-cn/ 使用npm安装：npm install vue-router --save 在index.html中引入依赖： 1&lt;script src="../node_modules/vue-router/dist/vue-router.js"&gt;&lt;/script&gt; 7.3.快速入门新建vue-router对象，并且指定路由规则： 12345678910// 创建VueRouter对象const router = new VueRouter(&#123; routes:[ // 编写路由规则 &#123; path:"/login", // 请求路径 component:loginForm // 组件名称 &#125;, &#123;path:"/register",component:registerForm&#125;, ]&#125;) 创建VueRouter对象，并指定路由参数 routes：路由规则的数组，可以指定多个对象，每个对象是一条路由规则，包含以下属性： path：路由的路径 component：组件名称 在父组件中引入router对象： 12345678var vm = new Vue(&#123; el:"#app", components:&#123;// 引用登录和注册组件 loginForm, registerForm &#125;, router // 引用上面定义的router对象&#125;) 页面跳转控制： 12345678910&lt;div id="app"&gt; &lt;!--router-link来指定跳转的路径--&gt; &lt;span&gt;&lt;router-link to="/login"&gt;登录&lt;/router-link&gt;&lt;/span&gt; &lt;span&gt;&lt;router-link to="/register"&gt;注册&lt;/router-link&gt;&lt;/span&gt; &lt;hr/&gt; &lt;div&gt; &lt;!--vue-router的锚点--&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/div&gt; 通过&lt;router-view&gt;来指定一个锚点，当路由的路径匹配时，vue-router会自动把对应组件放到锚点位置进行渲染 通过&lt;router-link&gt;指定一个跳转链接，当点击时，会触发vue-router的路由功能，路径中的hash值会随之改变 效果： 注意：单页应用中，页面的切换并不是页面的跳转。仅仅是地址最后的hash值变化。 事实上，我们总共就一个HTML：index.html 8.webpackWebpack 是一个前端资源的打包工具，它可以将js、image、css等资源当成一个模块进行打包。 中文官方网站：https://www.webpackjs.com/ 官网给出的解释： 本质上，webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。 为什么需要打包？ 将许多碎小文件打包成一个整体，减少单页面内的衍生请求次数，提高网站效率。 将ES6的高级语法进行转换编译，以兼容老版本的浏览器。 将代码打包的同时进行混淆，提高代码的安全性。 8.1.安装webpack支持全局安装和本地安装，官方推荐是本地安装，我们按照官方的来。 安装最新版本webpack，输入命令：npm install --save-dev webpack webpack 4+ 版本，你还需要安装 CLI ，输入命令：npm install webpack webpack-cli --save-dev 此时，我们注意下项目中文件夹下，会有一个package.json文件。（其实早就有了） 打开文件，可以看到我们之前用npm安装过的文件都会出现在这里： 8.2.核心概念学习Webpack，你需要先理解四个核心概念： 入口(entry) webpack打包的起点，可以有一个或多个，一般是js文件。webpack会从启点文件开始，寻找启点直接或间接依赖的其它所有的依赖，包括JS、CSS、图片资源等，作为将来打包的原始数据 输出(output) 出口一般包含两个属性：path和filename。用来告诉webpack打包的目标文件夹，以及文件的名称。目的地也可以有多个。 加载器（loader） webpack本身只识别Js文件，如果要加载非JS文件，必须指定一些额外的加载器（loader），例如css-loader。然后将这些文件转为webpack能处理的有效模块，最后利用webpack的打包能力去处理。 插件(plugins) 插件可以扩展webpack的功能，让webpack不仅仅是完成打包，甚至各种更复杂的功能，或者是对打包功能进行优化、压缩，提高效率。 8.3.编写webpack配置接下来，我们编写一个webpack的配置，来指定一些打包的配置项。配置文件的名称，默认就是webpack.config.js，我们放到hello-vue的根目录： 配置文件中就是要指定上面说的四个核心概念，入口、出口、加载器、插件。 不过，加载器和插件是可选的。我们先编写入口和出口 8.3.1.入口entrywebpack打包的启点，可以有一个或多个，一般是js文件。现在思考一下我们有没有一个入口？貌似没有，我们所有的东西都集中在index.html，不是一个js，那怎么办？ 我们新建一个js，把index.html中的部分内容进行集中，然后在index.html中引用这个js不就OK了！ 然后把原来index.html中的js代码全部移动到index.js中 123456789101112131415161718192021222324// 使用es6的语法导入js模块import Vue from '../node_modules/vue/dist/vue';import VueRouter from '../node_modules/vue-router/dist/vue-router';import loginForm from './user/login';import registerForm from './user/register';Vue.use(VueRouter);// 创建vue对象const router = new VueRouter(&#123; routes: [ // 编写路由规则 // path: 路由请求路径；component：组件名称 &#123;path: "/login", component: loginForm&#125;, &#123;path: "/register", component: registerForm&#125; ]&#125;);var vm = new Vue(&#123; el: "#app", components: &#123; loginForm, registerForm &#125;, router&#125;); 原来的index.html中引入了很多其它js，在这里我们使用es6的import语法进行导入。 注意，要使用import，就需要在login.js和register.js中添加export导出语句： 123456789const loginForm=&#123; template: '\ &lt;div&gt;\ &lt;h2&gt;登陆页&lt;/h2&gt;\ 用户名：&lt;input type="text"&gt;&lt;br&gt;\ 密&amp;emsp;码：&lt;input type="password"&gt;\ &lt;/div&gt;',&#125;export default loginForm; register.js: 1234567891011const registerForm = &#123; template:'\ &lt;div&gt;\ &lt;h2&gt;注册页&lt;/h2&gt; \ 用&amp;ensp;户&amp;ensp;名：&lt;input type="text"&gt;&lt;br/&gt;\ 密&amp;emsp;&amp;emsp;码：&lt;input type="password"&gt;&lt;br/&gt;\ 确认密码：&lt;input type="password"&gt;&lt;br/&gt;\ &lt;/div&gt;\ '&#125;export default registerForm; vue-router使用模块化加载后，必须增加一句：Vue.use(VueRouter) 这样，index.js就成了我们整个配置的入口了。 我们在webpack.config.js中添加以下内容： 123module.exports=&#123; entry:'./src/index.js', //指定打包的入口文件&#125; 8.3.2.出口output出口，就是输出的目的地。一般我们会用一个dist目录，作为打包输出的文件夹： 然后，编写webpack.config.js，添加出口配置： 12345678module.exports=&#123; entry:'./src/main.js', //指定打包的入口文件 output:&#123; // path: 输出的目录，__dirname是相对于webpack.config.js配置文件的绝对路径 path : __dirname+'/dist', filename:'build.js' //输出的js文件名 &#125;&#125; 8.4.执行打包在控制台输入以下命令： 1npx webpack --config webpack.config.js 随后，查看dist目录： 尝试打开build.js，你根本看不懂： 所有的js合并为1个，并且对变量名进行了随机打乱，这样就起到了 压缩、混淆的作用。 8.5.测试运行在index.html中引入刚刚生成的build.js文件， 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;!--router-link来指定跳转的路径--&gt; &lt;span&gt;&lt;router-link to="/login"&gt;登录&lt;/router-link&gt;&lt;/span&gt; &lt;span&gt;&lt;router-link to="/register"&gt;注册&lt;/router-link&gt;&lt;/span&gt; &lt;hr/&gt; &lt;div&gt; &lt;!--vue-router的锚点--&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src="../dist/build.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 然后运行： 8.6.打包CSS我们来编写一段CSS代码，对index的样式做一些美化： 内容： 123456789101112131415161718192021#app a&#123; display: inline-block; width: 150px; line-height: 30px; background-color: dodgerblue; color: white; font-size: 16px; text-decoration: none;&#125;#app a:hover&#123; background-color: whitesmoke; color: dodgerblue;&#125;#app div&#123; width: 300px; height: 150px;&#125;#app&#123; width: 305px; border: 1px solid dodgerblue;&#125; 8.6.1.安装加载器前面说过，webpack默认只支持js加载。要加载CSS文件，必须安装加载器： 命令：npm install style-loader css-loader --save-dev 此时，在package.json中能看到新安装的： 8.6.3.index.js引入css文件因为入口在index.js，因此css文件也要在这里引入。依然使用ES6 的模块语法： 1import './css/main.css' 8.6.4.配置加载器在webpack.config.js配置文件中配置css的加载器 123456789101112131415161718module.exports = &#123; entry: './src/main.js', //指定打包的入口文件 output: &#123; path: __dirname + '/dist', // 注意：__dirname表示webpack.config.js所在目录的绝对路径 filename: 'build.js' //输出文件 &#125;, module: &#123; rules: [ &#123; test: /\.css$/, // 通过正则表达式匹配所有以.css后缀的文件 use: [ // 要使用的加载器，这两个顺序一定不要乱 'style-loader', 'css-loader' ] &#125; ] &#125;&#125; 8.6.5.重新打包再次输入打包指令：npx webpack --config webpack.config.js 效果： 8.7.script脚本我们每次使用npm安装，都会在package.json中留下痕迹，事实上，package.json中不仅可以记录安装的内容，还可编写脚本，让我们运行命令更加快捷。 我们可以把webpack的命令编入其中： 以后，如果要打包，就可以直接输入：npm run build即可。 npm run ：执行npm脚本，后面跟的是配置脚本的名称build 8.8.打包HTML之前的打包过程中，除了HTML文件外的其它文件都被打包了，当在线上部署时，我们还得自己复制HTML到dist，然后手动添加生成的js到HTML中，这非常不友好。 webpack中的一个插件：html-webpack-plugin，可以解决这个问题。 1）安装插件：npm install --save-dev html-webpack-plugin 需要在webpack.config.js中添加插件： 123456789101112131415161718192021222324252627const HtmlWebpackPlugin = require('html-webpack-plugin');module.exports = &#123; entry: './src/main.js', //指定打包的入口文件 output: &#123; path: __dirname + '/dist', // 注意：__dirname表示webpack.config.js所在目录的绝对路径 filename: 'build.js' //输出文件 &#125;, module: &#123; rules: [ &#123; test: /\.css$/, // 通过正则表达式匹配所有以.css后缀的文件 use: [ // 要使用的加载器，这两个顺序一定不要乱 'style-loader', 'css-loader' ] &#125; ] &#125;, plugins:[ new HtmlWebpackPlugin(&#123; title: '首页', //生成的页面标题&lt;head&gt;&lt;title&gt;首页&lt;/title&gt;&lt;/head&gt; filename: 'index.html', // dist目录下生成的文件名 template: './src/index.html' // 我们原来的index.html，作为模板 &#125;) ]&#125; 2）将原来HTML中的引入js代码删除： 3）再次打包：npm run build 4）查看dist目录： 打开index.html，发现已经自动添加了当前目录下的build.js 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;!--router-link来指定跳转的路径--&gt; &lt;span&gt;&lt;router-link to="/login"&gt;登录&lt;/router-link&gt;&lt;/span&gt; &lt;span&gt;&lt;router-link to="/register"&gt;注册&lt;/router-link&gt;&lt;/span&gt; &lt;div&gt; &lt;!--vue-router的锚点--&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/div&gt;&lt;script type="text/javascript" src="build.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 8.9.热更新的web服务刚才的案例中，每次修改任何js或css内容，都必须重新打包，非常麻烦。 webpack给我们提供了一个插件，可以帮我们运行一个web服务，加载页面内容，并且修改js后不需要重新加载就能看到最新结果： 1）安装插件：npm install webpack-dev-server --save-dev 2）添加启动脚本 在package.json中配置script 123"scripts": &#123; "dev": "webpack-dev-server --inline --hot --open --port 8080 --host 127.0.0.1"&#125;, –inline：自动刷新 –hot：热加载 –port：指定端口 –open：自动在默认浏览器打开 –host：可以指定服务器的 ip，不指定则为127.0.0.1 3）运行脚本：npm run dev 4）效果： 9.vue-cli9.1.介绍和安装在开发中，需要打包的东西不止是js、css、html。还有更多的东西要处理，这些插件和加载器如果我们一一去添加就会比较麻烦。 幸好，vue官方提供了一个快速搭建vue项目的脚手架：vue-cli 使用它能快速的构建一个web工程模板。 官网：https://github.com/vuejs/vue-cli 安装命令：npm install -g vue-cli 9.2.快速上手我们新建一个module： 切换到该目录： 用vue-cli命令，快速搭建一个webpack的项目：vue init webpack 前面几项都走默认或yes 下面这些我们选no 最后，再选yes，使用 npm安装 开始初始化项目，并安装依赖，可能需要 安装成功！ 可以使用npm run dev命令启动。 9.3.项目结构安装好的项目结构： 入口文件：main.js 9.4.单文件组件需要注意的是，我们看到有一类后缀名为.vue的文件，我们称为单文件组件 每一个.vue文件，就是一个独立的vue组件。类似于我们刚才写的login.js和register.js 只不过，我们在js中编写 html模板和样式非常的不友好，而且没有语法提示和高亮。 而单文件组件中包含三部分内容： template：模板，支持html语法高亮和提示 script：js脚本，这里编写的就是vue的组件对象，还可以有data(){}等 style：样式，支持CSS语法高亮和提示 每个组件都有自己独立的html、JS、CSS，互不干扰，真正做到可独立复用。 9.5.运行看看生成的package.json： 可以看到这引入了非常多的依赖，绝大多数都是开发期依赖，比如大量的加载器。 运行时依赖只有vue和vue-router 脚本有三个： dev：使用了webpack-dev-server命令，开发时热部署使用 start：使用了npm run dev命令，与上面的dev效果完全一样，当脚本名为“start”时，可以省略“run”。 build：等同于webpack的打包功能，会打包到dist目录下。 我们执行npm run dev 或者 npm start 都可以启动项目： 页面：]]></content>
      <categories>
        <category>项目实战-微服务商城</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务商城（五）——Vue入门学习一]]></title>
    <url>%2Fday04-vue%E5%85%A5%E9%97%A81.html</url>
    <content type="text"><![CDATA[学习目标 会创建Vue实例，知道Vue的常见属性 会使用Vue的生命周期的钩子函数 会使用vue常见指令 会使用vue计算属性和watch监控 会编写Vue组件 掌握组件间通信 了解vue-router使用 了解webpack使用 会使用vue-cli搭建项目 0.前言前几天我们已经对后端的技术栈有了初步的了解、并且已经搭建了整个后端微服务的平台。接下来要做的事情就是功能开发了。但是没有前端页面，我们肯定无从下手，因此今天我们就要来了解一下前端的一些技术，完成前端页面搭建。 先聊一下前端开发模式的发展。 静态页面 最初的网页以HTML为主，是纯静态的网页。网页是只读的，信息流只能从服务端到客户端单向流通。开发人员也只关心页面的样式和内容即可。 异步刷新，操作DOM 1995年，网景工程师Brendan Eich 花了10天时间设计了JavaScript语言. 随着JavaScript的诞生，我们可以操作页面的DOM元素及样式，页面有了一些动态的效果，但是依然是以静态为主。 ajax盛行： 2005年开始，ajax逐渐被前端开发人员所重视，因为不用刷新页面就可以更新页面的数据和渲染效果。 此时的开发人员不仅仅要编写HTML样式，还要懂ajax与后端交互，然后通过JS操作Dom元素来实现页面动态效果。比较流行的框架如Jquery就是典型代表。 MVVM，关注模型和视图 2008年，google的Chrome发布，随后就以极快的速度占领市场，超过IE成为浏览器市场的主导者。 2009年，Ryan Dahl在谷歌的Chrome V8引擎基础上，打造了基于事件循环的异步IO框架：Node.js。 基于事件循环的异步IO 单线程运行，避免多线程的变量同步问题 JS可以编写后台代码，前后台统一编程语言 node.js的伟大之处不在于让JS迈向了后端开发，而是构建了一个庞大的生态系统。 2010年，NPM作为node.js的包管理系统首次发布，开发人员可以遵循Common.js规范来编写Node.js模块，然后发布到NPM上供其他开发人员使用。目前已经是世界最大的包模块管理系统。 随后，在node的基础上，涌现出了一大批的前端框架： MVVM模式 M：即Model，模型，包括数据和一些基本操作 V：即View，视图，页面渲染结果 VM：即View-Model，模型与视图间的双向操作（无需开发人员干涉） 在MVVM之前，开发人员从后端获取需要的数据模型，然后要通过DOM操作Model渲染到View中。而后当用户操作视图，我们还需要通过DOM获取View中的数据，然后同步到Model中。 而MVVM中的VM要做的事情就是把DOM操作完全封装起来，开发人员不用再关心Model和View之间是如何互相影响的： 只要我们Model发生了改变，View上自然就会表现出来。 当用户修改了View，Model中的数据也会跟着改变。 把开发人员从繁琐的DOM操作中解放出来，把关注点放在如何操作Model上。 而我们今天要学习的，就是一款MVVM模式的框架：Vue 1.认识VueVue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。 ​ 前端框架三巨头：Vue.js、React.js、AngularJS，vue.js以其轻量易用著称，vue.js和React.js发展速度最快，AngularJS还是老大。 官网：https://cn.vuejs.org/ 参考：https://cn.vuejs.org/v2/guide/ Git地址：https://github.com/vuejs 尤雨溪，Vue.js 创作者，Vue Technology创始人，致力于Vue的研究开发。 2.Node和NPM前面说过，NPM是Node提供的模块管理工具，可以非常方便的下载安装很多前端框架，包括Jquery、AngularJS、VueJs都有。为了后面学习方便，我们先安装node及NPM工具。 2.1.下载Node.js下载地址：https://nodejs.org/en/ 推荐下载LTS版本。 课程中采用的是8.11.3版本。也是目前最新的。大家自行下载或者使用课前资料中提供的安装包。然后下一步安装即可。 完成以后，在控制台输入： 1node -v 看到版本信息： 2.2.NPMNode自带了NPM了，在控制台输入npm -v查看： npm默认的仓库地址是在国外网站，速度较慢，建议大家设置到淘宝镜像。但是切换镜像是比较麻烦的。推荐一款切换镜像的工具：nrm 我们首先安装nrm，这里-g代表全局安装。可能需要一点儿时间 1npm install nrm -g 然后通过nrm ls命令查看npm的仓库列表,带*的就是当前选中的镜像仓库： 通过nrm use taobao来指定要使用的镜像源： 然后通过nrm test npm来测试速度： 注意： 有教程推荐大家使用cnpm命令，但是使用发现cnpm有时会有bug，不推荐。 安装完成请一定要重启下电脑！！！ 安装完成请一定要重启下电脑！！！ 安装完成请一定要重启下电脑！！！ 3.快速入门接下来，我们快速领略下vue的魅力 3.1.创建工程创建一个新的空工程： 然后新建一个module： 选中static web，静态web项目： 位置信息： 3.2.安装vue3.2.1.下载安装下载地址：https://github.com/vuejs/vue 可以下载2.5.16版本https://github.com/vuejs/vue/archive/v2.5.16.zip 下载解压，得到vue.js文件。 3.2.2.使用CDN或者也可以直接使用公共的CDN服务： 12&lt;!-- 开发环境版本，包含了用帮助的命令行警告 --&gt;&lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt; 或者： 12&lt;!-- 生产环境版本，优化了尺寸和速度 --&gt;&lt;script src="https://cdn.jsdelivr.net/npm/vue"&gt;&lt;/script&gt; 3.2.3.推荐npm安装在idea的左下角，有个Terminal按钮，点击打开控制台： 进入hello-vue目录，先输入：npm init -y 进行初始化 安装Vue，输入命令：npm install vue --save 然后就会在hello-vue目录发现一个node_modules目录，并且在下面有一个vue目录。 node_modules是通过npm安装的所有模块的默认位置。 3.3.vue入门案例3.3.1.HTML模板 在hello-vue目录新建一个HTML 在hello.html中，我们编写一段简单的代码： h2中要输出一句话：xx 非常帅。前面的xx是要渲染的数据。 3.3.2.vue声明式渲染然后我们通过Vue进行渲染： 12345678910111213141516&lt;body&gt; &lt;div id="app"&gt; &lt;h2&gt;&#123;&#123;name&#125;&#125;，非常帅！！！&lt;/h2&gt; &lt;/div&gt;&lt;/body&gt;&lt;script src="node_modules/vue/dist/vue.js" &gt;&lt;/script&gt;&lt;script&gt; // 创建vue实例 var app = new Vue(&#123; el:"#app", // el即element，该vue实例要渲染的页面元素 data:&#123; // 渲染页面需要的数据 name: "峰哥" &#125; &#125;);&lt;/script&gt; 首先通过 new Vue()来创建Vue实例 然后构造函数接收一个对象，对象中有一些属性： el：是element的缩写，通过id选中要渲染的页面元素，本例中是一个div data：数据，数据是一个对象，里面有很多属性，都可以渲染到视图中 name：这里我们指定了一个name属性 页面中的h2元素中，我们通过的方式，来渲染刚刚定义的name属性。 打开页面查看效果： 更神奇的在于，当你修改name属性时，页面会跟着变化： 3.3.3.双向绑定我们对刚才的案例进行简单修改： 1234567891011121314151617181920&lt;body&gt; &lt;div id="app"&gt; &lt;input type="text" v-model="num"&gt; &lt;h2&gt; &#123;&#123;name&#125;&#125;，非常帅！！！有&#123;&#123;num&#125;&#125;位女神为他着迷。 &lt;/h2&gt; &lt;/div&gt;&lt;/body&gt;&lt;script src="node_modules/vue/dist/vue.js" &gt;&lt;/script&gt;&lt;script&gt; // 创建vue实例 var app = new Vue(&#123; el: "#app", // el即element，该vue实例要渲染的页面元素 data: &#123; // 渲染页面需要的数据 name: "峰哥", num: 5 &#125; &#125;);&lt;/script&gt; 我们在data添加了新的属性：num 在页面中有一个input元素，通过v-model与num进行绑定。 同时通过在页面输出 效果： 我们可以观察到，输入框的变化引起了data中的num的变化，同时页面输出也跟着变化。 input与num绑定，input的value值变化，影响到了data中的num值 页面与数据num绑定，因此num值变化，引起了页面效果变化。 没有任何dom操作，这就是双向绑定的魅力。 3.3.4.事件处理我们在页面添加一个按钮： 1&lt;button v-on:click="num++"&gt;点我&lt;/button&gt; 这里用v-on指令绑定点击事件，而不是普通的onclick，然后直接操作num 普通click是无法直接操作num的。 效果： 4.Vue实例4.1.创建Vue实例每个 Vue 应用都是通过用 Vue 函数创建一个新的 Vue 实例开始的： 123var vm = new Vue(&#123; // 选项&#125;) 在构造函数中传入一个对象，并且在对象中声明各种Vue需要的数据和方法，包括： el data methods 等等 接下来我们一 一介绍。 4.2.模板或元素每个Vue实例都需要关联一段Html模板，Vue会基于此模板进行视图渲染。 我们可以通过el属性来指定。 例如一段html模板： 123&lt;div id="app"&gt; &lt;/div&gt; 然后创建Vue实例，关联这个div 123var vm = new Vue(&#123; el:"#app"&#125;) 这样，Vue就可以基于id为app的div元素作为模板进行渲染了。在这个div范围以外的部分是无法使用vue特性的。 4.3.数据当Vue实例被创建时，它会尝试获取在data中定义的所有属性，用于视图的渲染，并且监视data中的属性变化，当data发生改变，所有相关的视图都将重新渲染，这就是“响应式“系统。 html： 123&lt;div id="app"&gt; &lt;input type="text" v-model="name"/&gt;&lt;/div&gt; js: 123456var vm = new Vue(&#123; el:"#app", data:&#123; name:"刘德华" &#125;&#125;) name的变化会影响到input的值 input中输入的值，也会导致vm中的name发生改变 4.4.方法Vue实例中除了可以定义data属性，也可以定义方法，并且在Vue实例的作用范围内使用。 html: 1234&lt;div id="app"&gt; &#123;&#123;num&#125;&#125; &lt;button v-on:click="add"&gt;加&lt;/button&gt;&lt;/div&gt; js: 123456789101112var vm = new Vue(&#123; el:"#app", data:&#123; num: 0 &#125;, methods:&#123; add:function()&#123; // this代表的当前vue实例 this.num++; &#125; &#125;&#125;) 4.5.生命周期钩子4.5.1.生命周期每个 Vue 实例在被创建时都要经过一系列的初始化过程 ：创建实例，装载模板，渲染模板等等。Vue为生命周期中的每个状态都设置了钩子函数（监听函数）。每当Vue实例处于不同的生命周期时，对应的函数就会被触发调用。 生命周期： 4.5.2.钩子函数beforeCreated：我们在用Vue时都要进行实例化，因此，该函数就是在Vue实例化是调用，也可以将他理解为初始化函数比较方便一点，在Vue1.0时，这个函数的名字就是init。 created：在创建实例之后进行调用。 beforeMount：页面加载完成，没有渲染。如：此时页面还是 mounted：我们可以将他理解为原生js中的1234567891011121314151617181920212223242526272829303132beforeDestroy：该函数将在销毁实例前进行调用 。destroyed：改函数将在销毁实例时进行调用。beforeUpdate：组件更新之前。updated：组件更新之后。例如：created代表在vue实例创建后；我们可以在Vue中定义一个created函数，代表这个时期的钩子函数：```js // 创建vue实例 var app = new Vue(&#123; el: &quot;#app&quot;, // el即element，该vue实例要渲染的页面元素 data: &#123; // 渲染页面需要的数据 name: &quot;峰哥&quot;, num: 5 &#125;, methods: &#123; add: function()&#123; this.num--; &#125; &#125;, created: function () &#123; this.num = 100; &#125; &#125;); 结果： 4.5.3.this我们可以看下在vue内部的this变量是谁，我们在created的时候，打印this 123456methods: &#123; add: function()&#123; this.num--; console.log(this); &#125;&#125;, 控制台的输出： 5.指令什么是指令？ 指令 (Directives) 是带有 v- 前缀的特殊特性。指令特性的预期值是：单个 JavaScript 表达式。指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM。 例如我们在入门案例中的v-on，代表绑定事件。 5.1.插值表达式5.1.1.花括号格式： 1&#123;&#123;表达式&#125;&#125; 说明： 该表达式支持JS语法，可以调用js内置函数（必须有返回值） 表达式必须有返回结果。例如 1 + 1，没有结果的表达式不允许使用，如：var a = 1 + 1; 可以直接获取Vue实例中定义的数据或函数 示例： HTML： 1&lt;div id="app"&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt; JS: 123456var app = new Vue(&#123; el:"#app", data:&#123; name:"Jack" &#125;&#125;) 5.1.2.插值闪烁使用1234567891011121314151617181920212223242526272829我们将网速调慢一些，然后试试看刚才的案例：![1529836021593](assets/1529836021593.png)刷新页面：![](assets/54.gif)### 5.1.3.v-text和v-html使用v-text和v-html指令来替代`&#123;&#123;&#125;&#125;`说明：- v-text：将数据输出到元素内部，如果输出的数据有HTML代码，会作为普通文本输出- v-html：将数据输出到元素内部，如果输出的数据有HTML代码，会被渲染示例：HTML:```html&lt;div id=&quot;app&quot;&gt; v-text:&lt;span v-text=&quot;hello&quot;&gt;&lt;/span&gt; &lt;br/&gt; v-html:&lt;span v-html=&quot;hello&quot;&gt;&lt;/span&gt;&lt;/div&gt; JS: 123456var vm = new Vue(&#123; el:"#app", data:&#123; hello: "&lt;h1&gt;大家好，我是峰哥&lt;/h1&gt;" &#125;&#125;) 效果： 并且不会出现插值闪烁，当没有数据时，会显示空白。 5.2.v-model刚才的v-text和v-html可以看做是单向绑定，数据影响了视图渲染，但是反过来就不行。接下来学习的v-model是双向绑定，视图（View）和模型（Model）之间会互相影响。 既然是双向绑定，一定是在视图中可以修改数据，这样就限定了视图的元素类型。目前v-model的可使用元素有： input select textarea checkbox radio components（Vue中的自定义组件） 基本上除了最后一项，其它都是表单的输入项。 举例： html： 1234567891011121314151617&lt;div id="app"&gt; &lt;input type="checkbox" v-model="language" value="Java" /&gt;Java&lt;br/&gt; &lt;input type="checkbox" v-model="language" value="PHP" /&gt;PHP&lt;br/&gt; &lt;input type="checkbox" v-model="language" value="Swift" /&gt;Swift&lt;br/&gt; &lt;h1&gt; 你选择了：&#123;&#123;language.join(',')&#125;&#125; &lt;/h1&gt;&lt;/div&gt;&lt;script src="./node_modules/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; var vm = new Vue(&#123; el:"#app", data:&#123; language: [] &#125; &#125;)&lt;/script&gt; 多个CheckBox对应一个model时，model的类型是一个数组，单个checkbox值默认是boolean类型 radio对应的值是input的value值 input 和textarea 默认对应的model是字符串 select单选对应字符串，多选对应也是数组 效果： 5.3.v-on5.3.1.基本用法v-on指令用于给页面元素绑定事件。 语法： 1v-on:事件名=&quot;js片段或函数名&quot; 示例： 123456789101112131415161718192021&lt;div id="app"&gt; &lt;!--事件中直接写js片段--&gt; &lt;button v-on:click="num++"&gt;增加一个&lt;/button&gt;&lt;br/&gt; &lt;!--事件指定一个回调函数，必须是Vue实例中定义的函数--&gt; &lt;button v-on:click="decrement"&gt;减少一个&lt;/button&gt;&lt;br/&gt; &lt;h1&gt;有&#123;&#123;num&#125;&#125;个女神迷恋峰哥&lt;/h1&gt;&lt;/div&gt;&lt;script src="./node_modules/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; var app = new Vue(&#123; el:"#app", data:&#123; num:100 &#125;, methods:&#123; decrement()&#123; this.num--; &#125; &#125; &#125;)&lt;/script&gt; 效果： 另外，事件绑定可以简写，例如v-on:click=&#39;add&#39;可以简写为@click=&#39;add&#39; 5.3.2.事件修饰符在事件处理程序中调用 event.preventDefault() 或 event.stopPropagation() 是非常常见的需求。尽管我们可以在方法中轻松实现这点，但更好的方式是：方法只有纯粹的数据逻辑，而不是去处理 DOM 事件细节。 为了解决这个问题，Vue.js 为 v-on 提供了事件修饰符。修饰符是由点开头的指令后缀来表示的。 .stop ：阻止事件冒泡到父元素 .prevent：阻止默认事件发生 .capture：使用事件捕获模式 .self：只有元素自身触发事件才执行。（冒泡或捕获的都不执行） .once：只执 阻止默认事件 123456789101112131415161718192021222324&lt;div id="app"&gt; &lt;!--右击事件，并阻止默认事件发生--&gt; &lt;button v-on:contextmenu.prevent="num++"&gt;增加一个&lt;/button&gt; &lt;br/&gt; &lt;!--右击事件，不阻止默认事件发生--&gt; &lt;button v-on:contextmenu="decrement($event)"&gt;减少一个&lt;/button&gt; &lt;br/&gt; &lt;h1&gt;有&#123;&#123;num&#125;&#125;个女神迷恋峰哥&lt;/h1&gt;&lt;/div&gt;&lt;script src="./node_modules/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; var app = new Vue(&#123; el: "#app", data: &#123; num: 100 &#125;, methods: &#123; decrement(ev) &#123; // ev.preventDefault(); this.num--; &#125; &#125; &#125;)&lt;/script&gt; 效果：（右键“增加一个”，不会触发默认的浏览器右击事件；右键“减少一个”，会触发默认的浏览器右击事件） 5.3.3.按键修添记住所有的 keyCode 比较困难，所以 Vue 为最常用的按键提供了别名： 12345&lt;!-- 同上 --&gt;&lt;input v-on:keyup.enter="submit"&gt;&lt;!-- 缩写语法 --&gt;&lt;input @keyup.enter="submit"&gt; 全部的按键别名： .enter .tab .delete (捕获“删除”和“退格”键) .esc .space .up .down .left .right 5.3.4.组合按钮可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器。 .ctrl .alt .shift 例如： 12345&lt;!-- Alt + C --&gt;&lt;input @keyup.alt.67="clear"&gt;&lt;!-- Ctrl + Click --&gt;&lt;div @click.ctrl="doSomething"&gt;Do something&lt;/div&gt; 5.4.v-for遍历数据渲染页面是非常常用的需求，Vue中通过v-for指令来实现。 5.4.1.遍历数组 语法： 1v-for=&quot;item in items&quot; items：要遍历的数组，需要在vue的data中定义好。 item：迭代得到的数组元素的别名 示例 12345678910111213141516171819202122&lt;div id="app"&gt; &lt;ul&gt; &lt;li v-for="user in users"&gt; &#123;&#123;user.name&#125;&#125; - &#123;&#123;user.gender&#125;&#125; - &#123;&#123;user.age&#125;&#125; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script src="./node_modules/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; var app = new Vue(&#123; el: "#app", data: &#123; users:[ &#123;name:'柳岩', gender:'女', age: 21&#125;, &#123;name:'峰哥', gender:'男', age: 18&#125;, &#123;name:'范冰冰', gender:'女', age: 24&#125;, &#123;name:'刘亦菲', gender:'女', age: 18&#125;, &#123;name:'古力娜扎', gender:'女', age: 25&#125; ] &#125;, &#125;)&lt;/script&gt; 效果： 5.4.2.数组角标在遍历的过程中，如果我们需要知道数组角标，可以指定第二个参数： 语法 1v-for=&quot;(item,index) in items&quot; items：要迭代的数组 item：迭代得到的数组元素别名 index：迭代到的当前元素索引，从0开始。 示例 12345&lt;ul&gt; &lt;li v-for="(user, index) in users"&gt; &#123;&#123;index + 1&#125;&#125;. &#123;&#123;user.name&#125;&#125; - &#123;&#123;user.gender&#125;&#125; - &#123;&#123;user.age&#125;&#125; &lt;/li&gt;&lt;/ul&gt; 效果： 5.4.3.遍历对象v-for除了可以迭代数组，也可以迭代对象。语法基本类似 语法： 123v-for="value in object"v-for="(value,key) in object"v-for="(value,key,index) in object" 1个参数时，得到的是对象的属性 2个参数时，第一个是属性，第二个是键 3个参数时，第三个是索引，从0开始 示例： 12345678910111213141516&lt;div id="app"&gt; &lt;ul&gt; &lt;li v-for="(value, key, index) in user"&gt; &#123;&#123;index + 1&#125;&#125;. &#123;&#123;key&#125;&#125; - &#123;&#123;value&#125;&#125; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script src="./node_modules/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; var vm = new Vue(&#123; el:"#app", data:&#123; user:&#123;name:'峰哥', gender:'男', age: 18&#125; &#125; &#125;)&lt;/script&gt; 效果： 5.4.4.key当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。 这个功能可以有效的提高渲染的效率。 但是要实现这个功能，你需要给Vue一些提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key 属性。理想的 key 值是每项都有的且唯一的 id。 示例： 123&lt;ul&gt; &lt;li v-for="(item,index) in items" :key=index&gt;&lt;/li&gt;&lt;/ul&gt; 这里使用了一个特殊语法：:key=&quot;&quot; 我们后面会讲到，它可以让你读取vue中的属性，并赋值给key属性 这里我们绑定的key是数组的索引，应该是唯一的 5.5.v-if和v-show5.5.1.基本使用v-if，顾名思义，条件判断。当得到结果为true时，所在的元素才会被渲染。 语法： 1v-if=&quot;布尔表达式&quot; 示例： 12345678910111213141516171819&lt;div id="app"&gt; &lt;button v-on:click="show = !show"&gt;点我呀&lt;/button&gt; &lt;br&gt; &lt;h1 v-if="show"&gt; 看到我啦？！ &lt;/h1&gt; &lt;h1 v-show="show"&gt; 看到我啦？！show &lt;/h1&gt;&lt;/div&gt;&lt;script src="./node_modules/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; var app = new Vue(&#123; el: "#app", data: &#123; show: true &#125; &#125;)&lt;/script&gt; 效果： 5.5.2.与v-for结合当v-if和v-for出现在一起时，v-for优先级更高。也就是说，会先遍历，再判断条件。 修改v-for中的案例，添加v-if： 12345&lt;ul&gt; &lt;li v-for="(user, index) in users" v-if="user.gender == '女'"&gt; &#123;&#123;index + 1&#125;&#125;. &#123;&#123;user.name&#125;&#125; - &#123;&#123;user.gender&#125;&#125; - &#123;&#123;user.age&#125;&#125; &lt;/li&gt;&lt;/ul&gt; 效果： 只显示女性用户信息 5.5.3.v-else你可以使用 v-else 指令来表示 v-if 的“else 块”： 12345678&lt;div id="app"&gt; &lt;h1 v-if="Math.random() &gt; 0.5"&gt; 看到我啦？！if &lt;/h1&gt; &lt;h1 v-else&gt; 看到我啦？！else &lt;/h1&gt;&lt;/div&gt; v-else 元素必须紧跟在带 v-if 或者 v-else-if 的元素的后面，否则它将不会被识别。 v-else-if，顾名思义，充当 v-if 的“else-if 块”，可以连续使用： 123456789101112131415161718192021222324&lt;div id="app"&gt; &lt;button v-on:click="random=Math.random()"&gt;点我呀&lt;/button&gt;&lt;span&gt;&#123;&#123;random&#125;&#125;&lt;/span&gt; &lt;h1 v-if="random &gt;= 0.75"&gt; 看到我啦？！if &lt;/h1&gt; &lt;h1 v-else-if="random &gt; 0.5"&gt; 看到我啦？！if 0.5 &lt;/h1&gt; &lt;h1 v-else-if="random &gt; 0.25"&gt; 看到我啦？！if 0.25 &lt;/h1&gt; &lt;h1 v-else&gt; 看到我啦？！else &lt;/h1&gt;&lt;/div&gt;&lt;script src="./node_modules/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; var app = new Vue(&#123; el: "#app", data: &#123; random: 1 &#125; &#125;)&lt;/script&gt; 类似于 v-else，v-else-if 也必须紧跟在带 v-if 或者 v-else-if 的元素之后。 演示： 5.5.4.v-show另一个用于根据条件展示元素的选项是 v-show 指令。用法大致一样： 1&lt;h1 v-show=&quot;ok&quot;&gt;Hello!&lt;/h1&gt; 不同的是带有 v-show 的元素始终会被渲染并保留在 DOM 中。v-show 只是简单地切换元素的 CSS 属性 display。 示例： 12345678910111213141516&lt;div id="app"&gt; &lt;!--事件中直接写js片段--&gt; &lt;button v-on:click="show = !show"&gt;点击切换&lt;/button&gt;&lt;br/&gt; &lt;h1 v-if="show"&gt; 你好 &lt;/h1&gt;&lt;/div&gt;&lt;script src="./node_modules/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; var app = new Vue(&#123; el:"#app", data:&#123; show:true &#125; &#125;)&lt;/script&gt; 代码： 5.6.v-bindhtml属性不能使用双大括号形式绑定，只能使用v-bind指令。 在将 v-bind 用于 class 和 style 时，Vue.js 做了专门的增强。表达式结果的类型除了字符串之外，还可以是对象或数组。 12345678910111213&lt;div id="app"&gt; &lt;!--可以是数据模型，可以是具有返回值的js代码块或者函数--&gt; &lt;div v-bind:title="title" style="border: 1px solid red; width: 50px; height: 50px;"&gt;&lt;/div&gt;&lt;/div&gt;&lt;script src="./node_modules/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; var app = new Vue(&#123; el: "#app", data: &#123; title: "title", &#125; &#125;)&lt;/script&gt; 效果： 在将 v-bind 用于 class 和 style 时，Vue.js 做了专门的增强。表达式结果的类型除了字符串之外，还可以是对象或数组。 5.6.1.绑定class样式 数组语法 我们可以借助于v-bind指令来实现： HTML： 123456789101112131415&lt;div id="app"&gt; &lt;div v-bind:class="activeClass"&gt;&lt;/div&gt; &lt;div v-bind:class="errorClass"&gt;&lt;/div&gt; &lt;div v-bind:class="[activeClass, errorClass]"&gt;&lt;/div&gt;&lt;/div&gt;&lt;script src="./node_modules/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; var app = new Vue(&#123; el: "#app", data: &#123; activeClass: 'active', errorClass: ['text-danger', 'text-error'] &#125; &#125;)&lt;/script&gt; 渲染后的效果：（具有active和hasError的样式） 对象语法 我们可以传给 v-bind:class 一个对象，以动态地切换 class： 1&lt;div v-bind:class="&#123; active: isActive &#125;"&gt;&lt;/div&gt; 上面的语法表示 active 这个 class 存在与否将取决于数据属性 isActive 的 truthiness（所有的值都是真实的，除了false,0,“”,null,undefined和NaN）。 你可以在对象中传入更多属性来动态切换多个 class。此外，v-bind:class 指令也可以与普通的 class 属性共存。如下模板: 123&lt;div class="static" v-bind:class="&#123; active: isActive, 'text-danger': hasError &#125;"&gt;&lt;/div&gt; 和如下 data： 1234data: &#123; isActive: true, hasError: false&#125; 结果渲染为： 1&lt;div class="static active"&gt;&lt;/div&gt; active样式和text-danger样式的存在与否，取决于isActive和hasError的值。本例中isActive为true，hasError为false，所以active样式存在，text-danger不存在。 通常情况下，绑定的数据对象不必内联定义在模板里： 1&lt;div class="static" v-bind:class="classObject"&gt;&lt;/div&gt; 数据： 123456data: &#123; classObject: &#123; active: true, 'text-danger': false &#125;&#125; 效果和之前一样： 1&lt;div class="static active"&gt;&lt;/div&gt; 5.6.2.绑定style样式 数组语法 数组语法可以将多个样式对象应用到同一个元素上： 1&lt;div v-bind:style="[baseStyles, overridingStyles]"&gt;&lt;/div&gt; 数据： 1234data: &#123; baseStyles: &#123;backgroundColor: 'red'&#125;, overridingStyles: &#123;border: '1px solid black'&#125;&#125; 渲染后的结果： 1&lt;div style="background-color:red; border: 1px solid black;"&gt;&lt;/div&gt; 对象语法 v-bind:style 的对象语法十分直观——看着非常像 CSS，但其实是一个 JavaScript 对象。CSS 属性名可以用驼峰式 (camelCase) 或短横线分隔 (kebab-case，记得用单引号括起来) 来命名： 1&lt;div v-bind:style="&#123;color: activeColor, fontSize: fontSize + 'px' &#125;"&gt;&lt;/div&gt; 数据： 1234data: &#123; activeColor: 'red', fontSize: 30&#125; 效果： 1&lt;div style="color: red; font-size: 30px;"&gt;&lt;/div&gt; 直接绑定到一个样式对象通常更好，这会让模板更清晰： 1&lt;div v-bind:style="styleObject"&gt;&lt;/div&gt; 123456data: &#123; styleObject: &#123; color: 'red', fontSize: '13px' &#125;&#125; 效果同上。 5.6.3.简写v-bind:class可以简写为:class 5.6.4另一个例子123456789101112131415161718192021222324252627282930313233343536&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style type="text/css"&gt; div#box&#123; width: 100px; height: 100px; color: darkgray; &#125; .red&#123; background-color: red; &#125; .blue&#123; background-color: blue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="app" &gt; &lt;button @click="color='red'"&gt;红色&lt;/button&gt; &lt;button @click="color='blue'"&gt;蓝色&lt;/button&gt; &lt;div v-bind:class="color"&gt; woemn &lt;/div&gt;&lt;/div&gt;&lt;script src="node_modules/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;script&gt; const app=new Vue(&#123; el:"#app", data:&#123; color:"red" &#125; &#125;);&lt;/script&gt;&lt;/body&gt; 改进上面的： 12345678910111213141516171819202122232425262728293031323334&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style type="text/css"&gt; div#box&#123; width: 100px; height: 100px; color: darkgray; &#125; .red&#123; background-color: red; &#125; .blue&#123; background-color: blue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="app" &gt; &lt;button @click="IsColor=!IsColor"&gt;切换&lt;/button&gt; &lt;div id="box" v-bind:class="&#123;red:IsColor,blue:!IsColor&#125;"&gt; woemn &lt;/div&gt;&lt;/div&gt;&lt;script src="node_modules/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;script&gt; const app=new Vue(&#123; el:"#app", data:&#123; IsColor:true &#125; &#125;);&lt;/script&gt;&lt;/body&gt; 5.7.计算属性在插值表达式中使用js表达式是非常方便的，而且也经常被用到。 但是如果表达式的内容很长，就会显得不够优雅，而且后期维护起来也不方便，例如下面的场景，我们有一个日期的数据，但是是毫秒值： 123data:&#123; birthday:1529032123201 // 毫秒值&#125; 我们在页面渲染，希望得到yyyy-MM-dd的样式： 1234&lt;h1&gt;您的生日是：&#123;&#123; new Date(birthday).getFullYear() + '-'+ new Date(birthday).getMonth()+ '-' + new Date(birthday).getDay() &#125;&#125;&lt;/h1&gt; 虽然能得到结果，但是非常麻烦。 Vue中提供了计算属性，来替代复杂的表达式： 123456789101112var vm = new Vue(&#123; el:"#app", data:&#123; birthday:1429032123201 // 毫秒值 &#125;, computed:&#123; birth()&#123;// 计算属性本质是一个方法，但是必须返回结果 const d = new Date(this.birthday); return d.getFullYear() + "-" + d.getMonth() + "-" + d.getDay(); &#125; &#125;&#125;) 计算属性本质就是方法，但是一定要返回数据。然后页面渲染时，可以把这个方法当成一个变量来使用。 页面使用： 123&lt;div id="app"&gt; &lt;h1&gt;您的生日是：&#123;&#123;birth&#125;&#125; &lt;/h1&gt;&lt;/div&gt; 效果： 我们可以将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的。然而，不同的是计算属性是基于它们的依赖进行缓存的。计算属性只有在它的相关依赖发生改变时才会重新求值。这就意味着只要birthday还没有发生改变，多次访问 birthday 计算属性会立即返回之前的计算结果，而不必再次执行函数。 5.8.watch###5.8.1浅监控 watch可以让我们监控一个值的变化。从而做出相应的反应。 示例： 1234567891011121314151617&lt;div id="app"&gt; &lt;input type="text" v-model="message"&gt;&lt;/div&gt;&lt;script src="./node_modules/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; var vm = new Vue(&#123; el:"#app", data:&#123; message:"" &#125;, watch:&#123; message(newVal, oldVal)&#123; console.log(newVal, oldVal); &#125; &#125; &#125;)&lt;/script&gt; 效果： 5.8.2深监控如果监控的是一个对象，需要进行深度监控到对象中的属性的变化 123456789101112131415161718192021222324&lt;body&gt;&lt;div id="app" &gt; &lt;h1&gt;&#123;&#123;person.name&#125;&#125;今年&#123;&#123;person.age&#125;&#125;岁了&lt;/h1&gt;&lt;/div&gt;&lt;script src="node_modules/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;script&gt; const app=new Vue(&#123; el:"#app", data:&#123; person:&#123; name:"jack", age:21 &#125; &#125;, watch:&#123; person:&#123; deep:true,//开启深度监控，可以监控到对象中属性的变化 handler(val)&#123;//定义监控到以后处理的方法 console.log(val.age) &#125; &#125; &#125; &#125;);&lt;/script&gt; 以前定义的时候，person是一个函数，现在改成对象，并且要指定两个属性： deep：代表深度监控，不仅监控person的变化，也监控person中属性变化 handler：就是以前的监控函数 6.组件化在大型应用开发的时候，页面可以划分成很多部分。往往不同的页面，也会有相同的部分。例如可能会有相同的头部导航。 但是如果每个页面都独自开发，这无疑增加了我们开发的成本。所以我们会把页面的不同部分拆分成独立的组件，然后在不同页面就可以共享这些组件，避免重复开发。 6.1.全局组件我们通过Vue的component方法来定义一个全局组件。 1234567891011121314151617181920&lt;div id="app"&gt; &lt;!--使用定义好的全局组件--&gt; &lt;counter&gt;&lt;/counter&gt;&lt;/div&gt;&lt;script src="./node_modules/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; // 定义全局组件，两个参数：1，组件名称。2，组件参数 //template:是模板 Vue.component("counter",&#123; template:'&lt;button v-on:click="count++"&gt;你点了我 &#123;&#123; count &#125;&#125; 次，我记住了.&lt;/button&gt;', data()&#123; return &#123; count:0 &#125; &#125; &#125;) var app = new Vue(&#123; el:"#app" &#125;)&lt;/script&gt; 组件其实也是一个Vue实例，因此它在定义时也会接收：data、methods、生命周期函数等 不同的是组件不会与页面的元素绑定，否则就无法复用了，因此没有el属性。 但是组件渲染需要html模板，所以增加了template属性，值就是HTML模板 全局组件定义完毕，任何vue实例都可以直接在HTML中通过组件名称来使用组件了。 data必须是一个函数，不再是一个对象。 效果： 6.2.组件的复用定义好的组件，可以任意复用多次： 123456&lt;div id="app"&gt; &lt;!--使用定义好的全局组件--&gt; &lt;counter&gt;&lt;/counter&gt; &lt;counter&gt;&lt;/counter&gt; &lt;counter&gt;&lt;/counter&gt;&lt;/div&gt; 效果： 你会发现每个组件互不干扰，都有自己的count值。怎么实现的？ 组件的data属性必须是函数！ 当我们定义这个 &lt;counter&gt; 组件时，它的data 并不是像这样直接提供一个对象： 123data: &#123; count: 0&#125; 取而代之的是，一个组件的 data 选项必须是一个函数，因此每个实例可以维护一份被返回对象的独立的拷贝： 12345data: function () &#123; return &#123; count: 0 &#125;&#125; 如果 Vue 没有这条规则，点击一个按钮就会影响到其它所有实例！ 6.3.局部注册一旦全局注册，就意味着即便以后你不再使用这个组件，它依然会随着Vue的加载而加载。 因此，对于一些并不频繁使用的组件，我们会采用局部注册。 我们先在外部定义一个对象，结构与创建组件时传递的第二个参数一致： 12345678const counter = &#123; template:'&lt;button v-on:click="count++"&gt;你点了我 &#123;&#123; count &#125;&#125; 次，我记住了.&lt;/button&gt;', data()&#123; return &#123; count:0 &#125; &#125;&#125;; 然后在Vue中使用它： 123456var app = new Vue(&#123; el:"#app", components:&#123; counter:counter // 将定义的对象注册为组件 &#125;&#125;) components就是当前vue对象子组件集合。 其key就是子组件名称 其值就是组件对象的属性 效果与刚才的全局注册是类似的，不同的是，这个counter组件只能在当前的Vue实例中使用 6.4.组件通信通常一个单页应用会以一棵嵌套的组件树的形式来组织： 页面首先分成了顶部导航、左侧内容区、右侧边栏三部分 左侧内容区又分为上下两个组件 右侧边栏中又包含了3个子组件 各个组件之间以嵌套的关系组合在一起，那么这个时候不可避免的会有组件间通信的需求。 6.4.1.props（父向子传递） 父组件使用子组件时，自定义属性（属性名任意，属性值为要传递的数据） 子组件通过props接收父组件属性 父组件使用子组件，并自定义了title属性： 12345678910111213141516171819202122232425262728&lt;div id="app"&gt; &lt;h1&gt;打个招呼：&lt;/h1&gt; &lt;!--使用子组件，同时传递title属性--&gt; &lt;introduce :title="msg"&gt;&lt;/introduce&gt; &lt;lessons :items="lessons"&gt;&lt;/lessons&gt;&lt;/div&gt;&lt;script src="./node_modules/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; //子 Vue.component("introduce",&#123; // 直接使用props接收到的属性来渲染页面 template:'&lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt;', props:['title'] // 通过props来接收一个父组件传递的属性 &#125;) //子 Vue.component("lessons",&#123; template:"&lt;ul&gt;&lt;li v-for='item in items'&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt;&lt;/ul&gt;", props:['items'] &#125;) //父 var app = new Vue(&#123; el:"#app", data:&#123; msg:"大家好，我是父传子", lessons:['java','php','python'] &#125; &#125;)&lt;/script&gt; 效果： 6.4.2.props验证我们定义一个子组件，并接受复杂数据： 12345678910Vue.component("lessons",&#123; template:"&lt;ul&gt;&lt;li v-for='item in items'&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt;&lt;/ul&gt;", props: &#123; items: &#123; type: Array, default: [], required: true &#125; &#125;&#125;) 这个子组件可以对 items 进行迭代，并输出到页面。 props：定义需要从父组件中接收的属性 items：是要接收的属性名称 type：限定父组件传递来的必须是数组 default：默认值 required：是否必须 当 prop 验证失败的时候，(开发环境构建版本的) Vue 将会产生一个控制台的警告。 我们在父组件中使用它： 12345&lt;div id="app"&gt; &lt;h2&gt;传智播客已开设如下课程：&lt;/h2&gt; &lt;!-- 使用子组件的同时，传递属性，这里使用了v-bind，指向了父组件自己的属性lessons --&gt; &lt;my-list :items="lessons"/&gt;&lt;/div&gt; 12345678910111213var app = new Vue(&#123; el:"#app", components:&#123; myList // 当key和value一样时，可以只写一个 &#125;, data:&#123; lessons:[ &#123;id:1, name: 'java'&#125;, &#123;id:2, name: 'php'&#125;, &#123;id:3, name: 'ios'&#125;, ] &#125;&#125;) 效果： type类型，可以有： 6.4.3.动态静态传递给 prop 传入一个静态的值： 1&lt;introduce title="大家好，我是锋哥"/&gt; 给 prop 传入一个动态的值： （通过v-bind从数据模型中，获取title的值） 1&lt;introduce :title="title"/&gt; 静态传递时，我们传入的值都是字符串类型的，但实际上任何类型的值都可以传给一个 props。 123456&lt;!-- 即便 `42` 是静态的，我们仍然需要 `v-bind` 来告诉 Vue --&gt;&lt;!-- 这是一个JavaScript表达式而不是一个字符串。--&gt;&lt;blog-post v-bind:likes="42"&gt;&lt;/blog-post&gt;&lt;!-- 用一个变量进行动态赋值。--&gt;&lt;blog-post v-bind:likes="post.likes"&gt;&lt;/blog-post&gt; 6.4.4.子向父的通信来看这样的一个案例： 12345678910111213141516171819202122&lt;div id="app"&gt; &lt;h2&gt;num: &#123;&#123;num&#125;&#125;&lt;/h2&gt; &lt;!--使用子组件的时候，传递num到子组件中--&gt; &lt;counter :num="num"&gt;&lt;/counter&gt;&lt;/div&gt;&lt;script src="node_modules/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; Vue.component("counter", &#123;// 子组件，定义了两个按钮，点击数字num会加或减 template:` &lt;div&gt; &lt;button @click="num++"&gt;加&lt;/button&gt; &lt;button @click="num--"&gt;减&lt;/button&gt; &lt;/div&gt;`, props:['num']// count是从父组件获取的。 &#125;) var app = new Vue(&#123; el:"#app", data:&#123; num:0 &#125; &#125;)&lt;/script&gt; 子组件接收父组件的num属性 子组件定义点击按钮，点击后对num进行加或减操作 我们尝试运行，好像没问题，点击按钮试试： 子组件接收到父组件属性后，默认是不允许修改的。怎么办？ 既然只有父组件能修改，那么加和减的操作一定是放在父组件： 1234567891011121314var app = new Vue(&#123; el:"#app", data:&#123; num:0 &#125;, methods:&#123; // 父组件中定义操作num的方法 increment()&#123; this.num++; &#125;, decrement()&#123; this.num--; &#125; &#125;&#125;) 但是，点击按钮是在子组件中，那就是说需要子组件来调用父组件的函数，怎么做？ 我们可以通过v-on指令将父组件的函数绑定到子组件上： 1234&lt;div id="app"&gt; &lt;h2&gt;num: &#123;&#123;num&#125;&#125;&lt;/h2&gt; &lt;counter :count="num" @inc="increment" @dec="decrement"&gt;&lt;/counter&gt;&lt;/div&gt; 在子组件中定义函数，函数的具体实现调用父组件的实现，并在子组件中调用这些函数。当子组件中按钮被点击时，调用绑定的函数： 1234567891011121314151617 // 子Vue.component("counter", &#123; template:` &lt;div&gt; &lt;button @click="plus"&gt;加&lt;/button&gt; &lt;button @click="reduce"&gt;减&lt;/button&gt; &lt;/div&gt;`, props:['count'], methods:&#123; plus()&#123; this.$emit("inc"); &#125;, reduce()&#123; this.$emit("dec"); &#125; &#125; &#125;) vue提供了一个内置的this.$emit()函数，用来调用父组件绑定的函数 完整的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839&lt;div id="app"&gt; &lt;counter :num="num" @inc="increment" @dec="decrement"&gt;&lt;/counter&gt; &lt;p &gt;&#123;&#123;num&#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script src="./node_modules/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; // 子 Vue.component("counter", &#123; template:` &lt;div&gt; &lt;button @click="plus"&gt;加&lt;/button&gt; &lt;button @click="reduce"&gt;减&lt;/button&gt; &lt;/div&gt;`, props:['count'], methods:&#123; plus()&#123; this.$emit("inc"); &#125;, reduce()&#123; this.$emit("dec"); &#125; &#125; &#125;); var app = new Vue(&#123; el:"#app", data:&#123; num:0 &#125;, methods:&#123; // 父组件中定义操作num的方法 increment()&#123; this.num++; &#125;, decrement()&#123; this.num--; &#125; &#125; &#125;);&lt;/script&gt;&lt;/body&gt; 效果：]]></content>
      <categories>
        <category>项目实战-微服务商城</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务商城（四）——ES6标准介绍]]></title>
    <url>%2Fday4-ES6%E6%A0%87%E5%87%86.html</url>
    <content type="text"><![CDATA[1、ES6 语法指后端项目搭建完毕，接下来就是前端页面了。不过在这之前需要一些准备工作。我们需要学习ES6的语法标准。 什么是ES6？就是ECMAScript第6版标准。 1.1.什么是ECMAScript？来看下前端的发展历程： web1.0时代： 最初的网页以HTML为主，是纯静态的网页。网页是只读的，信息流只能从服务的到客户端单向流通。开发人员也只关心页面的样式和内容即可。 web2.0时代： 1995年，网景工程师Brendan Eich 花了10天时间设计了JavaScript语言。 1996年，微软发布了JScript，其实是JavaScript的逆向工程实现。 1997年，为了统一各种不同script脚本语言，ECMA（欧洲计算机制造商协会）以JavaScript为基础，制定了ECMAscript标准规范。JavaScript和JScript都是ECMAScript的标准实现者，随后各大浏览器厂商纷纷实现了ECMAScript标准。 所以，ECMAScript是浏览器脚本语言的规范，而各种我们熟知的js语言，如JavaScript则是规范的具体实现。 1.2.ECMAScript的快速发展而后，ECMAScript就进入了快速发展期。 1998年6月，ECMAScript 2.0 发布。 1999年12月，ECMAScript 3.0 发布。这时，ECMAScript 规范本身也相对比较完善和稳定了，但是接下来的事情，就比较悲剧了。 2007年10月。。。。ECMAScript 4.0 草案发布。 这次的新规范，历时颇久，规范的新内容也有了很多争议。在制定ES4的时候，是分成了两个工作组同时工作的。 一边是以 Adobe, Mozilla, Opera 和 Google为主的 ECMAScript 4 工作组。 一边是以 Microsoft 和 Yahoo 为主的 ECMAScript 3.1 工作组。 ECMAScript 4 的很多主张比较激进，改动较大。而 ECMAScript 3.1 则主张小幅更新。最终经过 TC39 的会议，决定将一部分不那么激进的改动保留发布为 ECMAScript 3.1，而ES4的内容，则延续到了后来的ECMAScript5和6版本中 2009年12月，ECMAScript 5 发布。 2011年6月，ECMAScript 5.1 发布。 2015年6月，ECMAScript 6，也就是 ECMAScript 2015 发布了。 并且从 ECMAScript 6 开始，开始采用年号来做版本。即 ECMAScript 2015，就是ECMAScript6。 1.3.ES5和6的一些新特性我们这里只把一些常用的进行学习，更详细的大家参考：阮一峰的ES6教程 1.3.1.let 和 const 命令 var 之前，js定义变量只有一个关键字：var var有一个问题，就是定义的变量有时会莫名奇妙的成为全局变量。 例如这样的一段代码： 1234for(var i = 0; i &lt; 5; i++)&#123; console.log(i);&#125;console.log("循环外：" + i) 你猜下打印的结果是什么？ let let所声明的变量，只在let命令所在的代码块内有效。 我们把刚才的var改成let试试： 1234for(let i = 0; i &lt; 5; i++)&#123; console.log(i);&#125;console.log("循环外：" + i) 结果： const const声明的变量是常量，不能被修改 1.3.2.字符串扩展 新的API ES6为字符串扩展了几个新的API： includes()：返回布尔值，表示是否找到了参数字符串。 startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。 endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。 实验一下： 字符串模板 ES6中提供了`来作为字符串模板标记。我们可以这么玩： 在两个`之间的部分都会被作为字符串的值，不管你任意换行，甚至加入js脚本 键盘是的1的左侧，tab的上侧，esc的正下方 1.3.3.解构表达式 数组解构 比如有一个数组： 1let arr = [1,2,3] 我想获取其中的值，只能通过角标。ES6可以这样： 123const [x,y,z] = arr;// x，y，z将与arr中的每个位置对应来取值// 然后打印console.log(x,y,z); 结果： 对象解构 例如有个person对象： 12345const person = &#123; name:"jack", age:21, language: ['java','js','css']&#125; 我们可以这么做： 123456// 解构表达式获取值const &#123;name,age,language&#125; = person;// 打印console.log(name);console.log(age);console.log(language); 结果： 如过想要用其它变量接收，需要额外指定别名： {name:n}：name是person中的属性名，冒号后面的n是解构后要赋值给的变量。 1.3.4.函数优化 函数参数默认值 在ES6以前，我们无法给一个函数参数设置默认值，只能采用变通写法： 1234567function add(a , b) &#123; // 判断b是否为空，为空就给默认值1 b = b || 1; return a + b;&#125;// 传一个参数console.log(add(10)); 现在可以这么写： 12345function add(a , b = 1) &#123; return a + b;&#125;// 传一个参数console.log(add(10)); 箭头函数 ES6中定义函数的简写方式： 一个参数时： 12345var print = function (obj) &#123; console.log(obj);&#125;// 简写为：var print2 = obj =&gt; console.log(obj); 多个参数： 123456// 两个参数的情况：var sum = function (a , b) &#123; return a + b;&#125;// 简写为：var sum2 = (a,b) =&gt; a+b; 代码不止一行，可以用{}括起来 123var sum3 = (a,b) =&gt; &#123; return a + b;&#125; 对象的函数属性简写 比如一个Person对象，里面有eat方法： 12345678910111213let person = &#123; name: "jack", // 以前： eat: function (food) &#123; console.log(this.name + "在吃" + food); &#125;, // 箭头函数版： eat2: food =&gt; console.log(person.name + "在吃" + food),// 这里拿不到this // 简写版： eat3(food)&#123; console.log(this.name + "在吃" + food); &#125;&#125; 箭头函数结合解构表达式 比如有一个函数： 123456789const person = &#123; name:"jack", age:21, language: ['java','js','css']&#125;function hello(person) &#123; console.log("hello," + person.name)&#125; 如果用箭头函数和解构表达式 1var hi = (&#123;name&#125;) =&gt; console.log("hello," + name); 1.3.5.map和reduce数组中新增了map和reduce方法。 map map()：接收一个函数，将原数组中的所有元素用这个函数处理后放入新数组返回。 举例：有一个字符串数组，我们希望转为int数组 123456let arr = ['1','20','-5','3'];console.log(arr)arr = arr.map(s =&gt; parseInt(s));console.log(arr) reduce reduce()：接收一个函数（必须）和一个初始值（可选），该函数接收两个参数： 第一个参数是上一次reduce处理的结果 第二个参数是数组中要处理的下一个元素 reduce()会从左到右依次把数组中的元素用reduce处理，并把处理的结果作为下次reduce的第一个参数。如果是第一次，会把前两个元素作为计算参数，或者把用户指定的初始值作为起始参数 举例： 1const arr = [1,20,-5,3] 没有初始值： 指定初始值： 1.3.6.promise所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。 感觉跟java的Future类很像啊，有木有！ 我们可以通过Promise的构造函数来创建Promise对象，并在内部封装一个异步执行的结果。 语法： 123456789const promise = new Promise(function(resolve, reject) &#123; // ... 执行异步操作 if (/* 异步操作成功 */)&#123; resolve(value);// 调用resolve，代表Promise将返回成功的结果 &#125; else &#123; reject(error);// 调用reject，代表Promise会返回失败结果 &#125;&#125;); 这样，在promise中就封装了一段异步执行的结果。 如果我们想要等待异步执行完成，做一些事情，我们可以通过promise的then方法来实现,语法： 123promise.then(function(value)&#123; // 异步执行成功后的回调&#125;); 如果想要处理promise异步执行失败的事件，还可以跟上catch： 12345promise.then(function(value)&#123; // 异步执行成功后的回调&#125;).catch(function(error)&#123; // 异步执行失败后的回调&#125;) 示例： 12345678910111213141516171819const p = new Promise(function (resolve, reject) &#123; // 这里我们用定时任务模拟异步 setTimeout(() =&gt; &#123; const num = Math.random(); // 随机返回成功或失败 if (num &lt; 0.5) &#123; resolve(&quot;成功！num:&quot; + num) &#125; else &#123; reject(&quot;出错了！num:&quot; + num) &#125; &#125;, 300)&#125;)// 调用promisep.then(function (msg) &#123; console.log(msg);&#125;).catch(function (msg) &#123; console.log(msg);&#125;) 结果： 1.3.7.set和map（了解）ES6提供了Set和Map的数据结构。 Set，本质与数组类似。不同在于Set中只能保存不同元素，如果元素相同会被忽略。跟java很像吧。 构造函数： 12345// Set构造函数可以接收一个数组或空let set = new Set();set.add(1);// [1]// 接收数组let set2 = new Set([2,3,4,5,5]);// 得到[2,3,4,5] 普通方法： 123456789set.add(1);// 添加set.clear();// 清空set.delete(2);// 删除指定元素set.has(2); // 判断是否存在set.keys();// 返回所有keyset.values();// 返回所有值set.entries();// 返回键值对集合// 因为set没有键值对，所有其keys、values、entries方法返回值一样的。set.size; // 元素个数。是属性，不是方法。 map，本质是与Object类似的结构。不同在于，Object强制规定key只能是字符串。而Map结构的key可以是任意对象。即： object是 &lt;string,object&gt;集合 map是&lt;object,object&gt;集合 构造函数： 12345678910111213// map接收一个数组，数组中的元素是键值对数组const map = new Map([ ['key1','value1'], ['key2','value2'],])// 或者接收一个setconst set = new Set([ ['key1','value1'], ['key2','value2'],])const map2 = new Map(set)// 或者其它mapconst map3 = new Map(map); 方法： 1.3.8.模块化1.3.8.1.什么是模块化模块化就是把代码进行拆分，方便重复利用。类似java中的导包：要使用一个包，必须先导包。 而JS中没有包的概念，换来的是 模块。 模块功能主要由两个命令构成：export和import。 export命令用于规定模块的对外接口， import命令用于导入其他模块提供的功能。 1.3.8.2.export比如我定义一个js文件:hello.js，里面有一个对象： 12345const util = &#123; sum(a,b)&#123; return a + b; &#125;&#125; 我可以使用export将这个对象导出： 123456const util = &#123; sum(a,b)&#123; return a + b; &#125;&#125;export util; 当然，也可以简写为： 12345export const util = &#123; sum(a,b)&#123; return a + b; &#125;&#125; export不仅可以导出对象，一切JS变量都可以导出。比如：基本类型变量、函数、数组、对象。 当要导出多个值时，还可以简写。比如我有一个文件：user.js： 123var name = "jack"var age = 21export &#123;name,age&#125; 省略名称 上面的导出代码中，都明确指定了导出的变量名，这样其它人在导入使用时就必须准确写出变量名，否则就会出错。 因此js提供了default关键字，可以对导出的变量名进行省略 例如： 123456// 无需声明对象的名字export default &#123; sum(a,b)&#123; return a + b; &#125;&#125; 这样，当使用者导入时，可以任意起名字 1.3.8.3.import使用export命令定义了模块的对外接口以后，其他 JS 文件就可以通过import命令加载这个模块。 例如我要使用上面导出的util： 1234// 导入utilimport util from 'hello.js'// 调用util中的属性util.sum(1,2) 要批量导入前面导出的name和age： 123import &#123;name, age&#125; from 'user.js'console.log(name + " , 今年"+ age +"岁了") 但是上面的代码暂时无法测试，因为浏览器目前还不支持ES6 的导入和导出功能。除非借助于工具，把ES6 的语法进行编译降级到ES5，比如Babel-cli工具 我们暂时不做测试，大家了解即可。 1.3.9.对象扩展ES6给Object拓展了许多新的方法，如： keys(obj)：获取对象的所有key形成的数组 values(obj)：获取对象的所有value形成的数组 entries(obj)：获取对象的所有key和value形成的二维数组。格式：[[k1,v1],[k2,v2],...] assian(dest, …src) ：将多个src对象的值 拷贝到 dest中（浅拷贝）。 1.3.10.数组扩展ES6给数组新增了许多方法： find(callback)：把数组中的元素逐个传递给函数callback执行，如果返回true，则返回该元素 findIndex(callback)：与find类似，不过返回的是品牌到的元素的索引 includes（callback）：与find类似，如果匹配到元素，则返回true，代表找到了。]]></content>
      <categories>
        <category>项目实战-微服务商城</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务商城（三）——SpringCloud学习笔记二]]></title>
    <url>%2Fday03-%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A12.html</url>
    <content type="text"><![CDATA[0.学习目标 会配置Hystix熔断 会使用Feign进行远程调用 能独立搭建Zuul网关 能编写Zuul的拦截器 1.Hystix1.1.简介Hystix，即熔断器。 主页：https://github.com/Netflix/Hystrix/ Hystix是Netflix开源的一个延迟和容错库，用于隔离访问远程服务、第三方库，防止出现级联失败。 1.2.熔断器的工作机制： 正常工作的情况下，客户端请求调用服务cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccbbbsAPI接口： 当有服务出现异常时，直接进行失败回滚，服务降级处理： 当服务繁忙时，如果服务出现异常，不是粗暴的直接报错，而是返回一个友好的提示，虽然拒绝了用户的访问，但是会返回一个结果。 这就好比去买鱼，平常超市买鱼会额外赠送杀鱼的服务。等到逢年过节，超时繁忙时，可能就不提供杀鱼服务了，这就是服务的降级。 系统特别繁忙时，一些次要服务暂时中断，优先保证主要服务的畅通，一切资源优先让给主要服务来使用，在双十一、618时，京东天猫都会采用这样的策略。 1.3.动手实践1.3.1.引入依赖首先在consumer-demo中引入Hystix依赖： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;&lt;/dependency&gt; 1.3.2.开启熔断引入标签@EnableHystrix 1234@EnableHystrix //开启熔断@SpringBootApplication@EnableDiscoveryClient public class ConsumerDemoApplication &#123; 1.3.3.改造消费者我们改造consumer-demo，添加一个用来访问的user服务的DAO，并且声明一个失败时的回滚处理函数： 123456789101112131415161718192021222324252627282930@Componentpublic class UserDao &#123; @Autowired private RestTemplate restTemplate; private static final Logger logger = LoggerFactory.getLogger(UserDao.class); @HystrixCommand(fallbackMethod = "queryUserByIdFallback") public User queryUserById(Long id)&#123; long begin = System.currentTimeMillis(); String url = "http://user-service/user/" + id; User user = this.restTemplate.getForObject(url, User.class); long end = System.currentTimeMillis(); // 记录访问用时： logger.info("访问用时：&#123;&#125;", end - begin); return user; &#125; /** * 当上面queryById()方法执行不了就进行熔断执行queryUserByIdFallback()方法进行报错信息 * @param id * @return */ public User queryUserByIdFallback(Long id)&#123; User user = new User(); user.setId(id); user.setName("用户信息查询出现异常！"); return user; &#125;&#125; @HystrixCommand(fallbackMethod=&quot;queryUserByIdFallback&quot;)：声明一个失败回滚处理函数queryUserByIdFallback，当queryUserById执行超时（默认是1000毫秒），就会执行fallback函数，返回错误提示。 为了方便查看熔断的触发时机，我们记录请求访问时间。 在消费服务者consumer-demo原来的业务逻辑中调用这个DAO： 123456789101112131415@Servicepublic class UserService &#123; @Autowired private UserDao userDao; public List&lt;User&gt; queryUserByIds(List&lt;Long&gt; ids) &#123; List&lt;User&gt; users = new ArrayList&lt;&gt;(); ids.forEach(id -&gt; &#123; // 我们测试多次查询， users.add(this.userDao.queryUserById(id)); &#125;); return users; &#125;&#125; 1.3.4.改造服务提供者改造服务提供者，随机休眠一段时间，以触发熔断： 123456789101112@Servicepublic class UserService &#123; @Autowired private UserMapper userMapper; public User queryById(Long id) throws InterruptedException &#123; // 为了演示超时现象，我们在这里然线程休眠,时间随机 0~2000毫秒 Thread.sleep(new Random().nextInt(2000)); return this.userMapper.selectByPrimaryKey(id); &#125;&#125; 1.3.5.启动测试然后运行并查看日志： id为9、10、11的访问时间分别是： id为12的访问时间： 因此，只有12是正常访问，其它都会触发熔断，我们来查看结果： 1.3.5.优化虽然熔断实现了，但是我们的重试机制似乎没有生效，是这样吗？ 其实这里是因为我们的Ribbon超时时间设置的是1000ms: ​ 而Hystix的超时时间默认也是1000ms，因此重试机制没有被触发，而是先触发了熔断。 所以，Ribbon的超时时间一定要小于Hystix的超时时间。 我们可以通过hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds来设置Hystrix超时时间。 在消费者中（） 123456hystrix: command: execution: isolation: thread: timeoutInMillisecond: 6000 # 设置hystrix的超时时间为6000ms 2.Feign（包括了Hystix、ribbon）在前面的学习中，我们使用了Ribbon的负载均衡功能，大大简化了远程调用时的代码： 12String baseUrl = "http://user-service/user/";User user = this.restTemplate.getForObject(baseUrl + id, User.class) 如果就学到这里，你可能以后需要编写类似的大量重复代码，格式基本相同，无非参数不一样。有没有更优雅的方式，来对这些代码再次优化呢？ 这就是我们接下来要学的Feign的功能了。 2.1.简介有道词典的英文解释： ​ 为什么叫伪装？ Feign可以把Rest的请求进行隐藏，伪装成类似SpringMVC的Controller一样。你不用再自己拼接url，拼接参数等等操作，一切都交给Feign去做。 项目主页：https://github.com/OpenFeign/feign 声明式远程调用 2.2.快速入门2.2.1.导入依赖在consumer-demo中： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt; 开启Feign客户端 1234567@EnableHystrix@SpringBootApplication@EnableDiscoveryClient // 开启Eureka客户端@EnableFeignClients //开启feign客户端public class ConsumerDemoApplication &#123; &#125; 2.2.2.Feign的客户端consumer-demo中的dao中创建： 123456@FeignClient("user-service")public interface UserFeignClient &#123; @GetMapping("/user/&#123;id&#125;") User queryUserById(@PathVariable("id") Long id);&#125; 首先这是一个接口，Feign会通过动态代理，帮我们生成实现类。这点跟mybatis的mapper很像 @FeignClient，声明这是一个Feign客户端，类似@Mapper注解。同时通过value属性指定服务名称 接口中的定义方法，完全采用SpringMVC的注解，Feign会根据注解帮我们生成URL，并访问获取结果 改造原来的调用逻辑，不再调用UserDao： 123456789101112131415@Servicepublic class UserService &#123; @Autowired private UserFeignClient userFeignClient; public List&lt;User&gt; queryUserByIds(List&lt;Long&gt; ids) &#123; List&lt;User&gt; users = new ArrayList&lt;&gt;(); ids.forEach(id -&gt; &#123; // 我们测试多次查询， users.add(this.userFeignClient.queryUserById(id)); &#125;); return users; &#125;&#125; 2.2.3.开启Feign功能我们在启动类上，添加注解，开启Feign功能 123456789@SpringBootApplication@EnableDiscoveryClient@EnableHystrix@EnableFeignClients // 开启Feign功能public class UserConsumerDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(UserConsumerDemoApplication.class, args); &#125;&#125; 你会发现RestTemplate的注册被我删除了。Feign中已经自动集成了Ribbon负载均衡，因此我们不需要自己定义RestTemplate了 2.2.4.启动测试：访问接口： 正常获取到了结果。 2.3.负载均衡Feign中本身已经集成了Ribbon依赖和自动配置： ​ 因此我们不需要额外引入依赖，也不需要再注册RestTemplate对象。 另外，我们可以像上节课中讲的那样去配置Ribbon，可以通过ribbon.xx来进行全局配置。也可以通过服务名.ribbon.xx来对指定服务配置： 1234567user-service: ribbon: ConnectTimeout: 250 # 连接超时时间(ms) ReadTimeout: 1000 # 通信超时时间(ms) OkToRetryOnAllOperations: true # 是否对所有操作重试 MaxAutoRetriesNextServer: 1 # 同一服务不同实例的重试次数 MaxAutoRetries: 1 # 同一实例的重试次数 2.4.Hystix支持Feign默认也有对Hystix的集成： ​ 只不过，默认情况下是关闭的。我们需要通过下面的参数来开启： 123feign: hystrix: enabled: true # 开启Feign的熔断功能 但是，Feign中的Fallback配置不像Ribbon中那样简单了。 1）首先，我们要定义一个类，实现刚才编写的UserFeignClient，作为fallback的处理类 12345678910@Componentpublic class UserFeignClientFallback implements UserFeignClient &#123; @Override public User queryUserById(Long id) &#123; User user = new User(); user.setId(id); user.setName("用户查询出现异常！"); return user; &#125;&#125; 2）然后在UserFeignClient中，指定刚才编写的实现类 123456@FeignClient(value = "user-service", fallback = UserFeignClientFallback.class)public interface UserFeignClient &#123; @GetMapping("/user/&#123;id&#125;") User queryUserById(@PathVariable("id") Long id);&#125; 3）重启测试： 我们关闭user-service服务，然后在页面访问： 2.5.请求压缩(了解)Spring Cloud Feign 支持对请求和响应进行GZIP压缩，以减少通信过程中的性能损耗。通过下面的参数即可开启请求与响应的压缩功能： 123456feign: compression: request: enabled: true # 开启请求压缩 response: enabled: true # 开启响应压缩 同时，我们也可以对请求的数据类型，以及触发压缩的大小下限进行设置： 123456feign: compression: request: enabled: true # 开启请求压缩 mime-types: text/html,application/xml,application/json # 设置压缩的数据类型 min-request-size: 2048 # 设置触发压缩的大小下限 注：上面的数据类型、压缩大小下限均为默认值。 2.6.日志级别(了解)前面讲过，通过logging.level.xx=debug来设置日志级别。然而这个对Fegin客户端而言不会产生效果。因为@FeignClient注解修改的客户端在被代理时，都会创建一个新的Fegin.Logger实例。我们需要额外指定这个日志的级别才可以。 1）设置com.leyou包下的日志级别都为debug 123logging: level: com.leyou: debug 2）编写配置类，定义日志级别 Logger是导入：import feign.Logger; 1234567@Configurationpublic class FeignConfig &#123; @Bean Logger.Level feignLoggerLevel()&#123; return Logger.Level.FULL; &#125;&#125; 这里指定的Level级别是FULL，Feign支持4种级别： ​ NONE：不记录任何日志信息，这是默认值。 BASIC：仅记录请求的方法，URL以及响应状态码和执行时间 HEADERS：在BASIC的基础上，额外记录了请求和响应的头信息 FULL：记录所有请求和响应的明细，包括头信息、请求体、元数据。 3）在FeignClient中指定配置类： 12345@FeignClient(value = "user-service", fallback = UserFeignClientFallback.class, configuration = FeignConfig.class)public interface UserFeignClient &#123; @GetMapping("/user/&#123;id&#125;") User queryUserById(@PathVariable("id") Long id);&#125; 4）重启项目，即可看到每次访问的日志： 3.Zuul网关通过前面的学习，使用Spring Cloud实现微服务的架构基本成型，大致是这样的： 我们使用Spring Cloud Netflix中的Eureka实现了服务注册中心以及服务注册与发现；而服务间通过Ribbon或Feign实现服务的消费以及均衡负载；通过Spring Cloud Config实现了应用多环境的外部化配置以及版本管理。为了使得服务集群更为健壮，使用Hystrix的融断机制来避免在微服务架构中个别服务出现异常时引起的故障蔓延。 在该架构中，我们的服务集群包含：内部服务Service A和Service B，他们都会注册与订阅服务至Eureka Server，而Open Service是一个对外的服务，通过均衡负载公开至服务调用方。我们把焦点聚集在对外服务这块，直接暴露我们的服务地址，这样的实现是否合理，或者是否有更好的实现方式呢？ 先来说说这样架构需要做的一些事儿以及存在的不足： 首先，破坏了服务无状态特点。 为了保证对外服务的安全性，我们需要实现对服务访问的权限控制，而开放服务的权限控制机制将会贯穿并污染整个开放服务的业务逻辑，这会带来的最直接问题是，破坏了服务集群中REST API无状态的特点。 从具体开发和测试的角度来说，在工作中除了要考虑实际的业务逻辑之外，还需要额外考虑对接口访问的控制处理。 其次，无法直接复用既有接口。 当我们需要对一个即有的集群内访问接口，实现外部服务访问时，我们不得不通过在原有接口上增加校验逻辑，或增加一个代理调用来实现权限控制，无法直接复用原有的接口。 面对类似上面的问题，我们要如何解决呢？答案是：服务网关！ 为了解决上面这些问题，我们需要将权限控制这样的东西从我们的服务单元中抽离出去，而最适合这些逻辑的地方就是处于对外访问最前端的地方，我们需要一个更强大一些的均衡负载器的 服务网关。 服务网关是微服务架构中一个不可或缺的部分。通过服务网关统一向外系统提供REST API的过程中，除了具备服务路由、均衡负载功能之外，它还具备了权限控制等功能。Spring Cloud Netflix中的Zuul就担任了这样的一个角色，为微服务架构提供了前门保护的作用，同时将权限控制这些较重的非业务逻辑内容迁移到服务路由层面，使得服务集群主体能够具备更高的可复用性和可测试性。 3.1.简介官网：https://github.com/Netflix/zuul ​ Zuul：维基百科： 电影《捉鬼敢死队》中的怪兽，Zuul，在纽约引发了巨大骚乱。 事实上，在微服务架构中，Zuul就是守门的大Boss！一夫当关，万夫莫开！ 3.2.Zuul加入后的架构 不管是来自于客户端（PC或移动端）的请求，还是服务内部调用。一切对服务的请求都会经过Zuul这个网关，然后再由网关来实现 鉴权、动态路由等等操作。Zuul就是我们服务的统一入口。 3.3.快速入门3.3.1.新建工程填写基本信息： 添加Zuul依赖： 3.3.2.编写启动类通过@EnableZuulProxy注解开启Zuul的功能： 12345678@SpringBootApplication@EnableZuulProxy // 开启Zuul的网关功能public class ZuulDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ZuulDemoApplication.class, args); &#125;&#125; 3.3.3.编写配置12345server: port: 10010 #服务端口spring: application: name: api-gateway #指定服务名 3.3.4.编写路由规则我们需要用Zuul来代理user-service服务，先看一下控制面板中的服务状态： ip为：127.0.0.1 端口为：8081 映射规则： 12345zuul: routes: user-service: # 这里是路由id，随意写 path: /user-service/** # 这里是映射路径 url: http://127.0.0.1:8082 # 映射路径服务提供者的实际url地址 我们将符合path 规则的一切请求，都代理到 url参数指定的地址 本例中，我们将 /user-service/**开头的请求，代理到http://127.0.0.1:8082 3.3.5.启动测试：访问的路径中需要加上配置规则的映射路径， 以前访问方式为：http://127.0.0.1:8080/hello/list?ids=17 现在访问方式为：http://127.0.0.1:10010/user-service/user/16 ​ 3.4.面向服务的路由在刚才的路由规则中，我们把路径对应的服务地址写死了！如果同一服务有多个实例的话，这样做显然就不合理了。 我们应该根据服务的名称，去Eureka注册中心查找 服务对应的所有实例列表，然后进行动态路由才对！ 3.4.1.添加Eureka客户端依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt; 3.4.2.开启Eureka客户端发现功能123456789@SpringBootApplication@EnableZuulProxy // 开启Zuul的网关功能@EnableDiscoveryClientpublic class ZuulDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ZuulDemoApplication.class, args); &#125;&#125; 3.4.3.添加Eureka配置，获取服务信息12345678eureka: client: registry-fetch-interval-seconds: 5 # 获取服务列表的周期：5s service-url: defaultZone: http://127.0.0.1:10086/eureka instance: prefer-ip-address: true ip-address: 127.0.0.1 3.4.4.修改映射配置，通过服务名称获取因为已经有了Eureka客户端，我们可以从Eureka获取服务的地址信息，因此映射时无需指定IP地址，而是通过服务名称来访问，而且Zuul已经集成了Ribbon的负载均衡功能。 12345zuul: routes: user-service: # 这里是路由id，随意写 path: /user-service/** # 这里是映射路径 serviceId: user-service # 指定服务名称 3.4.5.启动测试再次启动，这次Zuul进行代理时，会利用Ribbon进行负载均衡访问： ​ 日志中可以看到使用了负载均衡器： 3.5.简化的路由配置在刚才的配置中，我们的规则是这样的： zuul.routes.&lt;route&gt;.path=/xxx/**： 来指定映射路径。&lt;route&gt;是自定义的路由名 zuul.routes.&lt;route&gt;.serviceId=/user-service：来指定服务名。 而大多数情况下，我们的&lt;route&gt;路由名称往往和 服务名会写成一样的。因此Zuul就提供了一种简化的配置语法：zuul.routes.&lt;serviceId&gt;=&lt;path&gt; 比方说上面我们关于user-service的配置可以简化为一条： 1234zuul: routes: user-service: /user-service/** # 这里是映射路径 &#123;服务名&#125;：&#123;服务路径&#125; 省去了对服务名称的配置。 3.6.默认的路由规则在使用Zuul的过程中，上面讲述的规则已经大大的简化了配置项。但是当服务较多时，配置也是比较繁琐的。因此Zuul就指定了默认的路由规则： 默认情况下，一切服务的映射路径就是服务名本身。 例如服务名为：user-service，则默认的映射路径就是：/user-service/** 也就是说，刚才的映射规则我们完全不配置也是OK的，不信就试试看。 3.7.路由前缀配置示例： 1234zuul: prefix: /api # 添加路由前缀 routes: user-service: /user-service/** # 服务路径 我们通过zuul.prefix=/api来指定了路由的前缀，这样在发起请求时，路径就要以/api开头。 路径/api/user-service/user/1将会被代理到/user-service/user/1 http://localhost:10010/api/user-service/user/17 3.8.过滤器Zuul作为网关的其中一个重要功能，就是实现请求的鉴权。而这个动作我们往往是通过Zuul提供的过滤器来实现的。 3.8.1.ZuulFilterZuulFilter是过滤器的顶级父类。在这里我们看一下其中定义的4个最重要的方法： 源码： 12345678910public abstract ZuulFilter implements IZuulFilter&#123; abstract public String filterType(); abstract public int filterOrder(); boolean shouldFilter();// 来自IZuulFilter Object run() throws ZuulException;// IZuulFilter&#125; shouldFilter：返回一个Boolean值，判断该过滤器是否需要执行。返回true执行，返回false不执行。 run：过滤器的具体业务逻辑。 filterType：返回字符串，代表过滤器的类型。包含以下4种： pre：请求在被路由之前执行 routing：在路由请求时调用 post：在routing和errror过滤器之后调用 error：处理请求时发生错误调用 filterOrder：通过返回的int值来定义过滤器的执行顺序，数字越小优先级越高。 3.8.2.过滤器执行生命周期：这张是Zuul官网提供的请求生命周期图，清晰的表现了一个请求在各个过滤器的执行顺序。 ​ 正常流程： 请求到达首先会经过pre类型过滤器，而后到达routing类型，进行路由，请求就到达真正的服务提供者，执行请求，返回结果后，会到达post过滤器。而后返回响应。 异常流程： 整个过程中，pre或者routing过滤器出现异常，都会直接进入error过滤器，再error处理完毕后，会将请求交给POST过滤器，最后返回给用户。 如果是error过滤器自己出现异常，最终也会进入POST过滤器，而后返回。 如果是POST过滤器出现异常，会跳转到error过滤器，但是与pre和routing不同的时，请求不会再到达POST过滤器了。 所有内置过滤器列表： ​ 3.8.3.使用场景场景非常多： 请求鉴权：一般放在pre类型，如果发现没有访问权限，直接就拦截了 异常处理：一般会在error类型和post类型过滤器中结合来处理。 服务调用时长统计：pre和post结合使用。 3.9.自定义过滤器接下来我们来自定义一个过滤器，模拟一个登录的校验。基本逻辑：如果请求中有access-token参数，则认为请求有效，放行。 3.9.1.定义过滤器类12345678910111213141516171819202122232425262728293031323334353637383940@Componentpublic class LoginFilter extends ZuulFilter&#123; @Override public String filterType() &#123; // 登录校验，肯定是在前置拦截 return "pre"; &#125; @Override public int filterOrder() &#123; // 顺序设置为1 return 1; &#125; @Override public boolean shouldFilter() &#123; // 返回true，代表过滤器生效。 return true; &#125; @Override public Object run() throws ZuulException &#123; // 登录校验逻辑。 // 1）获取Zuul提供的请求上下文对象 RequestContext ctx = RequestContext.getCurrentContext(); // 2) 从上下文中获取request对象 HttpServletRequest req = ctx.getRequest(); // 3) 从请求中获取token String token = req.getParameter("access-token"); // 4) 判断 if(token == null || "".equals(token.trim()))&#123; // 没有token，登录校验失败，拦截 ctx.setSendZuulResponse(false); // 返回401状态码。也可以考虑重定向到登录页。 ctx.setResponseStatusCode(HttpStatus.UNAUTHORIZED.value()); &#125; // 校验通过，可以考虑把用户信息放入上下文，继续向后执行 return null; &#125;&#125; 3.9.2.测试没有token参数时，访问失败： ​ 添加token参数后： 3.10.负载均衡和熔断Zuul中默认就已经集成了Ribbon负载均衡和Hystix熔断机制。但是所有的超时策略都是走的默认值，比如熔断超时时间只有1S，很容易就触发了。因此建议我们手动进行配置： 1234567891011121314zuul: retryable: trueribbon: ConnectTimeout: 250 # 连接超时时间(ms) ReadTimeout: 2000 # 通信超时时间(ms) OkToRetryOnAllOperations: true # 是否对所有操作重试 MaxAutoRetriesNextServer: 2 # 同一服务不同实例的重试次数 MaxAutoRetries: 1 # 同一实例的重试次数hystrix: command: execution: isolation: thread: timeoutInMillisecond: 6000 # 熔断超时时长：6000ms 3.11.Zuul的高可用]]></content>
      <categories>
        <category>项目实战-微服务商城</category>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
        <tag>Hystix</tag>
        <tag>Feign</tag>
        <tag>Zuul</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务商城（二）——SpringCloud学习笔记一]]></title>
    <url>%2Fday02-%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A1.html</url>
    <content type="text"><![CDATA[0.学习目标 了解系统架构的演变 了解RPC与Http的区别 掌握HttpClient的简单使用 知道什么是SpringCloud 独立搭建Eureka注册中心 独立配置Robbin负载均衡 1.系统架构演变随着互联网的发展，网站应用的规模不断扩大。需求的激增，带来的是技术上的压力。系统架构也因此也不断的演进、升级、迭代。从单一应用，到垂直拆分，到分布式服务，到SOA，以及现在火热的微服务架构，还有在Google带领下来势汹涌的Service Mesh。我们到底是该乘坐微服务的船只驶向远方，还是偏安一隅得过且过？ 其实生活不止眼前的苟且，还有诗和远方。所以我们今天就回顾历史，看一看系统架构演变的历程；把握现在，学习现在最火的技术架构；展望未来，争取成为一名优秀的Java工程师。 1.1. 集中式架构当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架(ORM)是影响项目开发的关键。 存在的问题： 代码耦合，开发维护困难 无法针对不同模块进行针对性优化 无法水平扩展 单点容错率低，并发能力差 1.2.垂直拆分当访问量逐渐增大，单一应用无法满足需求，此时为了应对更高的并发和业务需求，我们根据业务功能对系统进行拆分： 优点： 系统拆分实现了流量分担，解决了并发问题 可以针对不同模块进行优化 方便水平扩展，负载均衡，容错率提高 缺点： 系统间相互独立，会有很多重复开发工作，影响开发效率 1.3.分布式服务当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的分布式调用是关键。 优点： 将基础服务进行了抽取，系统间相互调用，提高了代码复用和开发效率 缺点： 系统间耦合度变高，调用关系错综复杂，难以维护 1.4.服务治理（SOA）当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心(SOA)是关键 以前出现了什么问题？ 服务越来越多，需要管理每个服务的地址 调用关系错综复杂，难以理清依赖关系 服务过多，服务状态难以管理，无法根据服务情况动态管理 服务治理要做什么？ 服务注册中心，实现服务自动注册和发现，无需人为记录服务地址 服务自动订阅，服务列表自动推送，服务调用透明化，无需关心依赖关系 动态监控服务状态监控报告，人为控制服务状态 缺点： 服务间会有依赖关系，一旦某个环节出错会影响较大 服务关系复杂，运维、测试部署困难，不符合DevOps思想 1.5.微服务前面说的SOA，英文翻译过来是面向服务。微服务，似乎也是服务，都是对系统进行拆分。因此两者非常容易混淆，但其实缺有一些差别： 微服务的特点： 单一职责：微服务中每一个服务都对应唯一的业务能力，做到单一职责 微：微服务的服务拆分粒度很小，例如一个用户管理就可以作为一个服务。每个服务虽小，但“五脏俱全”。 面向服务：面向服务是说每个服务都要对外暴露服务接口API。并不关心服务的技术实现，做到与平台和语言无关，也不限定用什么技术实现，只要提供Rest的接口即可。 自治：自治是说服务间互相独立，互不干扰 团队独立：每个服务都是一个独立的开发团队，人数不能过多。 技术独立：因为是面向服务，提供Rest接口，使用什么技术没有别人干涉 前后端分离：采用前后端分离开发，提供统一Rest接口，后端不用再为PC、移动段开发不同接口 数据库分离：每个服务都使用自己的数据源 部署独立，服务间虽然有调用，但要做到服务重启不影响其它服务。有利于持续集成和持续交付。每个服务都是独立的组件，可复用，可替换，降低耦合，易维护 微服务结构图： 2.远程调用方式无论是微服务还是SOA，都面临着服务间的远程调用。那么服务间的远程调用方式有哪些呢？ 常见的远程调用方式有以下几种： RPC：Remote Produce Call远程过程调用，类似的还有RMI。自定义数据格式，基于原生TCP通信，速度快，效率高。早期的webservice，现在热门的dubbo，都是RPC的典型 Http：http其实是一种网络传输协议，基于TCP，规定了数据传输的格式。现在客户端浏览器与服务端通信基本都是采用Http协议。也可以用来进行远程服务调用。缺点是消息封装臃肿。 现在热门的Rest风格，就可以通过http协议来实现。 如果你们公司全部采用java技术栈，name使用Dubbo作为微服务架构师一个不错的选择 相反，如果公司采用技术栈多样，而且你更青睐spring家族，那么SpringCloud搭建微服务是不二之选，在我们项目中，我们就会选择采用SpringCloud套件，因此我们会使用http方式来实现服务间调用 2.1.认识RPCRPC，即 Remote Procedure Call（远程过程调用），是一个计算机通信协议。 该协议允许运行于一台计算机的程序调用另一台计算机的子程序，而程序员无需额外地为这个交互作用编程。说得通俗一点就是：A计算机提供一个服务，B计算机可以像调用本地服务那样调用A计算机的服务。 通过上面的概念，我们可以知道，实现RPC主要是做到两点： 实现远程调用其他计算机的服务 要实现远程调用，肯定是通过网络传输数据。A程序提供服务，B程序通过网络将请求参数传递给A，A本地执行后得到结果，再将结果返回给B程序。这里需要关注的有两点： 1）采用何种网络通讯协议？ 现在比较流行的RPC框架，都会采用TCP作为底层传输协议 2）数据传输的格式怎样？ 两个程序进行通讯，必须约定好数据传输格式。就好比两个人聊天，要用同一种语言，否则无法沟通。所以，我们必须定义好请求和响应的格式。另外，数据在网路中传输需要进行序列化，所以还需要约定统一的序列化的方式。 像调用本地服务一样调用远程服务 如果仅仅是远程调用，还不算是RPC，因为RPC强调的是过程调用，调用的过程对用户而言是应该是透明的，用户不应该关心调用的细节，可以像调用本地服务一样调用远程服务。所以RPC一定要对调用的过程进行封装 RPC调用流程图： 想要了解详细的RPC实现，给大家推荐一篇文章：自己动手实现RPC 2.2.认识HttpHttp协议：超文本传输协议，是一种应用层协议。规定了网络传输的请求格式、响应格式、资源定位和操作的方式等。但是底层采用什么网络传输协议，并没有规定，不过现在都是采用TCP协议作为底层传输协议。说到这里，大家可能觉得，Http与RPC的远程调用非常像，都是按照某种规定好的数据格式进行网络通信，有请求，有响应。没错，在这点来看，两者非常相似，但是还是有一些细微差别。 RPC并没有规定数据传输格式，这个格式可以任意指定，不同的RPC协议，数据格式不一定相同。 Http中还定义了资源定位的路径，RPC中并不需要 最重要的一点：RPC需要满足像调用本地服务一样调用远程服务，也就是对调用过程在API层面进行封装。Http协议没有这样的要求，因此请求、响应等细节需要我们自己去实现。 优点：RPC方式更加透明，对用户更方便。Http方式更灵活，没有规定API和语言，跨语言、跨平台 缺点：RPC方式需要在API层面进行封装，限制了开发的语言环境。 例如我们通过浏览器访问网站，就是通过Http协议。只不过浏览器把请求封装，发起请求以及接收响应，解析响应的事情都帮我们做了。如果是不通过浏览器，那么这些事情都需要自己去完成。 2.3.如何选择？既然两种方式都可以实现远程调用，我们该如何选择呢？ 速度来看，RPC要比http更快，虽然底层都是TCP，但是http协议的信息往往比较臃肿，不过可以采用gzip压缩。 难度来看，RPC实现较为复杂，http相对比较简单 灵活性来看，http更胜一筹，因为它不关心实现细节，跨平台、跨语言。 因此，两者都有不同的使用场景： 如果对效率要求更高，并且开发过程使用统一的技术栈，那么用RPC还是不错的。 如果需要更加灵活，跨语言、跨平台，显然http更合适 那么我们该怎么选择呢？ 微服务，更加强调的是独立、自治、灵活。而RPC方式的限制较多，因此微服务框架中，一般都会采用基于Http的Rest风格服务。 3.Http客户端工具既然微服务选择了Http，那么我们就需要考虑自己来实现对请求和响应的处理。不过开源世界已经有很多的http客户端工具，能够帮助我们做这些事情，例如： HttpClient OKHttp URLConnection 接下来，我们就一起了解一款比较流行的客户端工具：HttpClient 3.1.HttpClient3.1.1.介绍HttpClient是Apache公司的产品，是Http Components下的一个组件。 官网地址：http://hc.apache.org/index.html 特点： 基于标准、纯净的Java语言。实现了Http1.0和Http1.1 以可扩展的面向对象的结构实现了Http全部的方法（GET, POST, PUT, DELETE, HEAD, OPTIONS, and TRACE） 支持HTTPS协议。 通过Http代理建立透明的连接。 自动处理Set-Cookie中的Cookie。 3.1.2.使用我们导入课前资料提供的demo工程：《http-demo》 发起get请求： 123456@Testpublic void testGet() throws IOException &#123; HttpGet request = new HttpGet("http://www.baidu.com"); String response = this.httpClient.execute(request, new BasicResponseHandler()); System.out.println(response);&#125; 发起Post请求： 12345678@Testpublic void testPost() throws IOException &#123; HttpPost request = new HttpPost("http://www.oschina.net/"); request.setHeader("User-Agent", "Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36"); String response = this.httpClient.execute(request, new BasicResponseHandler()); System.out.println(response);&#125; 尝试访问昨天编写的接口：http://localhost/hello 这个接口返回一个User对象 123456@Testpublic void testGetPojo() throws IOException &#123; HttpGet request = new HttpGet("http://localhost/hello"); String response = this.httpClient.execute(request, new BasicResponseHandler()); System.out.println(response);&#125; 我们实际得到的是一个json字符串： 123456789101112&#123; "id": 8, "userName": "liuyan", "password": "123456", "name": "柳岩", "age": 21, "sex": 2, "birthday": "1995-08-07T16:00:00.000+0000", "created": "2014-09-20T03:41:15.000+0000", "updated": "2014-09-20T03:41:15.000+0000", "note": "柳岩同学在传智播客学表演"&#125; 如果想要得到对象，我们还需要手动进行Json反序列化，这一点比较麻烦。 3.1.3.Json转换工具HttpClient请求数据后是json字符串，需要我们自己把Json字符串反序列化为对象，我们会使用JacksonJson工具来实现。 JacksonJson是SpringMVC内置的json处理工具，其中有一个ObjectMapper类，可以方便的实现对json的处理： 对象转json12345678910111213// json处理工具 private ObjectMapper mapper = new ObjectMapper(); @Test public void testJson() throws JsonProcessingException &#123; User user = new User(); user.setId(8L); user.setAge(21); user.setName("柳岩"); user.setUserName("liuyan"); // 序列化 String json = mapper.writeValueAsString(user); System.out.println("json = " + json); &#125; 结果： json转普通对象12345678910111213141516// json处理工具private ObjectMapper mapper = new ObjectMapper();@Testpublic void testJson() throws IOException &#123; User user = new User(); user.setId(8L); user.setAge(21); user.setName("柳岩"); user.setUserName("liuyan"); // 序列化 String json = mapper.writeValueAsString(user); // 反序列化，接收两个参数：json数据，反序列化的目标类字节码 User result = mapper.readValue(json, User.class); System.out.println("result = " + result);&#125; 结果： json转集合json转集合比较麻烦，因为你无法同时把集合的class和元素的class同时传递到一个参数。 因此Jackson做了一个类型工厂，用来解决这个问题： 12345678910111213141516171819// json处理工具private ObjectMapper mapper = new ObjectMapper();@Testpublic void testJson() throws IOException &#123; User user = new User(); user.setId(8L); user.setAge(21); user.setName("柳岩"); user.setUserName("liuyan"); // 序列化,得到对象集合的json字符串 String json = mapper.writeValueAsString(Arrays.asList(user, user)); // 反序列化，接收两个参数：json数据，反序列化的目标类字节码 List&lt;User&gt; users = mapper.readValue(json, mapper.getTypeFactory().constructCollectionType(List.class, User.class)); for (User u : users) &#123; System.out.println("u = " + u); &#125;&#125; 结果： json转任意复杂类型当对象泛型关系复杂时，类型工厂也不好使了。这个时候Jackson提供了TypeReference来接收类型泛型，然后底层通过反射来获取泛型上的具体类型。实现数据转换。 12345678910111213141516171819// json处理工具private ObjectMapper mapper = new ObjectMapper();@Testpublic void testJson() throws IOException &#123; User user = new User(); user.setId(8L); user.setAge(21); user.setName("柳岩"); user.setUserName("liuyan"); // 序列化,得到对象集合的json字符串 String json = mapper.writeValueAsString(Arrays.asList(user, user)); // 反序列化，接收两个参数：json数据，反序列化的目标类字节码 List&lt;User&gt; users = mapper.readValue(json, new TypeReference&lt;List&lt;User&gt;&gt;()&#123;&#125;); for (User u : users) &#123; System.out.println("u = " + u); &#125;&#125; 结果： 3.3.Spring的RestTemplateSpring提供了一个RestTemplate模板工具类，对基于Http的客户端进行了封装，并且实现了对象与json的序列化和反序列化，非常方便。RestTemplate并没有限定Http的客户端类型，而是进行了抽象，目前常用的3种都有支持： HttpClient OkHttp JDK原生的URLConnection（默认的） 例子工程http-demo去调用工程springboot-demo的服务 注：首先要有相同的User http-demo工程如下： 首先在项目中注册一个RestTemplate对象，可以在启动类位置注册： 12345678910111213@SpringBootApplicationpublic class HttpDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(HttpDemoApplication.class, args); &#125; @Bean public RestTemplate restTemplate() &#123; // 默认的RestTemplate，底层是走JDK的URLConnection方式。 return new RestTemplate(); &#125;&#125; 在测试类中直接@Autowired注入： 12345678910111213@RunWith(SpringRunner.class)@SpringBootTest(classes = HttpDemoApplication.class)public class HttpDemoApplicationTests &#123; @Autowired private RestTemplate restTemplate; @Test public void httpGet() &#123; User user = this.restTemplate.getForObject("http://localhost:8080/user/19", User.class); System.out.println(user); &#125;&#125; 通过RestTemplate的getForObject()方法，传递url地址及实体类的字节码，RestTemplate会自动发起请求，接收响应，并且帮我们对响应结果进行反序列化。 学习完了Http客户端工具，接下来就可以正式学习微服务了。 4.初始SpringCloud微服务是一种架构方式，最终肯定需要技术架构去实施。 微服务的实现方式很多，但是最火的莫过于Spring Cloud了。为什么？ 后台硬：作为Spring家族的一员，有整个Spring全家桶靠山，背景十分强大。 技术强：Spring作为Java领域的前辈，可以说是功力深厚。有强力的技术团队支撑，一般人还真比不了 群众基础好：可以说大多数程序员的成长都伴随着Spring框架，试问：现在有几家公司开发不用Spring？SpringCloud与Spring的各个框架无缝整合，对大家来说一切都是熟悉的配方，熟悉的味道。 使用方便：相信大家都体会到了SpringBoot给我们开发带来的便利，而SpringCloud完全支持SpringBoot的开发，用很少的配置就能完成微服务框架的搭建 4.1.简介SpringCloud是Spring旗下的项目之一，官网地址：http://projects.spring.io/spring-cloud/ Spring最擅长的就是集成，把世界上最好的框架拿过来，集成到自己的项目中。 SpringCloud也是一样，它将现在非常流行的一些技术整合到一起，实现了诸如：配置管理，服务发现，智能路由，负载均衡，熔断器，控制总线，集群状态等等功能。其主要涉及的组件包括： netflix（一个公司） Eureka：注册中心 Zuul：服务网关 Ribbon：负载均衡 Feign：服务调用 Hystix：熔断器 以上只是其中一部分，架构图： 4.2.版本SpringCloud的版本命名比较特殊，因为它不是一个组件，而是许多组件的集合，它的命名是以A到Z的为首字母的一些单词组成： 我们在项目中，会是以Finchley的版本。 其中包含的组件，也都有各自的版本，如下表： Component Edgware.SR3 Finchley.RC1 Finchley.BUILD-SNAPSHOT spring-cloud-aws 1.2.2.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-cloud-bus 1.3.2.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-cloud-cli 1.4.1.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-cloud-commons 1.3.3.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-cloud-contract 1.2.4.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-cloud-config 1.4.3.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-cloud-netflix 1.4.4.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-cloud-security 1.2.2.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-cloud-cloudfoundry 1.1.1.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-cloud-consul 1.3.3.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-cloud-sleuth 1.3.3.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-cloud-stream Ditmars.SR3 Elmhurst.RELEASE Elmhurst.BUILD-SNAPSHOT spring-cloud-zookeeper 1.2.1.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-boot 1.5.10.RELEASE 2.0.1.RELEASE 2.0.0.BUILD-SNAPSHOT spring-cloud-task 1.2.2.RELEASE 2.0.0.RC1 2.0.0.RELEASE spring-cloud-vault 1.1.0.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-cloud-gateway 1.0.1.RELEASE 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT spring-cloud-openfeign 2.0.0.RC1 2.0.0.BUILD-SNAPSHOT 接下来，我们就一一学习SpringCloud中的重要组件。 5.微服务场景模拟首先，我们需要模拟一个服务调用的场景。方便后面学习微服务架构 5.1.服务提供者我们新建一个项目，对外提供查询用户的服务。 5.1.1.Spring脚手架创建工程借助于Spring提供的快速搭建工具： 创建项目：user-service 填写项目信息： 添加web依赖： 添加mybatis依赖： 填写项目位置： 生成的项目结构： 依赖也已经全部自动引入： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.demo&lt;/groupId&gt; &lt;artifactId&gt;user-service-demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;user-service-demo&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.1.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.0.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 12 非常快捷啊！ 5.1.2.编写代码添加一个对外查询的接口： 123456789101112@RestController@RequestMapping("user")public class UserController &#123; @Autowired private UserService userService; @GetMapping("/&#123;id&#125;") public User queryById(@PathVariable("id") Long id) &#123; return this.userService.queryById(id); &#125;&#125; Service： 12345678910@Servicepublic class UserService &#123; @Autowired private UserMapper userMapper; public User queryById(Long id) &#123; return this.userMapper.selectByPrimaryKey(id); &#125;&#125; mapper: 123@Mapperpublic interface UserMapper extends tk.mybatis.mapper.common.Mapper&lt;User&gt;&#123;&#125; 实体类： 123456789101112131415161718192021222324252627282930313233343536373839@Data@Table(name = "tb_user")public class User implements Serializable &#123; private static final long serialVersionUID = 1L; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; // 用户名 private String username; // 密码 private String password; // 姓名 private String name; // 年龄 private Integer age; // 性别，1男性，2女性 private Integer sex; // 出生日期 private Date birthday; // 创建时间 private Date created; // 更新时间 private Date updated; // 备注 private String note; // 。。。省略getters和setters&#125; 属性文件,这里我们采用了yaml语法，而不是properties： 12345678910server: port: 8081mybatis: type-aliases-package: com.itcast.cn.userservice.pojospring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/leyou-test?serverTimezone=Asia/Shanghai&amp;characterEncoding=utf8 username: root password: cxg200888 5.1.3.启动并测试：启动项目，访问接口：http://localhost:8081/user/7 5.2.服务调用者5.2.1.创建工程工程：consumer-demo 与上面类似，这里不再赘述，需要注意的是，我们调用user-service的功能，因此不需要mybatis相关依赖了。 pom： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.demo&lt;/groupId&gt; &lt;artifactId&gt;user-consumer-demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;user-consumer-demo&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.1.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 添加OkHttp支持 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.squareup.okhttp3&lt;/groupId&gt; &lt;artifactId&gt;okhttp&lt;/artifactId&gt; &lt;version&gt;3.9.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 5.2.2.编写代码首先在启动类中注册RestTemplate： 12345678910111213@SpringBootApplicationpublic class UserConsumerDemoApplication &#123; @Bean public RestTemplate restTemplate() &#123; // 这次我们使用了OkHttp客户端,只需要注入工厂即可 return new RestTemplate(new OkHttp3ClientHttpRequestFactory()); &#125; public static void main(String[] args) &#123; SpringApplication.run(UserConsumerDemoApplication.class, args); &#125;&#125; 然后编写UserDao，注意，这里不是调用mapper查数据库，而是通过RestTemplate远程查询user-service-demo中的接口： 1234567891011@Componentpublic class UserDao &#123; @Autowired private RestTemplate restTemplate; public User queryUserById(Long id)&#123; String url = "http://localhost:8081/user/" + id; return this.restTemplate.getForObject(url, User.class); &#125;&#125; 然后编写consumer-demo，循环查询UserDAO信息： 123456789101112131415@Servicepublic class UserService &#123; @Autowired private UserDao userDao; public List&lt;User&gt; querUserByIds(List&lt;Long&gt; ids)&#123; List&lt;User&gt; users = new ArrayList&lt;&gt;(); for (Long id : ids) &#123; User user = this.userDao.queryUserById(id); users.add(user); &#125; return users; &#125;&#125; 编写controller： 123456789101112@RestController@RequestMapping("consume")public class ConsumerController &#123; @Autowired private UserService userService; @GetMapping public List&lt;User&gt; consume(@RequestParam("ids") List&lt;Long&gt; ids) &#123; return this.userService.queryUserByIds(ids); &#125;&#125; 5.2.3.启动测试：因为我们没有配置端口，那么默认就是8080，我们访问：http://localhost:8080/hello/list?ids=16,17,18 一个简单的远程服务调用案例就实现了。 5.3.有没有问题？简单回顾一下，刚才我们写了什么： use-service：一个提供根据id查询用户的微服务 consumer-demo：一个服务调用者，通过RestTemplate远程调用user-service-demo 流程如下： 存在什么问题？ 在consumer中，我们把url地址硬编码到了代码中，不方便后期维护 consumer需要记忆user-service的地址，如果出现变更，可能得不到通知，地址将失效 consumer不清楚user-service的状态，服务宕机也不知道 user-service只有1台服务，不具备高可用性 即便user-service形成集群，consumer还需自己实现负载均衡 其实上面说的问题，概括一下就是分布式服务必然要面临的问题： 服务管理 如何自动注册和发现 如何实现状态监管 如何实现动态路由 服务如何实现负载均衡 服务如何解决容灾问题 服务如何实现统一配置 以上的问题，我们都将在SpringCloud中得到答案。 6.Eureka注册中心6.1.认识Eureka首先我们来解决第一问题，服务的管理。 问题分析 在刚才的案例中，user-service对外提供服务，需要对外暴露自己的地址。而consumer（调用者）需要记录服务提供者的地址。将来地址出现变更，还需要及时更新。这在服务较少的时候并不觉得有什么，但是在现在日益复杂的互联网环境，一个项目肯定会拆分出十几，甚至数十个微服务。此时如果还人为管理地址，不仅开发困难，将来测试、发布上线都会非常麻烦，这与DevOps的思想是背道而驰的。 网约车 这就好比是 网约车出现以前，人们出门叫车只能叫出租车。一些私家车想做出租却没有资格，被称为黑车。而很多人想要约车，但是无奈出租车太少，不方便。私家车很多却不敢拦，而且满大街的车，谁知道哪个才是愿意载人的。一个想要，一个愿意给，就是缺少引子，缺乏管理啊。 此时滴滴这样的网约车平台出现了，所有想载客的私家车全部到滴滴注册，记录你的车型（服务类型），身份信息（联系方式）。这样提供服务的私家车，在滴滴那里都能找到，一目了然。 此时要叫车的人，只需要打开APP，输入你的目的地，选择车型（服务类型），滴滴自动安排一个符合需求的车到你面前，为你服务，完美！ Eureka做什么？ Eureka就好比是滴滴，负责管理、记录服务提供者的信息。服务调用者无需自己寻找服务，而是把自己的需求告诉Eureka，然后Eureka会把符合你需求的服务告诉你。 同时，服务提供方与Eureka之间通过“心跳”机制进行监控，当某个服务提供方出现问题，Eureka自然会把它从服务列表中剔除。 这就实现了服务的自动注册、发现、状态监控。 6.2.原理图 基本架构： Eureka：就是服务注册中心（可以是一个集群），对外暴露自己的地址 提供者：启动后向Eureka注册自己信息（地址，提供什么服务） 消费者：向Eureka订阅服务，Eureka会将对应服务的所有提供者地址列表发送给消费者，并且定期更新 心跳(续约)：提供者定期通过http方式向Eureka刷新自己的状态 6.3.入门案例6.3.1.编写注册中心EurekaServer接下来我们创建一个项目，启动一个EurekaServer： 依然使用spring提供的快速搭建工具： 选择依赖： 完整的Pom文件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.demo&lt;/groupId&gt; &lt;artifactId&gt;eureka-demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;eureka-demo&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.1.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;!-- SpringCloud版本，是最新的F系列 --&gt; &lt;spring-cloud.version&gt;Finchley.RC1&lt;/spring-cloud.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- Eureka服务端 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- SpringCloud依赖，一定要放到dependencyManagement中，起到管理版本的作用即可 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;spring-milestones&lt;/id&gt; &lt;name&gt;Spring Milestones&lt;/name&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt; &lt;/repositories&gt;&lt;/project&gt; 编写启动类： 12345678@SpringBootApplication@EnableEurekaServer // 声明这个应用是一个EurekaServerpublic class EurekaDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaDemoApplication.class, args); &#125;&#125; 编写配置： 1234567891011server: port: 10086 # 端口spring: application: name: eureka-server # 应用名称，会在Eureka中显示eureka: client: register-with-eureka: false # 是否注册自己的信息到EurekaServer，默认是true fetch-registry: false # 是否拉取其它服务的信息，默认是true service-url: # EurekaServer的地址，现在是自己的地址，如果是集群，需要加上其它Server的地址。 defaultZone: http://127.0.0.1:$&#123;server.port&#125;/eureka 启动服务，并访问：http://127.0.0.1:10086/eureka 6.3.2.将服务提供者（user-service）注册到Eureka注册服务，就是在服务上添加Eureka的客户端依赖，客户端代码会自动把服务注册到EurekaServer中。 我们在user-service中添加Eureka客户端依赖： 先添加SpringCloud依赖： 1234567891011121314151617181920212223&lt;!-- SpringCloud的依赖 --&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Finchley.RC1&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt;&lt;!-- Spring的仓库地址 --&gt;&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;spring-milestones&lt;/id&gt; &lt;name&gt;Spring Milestones&lt;/name&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt;&lt;/repositories&gt; 然后是Eureka客户端： 12345&lt;!-- Eureka客户端 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt; 在启动类上开启Eureka客户端功能 通过添加@EnableDiscoveryClient来开启Eureka客户端功能 1234567@SpringBootApplication@EnableDiscoveryClient // 开启EurekaClient功能public class UserServiceDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(UserServiceDemoApplication.class, args); &#125;&#125; 编写配置 12345678910111213141516171819202122server: port: 8081spring: datasource: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://localhost:3306/leyou-test?serverTimezone=Asia/Shanghai&amp;characterEncoding=utf8 username: root password: cxg200888 hikari: maximum-pool-size: 20 minimum-idle: 10 application: name: user-service # 应用名称mybatis: type-aliases-package: com.itcast.cn.userservice.pojoeureka: client: service-url: # EurekaServer地址 defaultZone: http://127.0.0.1:10086/eureka instance: prefer-ip-address: true # 当调用getHostname获取实例的hostname时，返回ip而不是host名称 ip-address: 127.0.0.1 # 指定自己的ip信息，不指定的话会自己寻找 注意： 这里我们添加了spring.application.name属性来指定应用名称，将来会作为应用的id使用。 不用指定register-with-eureka和fetch-registry，因为默认是true 重启项目，访问Eureka监控页面查看 我们发现user-service服务已经注册成功了 6.3.3.消费者（consumer-demo）从Eureka获取服务接下来我们修改consumer-demo，尝试从EurekaServer获取服务。 方法与消费者类似，只需要在项目中添加EurekaClient依赖，就可以通过服务名称来获取信息了！ 1）添加依赖： 先添加SpringCloud依赖： 1234567891011121314151617181920212223&lt;!-- SpringCloud的依赖 --&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Finchley.RC1&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt;&lt;!-- Spring的仓库地址 --&gt;&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;spring-milestones&lt;/id&gt; &lt;name&gt;Spring Milestones&lt;/name&gt; &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt;&lt;/repositories&gt; 然后是Eureka客户端： 12345&lt;!-- Eureka客户端 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt; 2）在启动类开启Eureka客户端 1234567891011@SpringBootApplication@EnableDiscoveryClient // 开启Eureka客户端public class UserConsumerDemoApplication &#123; @Bean public RestTemplate restTemplate() &#123; return new RestTemplate(new OkHttp3ClientHttpRequestFactory()); &#125; public static void main(String[] args) &#123; SpringApplication.run(UserConsumerDemoApplication.class, args); &#125;&#125; 3）修改配置： 123456789101112server: port: 8080spring: application: name: consumer # 应用名称eureka: client: service-url: # EurekaServer地址 defaultZone: http://127.0.0.1:10086/eureka instance: prefer-ip-address: true # 当其它服务获取地址时提供ip而不是hostname ip-address: 127.0.0.1 # 指定自己的ip信息，不指定的话会自己寻找 4）修改代码，用DiscoveryClient类的方法，根据服务名称，获取服务实例： 12345678910111213141516171819202122232425262728293031@Servicepublic class UserService &#123; @Autowired private RestTemplate restTemplate; @Autowired private DiscoveryClient discoveryClient;// Eureka客户端，可以获取到服务实例信息 public List&lt;User&gt; queryUserByIds(List&lt;Long&gt; ids) &#123; List&lt;User&gt; users = new ArrayList&lt;&gt;(); // String baseUrl = "http://localhost:8081/user/"; // 根据服务名称，获取服务实例 List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances("user-service"); // 因为只有一个UserService,因此我们直接get(0)获取 ServiceInstance instance = instances.get(0); // 获取ip和端口信息 String baseUrl = "http://"+instance.getHost() + ":" + instance.getPort()+"/user/"; ids.forEach(id -&gt; &#123; // 我们测试多次查询， users.add(this.restTemplate.getForObject(baseUrl + id, User.class)); // 每次间隔500毫秒 try &#123; Thread.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;); return users; &#125;&#125; 5）Debug跟踪运行： 生成的URL： 访问结果： 6.4.Eureka详解接下来我们详细讲解Eureka的原理及配置。 6.4.1.基础架构Eureka架构中的三个核心角色： 服务注册中心 Eureka的服务端应用，提供服务注册和发现功能，就是刚刚我们建立的eureka-demo 服务提供者 提供服务的应用，可以是SpringBoot应用，也可以是其它任意技术实现，只要对外提供的是Rest风格服务即可。本例中就是我们实现的user-service-demo 服务消费者 消费应用从注册中心获取服务列表，从而得知每个服务方的信息，知道去哪里调用服务方。本例中就是我们实现的consumer-demo 6.4.2.高可用的Eureka ServerEureka Server即服务的注册中心，在刚才的案例中，我们只有一个EurekaServer，事实上EurekaServer也可以是一个集群，形成高可用的Eureka中心。 服务同步 多个Eureka Server之间也会互相注册为服务，当服务提供者注册到Eureka Server集群中的某个节点时，该节点会把服务的信息同步给集群中的每个节点，从而实现数据同步。因此，无论客户端访问到Eureka Server集群中的任意一个节点，都可以获取到完整的服务列表信息。 动手搭建高可用的EurekaServer 我们假设要搭建两条EurekaServer的集群，端口分别为：10086和10087 1）我们修改原来的EurekaServer配置： 123456789server: port: 10086 # 端口spring: application: name: eureka-server # 应用名称，会在Eureka中显示eureka: client: service-url: # 配置其他Eureka服务的地址，而不是自己，比如10087 defaultZone: http://127.0.0.1:10087/eureka 所谓的高可用注册中心，其实就是把EurekaServer自己也作为一个服务进行注册，这样多个EurekaServer之间就能互相发现对方，从而形成集群。因此我们做了以下修改： 删除了register-with-eureka=false和fetch-registry=false两个配置。因为默认值是true，这样就会吧自己注册到注册中心了。 把service-url的值改成了另外一台EurekaServer的地址，而不是自己 2）另外一台配置恰好相反： 123456789server: port: 10087 # 端口spring: application: name: eureka-server # 应用名称，会在Eureka中显示eureka: client: service-url: # 配置其他Eureka服务的地址，而不是自己，比如10087 defaultZone: http://127.0.0.1:10086/eureka 注意：idea中一个应用不能启动两次，我们需要重新配置一个启动器： 然后启动即可。 3）启动测试： 4）客户端注册服务到集群 因为EurekaServer不止一个，因此注册服务的时候，service-url参数需要变化： 1234eureka: client: service-url: # EurekaServer地址,多个地址以','隔开 defaultZone: http://127.0.0.1:10086/eureka, 6.4.3.服务提供者服务提供者要向EurekaServer注册服务，并且完成服务续约等工作。 服务注册 服务提供者在启动时，会检测配置属性中的：eureka.client.register-with-erueka=true参数是否正确，事实上默认就是true。如果值确实为true，则会向EurekaServer发起一个Rest请求，并携带自己的元数据信息，Eureka Server会把这些信息保存到一个双层Map结构中。第一层Map的Key就是服务名称，第二层Map的key是服务的实例id。 服务续约 在注册服务完成以后，服务提供者会维持一个心跳（定时向EurekaServer发起Rest请求），告诉EurekaServer：“我还活着”。这个我们称为服务的续约（renew）； 有两个重要参数可以修改服务续约的行为： 1234eureka: instance: lease-expiration-duration-in-seconds: 90 lease-renewal-interval-in-seconds: 30 lease-renewal-interval-in-seconds：服务续约(renew)的间隔，默认为30秒 lease-expiration-duration-in-seconds：服务失效时间，默认值90秒 也就是说，默认情况下每个30秒服务会向注册中心发送一次心跳，证明自己还活着。如果超过90秒没有发送心跳，EurekaServer就会认为该服务宕机，会从服务列表中移除，这两个值在生产环境不要修改，默认即可。 但是在开发时，这个值有点太长了，经常我们关掉一个服务，会发现Eureka依然认为服务在活着。所以我们在开发阶段可以适当调小。 1234eureka: instance: lease-expiration-duration-in-seconds: 10 # 10秒即过期 lease-renewal-interval-in-seconds: 5 # 5秒一次心跳 实例id 先来看一下服务状态信息： 在Eureka监控页面，查看服务注册信息： 在status一列中，显示以下信息： UP(1)：代表现在是启动了1个示例，没有集群 DESKTOP-2MVEC12:user-service:8081：是示例的名称（instance-id）， 默认格式是：${hostname} + ${spring.application.name} + ${server.port} instance-id是区分同一服务的不同实例的唯一标准，因此不能重复。 我们可以通过instance-id属性来修改它的构成： 123eureka: instance: instance-id: $&#123;spring.application.name&#125;:$&#123;server.port&#125; 重启服务再试试看： 6.4.4.服务消费者 获取服务列表 当服务消费者启动是，会检测eureka.client.fetch-registry=true参数的值，如果为true，则会从Eureka Server服务的列表只读备份，然后缓存在本地。并且每隔30秒会重新获取并更新数据。我们可以通过下面的参数来修改： 123eureka: client: registry-fetch-interval-seconds: 5 生产环境中，我们不需要修改这个值。 但是为了开发环境下，能够快速得到服务的最新状态，我们可以将其设置小一点。 6.4.5.失效剔除和自我保护修改eureka-demo配置文件 失效剔除 有些时候，我们的服务提供方并不一定会正常下线，可能因为内存溢出、网络故障等原因导致服务无法正常工作。Eureka Server需要将这样的服务剔除出服务列表。因此它会开启一个定时任务，每隔60秒对所有失效的服务（超过90秒未响应）进行剔除。 可以通过eureka.server.eviction-interval-timer-in-ms参数对其进行修改，单位是毫秒，生成环境不要修改。 这个会对我们开发带来极大的不变，你对服务重启，隔了60秒Eureka才反应过来。开发阶段可以适当调整，比如10S 自我保护 我们关停一个服务，就会在Eureka面板看到一条警告： 这是触发了Eureka的自我保护机制。当一个服务未按时进行心跳续约时，Eureka会统计最近15分钟心跳失败的服务实例的比例是否超过了85%。在生产环境下，因为网络延迟等原因，心跳失败实例的比例很有可能超标，但是此时就把服务剔除列表并不妥当，因为服务可能没有宕机。Eureka就会把当前实例的注册信息保护起来，不予剔除。生产环境下这很有效，保证了大多数服务依然可用。 但是这给我们的开发带来了麻烦， 因此开发阶段我们都会关闭自我保护模式： 1234eureka: server: enable-self-preservation: false # 关闭自我保护模式（缺省为打开） eviction-interval-timer-in-ms: 1000 # 扫描失效服务的间隔时间（缺省为60*1000ms） 7.负载均衡Ribbon在刚才的案例中，我们启动了一个user-service，然后通过DiscoveryClient来获取服务实例信息，然后获取ip和端口来访问。 但是实际环境中，我们往往会开启很多个user-service的集群。此时我们获取的服务列表中就会有多个，到底该访问哪一个呢？ 一般这种情况下我们就需要编写负载均衡算法，在多个实例列表中进行选择。 不过Eureka中已经帮我们集成了负载均衡组件：Ribbon，简单修改代码即可使用。 什么是Ribbon： 接下来，我们就来使用Ribbon实现负载均衡。 7.1.启动两个服务实例首先我们启动两个user-service实例，一个8081，一个8082。 Eureka监控面板： 7.2.开启负载均衡修改项目：consumer-demo 因为Eureka中已经集成了Ribbon，所以我们无需引入新的依赖。直接修改代码： 在RestTemplate的配置方法上添加@LoadBalanced注解： 12345@Bean@LoadBalancedpublic RestTemplate restTemplate() &#123; return new RestTemplate(new OkHttp3ClientHttpRequestFactory());&#125; 修改调用方式，不再手动获取ip和端口，而是直接通过服务名称调用： 1234567891011121314151617181920212223242526@Servicepublic class UserService &#123; @Autowired private RestTemplate restTemplate; @Autowired private DiscoveryClient discoveryClient; public List&lt;User&gt; queryUserByIds(List&lt;Long&gt; ids) &#123; List&lt;User&gt; users = new ArrayList&lt;&gt;(); // 地址直接写服务名称即可 String baseUrl = "http://user-service/user/"; ids.forEach(id -&gt; &#123; // 我们测试多次查询， users.add(this.restTemplate.getForObject(baseUrl + id, User.class)); // 每次间隔500毫秒 try &#123; Thread.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;); return users; &#125;&#125; 访问页面，查看结果： 完美！ 7.3.源码跟踪为什么我们只输入了service名称就可以访问了呢？之前还要获取ip和端口。 显然有人帮我们根据service名称，获取到了服务实例的ip和端口。它就是LoadBalancerInterceptor 我们进行源码跟踪： 继续跟入execute方法：发现获取了8082端口的服务 再跟下一次，发现获取的是8081： 7.4.负载均衡策略Ribbon默认的负载均衡策略是简单的轮询，我们可以测试一下： 编写测试类，在刚才的源码中我们看到拦截中是使用RibbonLoadBalanceClient来进行负载均衡的，其中有一个choose方法，是这样介绍的： 现在这个就是负载均衡获取实例的方法。 我们对注入这个类的对象，然后对其测试： 123456789101112131415@RunWith(SpringRunner.class)@SpringBootTest(classes = UserConsumerDemoApplication.class)public class LoadBalanceTest &#123; @Autowired RibbonLoadBalancerClient client; @Test public void test()&#123; for (int i = 0; i &lt; 100; i++) &#123; ServiceInstance instance = this.client.choose("user-service"); System.out.println(instance.getHost() + ":" + instance.getPort()); &#125; &#125;&#125; 结果： 符合了我们的预期推测，确实是轮询方式。 我们是否可以修改负载均衡的策略呢？ 继续跟踪源码，发现这么一段代码： 我们看看这个rule是谁： 这里的rule默认值是一个RoundRobinRule，看类的介绍： 这不就是轮询的意思嘛。 我们注意到，这个类其实是实现了接口IRule的，查看一下： 定义负载均衡的规则接口。 它有以下实现： SpringBoot也帮我们提供了修改负载均衡规则的配置入口： 在服务消费者中添加如下： 123user-service: ribbon: NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule 格式是：{服务名称}.ribbon.NFLoadBalancerRuleClassName，值就是IRule的实现类。 再次测试，发现结果变成了随机： 7.5.重试机制Eureka的服务治理强调了CAP原则中的AP，即可用性和可靠性。它与Zookeeper这一类强调CP（一致性，可靠性）的服务治理框架最大的区别在于：Eureka为了实现更高的服务可用性，牺牲了一定的一致性，极端情况下它宁愿接收故障实例也不愿丢掉健康实例，正如我们上面所说的自我保护机制。 但是，此时如果我们调用了这些不正常的服务，调用就会失败，从而导致其它服务不能正常工作！这显然不是我们愿意看到的。 我们现在关闭一个user-service实例： 因为服务剔除的延迟，consumer并不会立即得到最新的服务列表，此时再次访问你会得到错误提示： 但是此时，8081服务其实是正常的。 因此Spring Cloud 整合了Spring Retry 来增强RestTemplate的重试能力，当一次服务调用失败后，不会立即抛出一次，而是再次重试另一个服务。 只需要简单配置即可实现Ribbon的重试： 消费者的配置文件： 123456789101112spring: cloud: loadbalancer: retry: enabled: true # 开启Spring Cloud的重试功能user-service: ribbon: ConnectTimeout: 250 # Ribbon的连接超时时间 单位ms ReadTimeout: 1000 # Ribbon的数据读取超时时间 OkToRetryOnAllOperations: true # 是否对所有操作都进行重试 MaxAutoRetriesNextServer: 1 # 切换实例的重试次数 MaxAutoRetries: 1 # 对当前实例的重试次数 根据如上配置，当访问到某个服务超时后，它会再次尝试访问下一个服务实例，如果不行就再换一个实例，如果不行，则返回失败。切换次数取决于MaxAutoRetriesNextServer参数的值 引入spring-retry依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.retry&lt;/groupId&gt; &lt;artifactId&gt;spring-retry&lt;/artifactId&gt;&lt;/dependency&gt; 我们重启user-consumer-demo，测试，发现即使user-service2宕机，也能通过另一台服务实例获取到结果！]]></content>
      <categories>
        <category>项目实战-微服务商城</category>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
        <tag>系统架构演变</tag>
        <tag>Eureka</tag>
        <tag>Ribbon</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务商城（一）——SpringBoot学习笔记]]></title>
    <url>%2Fday01-springboot.html</url>
    <content type="text"><![CDATA[0.学习目标 了解SpringBoot的作用 掌握java配置的方式 了解SpringBoot自动配置原理 掌握SpringBoot的基本使用 了解Thymeleaf的基本使用 1. 了解SpringBoot在这一部分，我们主要了解以下3个问题： 什么是SpringBoot 为什么要学习SpringBoot SpringBoot的特点 1.1.什么是SpringBootSpringBoot是Spring项目中的一个子工程，与我们所熟知的Spring-framework 同属于spring的产品: 我们可以看到下面的一段介绍： Takes an opinionated view of building production-ready Spring applications. Spring Boot favors convention over configuration and is designed to get you up and running as quickly as possible. 翻译一下： 用一些固定的方式来构建生产级别的spring应用。Spring Boot 推崇约定大于配置的方式以便于你能够尽可能快速的启动并运行程序。 其实人们把Spring Boot 称为搭建程序的脚手架。其最主要作用就是帮我们快速的构建庞大的spring项目，并且尽可能的减少一切xml配置，做到开箱即用，迅速上手，让我们关注与业务而非配置。 1.2.为什么要学习SpringBootjava一直被人诟病的一点就是臃肿、麻烦。当我们还在辛苦的搭建项目时，可能Python程序员已经把功能写好了，究其原因注意是两点： 复杂的配置， 项目各种配置其实是开发时的损耗， 因为在思考 Spring 特性配置和解决业务问题之间需要进行思维切换，所以写配置挤占了写应用程序逻辑的时间。 一个是混乱的依赖管理。 项目的依赖管理也是件吃力不讨好的事情。决定项目里要用哪些库就已经够让人头痛的了，你还要知道这些库的哪个版本和其他库不会有冲突，这难题实在太棘手。并且，依赖管理也是一种损耗，添加依赖不是写应用程序代码。一旦选错了依赖的版本，随之而来的不兼容问题毫无疑问会是生产力杀手。 而SpringBoot让这一切成为过去！ Spring Boot 简化了基于Spring的应用开发，只需要“run”就能创建一个独立的、生产级别的Spring应用。Spring Boot为Spring平台及第三方库提供开箱即用的设置（提供默认设置，存放默认配置的包就是启动器），这样我们就可以简单的开始。多数Spring Boot应用只需要很少的Spring配置。 我们可以使用SpringBoot创建java应用，并使用java –jar 启动它，就能得到一个生产级别的web工程。 1.3.SpringBoot的特点Spring Boot 主要目标是： 为所有 Spring 的开发者提供一个非常快速的、广泛接受的入门体验 开箱即用（启动器starter-其实就是SpringBoot提供的一个jar包），但通过自己设置参数（.properties），即可快速摆脱这种方式。 提供了一些大型项目中常见的非功能性特性，如内嵌服务器、安全、指标，健康检测、外部化配置等 绝对没有代码生成，也无需 XML 配置。 更多细节，大家可以到官网查看。 2.快速入门接下来，我们就来利用SpringBoot搭建一个web工程，体会一下SpringBoot的魅力所在！ 2.1.创建工程我们先新建一个空的工程： 工程名为demo： 新建一个model： 使用maven来构建： 然后填写项目坐标： 目录结构： 项目结构： 2.2.添加依赖看到这里很多同学会有疑惑，前面说传统开发的问题之一就是依赖管理混乱，怎么这里我们还需要管理依赖呢？难道SpringBoot不帮我们管理吗？ 别着急，现在我们的项目与SpringBoot还没有什么关联。SpringBoot提供了一个名为spring-boot-starter-parent的工程，里面已经对各种常用依赖（并非全部）的版本进行了管理，我们的项目需要以这个项目为父工程，这样我们就不用操心依赖的版本问题了，需要什么依赖，直接引入坐标即可！ 2.2.1.添加父工程坐标12345&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.0.RELEASE&lt;/version&gt;&lt;/parent&gt; 2.2.2.添加web启动器为了让SpringBoot帮我们完成各种自动配置，我们必须引入SpringBoot提供的自动配置依赖，我们称为启动器。因为我们是web项目，这里我们引入web启动器： 123456&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 需要注意的是，我们并没有在这里指定版本信息。因为SpringBoot的父工程已经对版本进行了管理了。 这个时候，我们会发现项目中多出了大量的依赖： 这些都是SpringBoot根据spring-boot-starter-web这个依赖自动引入的，而且所有的版本都已经管理好，不会出现冲突。 2.2.3.管理jdk版本默认情况下，maven工程的jdk版本是1.5，而我们开发使用的是1.8，因此这里我们需要修改jdk版本，只需要简单的添加以下属性即可： 123&lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt;&lt;/properties&gt; 2.2.4.完整pom123456789101112131415161718192021222324252627&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.leyou.demo&lt;/groupId&gt; &lt;artifactId&gt;springboot-demo&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.0.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 2.3.启动类Spring Boot项目通过main函数即可启动，我们需要创建一个启动类： 然后编写main函数： 123456@SpringBootApplicationpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125;&#125; 2.4.编写controller接下来，我们就可以像以前那样开发SpringMVC的项目了！ 我们编写一个controller： 代码： 12345678@RestControllerpublic class HelloController &#123; @GetMapping("hello") public String hello()&#123; return "hello, spring boot!"; &#125;&#125; 2.5.启动测试接下来，我们运行main函数，查看控制台： 并且可以看到监听的端口信息： 1）监听的端口是8080 2）SpringMVC的映射路径是：/ 3）/hello路径已经映射到了HelloController中的hello()方法 打开页面访问：http://localhost:8080/hello 测试成功了！ 3.Java配置在入门案例中，我们没有任何的配置，就可以实现一个SpringMVC的项目了，快速、高效！ 但是有同学会有疑问，如果没有任何的xml，那么我们如果要配置一个Bean该怎么办？比如我们要配置一个数据库连接池，以前会这么玩： 1234567&lt;!-- 配置连接池 --&gt;&lt;bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource" init-method="init" destroy-method="close"&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;" /&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;" /&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;" /&gt;&lt;/bean&gt; 现在该怎么做呢？ 3.1.回顾历史事实上，在Spring3.0开始，Spring官方就已经开始推荐使用java配置来代替传统的xml配置了，我们不妨来回顾一下Spring的历史： Spring1.0时代 在此时因为jdk1.5刚刚出来，注解开发并未盛行，因此一切Spring配置都是xml格式，想象一下所有的bean都用xml配置，细思极恐啊，心疼那个时候的程序员2秒 Spring2.0时代 Spring引入了注解开发，但是因为并不完善，因此并未完全替代xml，此时的程序员往往是把xml与注解进行结合，貌似我们之前都是这种方式。 Spring3.0及以后 3.0以后Spring的注解已经非常完善了，因此Spring推荐大家使用完全的java配置来代替以前的xml，不过似乎在国内并未推广盛行。然后当SpringBoot来临，人们才慢慢认识到java配置的优雅。 有句古话说的好：拥抱变化，拥抱未来。所以我们也应该顺应时代潮流，做时尚的弄潮儿，一起来学习下java配置的玩法。 3.2.尝试java配置java配置主要靠java类和一些注解，比较常用的注解有： @Configuration：声明一个类作为配置类，代替xml文件 @Bean：声明在方法上，将方法的返回值加入Bean容器，代替&lt;bean&gt;标签 @value：属性注入 @PropertySource：指定外部属性文件， 我们接下来用java配置来尝试实现连接池配置： 首先引入Druid连接池依赖： 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.6&lt;/version&gt;&lt;/dependency&gt; 创建一个jdbc.properties文件，编写jdbc属性： 1234jdbc.driverClassName=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://127.0.0.1:3306/leyoujdbc.username=rootjdbc.password=123 然后编写代码： 1234567891011121314151617181920212223@Configuration@PropertySource("classpath:jdbc.properties")public class JdbcConfig &#123; @Value("$&#123;jdbc.url&#125;") String url; @Value("$&#123;jdbc.driverClassName&#125;") String driverClassName; @Value("$&#123;jdbc.username&#125;") String username; @Value("$&#123;jdbc.password&#125;") String password; @Bean public DataSource dataSource() &#123; DruidDataSource dataSource = new DruidDataSource(); dataSource.setUrl(url); dataSource.setDriverClassName(driverClassName); dataSource.setUsername(username); dataSource.setPassword(password); return dataSource; &#125;&#125; 解读： @Configuration：声明我们JdbcConfig是一个配置类 @PropertySource：指定属性文件的路径是:classpath:jdbc.properties 通过@Value为属性注入值 通过@Bean将 dataSource()方法声明为一个注册Bean的方法，Spring会自动调用该方法，将方法的返回值加入Spring容器中。 然后我们就可以在任意位置通过@Autowired注入DataSource了！ 我们在HelloController中测试： 1234567891011@RestControllerpublic class HelloController &#123; @Autowired private DataSource dataSource; @GetMapping("hello") public String hello() &#123; return "hello, spring boot!" + dataSource; &#125;&#125; 然后Debug运行并查看： 属性注入成功了！ 3.3.SpringBoot的属性注入在上面的案例中，我们实验了java配置方式。不过属性注入使用的是@Value注解。这种方式虽然可行，但是不够强大，因为它只能注入基本类型值。 在SpringBoot中，提供了一种新的属性注入方式，支持各种java基本数据类型及复杂类型的注入。 1）我们新建一个类，用来进行属性注入： 123456789@ConfigurationProperties(prefix = "jdbc")public class JdbcProperties &#123; private String url; private String driverClassName; private String username; private String password; // ... 略 // getters 和 setters&#125; 在类上通过@ConfigurationProperties注解声明当前类为属性读取类 prefix=&quot;jdbc&quot;读取属性文件中，前缀为jdbc的值。 在类上定义各个属性，名称必须与属性文件中jdbc.后面部分一致 需要注意的是，这里我们并没有指定属性文件的地址，所以我们需要把jdbc.properties名称改为application.properties，这是SpringBoot默认读取的属性文件名： 2）在JdbcConfig中使用这个属性： 1234567891011121314@Configuration@EnableConfigurationProperties(JdbcProperties.class)public class JdbcConfig &#123; @Bean public DataSource dataSource(JdbcProperties jdbc) &#123; DruidDataSource dataSource = new DruidDataSource(); dataSource.setUrl(jdbc.getUrl()); dataSource.setDriverClassName(jdbc.getDriverClassName()); dataSource.setUsername(jdbc.getUsername()); dataSource.setPassword(jdbc.getPassword()); return dataSource; &#125;&#125; 通过@EnableConfigurationProperties(JdbcProperties.class)来声明要使用JdbcProperties这个类的对象 然后你可以通过以下方式注入JdbcProperties： @Autowired注入 12@Autowiredprivate JdbcProperties prop; 构造函数注入 1234private JdbcProperties prop;public JdbcConfig(Jdbcproperties prop)&#123; this.prop = prop;&#125; 声明有@Bean的方法参数注入 1234@Beanpublic Datasource dataSource(JdbcProperties prop)&#123; // ...&#125; 本例中，我们采用第三种方式。 3）测试结果： 大家会觉得这种方式似乎更麻烦了，事实上这种方式有更强大的功能，也是SpringBoot推荐的注入方式。两者对比关系： 优势： Relaxed binding：松散绑定 不严格要求属性文件中的属性名与成员变量名一致。支持驼峰，中划线，下划线等等转换，甚至支持对象引导。比如：user.friend.name：代表的是user对象中的friend属性中的name属性，显然friend也是对象。@value注解就难以完成这样的注入方式。 meta-data support：元数据支持，帮助IDE生成属性提示（写开源框架会用到）。 ​ 3.4、更优雅的注入事实上，如果一段属性只有一个Bean需要使用，我们无需将其注入到一个类（JdbcProperties）中。而是直接在需要的地方声明即可： 1234567891011@Configurationpublic class JdbcConfig &#123; @Bean // 声明要注入的属性前缀，SpringBoot会自动把相关属性通过set方法注入到DataSource中 @ConfigurationProperties(prefix = "jdbc") public DataSource dataSource() &#123; DruidDataSource dataSource = new DruidDataSource(); return dataSource; &#125;&#125; 我们直接把@ConfigurationProperties(prefix = &quot;jdbc&quot;)声明在需要使用的@Bean的方法上，然后SpringBoot就会自动调用这个Bean（此处是DataSource）的set方法，然后完成注入。使用的前提是：该类必须有对应属性的set方法！ 我们将jdbc的url改成：/heima，再次测试： 4.自动配置原理使用SpringBoot之后，一个整合了SpringMVC的WEB工程开发，变的无比简单，那些繁杂的配置都消失不见了，这是如何做到的？ 一切魔力的开始，都是从我们的main函数来的，所以我们再次来看下启动类： 我们发现特别的地方有两个： 注解：@SpringBootApplication run方法：SpringApplication.run() 我们分别来研究这两个部分。 4.1.了解@SpringBootApplication点击进入，查看源码： 这里重点的注解有3个： @SpringBootConfiguration @EnableAutoConfiguration @ComponentScan 4.1.1.@SpringBootConfiguration我们继续点击查看源码： 通过这段我们可以看出，在这个注解上面，又有一个@Configuration注解。通过上面的注释阅读我们知道：这个注解的作用就是声明当前类是一个配置类，然后Spring会自动扫描到添加了@Configuration的类，并且读取其中的配置信息。而@SpringBootConfiguration是来声明当前类是SpringBoot应用的配置类，项目中只能有一个。所以一般我们无需自己添加。 4.1.2.@EnableAutoConfiguration关于这个注解，官网上有一段说明： The second class-level annotation is @EnableAutoConfiguration. This annotationtells Spring Boot to “guess” how you want to configure Spring, based on the jardependencies that you have added. Since spring-boot-starter-web added Tomcatand Spring MVC, the auto-configuration assumes that you are developing a webapplication and sets up Spring accordingly. 简单翻译以下： 第二级的注解@EnableAutoConfiguration，告诉SpringBoot基于你所添加的依赖，去“猜测”你想要如何配置Spring。比如我们引入了spring-boot-starter-web，而这个启动器中帮我们添加了tomcat、SpringMVC的依赖。此时自动配置就知道你是要开发一个web应用，所以就帮你完成了web及SpringMVC的默认配置了！ 总结，SpringBoot内部对大量的第三方库或Spring内部库进行了默认配置，这些配置是否生效，取决于我们是否引入了对应库所需的依赖，如果有那么默认配置就会生效。 所以，我们使用SpringBoot构建一个项目，只需要引入所需框架的依赖，配置就可以交给SpringBoot处理了。除非你不希望使用SpringBoot的默认配置，它也提供了自定义配置的入口。 4.1.3.@ComponentScan我们跟进源码： 并没有看到什么特殊的地方。我们查看注释： 大概的意思： 配置组件扫描的指令。提供了类似与&lt;context:component-scan&gt;标签的作用 通过basePackageClasses或者basePackages属性来指定要扫描的包。如果没有指定这些属性，那么将从声明这个注解的类所在的包开始，扫描包及子包 而我们的@SpringBootApplication注解声明的类就是main函数所在的启动类，因此扫描的包是该类所在包及其子包。因此，一般启动类会放在一个比较前的包目录中。 4.2.默认配置原理4.2.1默认配置类通过刚才的学习，我们知道@EnableAutoConfiguration会开启SpringBoot的自动配置，并且根据你引入的依赖来生效对应的默认配置。那么问题来了： 这些默认配置是在哪里定义的呢？ 为何依赖引入就会触发配置呢？ 其实在我们的项目中，已经引入了一个依赖：spring-boot-autoconfigure，其中定义了大量自动配置类： 还有： 非常多，几乎涵盖了现在主流的开源框架，例如： redis jms amqp jdbc jackson mongodb jpa solr elasticsearch … 等等 我们来看一个我们熟悉的，例如SpringMVC，查看mvc 的自动配置类： 打开WebMvcAutoConfiguration： 我们看到这个类上的4个注解： @Configuration：声明这个类是一个配置类 @ConditionalOnWebApplication(type = Type.SERVLET) ConditionalOn，翻译就是在某个条件下，此处就是满足项目的类是是Type.SERVLET类型，也就是一个普通web工程，显然我们就是 @ConditionalOnClass({ Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class }) 这里的条件是OnClass，也就是满足以下类存在：Servlet、DispatcherServlet、WebMvcConfigurer，其中Servlet只要引入了tomcat依赖自然会有，后两个需要引入SpringMVC才会有。这里就是判断你是否引入了相关依赖，引入依赖后该条件成立，当前类的配置才会生效！ @ConditionalOnMissingBean(WebMvcConfigurationSupport.class) 这个条件与上面不同，OnMissingBean，是说环境中没有指定的Bean这个才生效。其实这就是自定义配置的入口，也就是说，如果我们自己配置了一个WebMVCConfigurationSupport的类，那么这个默认配置就会失效！ 接着，我们查看该类中定义了什么： 视图解析器： 处理器适配器（HandlerAdapter）： 还有很多，这里就不一一截图了。 4.2.2.默认配置属性另外，这些默认配置的属性来自哪里呢？ 我们看到，这里通过@EnableAutoConfiguration注解引入了两个属性：WebMvcProperties和ResourceProperties。这不正是SpringBoot的属性注入玩法嘛。 我们查看这两个属性类： 找到了内部资源视图解析器的prefix和suffix属性。 ResourceProperties中主要定义了静态资源（.js,.html,.css等)的路径： 如果我们要覆盖这些默认属性，只需要在application.properties中定义与其前缀prefix和字段名一致的属性即可。 4.3.总结SpringBoot为我们提供了默认配置，而默认配置生效的条件一般有两个： 你引入了相关依赖 你自己没有配置 1）启动器 所以，我们如果不想配置，只需要引入依赖即可，而依赖版本我们也不用操心，因为只要引入了SpringBoot提供的stater（启动器），就会自动管理依赖及版本了。 因此，玩SpringBoot的第一件事情，就是找启动器，SpringBoot提供了大量的默认启动器，参考课前资料中提供的《SpringBoot启动器.txt》 2）全局配置 另外，SpringBoot的默认配置，都会读取默认属性，而这些属性可以通过自定义application.properties文件来进行覆盖。这样虽然使用的还是默认配置，但是配置中的值改成了我们自定义的。 因此，玩SpringBoot的第二件事情，就是通过application.properties来覆盖默认属性值，形成自定义配置。我们需要知道SpringBoot的默认属性key，非常多，参考课前资料提供的：《SpringBoot全局属性.md》 属性配置文件通过application.properties和application.yml 12345678spring: datasource:# 数据源基本配置 username: root password: 123456 driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://192.168.1.103:3306/jdbc type: com.alibaba.druid.pool.DruidDataSource 5.SpringBoot实践接下来，我们来看看如何用SpringBoot来玩转以前的SSM,我们沿用之前讲解SSM用到的数据库tb_user和实体类User 安装插件lombok 要使用lombok必须每个工程都导入架包 123456&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.4&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; lombok使代码更简洁 @Data：在pojo中使用可以省略get和set方法 @Log(这是一个泛型注解，具体有很多种形式) @Slf4j：提供日志注解 5.1.整合SpringMVC虽然默认配置已经可以使用SpringMVC了，不过我们有时候需要进行自定义配置。 日志级别控制 123456logging: level: # org.springframework:spring本身 org.springframework: debug # 我们的包:com.cxg.demo com.cxg.demo: debug 5.1.1.修改端口查看SpringBoot的全局属性可知，端口通过以下方式配置： 12# 映射端口server.port=80 重启服务后测试： 5.1.2.访问静态资源现在，我们的项目是一个jar工程，那么就没有webapp，我们的静态资源该放哪里呢？ 回顾我们上面看的源码，有一个叫做ResourceProperties的类，里面就定义了静态资源的默认查找路径： 默认的静态资源路径为： classpath:/META-INF/resources/ classpath:/resources/ classpath:/static/ classpath:/public 只要静态资源放在这些目录中任何一个，SpringMVC都会帮我们处理。 我们习惯会把静态资源放在classpath:/static/目录下。我们创建目录，并且添加一些静态资源： 重启项目后测试： 5.1.3.添加拦截器拦截器也是我们经常需要使用的，在SpringBoot中该如何配置呢？ 拦截器不是一个普通属性，而是一个类，所以就要用到java配置方式了。在SpringBoot官方文档中有这么一段说明： If you want to keep Spring Boot MVC features and you want to add additional MVC configuration (interceptors, formatters, view controllers, and other features), you can add your own @Configuration class of type WebMvcConfigurer but without @EnableWebMvc. If you wish to provide custom instances of RequestMappingHandlerMapping, RequestMappingHandlerAdapter, or ExceptionHandlerExceptionResolver, you can declare a WebMvcRegistrationsAdapter instance to provide such components. If you want to take complete control of Spring MVC, you can add your own @Configuration annotated with @EnableWebMvc. 翻译： 如果你想要保持Spring Boot 的一些默认MVC特征，同时又想自定义一些MVC配置（包括：拦截器，格式化器, 视图控制器、消息转换器 等等），你应该让一个类实现WebMvcConfigurer，并且添加@Configuration注解，但是千万不要加@EnableWebMvc注解。如果你想要自定义HandlerMapping、HandlerAdapter、ExceptionResolver等组件，你可以创建一个WebMvcRegistrationsAdapter实例 来提供以上组件。 如果你想要完全自定义SpringMVC，不保留SpringBoot提供的一切特征，你可以自己定义类并且添加@Configuration注解和@EnableWebMvc注解 总结：通过实现WebMvcConfigurer并添加@Configuration注解来实现自定义部分SpringMvc配置。 首先我们定义一个拦截器： 12345678910111213141516171819public class LoginInterceptor implements HandlerInterceptor &#123; private Logger logger = LoggerFactory.getLogger(LoginInterceptor.class); @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) &#123; logger.debug("preHandle method is now running!"); return true; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) &#123; logger.debug("postHandle method is now running!"); &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) &#123; logger.debug("afterCompletion method is now running!"); &#125;&#125; 然后，我们定义配置类，注册拦截器： 123456789101112131415161718192021@Configurationpublic class MvcConfig implements WebMvcConfigurer&#123; /** * 通过@Bean注解，将我们定义的拦截器注册到Spring容器 * @return */ @Bean public LoginInterceptor loginInterceptor()&#123; return new LoginInterceptor(); &#125; /** * 重写接口中的addInterceptors方法，添加自定义拦截器 * @param registry */ @Override public void addInterceptors(InterceptorRegistry registry) &#123; // 通过registry来注册拦截器，通过addPathPatterns来添加拦截路径 registry.addInterceptor(this.loginInterceptor()).addPathPatterns("/**"); &#125;&#125; 结构如下： 接下来运行并查看日志： 你会发现日志中什么都没有，因为我们记录的log级别是debug，默认是显示info以上，我们需要进行配置。 SpringBoot通过logging.level.*=debug来配置日志级别，*填写包名 12# 设置com.leyou包的日志级别为debuglogging.level.com.leyou=debug 再次运行查看： 1232018-05-05 17:50:01.811 DEBUG 4548 --- [p-nio-80-exec-1] com.leyou.interceptor.LoginInterceptor : preHandle method is now running!2018-05-05 17:50:01.854 DEBUG 4548 --- [p-nio-80-exec-1] com.leyou.interceptor.LoginInterceptor : postHandle method is now running!2018-05-05 17:50:01.854 DEBUG 4548 --- [p-nio-80-exec-1] com.leyou.interceptor.LoginInterceptor : afterCompletion method is now running! 5.2.整合jdbc和事务spring中的jdbc连接和事务是配置中的重要一环，在SpringBoot中该如何处理呢？ 答案是不需要处理，我们只要找到SpringBoot提供的启动器即可： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt; 当然，不要忘了数据库驱动，SpringBoot并不知道我们用的什么数据库，这里我们选择MySQL： 1234&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt; 至于事务，SpringBoot中通过注解来控制。就是我们熟知的@Transactional 123456789101112131415@Servicepublic class UserService &#123; @Autowired private UserMapper userMapper; public User queryById(Long id)&#123; return this.userMapper.selectByPrimaryKey(id); &#125; @Transactional public void deleteById(Long id)&#123; this.userMapper.deleteByPrimaryKey(id); &#125;&#125; 5.3.整合连接池其实，在刚才引入jdbc启动器的时候，SpringBoot已经自动帮我们引入了一个连接池： HikariCP应该是目前速度最快的连接池了，我们看看它与c3p0的对比： 因此，我们只需要指定连接池参数即可： 12345678910# 连接四大参数spring.datasource.url=jdbc:mysql://localhost:3306/heimaspring.datasource.username=rootspring.datasource.password=123# 可省略，SpringBoot自动推断spring.datasource.driverClassName=com.mysql.jdbc.Driverspring.datasource.hikari.idle-timeout=60000spring.datasource.hikari.maximum-pool-size=30spring.datasource.hikari.minimum-idle=10 当然，如果你更喜欢Druid连接池，也可以使用Druid官方提供的启动器： 123456&lt;!-- Druid连接池 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.6&lt;/version&gt;&lt;/dependency&gt; 而连接信息的配置与上面是类似的，只不过在连接池特有属性上，方式略有不同： 12345678910#初始化连接数spring.datasource.druid.initial-size=1#最小空闲连接spring.datasource.druid.min-idle=1#最大活动连接spring.datasource.druid.max-active=20#获取连接时测试是否可用spring.datasource.druid.test-on-borrow=true#监控页面启动spring.datasource.druid.stat-view-servlet.allow=true 5.4.整合mybatis5.4.1.mybatisSpringBoot官方并没有提供Mybatis的启动器，不过Mybatis官网自己实现了： 123456&lt;!--mybatis --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt; 配置，基本没有需要配置的： 1234# mybatis 别名扫描mybatis.type-aliases-package=com.heima.pojo# mapper.xml文件位置,如果没有映射文件，请注释掉mybatis.mapper-locations=classpath:mappers/*.xml 需要注意，这里没有配置mapper接口扫描包，因此我们需要给每一个Mapper接口添加@Mapper注解，才能被识别。 123@Mapperpublic interface UserMapper &#123;&#125; 5.4.2.通用mapper通用Mapper的作者也为自己的插件编写了启动器，我们直接引入即可： 123456&lt;!-- 通用mapper --&gt;&lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.0.2&lt;/version&gt;&lt;/dependency&gt; 注意：一旦引入通用Mapper的启动器，会覆盖Mybatis官方启动器功能，因此需要移除对官方mybatis启动器依赖 不需要做任何配置就可以使用了。 无需任何配置就可以使用，如果有需要，可以看官方文档：https://github.com/abel533/Mapper/wiki/1.integration 我们要把启动类上的@MapperScan注解修改为通用mapper自带的 123@Mapperpublic interface UserMapper extends tk.mybatis.mapper.common.Mapper&lt;User&gt;&#123;&#125; 5.5.启动测试将controller进行简单改造： 123456789101112@RestControllerpublic class HelloController &#123; @Autowired private UserService userService; @GetMapping("/hello") public User hello() &#123; User user = this.userService.queryById(8L); return user; &#125;&#125; 我们启动项目，查看： 6.Thymeleaf快速入门SpringBoot并不推荐使用jsp，但是支持一些模板引擎技术： 以前大家用的比较多的是Freemarker，但是我们今天的主角是Thymeleaf！ 6.1.为什么是Thymeleaf？简单说， Thymeleaf 是一个跟 Velocity、FreeMarker 类似的模板引擎，它可以完全替代 JSP 。相较与其他的模板引擎，它有如下三个极吸引人的特点： 动静结合：Thymeleaf 在有网络和无网络的环境下皆可运行，即它可以让美工在浏览器查看页面的静态效果，也可以让程序员在服务器查看带数据的动态页面效果。这是由于它支持 html 原型，然后在 html 标签里增加额外的属性来达到模板+数据的展示方式。浏览器解释 html 时会忽略未定义的标签属性，所以 thymeleaf 的模板可以静态地运行；当有数据返回到页面时，Thymeleaf 标签会动态地替换掉静态内容，使页面动态显示。 开箱即用：它提供标准和spring标准两种方言，可以直接套用模板实现JSTL、 OGNL表达式效果，避免每天套模板、该jstl、改标签的困扰。同时开发人员也可以扩展和创建自定义的方言。 多方言支持：Thymeleaf 提供spring标准方言和一个与 SpringMVC 完美集成的可选模块，可以快速的实现表单绑定、属性编辑器、国际化等功能。 与SpringBoot完美整合，SpringBoot提供了Thymeleaf的默认配置，并且为Thymeleaf设置了视图解析器，我们可以像以前操作jsp一样来操作Thymeleaf。代码几乎没有任何区别，就是在模板语法上有区别。 接下来，我们就通过入门案例来体会Thymeleaf的魅力： 6.2.编写接口编写一个controller，返回一些用户数据，放入模型中，等会在页面渲染 123456789@GetMapping("/all")public String all(ModelMap model) &#123; // 查询用户 List&lt;User&gt; users = this.userService.queryAll(); // 放入模型 model.addAttribute("users", users); // 返回模板名称（就是classpath:/templates/目录下的html文件名） return "users";&#125; 6.3.引入启动器直接引入启动器： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; SpringBoot会自动为Thymeleaf注册一个视图解析器： 与解析JSP的InternalViewResolver类似，Thymeleaf也会根据前缀和后缀来确定模板文件的位置： 默认前缀：classpath:/templates/ 默认后缀：.html 所以如果我们返回视图：users，会指向到 classpath:/templates/users.html 一般我们无需进行修改，默认即可。 6.4.静态页面根据上面的文档介绍，模板默认放在classpath下的templates文件夹，我们新建一个html文件放入其中： 编写html模板，渲染模型中的数据： 注意，把html 的名称空间，改成：xmlns:th=&quot;http://www.thymeleaf.org&quot; 会有语法提示 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html xmlns:th="http://www.thymeleaf.org"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;首页&lt;/title&gt; &lt;style type="text/css"&gt; table &#123;border-collapse: collapse; font-size: 14px; width: 80%; margin: auto&#125; table, th, td &#123;border: 1px solid darkslategray;padding: 10px&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div style="text-align: center"&gt; &lt;span style="color: darkslategray; font-size: 30px"&gt;欢迎光临！&lt;/span&gt; &lt;hr/&gt; &lt;table class="list"&gt; &lt;tr&gt; &lt;th&gt;id&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;用户名&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;th&gt;生日&lt;/th&gt; &lt;th&gt;备注&lt;/th&gt; &lt;/tr&gt; &lt;tr th:each="user : $&#123;users&#125;"&gt; &lt;td th:text="$&#123;user.id&#125;"&gt;1&lt;/td&gt; &lt;td th:text="$&#123;user.name&#125;"&gt;张三&lt;/td&gt; &lt;td th:text="$&#123;user.userName&#125;"&gt;zhangsan&lt;/td&gt; &lt;td th:text="$&#123;user.age&#125;"&gt;20&lt;/td&gt; &lt;td th:text="$&#123;user.sex&#125; == 1 ? '男': '女'"&gt;男&lt;/td&gt; &lt;td th:text="$&#123;#dates.format(user.birthday, 'yyyy-MM-dd')&#125;"&gt;1980-02-30&lt;/td&gt; &lt;td th:text="$&#123;user.note&#125;"&gt;1&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 我们看到这里使用了以下语法： ${} ：这个类似与el表达式，但其实是ognl的语法，比el表达式更加强大 th-指令：th-是利用了Html5中的自定义属性来实现的。如果不支持H5，可以用data-th-来代替 th:each：类似于c:foreach 遍历集合，但是语法更加简洁 th:text：声明标签中的文本 例如&lt;td th-text=&#39;${user.id}&#39;&gt;1&lt;/td&gt;，如果user.id有值，会覆盖默认的1 如果没有值，则会显示td中默认的1。这正是thymeleaf能够动静结合的原因，模板解析失败不影响页面的显示效果，因为会显示默认值！ 6.5.测试接下来，我们打开页面测试一下： 6.6.模板缓存Thymeleaf会在第一次对模板解析之后进行缓存，极大的提高了并发处理能力。但是这给我们开发带来了不便，修改页面后并不会立刻看到效果，我们开发阶段可以关掉缓存使用： 12# 开发阶段关闭thymeleaf的模板缓存spring.thymeleaf.cache=false 注意： ​ 在Idea中，我们需要在修改页面后按快捷键：Ctrl + Shift + F9 对项目进行rebuild才可以。 ​ eclipse中没有测试过。 我们可以修改页面，测试一下。]]></content>
      <categories>
        <category>项目实战-微服务商城</category>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Thymeleaf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis安装]]></title>
    <url>%2Fredis%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE.html</url>
    <content type="text"><![CDATA[redis安装和配置1.安装 下载安装包上次课前资料提供的安装包，或者:官网下载建议上传到我们的home下：/home/leyou/ 解压 12在/home/leyou目录下解压 tar -xvf redis-4.0.9.tar.gz 编译安装 123mv redis-4.0.9 rediscd redismake &amp;&amp; make install 2.配置修改安装目录下的redis.conf文件1vim redis.conf 修改以下配置：123#bind 127.0.0.1 # 将这行代码注释，监听所有的ip地址，外网可以访问protected-mode no # 把yes改成no，允许外网访问daemonize yes # 把no改成yes，后台运行 3.启动或停止redis提供了服务端命令和客户端命令： redis-server 服务端命令，可以包含以下参数：start 启动stop 停止 1如：redis-server redis.conf redis-cli 客户端控制台，包含参数：-h xxx 指定服务端地址，缺省值是127.0.0.1-p xxx 指定服务端端口，缺省值是6379 1redis-cli Windows桌面 4.设置开机启动1) 输入命令，新建文件 1vim /etc/init.d/redis 输入下面内容： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#!/bin/sh# chkconfig: 2345 90 10# description: Redis is a persistent key-value databasePATH=/usr/local/bin:/sbin:/usr/bin:/binREDISPORT=6379EXEC=/usr/local/bin/redis-serverREDIS_CLI=/usr/local/bin/redis-cliPIDFILE=/var/run/redis.pidCONF="/home/leyou/redis/redis.conf"case "$1" in start) if [ -f $PIDFILE ] then echo "$PIDFILE exists, process is already running or crashed" else echo "Starting Redis server..." $EXEC $CONF fi if [ "$?"="0" ] then echo "Redis is running..." fi ;; stop) if [ ! -f $PIDFILE ] then echo "$PIDFILE does not exist, process is not running" else PID=$(cat $PIDFILE) echo "Stopping ..." $REDIS_CLI -p $REDISPORT SHUTDOWN while [ -x $&#123;PIDFILE&#125; ] do echo "Waiting for Redis to shutdown ..." sleep 1 done echo "Redis stopped" fi ;; restart|force-reload) $&#123;0&#125; stop $&#123;0&#125; start ;; *) echo "Usage: /etc/init.d/redis &#123;start|stop|restart|force-reload&#125;" &gt;&amp;2 exit 1 esac 然后保存退出 注意：以下信息需要根据安装目录进行调整： EXEC=/usr/local/bin/redis-server # 执行脚本的地址 REDIS_CLI=/usr/local/bin/redis-cli # 客户端执行脚本的地址 PIDFILE=/var/run/redis.pid # 进程id文件地址 CONF=”/usr/local/src/redis-3.0.2/redis.conf” #配置文件地址 2）设置权限 1chmod 755 /etc/init.d/redis 3）启动测试 1/etc/init.d/redis start 启动成功会提示如下信息： 12Starting Redis server...Redis is running... 4）设置开机自启动 12chkconfig --add /etc/init.d/redischkconfig redis on]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下安装FastDFS]]></title>
    <url>%2Flinux%E4%B8%8B%E5%AE%89%E8%A3%85FastDFS.html</url>
    <content type="text"><![CDATA[1.FastDFS1.1.什么是分布式文件系统分布式文件系统（Distributed File System）是指文件系统管理的物理存储资源不一定直接连接在本地节点上，而是通过计算机网络与节点相连。 通俗来讲： 传统文件系统管理的文件就存储在本机。 分布式文件系统管理的文件存储在很多机器，这些机器通过网络连接，要被统一管理。无论是上传或者访问文件，都需要通过管理中心来访问 1.2.什么是FastDFSFastDFS是由淘宝的余庆先生所开发的一个轻量级、高性能的开源分布式文件系统。用纯C语言开发，功能丰富： 文件存储 文件同步 文件访问（上传、下载） 存取负载均衡 在线扩容 适合有大容量存储需求的应用或系统。同类的分布式文件系统有谷歌的GFS、HDFS（Hadoop）、TFS（淘宝）等。 1.3.FastDFS的架构1.3.1.架构图先上图： FastDFS两个主要的角色：Tracker Server 和 Storage Server 。 Tracker Server：跟踪服务器，主要负责调度storage节点与client通信，在访问上起负载均衡的作用，和记录storage节点的运行状态，是连接client和storage节点的枢纽。 Storage Server：存储服务器，保存文件和文件的meta data（元数据），每个storage server会启动一个单独的线程主动向Tracker cluster中每个tracker server报告其状态信息，包括磁盘使用情况，文件同步情况及文件上传下载次数统计等信息 Group：文件组，多台Storage Server的集群。上传一个文件到同组内的一台机器上后，FastDFS会将该文件即时同步到同组内的其它所有机器上，起到备份的作用。不同组的服务器，保存的数据不同，而且相互独立，不进行通信。 Tracker Cluster：跟踪服务器的集群，有一组Tracker Server（跟踪服务器）组成。 Storage Cluster ：存储集群，有多个Group组成。 1.3.2.上传和下载流程 上传 Client通过Tracker server查找可用的Storage server。 Tracker server向Client返回一台可用的Storage server的IP地址和端口号。 Client直接通过Tracker server返回的IP地址和端口与其中一台Storage server建立连接并进行文件上传。 上传完成，Storage server返回Client一个文件ID，文件上传结束。 下载 Client通过Tracker server查找要下载文件所在的的Storage server。 Tracker server向Client返回包含指定文件的某个Storage server的IP地址和端口号。 Client直接通过Tracker server返回的IP地址和端口与其中一台Storage server建立连接并指定要下载文件。 下载文件成功。 2. Centos下安装FastDFS2.1 安装准备将下面文件上传到linux下的/home/leyou/fdfs目录: FastDFS_v5.08.tar.gz fastdfs-nginx-module_v1.16.tar.gz libevent-2.0.22-stable.tar.gz libfastcommon-master.zip 2.2 安装依赖FastDFS运行需要一些依赖，在课前资料提供的虚拟中已经安装好了这些依赖，如果大家想要从头学习，可以按下面方式安装： 2.2.1 安装GCC依赖GCC用来对C语言代码进行编译运行，使用yum命令安装： 1yum -y install gcc 2.2.2 安装unzip工具unzip工具可以帮我们对压缩包进行解压 1yum install -y unzip zip 2.2.3 安装libevent1yum -y install libevent 2.2.4 安装Nginx所需依赖1yum -y install pcre pcre-devel zlib zlib-devel openssl openssl-devel 2.2.5 安装libfastcommon-master这个没有yum包，只能通过编译安装： 解压刚刚上传的libfastcommon-master.zip 1[root@promote fdfs]# unzip libfastcommon-master.zip 进入解压完成的目录： 1[root@promote fdfs]# cd libfastcommon-master 编译并且安装： 1[root@promote libfastcommon-master]# ./make.sh &amp;&amp; ./make.sh install 到这里为止，所有依赖都已经安装完毕，接下来我们安装FastDFS： 2.3 安装FastDFS2.3.1 编译安装这里我们也采用编译安装，步骤与刚才的编译安装方式一样： 解压 1[root@promote fdfs]# tar -xvf FastDFS_v5.08.tar.gz 进入目录 1[root@promote fdfs]# cd FastDFS 编译并安装 1[root@promote FastDFS]# ./make.sh &amp;&amp; ./make.sh install 校验安装结果 1）安装完成，我们应该能在/etc/init.d/目录，通过命令ll /etc/init.d/ | grep fdfs看到FastDFS提供的启动脚本： 其中： fdfs_trackerd 是tracker启动脚本 fdfs_storaged 是storage启动脚本 2）我们可以在 /etc/fdfs目录，通过命令查看到以下配置文件模板： 其中： tarcker.conf.sample 是tracker的配置文件模板 storage.conf.sample 是storage的配置文件模板 client.conf.sample 是客户端的配置文件模板 2.3.2 /etc/fdfs中修改trackerFastDFS的tracker和storage在刚刚的安装过程中，都已经被安装了，因此我们安装这两种角色的方式是一样的。不同的是，两种需要不同的配置文件。 我们要启动tracker，就修改刚刚看到的tarcker.conf，并且启动fdfs_trackerd脚本即可。 编辑tracker配置 首先我们将模板文件进行赋值和重命名： 123[root@promote ~]# cd /etc/fdfs/[root@promote fdfs]# cp tracker.conf.sample tracker.conf [root@promote fdfs]# vim tracker.conf 打开tracker.conf，修改base_path配置： 1base_path=/leyou/fdfs/tracker # tracker的数据和日志存放目录 创建目录 刚刚配置的目录可能不存在，我们在根目录上创建leyou 出来 1[root@promote fdfs]# mkdir -p /leyou/fdfs/tracker 启动tracker 我们可以使用 sh /etc/init.d/fdfs_trackerd 启动，不过安装过程中，fdfs已经被设置为系统服务，我们可以采用熟悉的服务启动方式： 1[root@promote fdfs]# service fdfs_trackerd start # 启动fdfs_trackerd服务，停止用stop 查看是否运行 1[root@promote fdfs]# ps -ef | grep fdfs 另外，我们可以通过以下命令，设置tracker开机启动： 1chkconfig fdfs_trackerd on 2.3.3 /etc/fdfs中启动storage我们要启动tracker，就修改刚刚看到的tarcker.conf，并且启动fdfs_trackerd脚本即可。 编辑storage配置 首先我们将模板文件进行赋值和重命名： 123 在etc/fdfs目录下[root@promote fdfs]# cp storage.conf.sample storage.conf[root@promote fdfs]# vim storage.conf 打开storage.conf，修改base_path配置： 123base_path=/leyou/fdfs/storage # storage的数据和日志存放目录store_path0=/leyou/fdfs/storage # storage的上传文件存放路径tracker_server=192.168.56.101:22122 # tracker的地址（服务器IP地址192.168.25.128） 创建目录 刚刚配置的目录可能不存在，我们创建出来 1[root@promote fdfs]# mkdir -p /leyou/fdfs/storage 启动storage 我们可以使用 sh /etc/init.d/fdfs_storaged 启动，同样我们可以用服务启动方式： 1[root@promote fdfs]# service fdfs_storaged start # 启动fdfs_storaged服务，停止用stop 另外，我们可以通过以下命令，设置tracker开机启动： 1[root@promote fdfs]# chkconfig fdfs_storaged on 最后，通过ps -ef | grep fdfs 查看进程： 2.3.4.测试上传进入/etc/fdfs目录，修改client.config 修改配置 12tracker_service=192.168.25.128:22122base_path=/image #要上传的文件目录 运行： /usr/bin/fdfs_upload_file：脚本 /etc/fdfs/client.conf ：配置文件 /image：要上传文件的 目录 1[root@promote fdfs]# /usr/bin/fdfs_upload_file /etc/fdfs/client.conf /image/1.jpg 成功后返回图片的id： group1/M00/00/00/wKgZgFwDWcGASgnlAAE74lc0orE837.jpg group1：组信息 M00：对应store_path0 /00/00：磁盘路径 2.4 安装Nginx及FastDFS模块2.4.1 FastDFS的Nginx模块 解压/home/leyou/fdfs下的 1[root@promote fdfs]# tar -xvf fastdfs-nginx-module_v1.16.tar.gz 配置config文件 123456# 进入配置目录[root@promote fdfs]# cd /home/leyou/fdfs/fastdfs-nginx-module/src/# 修改配置[root@promote src]# vim config# 执行下面命令（将配置中的/usr/local改为/usr）：:%s+/usr/local/+/usr/+g 配置mod_fastdfs.conf 1234# 将src目录下的mod_fastdfs.conf复制到 /etc/fdfs目录：[root@promote src]# cp mod_fastdfs.conf /etc/fdfs/# 编辑该文件[root@promote src]# vim /etc/fdfs/mod_fastdfs.cof 修改一下配置： 1234connect_timeout=10 # 客户端访问文件连接超时时长（单位：秒）tracker_server=192.168.25.128:22122 # tracker服务IP和端口url_have_group_name=true # 访问链接前缀加上组名store_path0=/leyou/fdfs/storage # 文件存储路径 复制 FastDFS的部分配置文件到/etc/fdfs目录 12[root@promote src]# cd /home/leyou/fdfs/FastDFS/conf/[root@promote conf]# http.conf mime.types /etc/fdfs/ 2.4.2 配置Nginx已经安装了nginx中配置 配置 在/home/leyou/nginx目录下 1[root@promote nginx]# ./configure --prefix=/opt/nginx --sbin-path=/usr/bin/nginx --add-module=/home/leyou/fdfs/fastdfs-nginx-module/src 编译安装 1[root@promote nginx]# make 备份之前的/usr/bin/nginx 1[root@promote nginx]# mv /usr/bin/nginx /usr/bin/nginx-bck 用刚刚编译的nginx替换之前安装的nginx 1[root@promote nginx]# cp /home/leyou/nginx/objs/nginx /usr/bin/ 配置nginx整合fastdfs-module模块 我们需要修改nginx配置文件，在/opt/nginx/config/nginx.conf文件中： 1[root@promote nginx]# vim /opt/nginx/conf/nginx.conf 将文件中，添加如下代码： 1234567891011121314151617181920server &#123; listen 80; server_name image.taotao.com; # 监听域名中带有group的，交给FastDFS模块处理 location ~/group([0-9])/ &#123; ngx_fastdfs_module; &#125; location / &#123; root html; index index.html index.htm; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; &#125; 启动 1234[root@promote objs]# nginx # 启动ngx_http_fastdfs_set pid=8152 # 启动成功[root@promote objs]# nginx -s stop # 停止[root@promote objs]# nginx -s reload # 重新加载配置 测试 http://image.leyou.com/group1/M00/00/00/wKgZgFwDWcGASgnlAAE74lc0orE837.jpg 设置nginx开机启动 创建一个开机启动的脚本： 1[root@promote nginx]# vim /etc/init.d/nginx 添加以下内容： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131#!/bin/sh## nginx - this script starts and stops the nginx daemon## chkconfig: - 85 15# description: NGINX is an HTTP(S) server, HTTP(S) reverse \# proxy and IMAP/POP3 proxy server# processname: nginx# config: /etc/nginx/nginx.conf# config: /etc/sysconfig/nginx# pidfile: /var/run/nginx.pid# Source function library.. /etc/rc.d/init.d/functions# Source networking configuration.. /etc/sysconfig/network# Check that networking is up.[ "$NETWORKING" = "no" ] &amp;&amp; exit 0#nginx脚本地址nginx="/usr/bin/nginx"prog=$(basename $nginx)#nginx配置目录NGINX_CONF_FILE="/opt/nginx/conf/nginx.conf"[ -f /etc/sysconfig/nginx ] &amp;&amp; . /etc/sysconfig/nginxlockfile=/var/lock/subsys/nginxmake_dirs() &#123; # make required directories user=`$nginx -V 2&gt;&amp;1 | grep "configure arguments:.*--user=" | sed 's/[^*]*--user=\([^ ]*\).*/\1/g' -` if [ -n "$user" ]; then if [ -z "`grep $user /etc/passwd`" ]; then useradd -M -s /bin/nologin $user fi options=`$nginx -V 2&gt;&amp;1 | grep 'configure arguments:'` for opt in $options; do if [ `echo $opt | grep '.*-temp-path'` ]; then value=`echo $opt | cut -d "=" -f 2` if [ ! -d "$value" ]; then # echo "creating" $value mkdir -p $value &amp;&amp; chown -R $user $value fi fi done fi&#125;start() &#123; [ -x $nginx ] || exit 5 [ -f $NGINX_CONF_FILE ] || exit 6 make_dirs echo -n $"Starting $prog: " daemon $nginx -c $NGINX_CONF_FILE retval=$? echo [ $retval -eq 0 ] &amp;&amp; touch $lockfile return $retval&#125;stop() &#123; echo -n $"Stopping $prog: " killproc $prog -QUIT retval=$? echo [ $retval -eq 0 ] &amp;&amp; rm -f $lockfile return $retval&#125;restart() &#123; configtest || return $? stop sleep 1 start&#125;reload() &#123; configtest || return $? echo -n $"Reloading $prog: " killproc $nginx -HUP RETVAL=$? echo&#125;force_reload() &#123; restart&#125;configtest() &#123; $nginx -t -c $NGINX_CONF_FILE&#125;rh_status() &#123; status $prog&#125;rh_status_q() &#123; rh_status &gt;/dev/null 2&gt;&amp;1&#125;case "$1" in start) rh_status_q &amp;&amp; exit 0 $1 ;; stop) rh_status_q || exit 0 $1 ;; restart|configtest) $1 ;; reload) rh_status_q || exit 7 $1 ;; force-reload) force_reload ;; status) rh_status ;; condrestart|try-restart) rh_status_q || exit 0 ;; *) echo $"Usage: $0 &#123;start|stop|status|restart|condrestart|try-restart|reload|force-reload|configtest&#125;" exit 2esac 修改文件权限，并加入服务列表 1234# 修改权限（最高）chmod 777 /etc/init.d/nginx # 添加到服务列表chkconfig --add /etc/init.d/nginx 设置开机启动 1chkconfig nginx on]]></content>
      <categories>
        <category>分布式文件系统</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>FastDFS</tag>
        <tag>分布式文件系统</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx安装]]></title>
    <url>%2FNginx%E7%9A%84%E5%AE%89%E8%A3%85.html</url>
    <content type="text"><![CDATA[nginx的介绍Nginx是一款高性能的http 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器。由俄罗斯的程序设计师Igor Sysoev所开发，官方测试nginx能够支支撑5万并发链接，并且cpu、内存等资源消耗却非常低，运行非常稳定。 安装准备 虚拟机VM Linux CentOs6.8系统 电脑 安装依赖需要安装gcc的环境1[root@localhost ~]# yum install gcc-c++ 第三方的开发包 PCRE:​PCRE，(Perl Compatible Regular Expressions)是一个Perl库，包括 perl兼容的正则表达式库。nginx的http模块使用pcre来解析正则表达式 1[root@localhost ~]# yum install -y pcre pcre-devel zlib:zlib库提供了很多种压缩和解压缩的方式，nginx使用zlib对http包的内容进行gzip，所以需要在linux上安装zlib库。 1[root@localhost ~]# yum install -y zlib zlib-devel openssl:OpenSSL 是一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及SSL协议，并提供丰富的应用程序供测试或其它目的使用。nginx不仅支持http协议，还支持https（即在ssl协议上传输http），所以需要在linux安装openssl库。 1[root@localhost ~]# yum install -y openssl openssl-devel 下载nginxhttp://nginx.org/download/为nginx下载地址 1[root@localhost ~]# wget http://nginx.org/download/nginx-1.10.0.tar.gz 安装nginx 创建一个work文件: 12[root@localhost home]# mkdir work 将nginx-1.10.0.tar.gz 复制到/home/work目录下 1[root@localhost ~]# cp nginx-1.10.0.tar.gz /home/work 解压nginx： 1[root@localhost work]# tar -xvf nginx-1.10.0.tar.gz 改名字： 1[root@localhost work]# mv nginx-1.10.0 nginx 配置nginx:安装目录是/opt/nginx 1234//进入解压好的nginx[root@localhost work]#cd nginx//安装[root@localhost nginx]# ./configure --prefix=/opt/nginx --sbin-path=/usr/bin/nginx 编译安装: 1[root@localhost nginx]# make &amp;&amp; make install 启动： 1[root@localhost nginx]# nginx 测试输入linux的ip地址 停止和重新加载在存放nginx的目录下/home/leyou/nginx操作 停止：1[root@localhost nginx]# nginx -s stop 重新加载：1[root@localhost nginx]# nginx -s reload]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>nginx安装</tag>
      </tags>
  </entry>
</search>
